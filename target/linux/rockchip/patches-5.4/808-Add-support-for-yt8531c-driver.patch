From 28a6c8d1d6802f7c1789a942a6d1c4630469b295 Mon Sep 17 00:00:00 2001
From: root <root@dev131.embedfire.local>
Date: Thu, 30 Sep 2021 04:48:26 +0000
Subject: [PATCH] Add support for yt8531c driver

---
 drivers/net/phy/Kconfig                       |    5 +
 drivers/net/phy/Makefile                      |    1 +
 drivers/net/phy/for-module-only/Makefile      |   13 +
 .../net/phy/for-module-only/yt_phy_module.c   |   45 +
 .../net/phy/for-reference-only/phy_device.c   | 1527 ++++++++++++++++
 .../phy_device.c.Readme.txt                   |    1 +
 drivers/net/phy/motorcomm.c                   | 1497 ++++++++++++++++
 drivers/net/phy/yt8614-phy.c                  | 1540 +++++++++++++++++
 drivers/net/phy/yt8614-phy.h                  |  491 ++++++
 include/linux/motorcomm_phy.h                 |  118 ++
 10 files changed, 5238 insertions(+)
 create mode 100644 drivers/net/phy/for-module-only/Makefile
 create mode 100644 drivers/net/phy/for-module-only/yt_phy_module.c
 create mode 100644 drivers/net/phy/for-reference-only/phy_device.c
 create mode 100644 drivers/net/phy/for-reference-only/phy_device.c.Readme.txt
 create mode 100644 drivers/net/phy/motorcomm.c
 create mode 100644 drivers/net/phy/yt8614-phy.c
 create mode 100644 drivers/net/phy/yt8614-phy.h
 create mode 100644 include/linux/motorcomm_phy.h

diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index dcf2051ef..71b99e08a 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -429,6 +429,11 @@ config MICROCHIP_T1_PHY
 	---help---
 	  Supports the LAN87XX PHYs.
 
+config MOTORCOMM_PHY
+	tristate "Motorcomm PHYs"
+	---help---
+	  Supports the YT8010, YT8510, YT8511, YT8512 PHYs.
+
 config MICROSEMI_PHY
 	tristate "Microsemi PHYs"
 	---help---
diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index a03437e09..a3933c83f 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -83,6 +83,7 @@ obj-$(CONFIG_MICREL_PHY)	+= micrel.o
 obj-$(CONFIG_MICROCHIP_PHY)	+= microchip.o
 obj-$(CONFIG_MICROCHIP_T1_PHY)	+= microchip_t1.o
 obj-$(CONFIG_MICROSEMI_PHY)	+= mscc.o
+obj-$(CONFIG_MOTORCOMM_PHY)	+= motorcomm.o
 obj-$(CONFIG_NATIONAL_PHY)	+= national.o
 obj-$(CONFIG_NXP_TJA11XX_PHY)	+= nxp-tja11xx.o
 obj-$(CONFIG_QSEMI_PHY)		+= qsemi.o
diff --git a/drivers/net/phy/for-module-only/Makefile b/drivers/net/phy/for-module-only/Makefile
new file mode 100644
index 000000000..8cb1c7a5a
--- /dev/null
+++ b/drivers/net/phy/for-module-only/Makefile
@@ -0,0 +1,13 @@
+obj-m += yt_phy_module.o 
+
+DRIVER_INC = $(PWD)/../../../../include/
+
+EXTRA_CFLAGS = -I$(DRIVER_INC) -Wall -g
+
+KSRC = /lib/modules/`uname -r`/build
+
+all:
+	make -C $(KSRC) M=$(PWD) modules
+
+clean:
+	make -C $(KSRC) M=$(PWD) clean
diff --git a/drivers/net/phy/for-module-only/yt_phy_module.c b/drivers/net/phy/for-module-only/yt_phy_module.c
new file mode 100644
index 000000000..9d2d4db8a
--- /dev/null
+++ b/drivers/net/phy/for-module-only/yt_phy_module.c
@@ -0,0 +1,45 @@
+#if 0
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h> 
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/fcntl.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h> 
+#include <linux/etherdevice.h>
+#include <linux/netdevice.h> 
+#include <linux/etherdevice.h>
+#include <linux/ip.h> 
+#include <linux/udp.h>
+#endif
+
+#include "../../../../include/linux/motorcomm_phy.h"
+#include "../motorcomm.c"
+//#include "../yt8614-phy.c"
+
+#if 0 
+static int __init pkt_init(void)
+{
+	printk(KERN_INFO "YT phy driver module initialized.\n");
+	return 0;
+}
+
+static void __exit pkt_exit(void)
+{
+	printk(KERN_INFO "YT phy driver module exits.\n");
+}
+
+module_init(pkt_init);
+module_exit(pkt_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("yzhang");
+MODULE_DESCRIPTION("YT phy driver in module.");
+MODULE_VERSION("0.1");
+#endif
diff --git a/drivers/net/phy/for-reference-only/phy_device.c b/drivers/net/phy/for-reference-only/phy_device.c
new file mode 100644
index 000000000..96983bc6a
--- /dev/null
+++ b/drivers/net/phy/for-reference-only/phy_device.c
@@ -0,0 +1,1527 @@
+/* Framework for finding and configuring PHYs.
+ * Also contains generic PHY driver
+ *
+ * Author: Andy Fleming
+ *
+ * Copyright (c) 2004 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/phy.h>
+#include <linux/mdio.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/of.h>
+
+#include <asm/irq.h>
+
+MODULE_DESCRIPTION("PHY library");
+MODULE_AUTHOR("Andy Fleming");
+MODULE_LICENSE("GPL");
+
+void phy_device_free(struct phy_device *phydev)
+{
+	put_device(&phydev->dev);
+}
+EXPORT_SYMBOL(phy_device_free);
+
+static void phy_device_release(struct device *dev)
+{
+	kfree(to_phy_device(dev));
+}
+
+enum genphy_driver {
+	GENPHY_DRV_1G,
+	GENPHY_DRV_10G,
+	GENPHY_DRV_MAX
+};
+
+static struct phy_driver genphy_driver[GENPHY_DRV_MAX];
+
+static LIST_HEAD(phy_fixup_list);
+static DEFINE_MUTEX(phy_fixup_lock);
+
+/**
+ * phy_register_fixup - creates a new phy_fixup and adds it to the list
+ * @bus_id: A string which matches phydev->dev.bus_id (or PHY_ANY_ID)
+ * @phy_uid: Used to match against phydev->phy_id (the UID of the PHY)
+ *	It can also be PHY_ANY_UID
+ * @phy_uid_mask: Applied to phydev->phy_id and fixup->phy_uid before
+ *	comparison
+ * @run: The actual code to be run when a matching PHY is found
+ */
+int phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,
+		       int (*run)(struct phy_device *))
+{
+	struct phy_fixup *fixup = kzalloc(sizeof(*fixup), GFP_KERNEL);
+
+	if (!fixup)
+		return -ENOMEM;
+
+	strlcpy(fixup->bus_id, bus_id, sizeof(fixup->bus_id));
+	fixup->phy_uid = phy_uid;
+	fixup->phy_uid_mask = phy_uid_mask;
+	fixup->run = run;
+
+	mutex_lock(&phy_fixup_lock);
+	list_add_tail(&fixup->list, &phy_fixup_list);
+	mutex_unlock(&phy_fixup_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(phy_register_fixup);
+
+/* Registers a fixup to be run on any PHY with the UID in phy_uid */
+int phy_register_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask,
+			       int (*run)(struct phy_device *))
+{
+	return phy_register_fixup(PHY_ANY_ID, phy_uid, phy_uid_mask, run);
+}
+EXPORT_SYMBOL(phy_register_fixup_for_uid);
+
+/* Registers a fixup to be run on the PHY with id string bus_id */
+int phy_register_fixup_for_id(const char *bus_id,
+			      int (*run)(struct phy_device *))
+{
+	return phy_register_fixup(bus_id, PHY_ANY_UID, 0xffffffff, run);
+}
+EXPORT_SYMBOL(phy_register_fixup_for_id);
+
+/* Returns 1 if fixup matches phydev in bus_id and phy_uid.
+ * Fixups can be set to match any in one or more fields.
+ */
+static int phy_needs_fixup(struct phy_device *phydev, struct phy_fixup *fixup)
+{
+	if (strcmp(fixup->bus_id, dev_name(&phydev->dev)) != 0)
+		if (strcmp(fixup->bus_id, PHY_ANY_ID) != 0)
+			return 0;
+
+	if ((fixup->phy_uid & fixup->phy_uid_mask) !=
+	    (phydev->phy_id & fixup->phy_uid_mask))
+		if (fixup->phy_uid != PHY_ANY_UID)
+			return 0;
+
+	return 1;
+}
+
+/* Runs any matching fixups for this phydev */
+static int phy_scan_fixups(struct phy_device *phydev)
+{
+	struct phy_fixup *fixup;
+
+	mutex_lock(&phy_fixup_lock);
+	list_for_each_entry(fixup, &phy_fixup_list, list) {
+		if (phy_needs_fixup(phydev, fixup)) {
+			int err = fixup->run(phydev);
+
+			if (err < 0) {
+				mutex_unlock(&phy_fixup_lock);
+				return err;
+			}
+			phydev->has_fixups = true;
+		}
+	}
+	mutex_unlock(&phy_fixup_lock);
+
+	return 0;
+}
+
+struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
+				     bool is_c45,
+				     struct phy_c45_device_ids *c45_ids)
+{
+	struct phy_device *dev;
+
+	/* We allocate the device, and initialize the default values */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return ERR_PTR(-ENOMEM);
+
+	dev->dev.release = phy_device_release;
+
+	dev->speed = 0;
+	dev->duplex = -1;
+	dev->pause = 0;
+	dev->asym_pause = 0;
+	dev->link = 1;
+	dev->interface = PHY_INTERFACE_MODE_GMII;
+
+	dev->autoneg = AUTONEG_ENABLE;
+
+	dev->is_c45 = is_c45;
+	dev->addr = addr;
+	dev->phy_id = phy_id;
+	if (c45_ids)
+		dev->c45_ids = *c45_ids;
+	dev->bus = bus;
+	dev->dev.parent = &bus->dev;
+	dev->dev.bus = &mdio_bus_type;
+	dev->irq = bus->irq ? bus->irq[addr] : PHY_POLL;
+	dev_set_name(&dev->dev, PHY_ID_FMT, bus->id, addr);
+
+	dev->state = PHY_DOWN;
+
+	mutex_init(&dev->lock);
+	INIT_DELAYED_WORK(&dev->state_queue, phy_state_machine);
+	INIT_WORK(&dev->phy_queue, phy_change);
+
+	/* Request the appropriate module unconditionally; don't
+	 * bother trying to do so only if it isn't already loaded,
+	 * because that gets complicated. A hotplug event would have
+	 * done an unconditional modprobe anyway.
+	 * We don't do normal hotplug because it won't work for MDIO
+	 * -- because it relies on the device staying around for long
+	 * enough for the driver to get loaded. With MDIO, the NIC
+	 * driver will get bored and give up as soon as it finds that
+	 * there's no driver _already_ loaded.
+	 */
+	request_module(MDIO_MODULE_PREFIX MDIO_ID_FMT, MDIO_ID_ARGS(phy_id));
+
+	device_initialize(&dev->dev);
+
+	return dev;
+}
+EXPORT_SYMBOL(phy_device_create);
+
+/* get_phy_c45_devs_in_pkg - reads a MMD's devices in package registers.
+ * @bus: the target MII bus
+ * @addr: PHY address on the MII bus
+ * @dev_addr: MMD address in the PHY.
+ * @devices_in_package: where to store the devices in package information.
+ *
+ * Description: reads devices in package registers of a MMD at @dev_addr
+ * from PHY at @addr on @bus.
+ *
+ * Returns: 0 on success, -EIO on failure.
+ */
+static int get_phy_c45_devs_in_pkg(struct mii_bus *bus, int addr, int dev_addr,
+				   u32 *devices_in_package)
+{
+	int phy_reg, reg_addr;
+
+	reg_addr = MII_ADDR_C45 | dev_addr << 16 | MDIO_DEVS2;
+	phy_reg = mdiobus_read(bus, addr, reg_addr);
+	if (phy_reg < 0)
+		return -EIO;
+	*devices_in_package = (phy_reg & 0xffff) << 16;
+
+	reg_addr = MII_ADDR_C45 | dev_addr << 16 | MDIO_DEVS1;
+	phy_reg = mdiobus_read(bus, addr, reg_addr);
+	if (phy_reg < 0)
+		return -EIO;
+	*devices_in_package |= (phy_reg & 0xffff);
+
+	return 0;
+}
+
+/**
+ * get_phy_c45_ids - reads the specified addr for its 802.3-c45 IDs.
+ * @bus: the target MII bus
+ * @addr: PHY address on the MII bus
+ * @phy_id: where to store the ID retrieved.
+ * @c45_ids: where to store the c45 ID information.
+ *
+ *   If the PHY devices-in-package appears to be valid, it and the
+ *   corresponding identifiers are stored in @c45_ids, zero is stored
+ *   in @phy_id.  Otherwise 0xffffffff is stored in @phy_id.  Returns
+ *   zero on success.
+ *
+ */
+static int get_phy_c45_ids(struct mii_bus *bus, int addr, u32 *phy_id,
+			   struct phy_c45_device_ids *c45_ids) {
+	int phy_reg;
+	int i, reg_addr;
+	const int num_ids = ARRAY_SIZE(c45_ids->device_ids);
+	u32 *devs = &c45_ids->devices_in_package;
+
+	/* Find first non-zero Devices In package. Device zero is reserved
+	 * for 802.3 c45 complied PHYs, so don't probe it at first.
+	 */
+	for (i = 1; i < num_ids && *devs == 0; i++) {
+		phy_reg = get_phy_c45_devs_in_pkg(bus, addr, i, devs);
+		if (phy_reg < 0)
+			return -EIO;
+
+		if ((*devs & 0x1fffffff) == 0x1fffffff) {
+			/*  If mostly Fs, there is no device there,
+			 *  then let's continue to probe more, as some
+			 *  10G PHYs have zero Devices In package,
+			 *  e.g. Cortina CS4315/CS4340 PHY.
+			 */
+			phy_reg = get_phy_c45_devs_in_pkg(bus, addr, 0, devs);
+			if (phy_reg < 0)
+				return -EIO;
+			/* no device there, let's get out of here */
+			if ((*devs & 0x1fffffff) == 0x1fffffff) {
+				*phy_id = 0xffffffff;
+				return 0;
+			} else {
+				break;
+			}
+		}
+	}
+
+	/* Now probe Device Identifiers for each device present. */
+	for (i = 1; i < num_ids; i++) {
+		if (!(c45_ids->devices_in_package & (1 << i)))
+			continue;
+
+		reg_addr = MII_ADDR_C45 | i << 16 | MII_PHYSID1;
+		phy_reg = mdiobus_read(bus, addr, reg_addr);
+		if (phy_reg < 0)
+			return -EIO;
+		c45_ids->device_ids[i] = (phy_reg & 0xffff) << 16;
+
+		reg_addr = MII_ADDR_C45 | i << 16 | MII_PHYSID2;
+		phy_reg = mdiobus_read(bus, addr, reg_addr);
+		if (phy_reg < 0)
+			return -EIO;
+		c45_ids->device_ids[i] |= (phy_reg & 0xffff);
+	}
+	*phy_id = 0;
+	return 0;
+}
+
+/**
+ * get_phy_id - reads the specified addr for its ID.
+ * @bus: the target MII bus
+ * @addr: PHY address on the MII bus
+ * @phy_id: where to store the ID retrieved.
+ * @is_c45: If true the PHY uses the 802.3 clause 45 protocol
+ * @c45_ids: where to store the c45 ID information.
+ *
+ * Description: In the case of a 802.3-c22 PHY, reads the ID registers
+ *   of the PHY at @addr on the @bus, stores it in @phy_id and returns
+ *   zero on success.
+ *
+ *   In the case of a 802.3-c45 PHY, get_phy_c45_ids() is invoked, and
+ *   its return value is in turn returned.
+ *
+ */
+static int get_phy_id(struct mii_bus *bus, int addr, u32 *phy_id,
+		      bool is_c45, struct phy_c45_device_ids *c45_ids)
+{
+	int phy_reg;
+
+	if (is_c45)
+		return get_phy_c45_ids(bus, addr, phy_id, c45_ids);
+
+	/* Grab the bits from PHYIR1, and put them in the upper half */
+	phy_reg = mdiobus_read(bus, addr, MII_PHYSID1);
+	if (phy_reg < 0)
+		return -EIO;
+
+	*phy_id = (phy_reg & 0xffff) << 16;
+
+	/* Grab the bits from PHYIR2, and put them in the lower half */
+	phy_reg = mdiobus_read(bus, addr, MII_PHYSID2);
+	if (phy_reg < 0)
+		return -EIO;
+
+	*phy_id |= (phy_reg & 0xffff);
+
+	return 0;
+}
+
+/* yzhang added for YT8511 phy 125m clock out */
+extern int yt8511_config_out_125m(struct mii_bus *bus, int phy_id);
+extern int yt8511_config_dis_txdelay(struct mii_bus *bus, int phy_id);
+
+/**
+ * get_phy_device - reads the specified PHY device and returns its @phy_device
+ *		    struct
+ * @bus: the target MII bus
+ * @addr: PHY address on the MII bus
+ * @is_c45: If true the PHY uses the 802.3 clause 45 protocol
+ *
+ * Description: Reads the ID registers of the PHY at @addr on the
+ *   @bus, then allocates and returns the phy_device to represent it.
+ */
+struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45)
+{
+	struct phy_c45_device_ids c45_ids = {0};
+	u32 phy_id = 0;
+	int r;
+
+	r = get_phy_id(bus, addr, &phy_id, is_c45, &c45_ids);
+	if (r)
+		return ERR_PTR(r);
+
+	/* If the phy_id is mostly Fs, there is no device there */
+	if ((phy_id & 0x1fffffff) == 0x1fffffff)
+		return NULL;
+
+	printk (KERN_INFO "yzhang..read phyaddr=%d, phyid=%08x\n",addr, phy_id);
+	if(0x10a == phy_id)
+	{
+#if 0
+		r = yt8511_config_dis_txdelay(bus, addr);
+		printk (KERN_INFO "yzhang..8511 dis txdelay, reg=%#04x\n",bus->read(bus,addr,0x1f)/*double check as delay*/);
+		if (r<0)
+		{
+			printk (KERN_INFO "yzhang..failed to dis txdelay, ret=%d\n",r);
+		}
+#endif
+
+#if 1
+		printk (KERN_INFO "yzhang..get YT8511, abt to set 125m clk out, phyaddr=%d, phyid=%08x\n",addr, phy_id);
+		r = yt8511_config_out_125m(bus, addr);
+		printk (KERN_INFO "yzhang..8511 set 125m clk out, reg=%#04x\n",bus->read(bus,addr,0x1f)/*double check as delay*/);
+		if (r<0)
+		{
+			printk (KERN_INFO "yzhang..failed to set 125m clk out, ret=%d\n",r);
+		}
+#endif
+	}
+	
+	return phy_device_create(bus, addr, phy_id, is_c45, &c45_ids);
+}
+EXPORT_SYMBOL(get_phy_device);
+
+/**
+ * phy_device_register - Register the phy device on the MDIO bus
+ * @phydev: phy_device structure to be added to the MDIO bus
+ */
+int phy_device_register(struct phy_device *phydev)
+{
+	int err;
+
+	/* Don't register a phy if one is already registered at this address */
+	if (phydev->bus->phy_map[phydev->addr])
+		return -EINVAL;
+	phydev->bus->phy_map[phydev->addr] = phydev;
+
+	/* Run all of the fixups for this PHY */
+	err = phy_scan_fixups(phydev);
+	if (err) {
+		pr_err("PHY %d failed to initialize\n", phydev->addr);
+		goto out;
+	}
+
+	err = device_add(&phydev->dev);
+	if (err) {
+		pr_err("PHY %d failed to add\n", phydev->addr);
+		goto out;
+	}
+
+	return 0;
+
+ out:
+	phydev->bus->phy_map[phydev->addr] = NULL;
+	return err;
+}
+EXPORT_SYMBOL(phy_device_register);
+
+/**
+ * phy_device_remove - Remove a previously registered phy device from the MDIO bus
+ * @phydev: phy_device structure to remove
+ *
+ * This doesn't free the phy_device itself, it merely reverses the effects
+ * of phy_device_register(). Use phy_device_free() to free the device
+ * after calling this function.
+ */
+void phy_device_remove(struct phy_device *phydev)
+{
+	struct mii_bus *bus = phydev->bus;
+	int addr = phydev->addr;
+
+	device_del(&phydev->dev);
+	bus->phy_map[addr] = NULL;
+}
+EXPORT_SYMBOL(phy_device_remove);
+
+/**
+ * phy_find_first - finds the first PHY device on the bus
+ * @bus: the target MII bus
+ */
+struct phy_device *phy_find_first(struct mii_bus *bus)
+{
+	int addr;
+
+	for (addr = 0; addr < PHY_MAX_ADDR; addr++) {
+		if (bus->phy_map[addr])
+			return bus->phy_map[addr];
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(phy_find_first);
+
+/**
+ * phy_prepare_link - prepares the PHY layer to monitor link status
+ * @phydev: target phy_device struct
+ * @handler: callback function for link status change notifications
+ *
+ * Description: Tells the PHY infrastructure to handle the
+ *   gory details on monitoring link status (whether through
+ *   polling or an interrupt), and to call back to the
+ *   connected device driver when the link status changes.
+ *   If you want to monitor your own link state, don't call
+ *   this function.
+ */
+static void phy_prepare_link(struct phy_device *phydev,
+			     void (*handler)(struct net_device *))
+{
+	phydev->adjust_link = handler;
+}
+
+/**
+ * phy_connect_direct - connect an ethernet device to a specific phy_device
+ * @dev: the network device to connect
+ * @phydev: the pointer to the phy device
+ * @handler: callback function for state change notifications
+ * @interface: PHY device's interface
+ */
+int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
+		       void (*handler)(struct net_device *),
+		       phy_interface_t interface)
+{
+	int rc;
+
+	rc = phy_attach_direct(dev, phydev, phydev->dev_flags, interface);
+	if (rc)
+		return rc;
+
+	phy_prepare_link(phydev, handler);
+	phy_start_machine(phydev);
+	if (phydev->irq > 0)
+		phy_start_interrupts(phydev);
+
+	return 0;
+}
+EXPORT_SYMBOL(phy_connect_direct);
+
+/**
+ * phy_connect - connect an ethernet device to a PHY device
+ * @dev: the network device to connect
+ * @bus_id: the id string of the PHY device to connect
+ * @handler: callback function for state change notifications
+ * @interface: PHY device's interface
+ *
+ * Description: Convenience function for connecting ethernet
+ *   devices to PHY devices.  The default behavior is for
+ *   the PHY infrastructure to handle everything, and only notify
+ *   the connected driver when the link status changes.  If you
+ *   don't want, or can't use the provided functionality, you may
+ *   choose to call only the subset of functions which provide
+ *   the desired functionality.
+ */
+struct phy_device *phy_connect(struct net_device *dev, const char *bus_id,
+			       void (*handler)(struct net_device *),
+			       phy_interface_t interface)
+{
+	struct phy_device *phydev;
+	struct device *d;
+	int rc;
+
+	/* Search the list of PHY devices on the mdio bus for the
+	 * PHY with the requested name
+	 */
+	d = bus_find_device_by_name(&mdio_bus_type, NULL, bus_id);
+	if (!d) {
+		pr_err("PHY %s not found\n", bus_id);
+		return ERR_PTR(-ENODEV);
+	}
+	phydev = to_phy_device(d);
+
+	rc = phy_connect_direct(dev, phydev, handler, interface);
+	if (rc)
+		return ERR_PTR(rc);
+
+	return phydev;
+}
+EXPORT_SYMBOL(phy_connect);
+
+/**
+ * phy_disconnect - disable interrupts, stop state machine, and detach a PHY
+ *		    device
+ * @phydev: target phy_device struct
+ */
+void phy_disconnect(struct phy_device *phydev)
+{
+	if (phydev->irq > 0)
+		phy_stop_interrupts(phydev);
+
+	phy_stop_machine(phydev);
+
+	phydev->adjust_link = NULL;
+
+	phy_detach(phydev);
+}
+EXPORT_SYMBOL(phy_disconnect);
+
+/**
+ * phy_poll_reset - Safely wait until a PHY reset has properly completed
+ * @phydev: The PHY device to poll
+ *
+ * Description: According to IEEE 802.3, Section 2, Subsection 22.2.4.1.1, as
+ *   published in 2008, a PHY reset may take up to 0.5 seconds.  The MII BMCR
+ *   register must be polled until the BMCR_RESET bit clears.
+ *
+ *   Furthermore, any attempts to write to PHY registers may have no effect
+ *   or even generate MDIO bus errors until this is complete.
+ *
+ *   Some PHYs (such as the Marvell 88E1111) don't entirely conform to the
+ *   standard and do not fully reset after the BMCR_RESET bit is set, and may
+ *   even *REQUIRE* a soft-reset to properly restart autonegotiation.  In an
+ *   effort to support such broken PHYs, this function is separate from the
+ *   standard phy_init_hw() which will zero all the other bits in the BMCR
+ *   and reapply all driver-specific and board-specific fixups.
+ */
+static int phy_poll_reset(struct phy_device *phydev)
+{
+	/* Poll until the reset bit clears (50ms per retry == 0.6 sec) */
+	unsigned int retries = 12;
+	int ret;
+	
+	printk(KERN_INFO "yzhang..phy_poll_reset cal in \n");
+
+	do {
+		msleep(50);
+		ret = phy_read(phydev, MII_BMCR);
+		if (ret < 0)
+			return ret;
+	} while (ret & BMCR_RESET && --retries);
+	if (ret & BMCR_RESET)
+		return -ETIMEDOUT;
+
+	/* Some chips (smsc911x) may still need up to another 1ms after the
+	 * BMCR_RESET bit is cleared before they are usable.
+	 */
+	msleep(1);
+	printk(KERN_INFO "yzhang..phy_poll_reset cal out.\n");
+	return 0;
+}
+
+int phy_init_hw(struct phy_device *phydev)
+{
+	int ret = 0;
+
+	if (!phydev->drv || !phydev->drv->config_init)
+		return 0;
+
+	if (phydev->drv->soft_reset)
+		ret = phydev->drv->soft_reset(phydev);
+	else
+		ret = genphy_soft_reset(phydev);
+
+	if (ret < 0)
+		return ret;
+
+	ret = phy_scan_fixups(phydev);
+	if (ret < 0)
+		return ret;
+
+	return phydev->drv->config_init(phydev);
+}
+EXPORT_SYMBOL(phy_init_hw);
+
+/**
+ * phy_attach_direct - attach a network device to a given PHY device pointer
+ * @dev: network device to attach
+ * @phydev: Pointer to phy_device to attach
+ * @flags: PHY device's dev_flags
+ * @interface: PHY device's interface
+ *
+ * Description: Called by drivers to attach to a particular PHY
+ *     device. The phy_device is found, and properly hooked up
+ *     to the phy_driver.  If no driver is attached, then a
+ *     generic driver is used.  The phy_device is given a ptr to
+ *     the attaching device, and given a callback for link status
+ *     change.  The phy_device is returned to the attaching driver.
+ *     This function takes a reference on the phy device.
+ */
+int phy_attach_direct(struct net_device *dev, struct phy_device *phydev,
+		      u32 flags, phy_interface_t interface)
+{
+	struct mii_bus *bus = phydev->bus;
+	struct device *d = &phydev->dev;
+	int err;
+
+	if (!try_module_get(bus->owner)) {
+		dev_err(&dev->dev, "failed to get the bus module\n");
+		return -EIO;
+	}
+
+	get_device(d);
+
+	/* Assume that if there is no driver, that it doesn't
+	 * exist, and we should use the genphy driver.
+	 */
+	if (!d->driver) {
+		if (phydev->is_c45)
+			d->driver = &genphy_driver[GENPHY_DRV_10G].driver;
+		else
+			d->driver = &genphy_driver[GENPHY_DRV_1G].driver;
+
+		err = d->driver->probe(d);
+		if (err >= 0)
+			err = device_bind_driver(d);
+
+		if (err)
+			goto error;
+	}
+
+	if (phydev->attached_dev) {
+		dev_err(&dev->dev, "PHY already attached\n");
+		err = -EBUSY;
+		goto error;
+	}
+
+	phydev->attached_dev = dev;
+	dev->phydev = phydev;
+
+	phydev->dev_flags = flags;
+
+	phydev->interface = interface;
+
+	phydev->state = PHY_READY;
+
+	/* Do initial configuration here, now that
+	 * we have certain key parameters
+	 * (dev_flags and interface)
+	 */
+	err = phy_init_hw(phydev);
+	if (err)
+		phy_detach(phydev);
+	else
+		phy_resume(phydev);
+
+	return err;
+
+error:
+	put_device(d);
+	module_put(bus->owner);
+	return err;
+}
+EXPORT_SYMBOL(phy_attach_direct);
+
+/**
+ * phy_attach - attach a network device to a particular PHY device
+ * @dev: network device to attach
+ * @bus_id: Bus ID of PHY device to attach
+ * @interface: PHY device's interface
+ *
+ * Description: Same as phy_attach_direct() except that a PHY bus_id
+ *     string is passed instead of a pointer to a struct phy_device.
+ */
+struct phy_device *phy_attach(struct net_device *dev, const char *bus_id,
+			      phy_interface_t interface)
+{
+	struct bus_type *bus = &mdio_bus_type;
+	struct phy_device *phydev;
+	struct device *d;
+	int rc;
+
+	/* Search the list of PHY devices on the mdio bus for the
+	 * PHY with the requested name
+	 */
+	d = bus_find_device_by_name(bus, NULL, bus_id);
+	if (!d) {
+		pr_err("PHY %s not found\n", bus_id);
+		return ERR_PTR(-ENODEV);
+	}
+	phydev = to_phy_device(d);
+
+	rc = phy_attach_direct(dev, phydev, phydev->dev_flags, interface);
+	if (rc)
+		return ERR_PTR(rc);
+
+	return phydev;
+}
+EXPORT_SYMBOL(phy_attach);
+
+/**
+ * phy_detach - detach a PHY device from its network device
+ * @phydev: target phy_device struct
+ *
+ * This detaches the phy device from its network device and the phy
+ * driver, and drops the reference count taken in phy_attach_direct().
+ */
+void phy_detach(struct phy_device *phydev)
+{
+	struct mii_bus *bus;
+	int i;
+
+	phydev->attached_dev->phydev = NULL;
+	phydev->attached_dev = NULL;
+	phy_suspend(phydev);
+
+	/* If the device had no specific driver before (i.e. - it
+	 * was using the generic driver), we unbind the device
+	 * from the generic driver so that there's a chance a
+	 * real driver could be loaded
+	 */
+	for (i = 0; i < ARRAY_SIZE(genphy_driver); i++) {
+		if (phydev->dev.driver == &genphy_driver[i].driver) {
+			device_release_driver(&phydev->dev);
+			break;
+		}
+	}
+
+	/*
+	 * The phydev might go away on the put_device() below, so avoid
+	 * a use-after-free bug by reading the underlying bus first.
+	 */
+	bus = phydev->bus;
+
+	put_device(&phydev->dev);
+	module_put(bus->owner);
+}
+EXPORT_SYMBOL(phy_detach);
+
+int phy_suspend(struct phy_device *phydev)
+{
+	struct phy_driver *phydrv = to_phy_driver(phydev->dev.driver);
+	struct ethtool_wolinfo wol = { .cmd = ETHTOOL_GWOL };
+	int ret = 0;
+
+	/* If the device has WOL enabled, we cannot suspend the PHY */
+	phy_ethtool_get_wol(phydev, &wol);
+	if (wol.wolopts)
+		return -EBUSY;
+
+	if (phydrv->suspend)
+		ret = phydrv->suspend(phydev);
+
+	if (ret)
+		return ret;
+
+	phydev->suspended = true;
+
+	return ret;
+}
+EXPORT_SYMBOL(phy_suspend);
+
+int phy_resume(struct phy_device *phydev)
+{
+	struct phy_driver *phydrv = to_phy_driver(phydev->dev.driver);
+	int ret = 0;
+
+	if (phydrv->resume)
+		ret = phydrv->resume(phydev);
+
+	if (ret)
+		return ret;
+
+	phydev->suspended = false;
+
+	return ret;
+}
+EXPORT_SYMBOL(phy_resume);
+
+/* Generic PHY support and helper functions */
+
+/**
+ * genphy_config_advert - sanitize and advertise auto-negotiation parameters
+ * @phydev: target phy_device struct
+ *
+ * Description: Writes MII_ADVERTISE with the appropriate values,
+ *   after sanitizing the values to make sure we only advertise
+ *   what is supported.  Returns < 0 on error, 0 if the PHY's advertisement
+ *   hasn't changed, and > 0 if it has changed.
+ */
+static int genphy_config_advert(struct phy_device *phydev)
+{
+	u32 advertise;
+	int oldadv, adv, bmsr;
+	int err, changed = 0;
+
+	/* Only allow advertising what this PHY supports */
+	phydev->advertising &= phydev->supported;
+	advertise = phydev->advertising;
+
+	/* Setup standard advertisement */
+	adv = phy_read(phydev, MII_ADVERTISE);
+	if (adv < 0)
+		return adv;
+
+	oldadv = adv;
+	adv &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4 | ADVERTISE_PAUSE_CAP |
+		 ADVERTISE_PAUSE_ASYM);
+	adv |= ethtool_adv_to_mii_adv_t(advertise);
+
+	if (adv != oldadv) {
+		err = phy_write(phydev, MII_ADVERTISE, adv);
+
+		if (err < 0)
+			return err;
+		changed = 1;
+	}
+
+	bmsr = phy_read(phydev, MII_BMSR);
+	if (bmsr < 0)
+		return bmsr;
+
+	/* Per 802.3-2008, Section 22.2.4.2.16 Extended status all
+	 * 1000Mbits/sec capable PHYs shall have the BMSR_ESTATEN bit set to a
+	 * logical 1.
+	 */
+	if (!(bmsr & BMSR_ESTATEN))
+		return changed;
+
+	/* Configure gigabit if it's supported */
+	adv = phy_read(phydev, MII_CTRL1000);
+	if (adv < 0)
+		return adv;
+
+	oldadv = adv;
+	adv &= ~(ADVERTISE_1000FULL | ADVERTISE_1000HALF);
+
+	if (phydev->supported & (SUPPORTED_1000baseT_Half |
+				 SUPPORTED_1000baseT_Full)) {
+		adv |= ethtool_adv_to_mii_ctrl1000_t(advertise);
+	}
+
+	if (adv != oldadv)
+		changed = 1;
+
+	err = phy_write(phydev, MII_CTRL1000, adv);
+	if (err < 0)
+		return err;
+
+	return changed;
+}
+
+/**
+ * genphy_setup_forced - configures/forces speed/duplex from @phydev
+ * @phydev: target phy_device struct
+ *
+ * Description: Configures MII_BMCR to force speed/duplex
+ *   to the values in phydev. Assumes that the values are valid.
+ *   Please see phy_sanitize_settings().
+ */
+int genphy_setup_forced(struct phy_device *phydev)
+{
+	int ctl = 0;
+
+	phydev->pause = 0;
+	phydev->asym_pause = 0;
+
+	if (SPEED_1000 == phydev->speed)
+		ctl |= BMCR_SPEED1000;
+	else if (SPEED_100 == phydev->speed)
+		ctl |= BMCR_SPEED100;
+
+	if (DUPLEX_FULL == phydev->duplex)
+		ctl |= BMCR_FULLDPLX;
+
+	return phy_write(phydev, MII_BMCR, ctl);
+}
+EXPORT_SYMBOL(genphy_setup_forced);
+
+/**
+ * genphy_restart_aneg - Enable and Restart Autonegotiation
+ * @phydev: target phy_device struct
+ */
+int genphy_restart_aneg(struct phy_device *phydev)
+{
+	int ctl = phy_read(phydev, MII_BMCR);
+
+	if (ctl < 0)
+		return ctl;
+
+	ctl |= BMCR_ANENABLE | BMCR_ANRESTART;
+
+	/* Don't isolate the PHY if we're negotiating */
+	ctl &= ~BMCR_ISOLATE;
+
+	return phy_write(phydev, MII_BMCR, ctl);
+}
+EXPORT_SYMBOL(genphy_restart_aneg);
+
+/**
+ * genphy_config_aneg - restart auto-negotiation or write BMCR
+ * @phydev: target phy_device struct
+ *
+ * Description: If auto-negotiation is enabled, we configure the
+ *   advertising, and then restart auto-negotiation.  If it is not
+ *   enabled, then we write the BMCR.
+ */
+int genphy_config_aneg(struct phy_device *phydev)
+{
+	int result;
+
+	if (AUTONEG_ENABLE != phydev->autoneg)
+		return genphy_setup_forced(phydev);
+
+	result = genphy_config_advert(phydev);
+	if (result < 0) /* error */
+		return result;
+	if (result == 0) {
+		/* Advertisement hasn't changed, but maybe aneg was never on to
+		 * begin with?  Or maybe phy was isolated?
+		 */
+		int ctl = phy_read(phydev, MII_BMCR);
+
+		if (ctl < 0)
+			return ctl;
+
+		if (!(ctl & BMCR_ANENABLE) || (ctl & BMCR_ISOLATE))
+			result = 1; /* do restart aneg */
+	}
+
+	/* Only restart aneg if we are advertising something different
+	 * than we were before.
+	 */
+	if (result > 0)
+		result = genphy_restart_aneg(phydev);
+
+	return result;
+}
+EXPORT_SYMBOL(genphy_config_aneg);
+
+/**
+ * genphy_aneg_done - return auto-negotiation status
+ * @phydev: target phy_device struct
+ *
+ * Description: Reads the status register and returns 0 either if
+ *   auto-negotiation is incomplete, or if there was an error.
+ *   Returns BMSR_ANEGCOMPLETE if auto-negotiation is done.
+ */
+int genphy_aneg_done(struct phy_device *phydev)
+{
+	int retval = phy_read(phydev, MII_BMSR);
+
+	return (retval < 0) ? retval : (retval & BMSR_ANEGCOMPLETE);
+}
+EXPORT_SYMBOL(genphy_aneg_done);
+
+static int gen10g_config_aneg(struct phy_device *phydev)
+{
+	return 0;
+}
+
+/**
+ * genphy_update_link - update link status in @phydev
+ * @phydev: target phy_device struct
+ *
+ * Description: Update the value in phydev->link to reflect the
+ *   current link value.  In order to do this, we need to read
+ *   the status register twice, keeping the second value.
+ */
+int genphy_update_link(struct phy_device *phydev)
+{
+	int status;
+
+	/* Do a fake read */
+	status = phy_read(phydev, MII_BMSR);
+	if (status < 0)
+		return status;
+
+	/* Read link and autonegotiation status */
+	status = phy_read(phydev, MII_BMSR);
+	if (status < 0)
+		return status;
+
+	if ((status & BMSR_LSTATUS) == 0)
+		phydev->link = 0;
+	else
+		phydev->link = 1;
+
+	return 0;
+}
+EXPORT_SYMBOL(genphy_update_link);
+
+/**
+ * genphy_read_status - check the link status and update current link state
+ * @phydev: target phy_device struct
+ *
+ * Description: Check the link, then figure out the current state
+ *   by comparing what we advertise with what the link partner
+ *   advertises.  Start by checking the gigabit possibilities,
+ *   then move on to 10/100.
+ */
+int genphy_read_status(struct phy_device *phydev)
+{
+	int adv;
+	int err;
+	int lpa;
+	int lpagb = 0;
+	int common_adv;
+	int common_adv_gb = 0;
+
+	/* Update the link, but return if there was an error */
+	err = genphy_update_link(phydev);
+	if (err)
+		return err;
+
+	phydev->lp_advertising = 0;
+
+	if (AUTONEG_ENABLE == phydev->autoneg) {
+		if (phydev->supported & (SUPPORTED_1000baseT_Half
+					| SUPPORTED_1000baseT_Full)) {
+			lpagb = phy_read(phydev, MII_STAT1000);
+			if (lpagb < 0)
+				return lpagb;
+
+			adv = phy_read(phydev, MII_CTRL1000);
+			if (adv < 0)
+				return adv;
+
+			phydev->lp_advertising =
+				mii_stat1000_to_ethtool_lpa_t(lpagb);
+			common_adv_gb = lpagb & adv << 2;
+		}
+
+		lpa = phy_read(phydev, MII_LPA);
+		if (lpa < 0)
+			return lpa;
+
+		phydev->lp_advertising |= mii_lpa_to_ethtool_lpa_t(lpa);
+
+		adv = phy_read(phydev, MII_ADVERTISE);
+		if (adv < 0)
+			return adv;
+
+		common_adv = lpa & adv;
+
+		phydev->speed = SPEED_10;
+		phydev->duplex = DUPLEX_HALF;
+		phydev->pause = 0;
+		phydev->asym_pause = 0;
+
+		if (common_adv_gb & (LPA_1000FULL | LPA_1000HALF)) {
+			phydev->speed = SPEED_1000;
+
+			if (common_adv_gb & LPA_1000FULL)
+				phydev->duplex = DUPLEX_FULL;
+		} else if (common_adv & (LPA_100FULL | LPA_100HALF)) {
+			phydev->speed = SPEED_100;
+
+			if (common_adv & LPA_100FULL)
+				phydev->duplex = DUPLEX_FULL;
+		} else
+			if (common_adv & LPA_10FULL)
+				phydev->duplex = DUPLEX_FULL;
+
+		if (phydev->duplex == DUPLEX_FULL) {
+			phydev->pause = lpa & LPA_PAUSE_CAP ? 1 : 0;
+			phydev->asym_pause = lpa & LPA_PAUSE_ASYM ? 1 : 0;
+		}
+	} else {
+		int bmcr = phy_read(phydev, MII_BMCR);
+
+		if (bmcr < 0)
+			return bmcr;
+
+		if (bmcr & BMCR_FULLDPLX)
+			phydev->duplex = DUPLEX_FULL;
+		else
+			phydev->duplex = DUPLEX_HALF;
+
+		if (bmcr & BMCR_SPEED1000)
+			phydev->speed = SPEED_1000;
+		else if (bmcr & BMCR_SPEED100)
+			phydev->speed = SPEED_100;
+		else
+			phydev->speed = SPEED_10;
+
+		phydev->pause = 0;
+		phydev->asym_pause = 0;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(genphy_read_status);
+
+static int gen10g_read_status(struct phy_device *phydev)
+{
+	int devad, reg;
+	u32 mmd_mask = phydev->c45_ids.devices_in_package;
+
+	phydev->link = 1;
+
+	/* For now just lie and say it's 10G all the time */
+	phydev->speed = SPEED_10000;
+	phydev->duplex = DUPLEX_FULL;
+
+	for (devad = 0; mmd_mask; devad++, mmd_mask = mmd_mask >> 1) {
+		if (!(mmd_mask & 1))
+			continue;
+
+		/* Read twice because link state is latched and a
+		 * read moves the current state into the register
+		 */
+		phy_read_mmd(phydev, devad, MDIO_STAT1);
+		reg = phy_read_mmd(phydev, devad, MDIO_STAT1);
+		if (reg < 0 || !(reg & MDIO_STAT1_LSTATUS))
+			phydev->link = 0;
+	}
+
+	return 0;
+}
+
+/**
+ * genphy_soft_reset - software reset the PHY via BMCR_RESET bit
+ * @phydev: target phy_device struct
+ *
+ * Description: Perform a software PHY reset using the standard
+ * BMCR_RESET bit and poll for the reset bit to be cleared.
+ *
+ * Returns: 0 on success, < 0 on failure
+ */
+int genphy_soft_reset(struct phy_device *phydev)
+{
+	int ret;
+
+	ret = phy_write(phydev, MII_BMCR, BMCR_RESET);
+	if (ret < 0)
+		return ret;
+
+	return phy_poll_reset(phydev);
+}
+EXPORT_SYMBOL(genphy_soft_reset);
+
+int genphy_config_init(struct phy_device *phydev)
+{
+	int val;
+	u32 features;
+
+	features = (SUPPORTED_TP | SUPPORTED_MII
+			| SUPPORTED_AUI | SUPPORTED_FIBRE |
+			SUPPORTED_BNC);
+
+	/* Do we support autonegotiation? */
+	val = phy_read(phydev, MII_BMSR);
+	if (val < 0)
+		return val;
+
+	if (val & BMSR_ANEGCAPABLE)
+		features |= SUPPORTED_Autoneg;
+
+	if (val & BMSR_100FULL)
+		features |= SUPPORTED_100baseT_Full;
+	if (val & BMSR_100HALF)
+		features |= SUPPORTED_100baseT_Half;
+	if (val & BMSR_10FULL)
+		features |= SUPPORTED_10baseT_Full;
+	if (val & BMSR_10HALF)
+		features |= SUPPORTED_10baseT_Half;
+
+	if (val & BMSR_ESTATEN) {
+		val = phy_read(phydev, MII_ESTATUS);
+		if (val < 0)
+			return val;
+
+		if (val & ESTATUS_1000_TFULL)
+			features |= SUPPORTED_1000baseT_Full;
+		if (val & ESTATUS_1000_THALF)
+			features |= SUPPORTED_1000baseT_Half;
+	}
+
+	phydev->supported &= features;
+	phydev->advertising &= features;
+
+	printk("yzhang..genphy init done,phyid=%08x.\n", phydev->phy_id);
+	return 0;
+}
+
+static int gen10g_soft_reset(struct phy_device *phydev)
+{
+	/* Do nothing for now */
+	return 0;
+}
+EXPORT_SYMBOL(genphy_config_init);
+
+static int gen10g_config_init(struct phy_device *phydev)
+{
+	/* Temporarily just say we support everything */
+	phydev->supported = SUPPORTED_10000baseT_Full;
+	phydev->advertising = SUPPORTED_10000baseT_Full;
+
+	return 0;
+}
+
+int genphy_suspend(struct phy_device *phydev)
+{
+	int value;
+
+	mutex_lock(&phydev->lock);
+
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value | BMCR_PDOWN);
+
+	mutex_unlock(&phydev->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(genphy_suspend);
+
+static int gen10g_suspend(struct phy_device *phydev)
+{
+	return 0;
+}
+
+int genphy_resume(struct phy_device *phydev)
+{
+	int value;
+
+	mutex_lock(&phydev->lock);
+
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value & ~BMCR_PDOWN);
+
+	mutex_unlock(&phydev->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(genphy_resume);
+
+static int gen10g_resume(struct phy_device *phydev)
+{
+	return 0;
+}
+
+static int __set_phy_supported(struct phy_device *phydev, u32 max_speed)
+{
+	/* The default values for phydev->supported are provided by the PHY
+	 * driver "features" member, we want to reset to sane defaults first
+	 * before supporting higher speeds.
+	 */
+	phydev->supported &= PHY_DEFAULT_FEATURES;
+
+	switch (max_speed) {
+	default:
+		return -ENOTSUPP;
+	case SPEED_1000:
+		phydev->supported |= PHY_1000BT_FEATURES;
+		/* fall through */
+	case SPEED_100:
+		phydev->supported |= PHY_100BT_FEATURES;
+		/* fall through */
+	case SPEED_10:
+		phydev->supported |= PHY_10BT_FEATURES;
+	}
+
+	return 0;
+}
+
+int phy_set_max_speed(struct phy_device *phydev, u32 max_speed)
+{
+	int err;
+
+	err = __set_phy_supported(phydev, max_speed);
+	if (err)
+		return err;
+
+	phydev->advertising = phydev->supported;
+
+	return 0;
+}
+EXPORT_SYMBOL(phy_set_max_speed);
+
+static void of_set_phy_supported(struct phy_device *phydev)
+{
+	struct device_node *node = phydev->dev.of_node;
+	u32 max_speed;
+
+	if (!IS_ENABLED(CONFIG_OF_MDIO))
+		return;
+
+	if (!node)
+		return;
+
+	if (!of_property_read_u32(node, "max-speed", &max_speed))
+		__set_phy_supported(phydev, max_speed);
+}
+
+/**
+ * phy_probe - probe and init a PHY device
+ * @dev: device to probe and init
+ *
+ * Description: Take care of setting up the phy_device structure,
+ *   set the state to READY (the driver's init function should
+ *   set it to STARTING if needed).
+ */
+static int phy_probe(struct device *dev)
+{
+	struct phy_device *phydev = to_phy_device(dev);
+	struct device_driver *drv = phydev->dev.driver;
+	struct phy_driver *phydrv = to_phy_driver(drv);
+	int err = 0;
+
+	phydev->drv = phydrv;
+
+	/* Disable the interrupt if the PHY doesn't support it
+	 * but the interrupt is still a valid one
+	 */
+	if (!(phydrv->flags & PHY_HAS_INTERRUPT) &&
+	    phy_interrupt_is_valid(phydev))
+		phydev->irq = PHY_POLL;
+
+	if (phydrv->flags & PHY_IS_INTERNAL)
+		phydev->is_internal = true;
+
+	mutex_lock(&phydev->lock);
+
+	/* Start out supporting everything. Eventually,
+	 * a controller will attach, and may modify one
+	 * or both of these values
+	 */
+	phydev->supported = phydrv->features;
+	of_set_phy_supported(phydev);
+	phydev->advertising = phydev->supported;
+
+	/* Set the state to READY by default */
+	phydev->state = PHY_READY;
+
+	if (phydev->drv->probe)
+		err = phydev->drv->probe(phydev);
+
+	mutex_unlock(&phydev->lock);
+
+	return err;
+}
+
+static int phy_remove(struct device *dev)
+{
+	struct phy_device *phydev = to_phy_device(dev);
+
+	cancel_delayed_work_sync(&phydev->state_queue);
+
+	mutex_lock(&phydev->lock);
+	phydev->state = PHY_DOWN;
+	mutex_unlock(&phydev->lock);
+
+	if (phydev->drv->remove)
+		phydev->drv->remove(phydev);
+	phydev->drv = NULL;
+
+	return 0;
+}
+
+/**
+ * phy_driver_register - register a phy_driver with the PHY layer
+ * @new_driver: new phy_driver to register
+ */
+int phy_driver_register(struct phy_driver *new_driver)
+{
+	int retval;
+
+	new_driver->driver.name = new_driver->name;
+	new_driver->driver.bus = &mdio_bus_type;
+	new_driver->driver.probe = phy_probe;
+	new_driver->driver.remove = phy_remove;
+
+	retval = driver_register(&new_driver->driver);
+	if (retval) {
+		pr_err("%s: Error %d in registering driver\n",
+		       new_driver->name, retval);
+
+		return retval;
+	}
+
+	pr_debug("%s: Registered new driver\n", new_driver->name);
+
+	return 0;
+}
+EXPORT_SYMBOL(phy_driver_register);
+
+int phy_drivers_register(struct phy_driver *new_driver, int n)
+{
+	int i, ret = 0;
+
+	for (i = 0; i < n; i++) {
+		ret = phy_driver_register(new_driver + i);
+		if (ret) {
+			while (i-- > 0)
+				phy_driver_unregister(new_driver + i);
+			break;
+		}
+	}
+	return ret;
+}
+EXPORT_SYMBOL(phy_drivers_register);
+
+void phy_driver_unregister(struct phy_driver *drv)
+{
+	driver_unregister(&drv->driver);
+}
+EXPORT_SYMBOL(phy_driver_unregister);
+
+void phy_drivers_unregister(struct phy_driver *drv, int n)
+{
+	int i;
+
+	for (i = 0; i < n; i++)
+		phy_driver_unregister(drv + i);
+}
+EXPORT_SYMBOL(phy_drivers_unregister);
+
+static struct phy_driver genphy_driver[] = {
+{
+	.phy_id		= 0xffffffff,
+	.phy_id_mask	= 0xffffffff,
+	.name		= "Generic PHY",
+	.soft_reset	= genphy_no_soft_reset,
+	.config_init	= genphy_config_init,
+	.features	= PHY_GBIT_FEATURES | SUPPORTED_MII |
+			  SUPPORTED_AUI | SUPPORTED_FIBRE |
+			  SUPPORTED_BNC,
+	.config_aneg	= genphy_config_aneg,
+	.aneg_done	= genphy_aneg_done,
+	.read_status	= genphy_read_status,
+	.suspend	= genphy_suspend,
+	.resume		= genphy_resume,
+	.driver		= { .owner = THIS_MODULE, },
+}, {
+	.phy_id         = 0xffffffff,
+	.phy_id_mask    = 0xffffffff,
+	.name           = "Generic 10G PHY",
+	.soft_reset	= gen10g_soft_reset,
+	.config_init    = gen10g_config_init,
+	.features       = 0,
+	.config_aneg    = gen10g_config_aneg,
+	.read_status    = gen10g_read_status,
+	.suspend        = gen10g_suspend,
+	.resume         = gen10g_resume,
+	.driver         = {.owner = THIS_MODULE, },
+} };
+
+static int __init phy_init(void)
+{
+	int rc;
+
+	rc = mdio_bus_init();
+	if (rc)
+		return rc;
+
+	rc = phy_drivers_register(genphy_driver,
+				  ARRAY_SIZE(genphy_driver));
+	if (rc)
+		mdio_bus_exit();
+
+	return rc;
+}
+
+static void __exit phy_exit(void)
+{
+	phy_drivers_unregister(genphy_driver,
+			       ARRAY_SIZE(genphy_driver));
+	mdio_bus_exit();
+}
+
+subsys_initcall(phy_init);
+module_exit(phy_exit);
diff --git a/drivers/net/phy/for-reference-only/phy_device.c.Readme.txt b/drivers/net/phy/for-reference-only/phy_device.c.Readme.txt
new file mode 100644
index 000000000..f551fcea9
--- /dev/null
+++ b/drivers/net/phy/for-reference-only/phy_device.c.Readme.txt
@@ -0,0 +1 @@
+for Motorcomm Phy support in RK3399/3288 platform, please refer to changes to this file: phy_device.c
\ No newline at end of file
diff --git a/drivers/net/phy/motorcomm.c b/drivers/net/phy/motorcomm.c
new file mode 100644
index 000000000..f2fb62a48
--- /dev/null
+++ b/drivers/net/phy/motorcomm.c
@@ -0,0 +1,1497 @@
+/*
+ * drivers/net/phy/motorcomm.c
+ *
+ * Driver for Motorcomm PHYs
+ *
+ * Author: Leilei Zhao <leilei.zhao@motorcomm.com>
+ *
+ * Copyright (c) 2019 Motorcomm, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Support : Motorcomm Phys:
+ *		Giga phys: yt8511, yt8521
+ *		100/10 Phys : yt8512, yt8512b, yt8510
+ *		Automotive 100Mb Phys : yt8010
+ *		Automotive 100/10 hyper range Phys: yt8510
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/phy.h>
+#include <linux/motorcomm_phy.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#ifndef LINUX_VERSION_CODE
+#include <linux/version.h>
+#else
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
+#endif
+/*for wol, 20210604*/
+#include <linux/netdevice.h>
+
+#include "yt8614-phy.h"
+
+/**** configuration section begin ***********/
+
+/* if system depends on ethernet packet to restore from sleep, please define this macro to 1
+ * otherwise, define it to 0.
+ */
+#define SYS_WAKEUP_BASED_ON_ETH_PKT 	0
+
+/* to enable system WOL of phy, please define this macro to 1
+ * otherwise, define it to 0.
+ */
+#define YTPHY_ENABLE_WOL 		0
+
+/* some GMAC need clock input from PHY, for eg., 125M, please enable this macro
+ * by degault, it is set to 0
+ * NOTE: this macro will need macro SYS_WAKEUP_BASED_ON_ETH_PKT to set to 1
+ */
+#define GMAC_CLOCK_INPUT_NEEDED 0
+
+
+#define YT8521_PHY_MODE_FIBER	1 //fiber mode only
+#define YT8521_PHY_MODE_UTP		2 //utp mode only
+#define YT8521_PHY_MODE_POLL	3 //fiber and utp, poll mode
+
+/* please make choice according to system design
+ * for Fiber only system, please define YT8521_PHY_MODE_CURR 1
+ * for UTP only system, please define YT8521_PHY_MODE_CURR 2
+ * for combo system, please define YT8521_PHY_MODE_CURR 3 
+ */
+#define YT8521_PHY_MODE_CURR	3
+
+/**** configuration section end ***********/
+
+
+/* no need to change below */
+
+#if (YTPHY_ENABLE_WOL)
+#undef SYS_WAKEUP_BASED_ON_ETH_PKT
+#define SYS_WAKEUP_BASED_ON_ETH_PKT 	1
+#endif
+
+/* workaround for 8521 fiber 100m mode */
+static int link_mode_8521 = 0; //0: no link; 1: utp; 32: fiber. traced that 1000m fiber uses 32.
+static int link_mode_8614[4] = {0}; //0: no link; 1: utp; 32: fiber. traced that 1000m fiber uses 32.
+
+/* for multiple port phy, base phy address */
+static unsigned int yt_mport_base_phy_addr = 0xff; //0xff: invalid; for 8618
+static unsigned int yt_mport_base_phy_addr_8614 = 0xff; //0xff: invalid;
+
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(5,0,0) )
+int genphy_config_init(struct phy_device *phydev)
+{
+	return  genphy_read_abilities(phydev);
+}
+#endif
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+static int ytphy_config_init(struct phy_device *phydev)
+{
+	return 0;
+}
+#endif
+
+static int ytphy_read_ext(struct phy_device *phydev, u32 regnum)
+{
+	int ret;
+	int val;
+
+	ret = phy_write(phydev, REG_DEBUG_ADDR_OFFSET, regnum);
+	if (ret < 0)
+		return ret;
+
+	val = phy_read(phydev, REG_DEBUG_DATA);
+
+	return val;
+}
+
+static int ytphy_write_ext(struct phy_device *phydev, u32 regnum, u16 val)
+{
+	int ret;
+
+	ret = phy_write(phydev, REG_DEBUG_ADDR_OFFSET, regnum);
+	if (ret < 0)
+		return ret;
+
+	ret = phy_write(phydev, REG_DEBUG_DATA, val);
+
+	return ret;
+}
+
+static int yt8010_config_aneg(struct phy_device *phydev)
+{
+	phydev->speed = SPEED_100;
+	return 0;
+}
+
+static int yt8512_clk_init(struct phy_device *phydev)
+{
+	int ret;
+	int val;
+
+	val = ytphy_read_ext(phydev, YT8512_EXTREG_AFE_PLL);
+	if (val < 0)
+		return val;
+
+	val |= YT8512_CONFIG_PLL_REFCLK_SEL_EN;
+
+	ret = ytphy_write_ext(phydev, YT8512_EXTREG_AFE_PLL, val);
+	if (ret < 0)
+		return ret;
+
+	val = ytphy_read_ext(phydev, YT8512_EXTREG_EXTEND_COMBO);
+	if (val < 0)
+		return val;
+
+	val |= YT8512_CONTROL1_RMII_EN;
+
+	ret = ytphy_write_ext(phydev, YT8512_EXTREG_EXTEND_COMBO, val);
+	if (ret < 0)
+		return ret;
+
+	val = phy_read(phydev, MII_BMCR);
+	if (val < 0)
+		return val;
+
+	val |= YT_SOFTWARE_RESET;
+	ret = phy_write(phydev, MII_BMCR, val);
+
+	return ret;
+}
+
+static int yt8512_led_init(struct phy_device *phydev)
+{
+	int ret;
+	int val;
+	int mask;
+
+	val = ytphy_read_ext(phydev, YT8512_EXTREG_LED0);
+	if (val < 0)
+		return val;
+
+	val |= YT8512_LED0_ACT_BLK_IND;
+
+	mask = YT8512_LED0_DIS_LED_AN_TRY | YT8512_LED0_BT_BLK_EN |
+		YT8512_LED0_HT_BLK_EN | YT8512_LED0_COL_BLK_EN |
+		YT8512_LED0_BT_ON_EN;
+	val &= ~mask;
+
+	ret = ytphy_write_ext(phydev, YT8512_EXTREG_LED0, val);
+	if (ret < 0)
+		return ret;
+
+	val = ytphy_read_ext(phydev, YT8512_EXTREG_LED1);
+	if (val < 0)
+		return val;
+
+	val |= YT8512_LED1_BT_ON_EN;
+
+	mask = YT8512_LED1_TXACT_BLK_EN | YT8512_LED1_RXACT_BLK_EN;
+	val &= ~mask;
+
+	ret = ytphy_write_ext(phydev, YT8512_LED1_BT_ON_EN, val);
+
+	return ret;
+}
+
+static int yt8512_config_init(struct phy_device *phydev)
+{
+	int ret;
+	int val;
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	ret = ytphy_config_init(phydev);
+#else
+	ret = genphy_config_init(phydev);
+#endif
+	if (ret < 0)
+		return ret;
+
+	ret = yt8512_clk_init(phydev);
+	if (ret < 0)
+		return ret;
+
+	ret = yt8512_led_init(phydev);
+
+	/* disable auto sleep */
+	val = ytphy_read_ext(phydev, YT8512_EXTREG_SLEEP_CONTROL1);
+	if (val < 0)
+		return val;
+
+	val &= (~BIT(YT8512_EN_SLEEP_SW_BIT));
+
+	ret = ytphy_write_ext(phydev, YT8512_EXTREG_SLEEP_CONTROL1, val);
+	if (ret < 0)
+		return ret;
+
+	return ret;
+}
+
+static int yt8512_read_status(struct phy_device *phydev)
+{
+	int ret;
+	int val;
+	int speed, speed_mode, duplex;
+
+	ret = genphy_update_link(phydev);
+	if (ret)
+		return ret;
+
+	val = phy_read(phydev, REG_PHY_SPEC_STATUS);
+	if (val < 0)
+		return val;
+
+	duplex = (val & YT8512_DUPLEX) >> YT8512_DUPLEX_BIT;
+	speed_mode = (val & YT8512_SPEED_MODE) >> YT8512_SPEED_MODE_BIT;
+	switch (speed_mode) {
+	case 0:
+		speed = SPEED_10;
+		break;
+	case 1:
+		speed = SPEED_100;
+		break;
+	case 2:
+	case 3:
+	default:
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+		speed = -1;
+#else
+		speed = SPEED_UNKNOWN;
+#endif
+		break;
+	}
+
+	phydev->speed = speed;
+	phydev->duplex = duplex;
+
+	return 0;
+}
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+#else
+#if 0
+int yt8521_soft_reset(struct phy_device *phydev)
+{
+	int ret;
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+	ret = genphy_soft_reset(phydev);
+	if (ret < 0)
+		return ret;
+
+	ytphy_write_ext(phydev, 0xa000, 2);
+	ret = genphy_soft_reset(phydev);
+	if (ret < 0) {
+		ytphy_write_ext(phydev, 0xa000, 0);
+		return ret;
+	}
+
+	return 0;
+}
+#else
+/* qingsong feedback 2 genphy_soft_reset will cause problem.
+ * and this is the reduction version
+ */
+int yt8521_soft_reset(struct phy_device *phydev)
+{
+	int ret, val;
+
+	val = ytphy_read_ext(phydev, 0xa001);
+	ytphy_write_ext(phydev, 0xa001, (val & ~0x8000));
+
+	ret = genphy_soft_reset(phydev);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+#endif
+
+#endif
+
+#if GMAC_CLOCK_INPUT_NEEDED
+static int ytphy_mii_rd_ext(struct mii_bus *bus, int phy_id, u32 regnum)
+{
+	int ret;
+	int val;
+
+	ret = bus->write(bus, phy_id, REG_DEBUG_ADDR_OFFSET, regnum);
+	if (ret < 0)
+		return ret;
+
+	val = bus->read(bus, phy_id, REG_DEBUG_DATA);
+
+	return val;
+}
+
+static int ytphy_mii_wr_ext(struct mii_bus *bus, int phy_id, u32 regnum, u16 val)
+{
+	int ret;
+
+	ret = bus->write(bus, phy_id, REG_DEBUG_ADDR_OFFSET, regnum);
+	if (ret < 0)
+		return ret;
+
+	ret = bus->write(bus, phy_id, REG_DEBUG_DATA, val);
+
+	return ret;
+}
+
+int yt8511_config_dis_txdelay(struct mii_bus *bus, int phy_id)
+{
+    int ret;
+    int val;
+
+    /* disable auto sleep */
+    val = ytphy_mii_rd_ext(bus, phy_id, 0x27);
+    if (val < 0)
+            return val;
+
+    val &= (~BIT(15));
+
+    ret = ytphy_mii_wr_ext(bus, phy_id, 0x27, val);
+    if (ret < 0)
+            return ret;
+
+    /* enable RXC clock when no wire plug */
+    val = ytphy_mii_rd_ext(bus, phy_id, 0xc);
+    if (val < 0)
+            return val;
+
+    /* ext reg 0xc b[7:4]
+	Tx Delay time = 150ps * N - 250ps
+    */
+    val &= ~(0xf << 4);
+    ret = ytphy_mii_wr_ext(bus, phy_id, 0xc, val);
+    printk("yt8511_config_dis_txdelay..phy txdelay, val=%#08x\n",val);
+
+    return ret;
+}
+
+
+int yt8511_config_out_125m(struct mii_bus *bus, int phy_id)
+{
+	int ret;
+	int val;
+
+	/* disable auto sleep */
+	val = ytphy_mii_rd_ext(bus, phy_id, 0x27);
+	if (val < 0)
+	        return val;
+
+	val &= (~BIT(15));
+
+	ret = ytphy_mii_wr_ext(bus, phy_id, 0x27, val);
+	if (ret < 0)
+	        return ret;
+
+	/* enable RXC clock when no wire plug */
+	val = ytphy_mii_rd_ext(bus, phy_id, 0xc);
+	if (val < 0)
+	        return val;
+
+	/* ext reg 0xc.b[2:1]
+	00-----25M from pll;
+	01---- 25M from xtl;(default)
+	10-----62.5M from pll;
+	11----125M from pll(here set to this value)
+	*/
+	val |= (3 << 1);
+	ret = ytphy_mii_wr_ext(bus, phy_id, 0xc, val);
+	printk("yt8511_config_out_125m, phy clk out, val=%#08x\n",val);
+
+#if 0
+	/* for customer, please enable it based on demand.
+	 * configure to master
+	 */	
+	val = bus->read(bus, phy_id, 0x9/*master/slave config reg*/);
+	val |= (0x3<<11); //to be manual config and force to be master
+	ret = bus->write(bus, phy_id, 0x9, val); //take effect until phy soft reset
+	if (ret < 0)
+		return ret;
+
+	printk("yt8511_config_out_125m, phy to be master, val=%#08x\n",val);
+#endif
+
+    return ret;
+}
+
+static int yt8511_config_init(struct phy_device *phydev)
+{
+	int ret;
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	ret = ytphy_config_init(phydev);
+#else
+	ret = genphy_config_init(phydev);
+#endif
+
+	return ret;
+}
+#endif /*GMAC_CLOCK_INPUT_NEEDED*/
+
+#if (YTPHY_ENABLE_WOL)
+static int ytphy_switch_reg_space(struct phy_device *phydev, int space)
+{
+	int ret;
+
+	if (space == YTPHY_REG_SPACE_UTP){
+		ret = ytphy_write_ext(phydev, 0xa000, 0);
+	}else{
+		ret = ytphy_write_ext(phydev, 0xa000, 2);
+	}
+	
+	return ret;
+}
+
+static int ytphy_wol_en_cfg(struct phy_device *phydev, ytphy_wol_cfg_t wol_cfg)
+{
+	int ret=0;
+	int val=0;
+
+	val = ytphy_read_ext(phydev, YTPHY_WOL_CFG_REG);
+	if (val < 0)
+		return val;
+
+	if(wol_cfg.enable) {
+		val |= YTPHY_WOL_CFG_EN;
+
+		if(wol_cfg.type == YTPHY_WOL_TYPE_LEVEL) {
+			val &= ~YTPHY_WOL_CFG_TYPE;
+			val &= ~YTPHY_WOL_CFG_INTR_SEL;
+		} else if(wol_cfg.type == YTPHY_WOL_TYPE_PULSE) {
+			val |= YTPHY_WOL_CFG_TYPE;
+			val |= YTPHY_WOL_CFG_INTR_SEL;
+
+			if(wol_cfg.width == YTPHY_WOL_WIDTH_84MS) {
+				val &= ~YTPHY_WOL_CFG_WIDTH1;
+				val &= ~YTPHY_WOL_CFG_WIDTH2;
+			} else if(wol_cfg.width == YTPHY_WOL_WIDTH_168MS) {
+				val |= YTPHY_WOL_CFG_WIDTH1;
+				val &= ~YTPHY_WOL_CFG_WIDTH2;
+			} else if(wol_cfg.width == YTPHY_WOL_WIDTH_336MS) {
+				val &= ~YTPHY_WOL_CFG_WIDTH1;
+				val |= YTPHY_WOL_CFG_WIDTH2;
+			} else if(wol_cfg.width == YTPHY_WOL_WIDTH_672MS) {
+				val |= YTPHY_WOL_CFG_WIDTH1;
+				val |= YTPHY_WOL_CFG_WIDTH2;
+			}
+		}
+	} else {
+		val &= ~YTPHY_WOL_CFG_EN;
+		val &= ~YTPHY_WOL_CFG_INTR_SEL;
+	}
+
+	ret = ytphy_write_ext(phydev, YTPHY_WOL_CFG_REG, val);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void ytphy_get_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)
+{
+	int val = 0;
+
+	wol->supported = WAKE_MAGIC;
+	wol->wolopts = 0;
+
+	val = ytphy_read_ext(phydev, YTPHY_WOL_CFG_REG);
+	if (val < 0)
+		return;
+
+	if (val & YTPHY_WOL_CFG_EN)
+		wol->wolopts |= WAKE_MAGIC;
+
+	return;
+}
+
+static int ytphy_set_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)
+{
+	int ret, pre_page, val;
+	ytphy_wol_cfg_t wol_cfg;
+	struct net_device *p_attached_dev = phydev->attached_dev;
+
+	memset(&wol_cfg,0,sizeof(ytphy_wol_cfg_t));
+	pre_page = ytphy_read_ext(phydev, 0xa000);
+	if (pre_page < 0)
+		return pre_page;
+
+	/* Switch to phy UTP page */
+	ret = ytphy_switch_reg_space(phydev, YTPHY_REG_SPACE_UTP);
+	if (ret < 0)
+		return ret;
+
+	if (wol->wolopts & WAKE_MAGIC) {
+		
+		/* Enable the WOL interrupt */
+		val = phy_read(phydev, YTPHY_UTP_INTR_REG);
+		val |= YTPHY_WOL_INTR;
+		ret = phy_write(phydev, YTPHY_UTP_INTR_REG, val);
+		if (ret < 0)
+			return ret;
+
+		/* Set the WOL config */
+		wol_cfg.enable = 1; //enable
+		wol_cfg.type= YTPHY_WOL_TYPE_PULSE;
+		wol_cfg.width= YTPHY_WOL_WIDTH_672MS;
+		ret = ytphy_wol_en_cfg(phydev, wol_cfg);
+		if (ret < 0)
+			return ret;
+
+		/* Store the device address for the magic packet */
+		ret = ytphy_write_ext(phydev, YTPHY_MAGIC_PACKET_MAC_ADDR2,
+				((p_attached_dev->dev_addr[0] << 8) |
+				 p_attached_dev->dev_addr[1]));
+		if (ret < 0)
+			return ret;
+		ret = ytphy_write_ext(phydev, YTPHY_MAGIC_PACKET_MAC_ADDR1,
+				((p_attached_dev->dev_addr[2] << 8) |
+				 p_attached_dev->dev_addr[3]));
+		if (ret < 0)
+			return ret;
+		ret = ytphy_write_ext(phydev, YTPHY_MAGIC_PACKET_MAC_ADDR0,
+				((p_attached_dev->dev_addr[4] << 8) |
+				 p_attached_dev->dev_addr[5]));
+		if (ret < 0)
+			return ret;
+	} else {
+		wol_cfg.enable = 0; //disable
+		wol_cfg.type= YTPHY_WOL_TYPE_MAX;
+		wol_cfg.width= YTPHY_WOL_WIDTH_MAX;
+		ret = ytphy_wol_en_cfg(phydev, wol_cfg);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* Recover to previous register space page */
+	ret = ytphy_switch_reg_space(phydev, pre_page);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+#endif /*(YTPHY_ENABLE_WOL)*/
+
+static int yt8521_config_init(struct phy_device *phydev)
+{
+	int ret;
+	int val;
+
+	phydev->irq = PHY_POLL;
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	ret = ytphy_config_init(phydev);
+#else
+	ret = genphy_config_init(phydev);
+#endif
+	if (ret < 0)
+		return ret;
+
+	/* disable auto sleep */
+	val = ytphy_read_ext(phydev, YT8521_EXTREG_SLEEP_CONTROL1);
+	if (val < 0)
+		return val;
+
+	val &= (~BIT(YT8521_EN_SLEEP_SW_BIT));
+
+	ret = ytphy_write_ext(phydev, YT8521_EXTREG_SLEEP_CONTROL1, val);
+	if (ret < 0)
+		return ret;
+
+	/* enable RXC clock when no wire plug */
+	ret = ytphy_write_ext(phydev, 0xa000, 0);
+	if (ret < 0)
+		return ret;
+
+	val = ytphy_read_ext(phydev, 0xc);
+	if (val < 0)
+		return val;
+	val &= ~(1 << 12);
+	ret = ytphy_write_ext(phydev, 0xc, val);
+	if (ret < 0)
+		return ret;
+
+	printk (KERN_INFO "yt8521_config_init, 8521 init call out.\n");
+	return ret;
+}
+
+/*
+ * for fiber mode, there is no 10M speed mode and 
+ * this function is for this purpose.
+ */
+static int yt8521_adjust_status(struct phy_device *phydev, int val, int is_utp)
+{
+	int speed_mode, duplex;
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	int speed = -1;
+#else
+	int speed = SPEED_UNKNOWN;
+#endif
+
+	duplex = (val & YT8512_DUPLEX) >> YT8521_DUPLEX_BIT;
+	speed_mode = (val & YT8521_SPEED_MODE) >> YT8521_SPEED_MODE_BIT;
+	switch (speed_mode) {
+	case 0:
+		if (is_utp)
+			speed = SPEED_10;
+		break;
+	case 1:
+		speed = SPEED_100;
+		break;
+	case 2:
+		speed = SPEED_1000;
+		break;
+	case 3:
+		break;
+	default:
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+		speed = -1;
+#else
+		speed = SPEED_UNKNOWN;
+#endif
+		break;
+	}
+
+	phydev->speed = speed;
+	phydev->duplex = duplex;
+	//printk (KERN_INFO "yt8521_adjust_status call out,regval=0x%04x,mode=%s,speed=%dm...\n", val,is_utp?"utp":"fiber", phydev->speed);
+
+	return 0;
+}
+
+/*
+ * for fiber mode, when speed is 100M, there is no definition for autonegotiation, and
+ * this function handles this case and return 1 per linux kernel's polling.
+ */
+int yt8521_aneg_done (struct phy_device *phydev)
+{
+
+	//printk("yt8521_aneg_done callin,speed=%dm,linkmoded=%d\n", phydev->speed,link_mode_8521);
+
+	if((32 == link_mode_8521) && (SPEED_100 == phydev->speed))
+	{
+		return 1/*link_mode_8521*/;
+	}
+
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(3,11,0) )
+	return genphy_aneg_done(phydev);
+#else
+	return 1;
+#endif
+}
+
+static int yt8521_read_status(struct phy_device *phydev)
+{
+	int ret;
+	volatile int val, yt8521_fiber_latch_val, yt8521_fiber_curr_val;
+	volatile int link;
+	int link_utp = 0, link_fiber = 0;
+
+#if (YT8521_PHY_MODE_CURR != YT8521_PHY_MODE_FIBER)
+	/* reading UTP */
+	ret = ytphy_write_ext(phydev, 0xa000, 0);
+	if (ret < 0)
+		return ret;
+
+	val = phy_read(phydev, REG_PHY_SPEC_STATUS);
+	if (val < 0)
+		return val;
+
+	link = val & (BIT(YT8521_LINK_STATUS_BIT));
+	if (link) {
+		link_utp = 1;
+		link_mode_8521 = 1;
+		yt8521_adjust_status(phydev, val, 1);
+	} else {
+		link_utp = 0;
+	}
+#endif //(YT8521_PHY_MODE_CURR != YT8521_PHY_MODE_FIBER)
+
+#if (YT8521_PHY_MODE_CURR != YT8521_PHY_MODE_UTP)
+	/* reading Fiber */
+	ret = ytphy_write_ext(phydev, 0xa000, 2);
+	if (ret < 0)
+		return ret;
+
+	val = phy_read(phydev, REG_PHY_SPEC_STATUS);
+	if (val < 0)
+		return val;
+	
+	//note: below debug information is used to check multiple PHy ports.
+	//printk (KERN_INFO "yt8521_read_status, fiber status=%04x,macbase=0x%08lx\n", val,(unsigned long)phydev->attached_dev);
+
+	/* for fiber, from 1000m to 100m, there is not link down from 0x11, and check reg 1 to identify such case
+	 * this is important for Linux kernel for that, missing linkdown event will cause problem.
+	 */	
+	yt8521_fiber_latch_val = phy_read(phydev, MII_BMSR);
+	yt8521_fiber_curr_val = phy_read(phydev, MII_BMSR);
+	link = val & (BIT(YT8521_LINK_STATUS_BIT));
+	if((link) && (yt8521_fiber_latch_val != yt8521_fiber_curr_val))
+	{
+		link = 0;
+		printk (KERN_INFO "yt8521_read_status, fiber link down detect,latch=%04x,curr=%04x\n", yt8521_fiber_latch_val,yt8521_fiber_curr_val);
+	}
+	
+	if (link) {
+		link_fiber = 1;
+		yt8521_adjust_status(phydev, val, 0);
+		link_mode_8521 = 32; //fiber mode
+
+
+	} else {
+		link_fiber = 0;
+	}
+#endif //(YT8521_PHY_MODE_CURR != YT8521_PHY_MODE_UTP)
+
+	if (link_utp || link_fiber) {
+		phydev->link = 1;
+	} else {
+		phydev->link = 0;
+		link_mode_8521 = 0;
+	}
+
+#if (YT8521_PHY_MODE_CURR != YT8521_PHY_MODE_FIBER)
+	if (link_utp) {
+		ytphy_write_ext(phydev, 0xa000, 0);
+	}
+#endif
+
+	//printk (KERN_INFO "yzhang..8521 read status call out,link=%d,linkmode=%d\n", phydev->link, link_mode_8521 );
+	return 0;
+}
+
+int yt8521_suspend(struct phy_device *phydev)
+{
+#if !(SYS_WAKEUP_BASED_ON_ETH_PKT)				
+	int value;
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_lock(&phydev->lock);
+#else
+	/* no need lock in 4.19 */
+#endif
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value | BMCR_PDOWN);
+
+	ytphy_write_ext(phydev, 0xa000, 2);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value | BMCR_PDOWN);
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_unlock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+#endif /*!(SYS_WAKEUP_BASED_ON_ETH_PKT)*/				
+
+	return 0;
+}
+
+int yt8521_resume(struct phy_device *phydev)
+{
+#if !(SYS_WAKEUP_BASED_ON_ETH_PKT)				
+	int value;
+	int ret;
+	
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_lock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value & ~BMCR_PDOWN);
+
+	/* disable auto sleep */
+	value = ytphy_read_ext(phydev, YT8521_EXTREG_SLEEP_CONTROL1);
+	if (value < 0)
+		return value;
+
+	value &= (~BIT(YT8521_EN_SLEEP_SW_BIT));
+	ret = ytphy_write_ext(phydev, YT8521_EXTREG_SLEEP_CONTROL1, value);
+	if (ret < 0)
+		return ret;
+
+	/* enable RXC clock when no wire plug */
+	value = ytphy_read_ext(phydev, 0xc);
+	if (value < 0)
+		return value;
+	value &= ~(1 << 12);
+	ret = ytphy_write_ext(phydev, 0xc, value);
+	if (ret < 0)
+		return ret;
+
+	ytphy_write_ext(phydev, 0xa000, 2);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value & ~BMCR_PDOWN);
+
+#if (YT8521_PHY_MODE_CURR != YT8521_PHY_MODE_FIBER)
+	ytphy_write_ext(phydev, 0xa000, 0);
+#endif
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_unlock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+#endif /*!(SYS_WAKEUP_BASED_ON_ETH_PKT)*/				
+
+	return 0;
+}
+
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+#else
+int yt8618_soft_reset(struct phy_device *phydev)
+{
+	int ret;
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+	ret = genphy_soft_reset(phydev);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+int yt8614_soft_reset(struct phy_device *phydev)
+{
+	int ret;
+
+	/* utp */
+	ytphy_write_ext(phydev, 0xa000, 0);
+	ret = genphy_soft_reset(phydev);
+	if (ret < 0)
+		return ret;
+
+	/* qsgmii */
+	ytphy_write_ext(phydev, 0xa000, 2);
+	ret = genphy_soft_reset(phydev);
+	if (ret < 0) {
+		ytphy_write_ext(phydev, 0xa000, 0); //back to utp mode
+		return ret;
+	}
+
+	/* sgmii */
+	ytphy_write_ext(phydev, 0xa000, 3);
+	ret = genphy_soft_reset(phydev);
+	if (ret < 0) {
+		ytphy_write_ext(phydev, 0xa000, 0); //back to utp mode
+		return ret;
+	}
+
+	return 0;
+}
+
+#endif
+
+static int yt8618_config_init(struct phy_device *phydev)
+{
+	int ret;
+	int val;
+
+	phydev->irq = PHY_POLL;
+
+	if(0xff == yt_mport_base_phy_addr)
+		/* by default, we think the first phy should be the base phy addr. for mul */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	{
+		yt_mport_base_phy_addr = phydev->addr;
+	}else if (yt_mport_base_phy_addr > phydev->addr) { 
+		printk (KERN_INFO "yzhang..8618 init, phy address mismatch, base=%d, cur=%d\n", yt_mport_base_phy_addr, phydev->addr);
+	}
+#else
+	{
+		yt_mport_base_phy_addr = phydev->mdio.addr;
+	}else if (yt_mport_base_phy_addr > phydev->mdio.addr) { 
+		printk (KERN_INFO "yzhang..8618 init, phy address mismatch, base=%d, cur=%d\n", yt_mport_base_phy_addr, phydev->mdio.addr);
+	}
+#endif	
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	ret = ytphy_config_init(phydev);
+#else
+	ret = genphy_config_init(phydev);
+#endif
+	if (ret < 0)
+		return ret;
+
+	/* for utp to optimize signal */
+	ret = ytphy_write_ext(phydev, 0x41, 0x33);
+	if (ret < 0)
+		return ret;
+	ret = ytphy_write_ext(phydev, 0x42, 0x66);
+	if (ret < 0)
+		return ret;
+	ret = ytphy_write_ext(phydev, 0x43, 0xaa);
+	if (ret < 0)
+		return ret;
+	ret = ytphy_write_ext(phydev, 0x44, 0xd0d);
+	if (ret < 0)
+		return ret;
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	if((phydev->addr > yt_mport_base_phy_addr) && ((2 == phydev->addr - yt_mport_base_phy_addr) || (5 == phydev->addr - yt_mport_base_phy_addr)))
+#else
+	if((phydev->mdio.addr > yt_mport_base_phy_addr) && ((2 == phydev->mdio.addr - yt_mport_base_phy_addr) || (5 == phydev->mdio.addr - yt_mport_base_phy_addr)))
+#endif
+	{
+		ret = ytphy_write_ext(phydev, 0x44, 0x2929);
+		if (ret < 0)
+			return ret;
+	}
+
+	val = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, val | BMCR_RESET);
+
+	printk (KERN_INFO "yt8618_config_init call out.\n");
+	return ret;
+}
+
+static int yt8614_config_init(struct phy_device *phydev)
+{
+	int ret = 0;
+
+	phydev->irq = PHY_POLL;
+
+	if(0xff == yt_mport_base_phy_addr_8614)
+		/* by default, we think the first phy should be the base phy addr. for mul */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	{
+		yt_mport_base_phy_addr_8614 = (unsigned int)phydev->addr;
+	}else if (yt_mport_base_phy_addr_8614 > (unsigned int)phydev->addr) { 
+		printk (KERN_INFO "yzhang..8618 init, phy address mismatch, base=%u, cur=%d\n", yt_mport_base_phy_addr_8614, phydev->addr);
+	}
+#else
+	{
+		yt_mport_base_phy_addr_8614 = (unsigned int)phydev->mdio.addr;
+	}else if (yt_mport_base_phy_addr_8614 > (unsigned int)phydev->mdio.addr) { 
+		printk (KERN_INFO "yzhang..8618 init, phy address mismatch, base=%u, cur=%d\n", yt_mport_base_phy_addr_8614, phydev->mdio.addr);
+	}
+#endif	
+	return ret;
+}
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+#define yt8614_get_port_from_phydev(phydev) ((0xff == yt_mport_base_phy_addr_8614) && (yt_mport_base_phy_addr_8614 <= (phydev)->addr) ? 0 : (unsigned int)((phydev)->addr) - yt_mport_base_phy_addr_8614)
+#else
+#define yt8614_get_port_from_phydev(phydev) ((0xff == yt_mport_base_phy_addr_8614) && (yt_mport_base_phy_addr_8614 <= (phydev)->mdio.addr) ? 0 : (unsigned int)((phydev)->mdio.addr) - yt_mport_base_phy_addr_8614)
+#endif
+
+int yt8618_aneg_done (struct phy_device *phydev)
+{
+
+	return genphy_aneg_done(phydev);
+}
+
+int yt8614_aneg_done (struct phy_device *phydev)
+{
+	int port = yt8614_get_port_from_phydev(phydev);
+	
+	/*it should be used for 8614 fiber*/
+	if((32 == link_mode_8614[port]) && (SPEED_100 == phydev->speed))
+	{
+		return 1;
+	}
+
+	return genphy_aneg_done(phydev);
+}
+
+static int yt8614_read_status(struct phy_device *phydev)
+{
+        //int i;
+	int ret;
+	volatile int val, yt8614_fiber_latch_val, yt8614_fiber_curr_val;
+	volatile int link;
+	int link_utp = 0, link_fiber = 0;
+	int port = yt8614_get_port_from_phydev(phydev);
+
+#if (YT8614_PHY_MODE_CURR != YT8521_PHY_MODE_FIBER)
+	/* switch to utp and reading regs  */
+	ret = ytphy_write_ext(phydev, 0xa000, 0);
+	if (ret < 0)
+		return ret;
+
+	val = phy_read(phydev, REG_PHY_SPEC_STATUS);
+	if (val < 0)
+		return val;
+
+	link = val & (BIT(YT8521_LINK_STATUS_BIT));
+	if (link) {
+		link_utp = 1;
+		// here is same as 8521 and re-use the function;
+		yt8521_adjust_status(phydev, val, 1);  
+	} else {
+		link_utp = 0;
+	}
+#endif //(YT8614_PHY_MODE_CURR != YT8521_PHY_MODE_FIBER)
+
+#if (YT8614_PHY_MODE_CURR != YT8521_PHY_MODE_UTP)
+	/* reading Fiber/sgmii */
+	ret = ytphy_write_ext(phydev, 0xa000, 3);
+	if (ret < 0)
+		return ret;
+
+	val = phy_read(phydev, REG_PHY_SPEC_STATUS);
+	if (val < 0)
+		return val;
+	
+	//printk (KERN_INFO "yzhang..8614 read fiber status=%04x,macbase=0x%08lx\n", val,(unsigned long)phydev->attached_dev);
+
+	/* for fiber, from 1000m to 100m, there is not link down from 0x11, and check reg 1 to identify such case */	
+	yt8614_fiber_latch_val = phy_read(phydev, MII_BMSR);
+	yt8614_fiber_curr_val = phy_read(phydev, MII_BMSR);
+	link = val & (BIT(YT8521_LINK_STATUS_BIT));
+	if((link) && (yt8614_fiber_latch_val != yt8614_fiber_curr_val))
+	{
+		link = 0;
+		printk (KERN_INFO "yt8614_read_status, fiber link down detect,latch=%04x,curr=%04x\n", yt8614_fiber_latch_val,yt8614_fiber_curr_val);
+	}
+	
+	if (link) {
+		link_fiber = 1;
+		yt8521_adjust_status(phydev, val, 0);
+		link_mode_8614[port] = 32; //fiber mode
+
+
+	} else {
+		link_fiber = 0;
+	}
+#endif //(YT8521_PHY_MODE_CURR != YT8521_PHY_MODE_UTP)
+
+	if (link_utp || link_fiber) {
+		phydev->link = 1;
+	} else {
+		phydev->link = 0;
+		link_mode_8614[port] = 0;
+	}
+
+#if (YT8614_PHY_MODE_CURR != YT8521_PHY_MODE_FIBER)
+	if (link_utp) {
+		ytphy_write_ext(phydev, 0xa000, 0);
+	}
+#endif
+	//printk (KERN_INFO "yt8614_read_status call out,link=%d,linkmode=%d\n", phydev->link, link_mode_8614[port] );
+
+	return 0;
+}
+
+static int yt8618_read_status(struct phy_device *phydev)
+{
+	int ret;
+	volatile int val; //maybe for 8614 yt8521_fiber_latch_val, yt8521_fiber_curr_val;
+	volatile int link;
+	int link_utp = 0, link_fiber = 0;
+
+	/* switch to utp and reading regs  */
+	ret = ytphy_write_ext(phydev, 0xa000, 0);
+	if (ret < 0)
+		return ret;
+
+	val = phy_read(phydev, REG_PHY_SPEC_STATUS);
+	if (val < 0)
+		return val;
+
+	link = val & (BIT(YT8521_LINK_STATUS_BIT));
+	if (link) {
+		link_utp = 1;
+		yt8521_adjust_status(phydev, val, 1);
+	} else {
+		link_utp = 0;
+	}
+
+	if (link_utp || link_fiber) {
+		phydev->link = 1;
+	} else {
+		phydev->link = 0;
+	}
+
+	return 0;
+}
+
+int yt8618_suspend(struct phy_device *phydev)
+{
+#if !(SYS_WAKEUP_BASED_ON_ETH_PKT)				
+	int value;
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_lock(&phydev->lock);
+#else
+	/* no need lock in 4.19 */
+#endif
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value | BMCR_PDOWN);
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_unlock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+#endif /*!(SYS_WAKEUP_BASED_ON_ETH_PKT)*/				
+
+	return 0;
+}
+
+int yt8618_resume(struct phy_device *phydev)
+{
+#if !(SYS_WAKEUP_BASED_ON_ETH_PKT)				
+	int value;
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_lock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value & ~BMCR_PDOWN);
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_unlock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+#endif /*!(SYS_WAKEUP_BASED_ON_ETH_PKT)*/				
+
+	return 0;
+}
+
+int yt8614_suspend(struct phy_device *phydev)
+{
+#if !(SYS_WAKEUP_BASED_ON_ETH_PKT)				
+	int value;
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_lock(&phydev->lock);
+#else
+	/* no need lock in 4.19 */
+#endif
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value | BMCR_PDOWN);
+
+	ytphy_write_ext(phydev, 0xa000, 3);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value | BMCR_PDOWN);
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_unlock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+#endif /*!(SYS_WAKEUP_BASED_ON_ETH_PKT)*/				
+
+	return 0;
+}
+
+int yt8614_resume(struct phy_device *phydev)
+{
+#if !(SYS_WAKEUP_BASED_ON_ETH_PKT)				
+	int value;
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_lock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value & ~BMCR_PDOWN);
+
+	ytphy_write_ext(phydev, 0xa000, 3);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value & ~BMCR_PDOWN);
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_unlock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+#endif /*!(SYS_WAKEUP_BASED_ON_ETH_PKT)*/				
+
+	return 0;
+}
+
+
+static struct phy_driver ytphy_drvs[] = {
+	{
+		.phy_id         = PHY_ID_YT8010,
+		.name           = "YT8010 Automotive Ethernet",
+		.phy_id_mask    = MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+		.features       = PHY_BASIC_FEATURES,
+		.flags          = PHY_HAS_INTERRUPT,
+#endif		
+		.config_aneg    = yt8010_config_aneg,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+		.config_init	= ytphy_config_init,
+#else
+		.config_init	= genphy_config_init,
+#endif
+		.read_status    = genphy_read_status,
+	}, {
+		.phy_id		= PHY_ID_YT8510,
+		.name		= "YT8510 100/10Mb Ethernet",
+		.phy_id_mask	= MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+		.features	= PHY_BASIC_FEATURES,
+		.flags			= PHY_HAS_INTERRUPT,
+#endif		
+		.config_aneg	= genphy_config_aneg,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+		.config_init	= ytphy_config_init,
+#else
+		.config_init	= genphy_config_init,
+#endif
+		.read_status	= genphy_read_status,
+	}, {
+		.phy_id		= PHY_ID_YT8511,
+		.name		= "YT8511 Gigabit Ethernet",
+		.phy_id_mask	= MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+		.features	= PHY_GBIT_FEATURES,
+		.flags			= PHY_HAS_INTERRUPT,
+#endif		
+		.config_aneg	= genphy_config_aneg,
+#if GMAC_CLOCK_INPUT_NEEDED
+		.config_init	= yt8511_config_init,
+#else
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+		.config_init	= ytphy_config_init,
+#else
+		.config_init	= genphy_config_init,
+#endif
+#endif
+		.read_status	= genphy_read_status,
+		.suspend	= genphy_suspend,
+		.resume		= genphy_resume,
+	}, {
+		.phy_id		= PHY_ID_YT8512,
+		.name		= "YT8512 Ethernet",
+		.phy_id_mask	= MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+		.features	= PHY_BASIC_FEATURES,
+		.flags			= PHY_HAS_INTERRUPT,
+#endif		
+		.config_aneg	= genphy_config_aneg,
+		.config_init	= yt8512_config_init,
+		.read_status	= yt8512_read_status,
+		.suspend	= genphy_suspend,
+		.resume		= genphy_resume,
+	}, {
+		.phy_id		= PHY_ID_YT8512B,
+		.name		= "YT8512B Ethernet",
+		.phy_id_mask	= MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+		.features	= PHY_BASIC_FEATURES,
+		.flags			= PHY_HAS_INTERRUPT,
+#endif		
+		.config_aneg	= genphy_config_aneg,
+		.config_init	= yt8512_config_init,
+		.read_status	= yt8512_read_status,
+		.suspend	= genphy_suspend,
+		.resume		= genphy_resume,
+	}, {
+        .phy_id         = PHY_ID_YT8521,
+        .name           = "YT8521 Ethernet",
+        .phy_id_mask    = MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+        .features       = PHY_BASIC_FEATURES | PHY_GBIT_FEATURES,
+#endif
+        .flags          = PHY_POLL,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+#else
+		.soft_reset	= yt8521_soft_reset,
+#endif
+        .config_aneg    = genphy_config_aneg,
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(3,11,0) )
+        .aneg_done	= yt8521_aneg_done,
+#endif
+        .config_init    = yt8521_config_init,
+        .read_status    = yt8521_read_status,
+        .suspend        = yt8521_suspend,
+        .resume         = yt8521_resume,
+#if (YTPHY_ENABLE_WOL)
+		.get_wol		= &ytphy_get_wol,
+		.set_wol		= &ytphy_set_wol,
+#endif                
+        },{
+		/* same as 8521 */
+        .phy_id         = PHY_ID_YT8531S,
+        .name           = "YT8531S Ethernet",
+        .phy_id_mask    = MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+        .features       = PHY_BASIC_FEATURES | PHY_GBIT_FEATURES,
+#endif
+        .flags          = PHY_POLL,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+#else
+		.soft_reset	= yt8521_soft_reset,
+#endif
+        .config_aneg    = genphy_config_aneg,
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(3,11,0) )
+        .aneg_done	= yt8521_aneg_done,
+#endif
+        .config_init    = yt8521_config_init,
+        .read_status    = yt8521_read_status,
+        .suspend        = yt8521_suspend,
+        .resume         = yt8521_resume,
+#if (YTPHY_ENABLE_WOL)
+		.get_wol		= &ytphy_get_wol,
+		.set_wol		= &ytphy_set_wol,
+#endif                
+        }, {
+        /* same as 8511 */
+		.phy_id		= PHY_ID_YT8531,
+		.name		= "YT8531 Gigabit Ethernet",
+		.phy_id_mask	= MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+		.features	= PHY_BASIC_FEATURES | PHY_GBIT_FEATURES,
+		.flags			= PHY_HAS_INTERRUPT,
+#endif		
+		.config_aneg	= genphy_config_aneg,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+		.config_init	= ytphy_config_init,
+#else
+		.config_init	= genphy_config_init,
+#endif
+		.read_status	= genphy_read_status,
+		.suspend	= genphy_suspend,
+		.resume		= genphy_resume,
+#if (YTPHY_ENABLE_WOL)
+		.get_wol		= &ytphy_get_wol,
+		.set_wol		= &ytphy_set_wol,
+#endif                
+	}, {
+        .phy_id         = PHY_ID_YT8618,
+        .name           = "YT8618 Ethernet",
+        .phy_id_mask    = MOTORCOMM_MPHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+        .features       = PHY_BASIC_FEATURES | PHY_GBIT_FEATURES,
+#endif
+        .flags          = PHY_POLL,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+#else
+		.soft_reset	= yt8618_soft_reset,
+#endif
+        .config_aneg    = genphy_config_aneg,
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(3,11,0) )
+        .aneg_done		= yt8618_aneg_done,
+#endif
+        .config_init    = yt8618_config_init,
+        .read_status    = yt8618_read_status,
+        .suspend        = yt8618_suspend,
+        .resume         = yt8618_resume,
+    }, {
+		.phy_id 		= PHY_ID_YT8614,
+		.name			= "YT8614 Ethernet",
+		.phy_id_mask	= MOTORCOMM_MPHY_ID_MASK_8614,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+		.features		= PHY_BASIC_FEATURES | PHY_GBIT_FEATURES,
+#endif
+		.flags			= PHY_POLL,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+#else
+		.soft_reset = yt8614_soft_reset,
+#endif
+		.config_aneg	= genphy_config_aneg,
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(3,11,0) )
+		.aneg_done		= yt8614_aneg_done,
+#endif
+		.config_init	= yt8614_config_init,
+		.read_status	= yt8614_read_status,
+		.suspend		= yt8614_suspend,
+		.resume 		= yt8614_resume,
+		}, 
+};
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+static int ytphy_drivers_register(struct phy_driver* phy_drvs, int size)
+{
+	int i, j;
+	int ret;
+
+	for (i = 0; i < size; i++) {
+		ret = phy_driver_register(&phy_drvs[i]);
+		if (ret)
+			goto err;
+	}
+
+	return 0;
+
+err:
+	for (j = 0; j < i; j++)
+		phy_driver_unregister(&phy_drvs[j]);
+
+	return ret;
+}
+
+static void ytphy_drivers_unregister(struct phy_driver* phy_drvs, int size)
+{
+	int i;
+
+	for (i = 0; i < size; i++) {
+		phy_driver_unregister(&phy_drvs[i]);
+	}
+}
+
+static int __init ytphy_init(void)
+{
+	printk("motorcomm phy register\n");
+	return ytphy_drivers_register(ytphy_drvs, ARRAY_SIZE(ytphy_drvs));
+}
+
+static void __exit ytphy_exit(void)
+{
+	printk("motorcomm phy unregister\n");
+	ytphy_drivers_unregister(ytphy_drvs, ARRAY_SIZE(ytphy_drvs));
+}
+
+module_init(ytphy_init);
+module_exit(ytphy_exit);
+#else
+/* for linux 4.x */
+module_phy_driver(ytphy_drvs);
+#endif
+
+MODULE_DESCRIPTION("Motorcomm PHY driver");
+MODULE_AUTHOR("Leilei Zhao");
+MODULE_LICENSE("GPL");
+
+static struct mdio_device_id __maybe_unused motorcomm_tbl[] = {
+	{ PHY_ID_YT8010, MOTORCOMM_PHY_ID_MASK },
+	{ PHY_ID_YT8510, MOTORCOMM_PHY_ID_MASK },
+	{ PHY_ID_YT8511, MOTORCOMM_PHY_ID_MASK },
+	{ PHY_ID_YT8512, MOTORCOMM_PHY_ID_MASK },
+	{ PHY_ID_YT8512B, MOTORCOMM_PHY_ID_MASK },
+	{ PHY_ID_YT8521, MOTORCOMM_PHY_ID_MASK },
+	{ PHY_ID_YT8531S, MOTORCOMM_PHY_ID_8531_MASK },
+	{ PHY_ID_YT8531, MOTORCOMM_PHY_ID_8531_MASK },
+	{ PHY_ID_YT8618, MOTORCOMM_MPHY_ID_MASK },
+	{ PHY_ID_YT8614, MOTORCOMM_MPHY_ID_MASK_8614 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(mdio, motorcomm_tbl);
+
diff --git a/drivers/net/phy/yt8614-phy.c b/drivers/net/phy/yt8614-phy.c
new file mode 100644
index 000000000..43172fe84
--- /dev/null
+++ b/drivers/net/phy/yt8614-phy.c
@@ -0,0 +1,1540 @@
+#include "yt8614-phy.h"
+
+/*
+ * customer should change it accordingly
+ */
+#define SWDRV_ERR_PRINT_VALUE_RET_T(a, b, c, logstr, arg...)  \
+        do { \
+			/*nothing*/; \
+		}while(0)
+
+#define YT8614_PHY_BASE_PHY_ADDR	8
+#define MPHY_LPORT_ARRAY_COUNT		1 
+phy_info_s g_phy_info[MPHY_LPORT_ARRAY_COUNT]; 
+
+static int driver_link_mode_8614[YT8614_MAX_LPORT_ID + 1] = {0}; //0: no link; 1: utp; 32: fiber. traced that 1000m fiber uses 32.
+
+phy_info_s * yt8614_app_get_phy_info(u32 lport);
+
+/* 上电硬复位后，初始化配置 PHY 相关寄存器，如下:
+
+   #切换到了 UTP 地址空间
+   Write phy_base_addr+0 ext_reg0xa000: 0x0
+
+   #配置 port0~3 的相关扩展寄存器，并配置 utp mii_reg0x0 作软复位
+   Write phy_base_addr+0 ext_reg0x41: 0x33
+   Write phy_base_addr+0 ext_reg0x42: 0x66
+   Write phy_base_addr+0 ext_reg0x43: 0xaa
+   Write phy_base_addr+0 ext_reg0x44: 0xd0d
+   Write phy_base_addr+0 mii_reg0x0 : 0x9140
+
+   Write phy_base_addr+1 ext_reg0x41: 0x33
+   Write phy_base_addr+1 ext_reg0x42: 0x66
+   Write phy_base_addr+1 ext_reg0x43: 0xaa
+   Write phy_base_addr+1 ext_reg0x44: 0xd0d
+   Write phy_base_addr+1 mii_reg0x0 : 0x9140
+   
+   Write phy_base_addr+2 ext_reg0x41: 0x33
+   Write phy_base_addr+2 ext_reg0x42: 0x66
+   Write phy_base_addr+2 ext_reg0x43: 0xaa
+   Write phy_base_addr+2 ext_reg0x44: 0xd0d
+   Write phy_base_addr+2 ext_reg0x57: 0x2929 #注意：此配置与其它口不同
+   Write phy_base_addr+2 mii_reg0x0 : 0x9140
+
+   Write phy_base_addr+3 ext_reg0x41: 0x33
+   Write phy_base_addr+3 ext_reg0x42: 0x66
+   Write phy_base_addr+3 ext_reg0x43: 0xaa
+   Write phy_base_addr+3 ext_reg0x44: 0xd0d
+   Write phy_base_addr+3 mii_reg0x0 : 0x9140 */
+
+static s32 yt8614_mdio_read_reg(unsigned int bus_id, unsigned int phy_addr, unsigned int reg, u16* val)
+{
+    s32 ret = SYS_E_NONE;
+
+    return ret;
+}
+
+static s32 yt8614_mdio_write_reg(unsigned int bus_id, unsigned int phy_addr, unsigned int reg, const u16 val)
+{
+    s32 ret = SYS_E_NONE;
+
+    return ret;
+}
+
+static s32 yt8614_read_ext_reg(struct phy_info_str *info, phy_data_s *param)
+{
+    s32 ret = SYS_E_NONE;
+    
+	ret = yt8614_mdio_write_reg(info->bus_id, info->phy_addr, REG_MII_EXT_ADDR, (const u16)param->reg);
+	SWDRV_ERR_PRINT_VALUE_RET_T(ret, 0, 0, 
+                                "lport:%d bus:%d phy_addr:%d reg:%d",
+                                info->lport,
+                                info->bus_id,
+                                info->phy_addr,
+                                param->reg);
+        
+	ret = yt8614_mdio_read_reg(info->bus_id, info->phy_addr, REG_MII_EXT_DATA, (u16*)&(param->val));        
+	SWDRV_ERR_PRINT_VALUE_RET_T(ret, 0, 0, 
+                                "lport:%d bus:%d phy_addr:%d reg:%d",
+                                info->lport,
+                                info->bus_id,
+                                info->phy_addr,
+                                param->val);
+
+    return ret;
+}
+
+static s32 yt8614_write_ext_reg(struct phy_info_str *info, phy_data_s *param)
+{
+	s32 ret = SYS_E_NONE;
+	
+	ret = yt8614_mdio_write_reg(info->bus_id, info->phy_addr, REG_MII_EXT_ADDR, (const u16)param->reg);
+	SWDRV_ERR_PRINT_VALUE_RET_T(ret, 0, 0, 
+								"lport:%d bus:%d phy_addr:%d reg:%d",
+								info->lport,
+								info->bus_id,
+								info->phy_addr,
+								param->reg);
+		
+	ret = yt8614_mdio_write_reg(info->bus_id, info->phy_addr, REG_MII_EXT_DATA, (const u16)param->val);		
+	SWDRV_ERR_PRINT_VALUE_RET_T(ret, 0, 0, 
+								"lport:%d bus:%d phy_addr:%d reg:%d",
+								info->lport,
+								info->bus_id,
+								info->phy_addr,
+								param->val);
+
+	return ret;
+}
+
+static s32 yt8614_set_reg_space(struct phy_info_str *info, u8 smiType)
+{   
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+
+    memset(&data, 0, sizeof(phy_data_s));
+        
+    if((smiType == YT8614_SMI_SEL_PHY) || (smiType == YT8614_SMI_SEL_SDS_QSGMII) || (smiType == YT8614_SMI_SEL_SDS_SGMII))
+    {
+        data.reg = YT8614_REG_COM_SMI_MUX;
+        data.val = smiType;
+        ret = yt8614_write_ext_reg(info, &data);
+        SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d reg:0x%x",
+                                    info->lport, data.reg);        
+    }
+    else
+    {
+        SWDRV_ERR_PRINT_VALUE_RET_T(0, 0, 0, "phy_yt8614_set_space: invalid smi type(%d)\n", smiType);
+        return SYS_E_PARAM;
+    }
+
+    return SYS_E_NONE;
+}
+
+s32 yt8614_read_reg(struct phy_info_str *info, phy_data_s *param)
+{   
+    if(param->regType == YT8614_TYPE_COMMON)
+    {
+        return yt8614_read_ext_reg(info, param);
+    }
+    else if(param->regType == YT8614_TYPE_UTP_MII)
+    {
+        yt8614_set_reg_space(info, YT8614_SMI_SEL_PHY);
+        return yt8614_mdio_read_reg(info->bus_id, info->phy_addr, param->reg, (u16 *)&(param->val));
+    }
+    else if(param->regType == YT8614_TYPE_LDS_MII)
+    {
+        yt8614_set_reg_space(info, YT8614_SMI_SEL_PHY);
+        return yt8614_mdio_read_reg(info->bus_id, info->phy_addr, param->reg, (u16 *)&(param->val));
+    }
+    else if(param->regType == YT8614_TYPE_UTP_MMD)
+    {
+        yt8614_set_reg_space(info, YT8614_SMI_SEL_PHY);
+		/* tbd. */
+        return SYS_E_PARAM;
+    }
+    else if(param->regType == YT8614_TYPE_UTP_EXT)
+    {
+        yt8614_set_reg_space(info, YT8614_SMI_SEL_PHY);
+        return yt8614_read_ext_reg(info, param);
+    }
+    else if(param->regType == YT8614_TYPE_SDS_QSGMII_MII)
+    {
+        yt8614_set_reg_space(info, YT8614_SMI_SEL_SDS_QSGMII);
+        return yt8614_mdio_read_reg(info->bus_id, info->phy_addr, param->reg, (u16 *)&(param->val));
+    }
+    else if(param->regType == YT8614_TYPE_SDS_QSGMII_EXT)
+    {
+        yt8614_set_reg_space(info, YT8614_SMI_SEL_SDS_QSGMII);
+        return yt8614_read_ext_reg(info, param);
+    }
+    else if(param->regType == YT8614_TYPE_SDS_SGMII_MII)
+    {
+        yt8614_set_reg_space(info, YT8614_SMI_SEL_SDS_SGMII);
+        return yt8614_mdio_read_reg(info->bus_id, info->phy_addr, param->reg, (u16 *)&(param->val));
+    }
+    else if(param->regType == YT8614_TYPE_SDS_SGMII_EXT)
+    {
+        yt8614_set_reg_space(info, YT8614_SMI_SEL_SDS_SGMII);
+        return yt8614_read_ext_reg(info, param);
+    }
+    else
+    {
+        SWDRV_ERR_PRINT_VALUE_RET_T(0, 0, 0, "yt8614_read_reg: invalid register type(%x)\n", param->regType);
+        return SYS_E_PARAM;
+    }
+
+    return SYS_E_NONE;
+}
+
+s32 yt8614_write_reg(struct phy_info_str *info, phy_data_s *param)
+{	
+	if(param->regType == YT8614_TYPE_COMMON)
+	{
+		return yt8614_write_ext_reg(info, param);
+	}
+	else if(param->regType == YT8614_TYPE_UTP_MII)
+	{
+		yt8614_set_reg_space(info, YT8614_SMI_SEL_PHY);
+		return yt8614_mdio_write_reg(info->bus_id, info->phy_addr, param->reg, param->val);
+	}
+	else if(param->regType == YT8614_TYPE_LDS_MII)
+	{
+		yt8614_set_reg_space(info, YT8614_SMI_SEL_PHY);
+		return yt8614_mdio_write_reg(info->bus_id, info->phy_addr, param->reg, param->val);
+	}
+	else if(param->regType == YT8614_TYPE_UTP_MMD)
+	{
+		yt8614_set_reg_space(info, YT8614_SMI_SEL_PHY);
+		/* tbd. */
+		return SYS_E_PARAM;
+	}
+	else if(param->regType == YT8614_TYPE_UTP_EXT)
+	{
+		yt8614_set_reg_space(info, YT8614_SMI_SEL_PHY);
+		return yt8614_write_ext_reg(info, param);
+	}
+	else if(param->regType == YT8614_TYPE_SDS_QSGMII_MII)
+	{
+		yt8614_set_reg_space(info, YT8614_SMI_SEL_SDS_QSGMII);
+		return yt8614_mdio_write_reg(info->bus_id, info->phy_addr, param->reg, param->val);
+	}
+	else if(param->regType == YT8614_TYPE_SDS_QSGMII_EXT)
+	{
+		yt8614_set_reg_space(info, YT8614_SMI_SEL_SDS_QSGMII);
+		return yt8614_write_ext_reg(info, param);
+	}
+	else if(param->regType == YT8614_TYPE_SDS_SGMII_MII)
+	{
+		yt8614_set_reg_space(info, YT8614_SMI_SEL_SDS_SGMII);
+		return yt8614_mdio_write_reg(info->bus_id, info->phy_addr, param->reg, param->val);
+	}
+	else if(param->regType == YT8614_TYPE_SDS_SGMII_EXT)
+	{
+		yt8614_set_reg_space(info, YT8614_SMI_SEL_SDS_SGMII);
+		return yt8614_write_ext_reg(info, param);
+	}
+	else
+	{
+		SWDRV_ERR_PRINT_VALUE_RET_T(0, 0, 0, "yt8614_write_reg: invalid register type(%x)\n", param->regType);
+		return SYS_E_PARAM;
+	}
+
+	return SYS_E_NONE;
+}
+
+
+/*
+ * soft reset to phy
+ * including:
+ *	UTP port
+ * 	sgmii interface
+ *	qsgmii interface
+ * 
+ * input: lport, make no sense. reserved for future using.
+ */
+s32 yt8614_phy_soft_reset(u32 lport)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+    
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg     = REG_SDS_BMCR;
+    data.regType = YT8614_TYPE_UTP_MII;
+
+    ret = phy_info->read(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d speed:%d", lport, speed);   
+    
+    data.val |= BMCR_RESET;
+        
+    ret = phy_info->write(phy_info, &data); 
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d speed:%d", lport, speed);
+
+    return ret;
+}
+
+/* 
+ * note, the lport is 0 based.
+ * this function do basic initialization for each port
+ */   
+s32 yt8614_phy_init(u32 lport)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+    
+    ////////////////////////////////////////////////////
+    /* Write phy_base_addr+0 ext_reg0x41: 0x33 */
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = 0x41;
+    data.regType = YT8614_TYPE_UTP_EXT;
+    data.val     = 0x33;
+    
+    ret = phy_info->write(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+
+    ////////////////////////////////////////////////////
+    /* Write phy_base_addr+1 ext_reg0x42: 0x66 */
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = 0x42;
+    data.regType = YT8614_TYPE_UTP_EXT;
+    data.val     = 0x66;
+    
+    ret = phy_info->write(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+
+    ////////////////////////////////////////////////////
+    /* Write phy_base_addr+3 ext_reg0x43: 0xaa */
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = 0x43;
+    data.regType = YT8614_TYPE_UTP_EXT;
+    data.val     = 0xaa;
+    
+    ret = phy_info->write(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+
+    ////////////////////////////////////////////////////
+    /* Write phy_base_addr+3 ext_reg0x44: 0xd0d */
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = 0x44;
+    data.regType = YT8614_TYPE_UTP_EXT;
+    data.val     = 0xd0d;
+    
+    ret = phy_info->write(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+
+    ////////////////////////////////////////////////////
+    /* Write phy_base_addr+2,5 ext_reg0x57: 0x2929 #there are difference with other ports */
+    if((lport==2) || (lport==5))
+    {
+        memset(&data, 0, sizeof(phy_data_s));
+        data.reg     = 0x57;
+        data.regType = YT8614_TYPE_UTP_EXT;
+        data.val     = 0x2929;
+        
+        ret = phy_info->write(phy_info, &data);    
+        SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+    }
+
+    ////////////////////////////////////////////////////
+    /* Write phy_base_addr+3 mii_reg0x0 :bit15=1, soft reset phy */
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = 0x0;
+    data.regType = YT8614_TYPE_UTP_MII;
+    ret = phy_info->read(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);    
+    data.val |= BMCR_RESET;
+    ret = phy_info->write(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+
+    ////////////////////////////////////////////////////
+	/* set pole positive or negative if needed */
+#if 0	
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = YT8614_REG_COM_SLED_CFG0;
+    data.regType = YT8614_TYPE_COMMON;
+    
+    ret = phy_info->read(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);    
+
+	/* clesr or set the bit FIBER_SLED_CFG0_ACT_LOW accordingly */
+    data.val &= ~FIBER_SLED_CFG0_ACT_LOW;
+    data.val |= FIBER_SLED_CFG0_ACT_LOW;
+    ret = phy_info->write(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+#endif
+
+    return SYS_E_NONE;
+}
+
+/*
+ * this function set fiber/sgmii to POWERDOWN mode or not
+ * 
+ */
+s32 yt8614_fiber_enable(u32 lport, BOOL enable)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = REG_SDS_BMCR;
+    data.regType = YT8614_TYPE_SDS_SGMII_MII;
+    
+    ret = phy_info->read(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d enable:%d", lport, enable);    
+    #if 0
+    printf("phy_yt8614_set_enable_1(port%02d enable=%d): value=0x%x\n",
+           lport, enable, data.val);
+    #endif
+    if(enable)
+    {
+        data.val &= ~FIBER_BMCR_PDOWN;
+    }
+    else
+    {
+        data.val |= FIBER_BMCR_PDOWN;
+    }
+    ret = phy_info->write(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d enable:%d", lport, enable);    
+
+    #if 0
+    ret = phy_info->read(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d enable:%d", lport, enable);    
+    printf("phy_yt8614_set_enable_2(port%d enable=%d): value=0x%x\n",
+           lport, enable, data.val);
+    #endif
+    
+    return ret;
+}
+
+/*
+ * this function set utp to POWERDOWN mode or not
+ * 
+ */
+s32 yt8614_utp_enable(u32 lport, BOOL enable)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = REG_SDS_BMCR;
+    data.regType = YT8614_TYPE_UTP_MII;
+    
+    ret = phy_info->read(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d enable:%d", lport, enable);    
+
+    if(enable)
+    {
+        data.val &= ~BMCR_PDOWN;
+    }
+    else
+    {
+        data.val |= BMCR_PDOWN;
+    }
+    ret = phy_info->write(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d enable:%d", lport, enable);    
+
+    return ret;
+}
+
+/*
+ * for fiber mode, force to unidirection.
+ */
+s32 yt8614_fiber_unidirection_set(u32 lport, int speed, BOOL enable)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = REG_SDS_BMCR;
+    data.regType = YT8614_TYPE_SDS_SGMII_MII;
+    
+    ret = phy_info->read(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d enable:%d", lport, enable);   
+    if(ret)
+    {
+        return SYS_E_PARAM;
+    }
+	
+    if(enable)
+    {
+        data.val &= ~FIBER_BMCR_ANENABLE;
+        data.val |= FIBER_BMCR_DUPLEX_MODE;
+        data.val |= FIBER_BMCR_EN_UNIDIR;
+    }
+    else
+    {
+        data.val |= FIBER_BMCR_ANENABLE;
+        //not to clear this bit. data.val &= ~FIBER_BMCR_DUPLEX_MODE;
+        data.val &= ~FIBER_BMCR_EN_UNIDIR;
+    }
+    ret = phy_info->write(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d enable:%d", lport, enable);    
+    if(ret)
+    {
+        return SYS_E_PARAM;
+    }
+
+	if(enable)
+		ret = yt8614_fiber_speed_set(lport, speed); 
+
+    return ret;
+}
+
+/*
+ * Fiber auto sensing for sgmii interface
+ */
+s32 yt8614_fiber_autosensing_set(u32 lport, BOOL enable)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg     = YT8614_REG_SGMII_EXT_HIDE_AUTO_SEN;
+    data.regType = YT8614_TYPE_SDS_SGMII_EXT;
+    
+    ret = phy_info->read(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d enable:%d", lport, enable);   
+
+    if(enable)
+    {
+        data.val |= FIBER_AUTO_SEN_ENABLE;
+    }
+    else
+    {
+        data.val &= ~FIBER_AUTO_SEN_ENABLE;
+    }
+    
+    ret = phy_info->write(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d enable:%d", lport, enable);
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg     = REG_SDS_BMCR;
+    data.regType = YT8614_TYPE_SDS_SGMII_MII;
+
+    ret = phy_info->read(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d enable:%d", lport, enable);   
+
+    // soft reset
+    // and clear power down bit automatically 
+    data.val |= BMCR_RESET;
+        
+    ret = phy_info->write(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d enable:%d", lport, enable); 
+
+    return SYS_E_NONE;
+}
+
+/*
+ * set fiber speed, can be:
+ * 		YT8614_COMBO_FIBER_1000M,
+ * 		YT8614_COMBO_FIBER_100M,
+ */
+s32 yt8614_fiber_speed_set(u32 lport, int fiber_speed)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+	unsigned int speed_bit;
+	u16 cur_val;
+	
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = YT8614_REG_COM_HIDE_SPEED;
+    data.regType = YT8614_TYPE_COMMON;
+    
+    ret = phy_info->read(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d combo_speed read:%d", lport, combo_speed);    
+    if(ret)
+    {
+        return ret;
+    }
+
+	speed_bit = 1 << (lport & 0x3) /* port 0-3 */;
+	cur_val = data.val;
+	
+	switch(fiber_speed) {
+	case YT8614_COMBO_FIBER_1000M:
+		data.val |= speed_bit;
+		break;
+	case YT8614_COMBO_FIBER_100M:
+		data.val &= ~speed_bit;
+		break;
+	default:
+		return SYS_E_PARAM;;
+	}
+
+	if(cur_val != data.val)
+	{
+		ret = phy_info->write(phy_info, &data);	
+		SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d combo_speed, write:%d", lport, combo_speed);    
+		if(!ret)
+		{
+			return ret;
+		}
+	}
+	ret = yt8614_fiber_autosensing_set(lport, FALSE);
+   
+    return ret;
+}
+
+
+/*
+ * set autonigotiation for qsgmii interface
+ */
+s32 yt8614_qsgmii_autoneg_set(u32 lport, BOOL enable)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg     = REG_MII_BMCR;
+    //data.regType = YT8614_TYPE_SDS_QSGMII_EXT;
+    data.regType = YT8614_TYPE_SDS_QSGMII_MII;
+    
+    ret = phy_info->read(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d enable:%d", lport, enable);   
+
+    if(enable)
+    {
+        data.val |= BMCR_ANENABLE;
+    }
+    else
+    {
+        data.val &= ~BMCR_ANENABLE;
+    }
+    
+    ret = phy_info->write(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d enable:%d", lport, enable);
+
+    return ret;
+}
+
+/*
+ * set autonigotiation for sgmii phy mode
+ * 
+ */
+s32 yt8614_sgmii_autoneg_set(u32 lport, BOOL enable)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg     = REG_MII_BMCR;
+    //data.regType = YT8614_TYPE_SDS_QSGMII_EXT;
+    data.regType = YT8614_TYPE_SDS_SGMII_MII;
+    
+    ret = phy_info->read(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d enable:%d", lport, enable);   
+
+    if(enable)
+    {
+        data.val |= BMCR_ANENABLE;
+    }
+    else
+    {
+        data.val &= ~BMCR_ANENABLE;
+    }
+    
+    ret = phy_info->write(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d enable:%d", lport, enable);
+
+    return ret;
+}
+
+
+s32 yt8614_qsgmii_sgmii_link_status_get(u32 lport, BOOL *enable, BOOL if_qsgmii)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg = REG_SDS_SPEC_STATUS;
+    
+    if(if_qsgmii)
+    {
+        data.regType = YT8614_TYPE_SDS_QSGMII_MII;
+    }
+    else
+    {
+        data.regType = YT8614_TYPE_SDS_SGMII_MII;
+    }
+
+    ret = phy_info->read(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport); 
+
+    if((data.val & FIBER_SSR_LSTATUS) == 0)
+    {
+        *enable = FALSE;
+    }
+    else
+    {
+        *enable = TRUE;
+    }
+
+    return ret;
+}
+
+/* for combo mode, set media priority
+ * input:
+ *		fiber=1, fiber of priority;
+ *		fiber=0, upt of priority;
+ */
+int yt8614_combo_media_priority_set (u32 lport, int fiber)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+	u16 cur_val;
+
+	if (!phy_info)
+		return SYS_E_PARAM;
+
+	memset(&data, 0, sizeof(phy_data_s));
+	data.reg	 = YT8614_REG_COM_HIDE_SPEED;
+	data.regType = YT8614_TYPE_COMMON;
+	ret = phy_info->read(phy_info, &data);	  
+	SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+	if (ret)
+		return SYS_E_PARAM;
+
+	cur_val = data.val;
+	if (fiber) {
+		if (!(data.val & (YT8614_REG_COM_HIDE_SPEED_CMB_PRI))) {
+			data.val |= YT8614_REG_COM_HIDE_SPEED_CMB_PRI;
+		}
+	}else {
+		if (data.val & (YT8614_REG_COM_HIDE_SPEED_CMB_PRI)) {
+			data.val &= ~(YT8614_REG_COM_HIDE_SPEED_CMB_PRI);
+		}
+	}
+
+	if (cur_val != data.val)
+	{
+		ret = phy_info->write(phy_info, &data);	  
+		SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+		if (!ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+/* for combo mode, set media priority
+ * input:
+ *		fiber=1, fiber of priority;
+ *		fiber=0, upt of priority;
+ */
+int yt8614_combo_media_priority_get (u32 lport, int *fiber)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+	if (!phy_info)
+		return SYS_E_PARAM;
+
+	memset(&data, 0, sizeof(phy_data_s));
+	data.reg	 = YT8614_REG_COM_HIDE_SPEED;
+	data.regType = YT8614_TYPE_COMMON;
+	ret = phy_info->read(phy_info, &data);	  
+	SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+	if (ret)
+		return SYS_E_PARAM;
+
+	*fiber = !!(data.val & (YT8614_REG_COM_HIDE_SPEED_CMB_PRI));
+
+	return ret;
+}
+
+/*
+ * set utp autonegotiation or force link mode.
+ */
+s32 yt8614_utp_autoneg_set(u32 lport, BOOL enable)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg = REG_MII_BMCR;
+	data.regType = YT8614_TYPE_UTP_MII;
+
+    ret = phy_info->read(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d autogeg read:%d", lport, enable); 
+
+    if(enable)
+    {
+        data.val |= BMCR_ANENABLE;
+    }
+    else
+    {
+        data.val &= ~BMCR_ANENABLE;
+    }
+    
+    ret = phy_info->write(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d autogeg write:%d", lport, enable); 
+
+    return ret;
+}
+
+
+/*
+ * get utp autonegotiation or force link mode.
+ */
+s32 yt8614_utp_autoneg_get(u32 lport, BOOL *enable)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg = REG_MII_BMCR;
+	data.regType = YT8614_TYPE_UTP_MII;
+
+    ret = phy_info->read(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d autogeg read:%d", lport, *enable); 
+
+    *enable = !!(data.val & BMCR_ANENABLE);
+
+    return ret;
+}
+
+/*
+ * input: cap_mask, bit definitions, pause capbility and 100/10 capbilitys follow the definition of mii reg4
+ *		for 1000M capability, bit0=1000M half; bit1=1000M full, see mii reg9.
+ */
+s32 yt8614_utp_autoneg_ability_set(u32 lport, unsigned int cap_mask)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg = REG_MII_ADVERTISE;
+	data.regType = YT8614_TYPE_UTP_MII;
+
+    ret = phy_info->read(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d autoneg_ability read:%d", lport, cap_mask); 
+    if(ret)
+    {
+        return SYS_E_PARAM;
+    }
+
+
+    if(ADVERTISE_10HALF & cap_mask)
+    {
+        data.val |= ADVERTISE_10HALF;
+    }
+    else
+    {
+        data.val &= ~ADVERTISE_10HALF;
+    }
+
+    if(ADVERTISE_10FULL & cap_mask)
+    {
+        data.val |= ADVERTISE_10FULL;
+    }
+    else
+    {
+        data.val &= ~ADVERTISE_10FULL;
+    }
+
+    if(ADVERTISE_100HALF & cap_mask)
+    {
+        data.val |= ADVERTISE_100HALF;
+    }
+    else
+    {
+        data.val &= ~ADVERTISE_100HALF;
+    }
+
+    if(ADVERTISE_100FULL & cap_mask)
+    {
+        data.val |= ADVERTISE_100FULL;
+    }
+    else
+    {
+        data.val &= ~ADVERTISE_100FULL;
+    }
+
+    if(ADVERTISE_PAUSE_CAP & cap_mask)
+    {
+        data.val |= ADVERTISE_PAUSE_CAP;
+    }
+    else
+    {
+        data.val &= ~ADVERTISE_PAUSE_CAP;
+    }
+
+    if(ADVERTISE_PAUSE_ASYM & cap_mask)
+    {
+        data.val |= ADVERTISE_PAUSE_ASYM;
+    }
+    else
+    {
+        data.val &= ~ADVERTISE_PAUSE_ASYM;
+    }
+
+    ret = phy_info->write(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d autoneg_ability write:%d", lport, cap_mask); 
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg = REG_MII_CTRL1000;
+	data.regType = YT8614_TYPE_UTP_MII;
+
+    ret = phy_info->read(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d autoneg_ability read:%d", lport, cap_mask); 
+    if(ret)
+    {
+        return SYS_E_PARAM;
+    }
+
+
+    if(0x1 & cap_mask)
+    {
+        data.val |= ADVERTISE_1000HALF;
+    }
+    else
+    {
+        data.val &= ~ADVERTISE_1000HALF;
+    }
+
+    if(0x2 & cap_mask)
+    {
+        data.val |= ADVERTISE_1000FULL;
+    }
+    else
+    {
+        data.val &= ~ADVERTISE_1000FULL;
+    }
+
+    ret = phy_info->write(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d autoneg_ability write:%d", lport, cap_mask); 
+
+    return yt8614_phy_soft_reset(lport);
+}
+
+/*
+ * input: lport
+ * output: 
+ *	cap_mask, bit definitions:
+ *		pause capbility and 100/10 capbilitys follow the definition of mii reg4.
+ *		for 1000M capability, bit0=1000M half; bit1=1000M full, refer to mii reg9.[9:8].
+ */
+s32 yt8614_utp_autoneg_ability_get(u32 lport, unsigned int *cap_mask)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg = REG_MII_ADVERTISE;
+	data.regType = YT8614_TYPE_UTP_MII;
+
+    ret = phy_info->read(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d autoneg_ability read:%d", lport, cap_mask); 
+    if(!ret)
+    {
+        return SYS_E_PARAM;
+    }
+
+
+    if(ADVERTISE_10HALF & data.val)
+    {
+        *cap_mask |= ADVERTISE_10HALF;
+    }
+    else
+    {
+        *cap_mask &= ~ADVERTISE_10HALF;
+    }
+
+    if(ADVERTISE_10FULL & data.val)
+    {
+        *cap_mask |= ADVERTISE_10FULL;
+    }
+    else
+    {
+        *cap_mask &= ~ADVERTISE_10FULL;
+    }
+
+    if(ADVERTISE_100HALF & data.val)
+    {
+        *cap_mask |= ADVERTISE_100HALF;
+    }
+    else
+    {
+        *cap_mask &= ~ADVERTISE_100HALF;
+    }
+
+    if(ADVERTISE_100FULL & data.val)
+    {
+        *cap_mask |= ADVERTISE_100FULL;
+    }
+    else
+    {
+        *cap_mask &= ~ADVERTISE_100FULL;
+    }
+
+    if(ADVERTISE_PAUSE_CAP & data.val)
+    {
+        *cap_mask |= ADVERTISE_PAUSE_CAP;
+    }
+    else
+    {
+        *cap_mask &= ~ADVERTISE_PAUSE_CAP;
+    }
+
+    if(ADVERTISE_PAUSE_ASYM & data.val)
+    {
+        *cap_mask |= ADVERTISE_PAUSE_ASYM;
+    }
+    else
+    {
+        *cap_mask &= ~ADVERTISE_PAUSE_ASYM;
+    }
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg = REG_MII_CTRL1000;
+	data.regType = YT8614_TYPE_UTP_MII;
+
+    ret = phy_info->read(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d autoneg_ability read:%d", lport, cap_mask); 
+
+    if(ADVERTISE_1000HALF & data.val )
+    {
+        *cap_mask |= 0x1;
+    }
+    else
+    {
+        *cap_mask &= ~0x1;
+    }
+
+    if(ADVERTISE_1000FULL & data.val )
+    {
+        *cap_mask |= 0x2;
+    }
+    else
+    {
+        *cap_mask &= ~0x2;
+    }
+
+    return ret;
+}
+
+
+s32 yt8614_utp_force_duplex_set(u32 lport, BOOL full)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg = REG_MII_BMCR;
+	data.regType = YT8614_TYPE_UTP_MII;
+
+    ret = phy_info->read(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d duplex read:%d", lport, duplex); 
+
+    if(full)
+    {
+        data.val |= BMCR_FULLDPLX;
+    }
+    else
+    {
+        data.val &= ~BMCR_FULLDPLX;
+    }
+    
+    ret = phy_info->write(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d duplex write:%d", lport, duplex); 
+
+    return ret;
+}
+
+s32 yt8614_utp_force_duplex_get(u32 lport, BOOL *full)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg = REG_MII_BMCR;
+	data.regType = YT8614_TYPE_UTP_MII;
+
+    ret = phy_info->read(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d duplex read:%d", lport, duplex); 
+
+    *full = !!(data.val &= BMCR_FULLDPLX);
+
+    return ret;
+}
+
+/*
+ * this function set speed configuration.
+ */
+s32 yt8614_utp_force_speed_set(u32 lport, unsigned int speed)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+	unsigned int speed_bit6, speed_bit13;
+	
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+	
+	switch (speed) {
+		case SPEED_1000M:
+			speed_bit6 = BMCR_SPEED1000;
+			speed_bit13 = 0;
+			break;
+		case SPEED_100M:
+			speed_bit13 = BMCR_SPEED100;
+			speed_bit6 = 0;
+			break;
+		case SPEED_10M:
+			speed_bit13 = 0;
+			speed_bit6 = 0;
+			break;
+		default:
+			return SYS_E_PARAM;;
+	}
+	
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg = REG_MII_BMCR;
+	data.regType = YT8614_TYPE_UTP_MII;
+
+    ret = phy_info->read(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d speed read:%d", lport, speed); 
+
+			
+    if(speed_bit6)
+    {
+        data.val |= speed_bit6;
+    }
+    else
+    {
+        data.val &= ~speed_bit6;
+    }
+
+    if(speed_bit13)
+    {
+        data.val |= speed_bit13;
+    }
+    else
+    {
+        data.val &= ~speed_bit13;
+    }
+    
+    ret = phy_info->write(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d speed write:%d", lport, speed); 
+
+    return ret;
+}
+
+s32 yt8614_utp_force_speed_get(u32 lport, unsigned int *speed)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+	unsigned int speed_bit6, speed_bit13;
+	
+    if(!phy_info)
+    {
+        return SYS_E_PARAM;
+    }
+
+	speed_bit6 = BMCR_SPEED1000;
+	speed_bit13 = BMCR_SPEED100;
+
+    ////////////////////////////////////////////////////
+    memset(&data, 0, sizeof(phy_data_s));
+    
+    data.reg = REG_MII_BMCR;
+	data.regType = YT8614_TYPE_UTP_MII;
+
+    ret = phy_info->read(phy_info, &data);
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d speed read:%d", lport, speed); 
+
+	if((data.val & speed_bit6) && !(data.val & speed_bit13)) {
+		*speed = SPEED_1000M;
+	}else if (!(data.val & speed_bit6) && (data.val & speed_bit13)) {
+		*speed = SPEED_100M;
+	}else if (!(data.val & speed_bit6) && !(data.val & speed_bit13)) {
+		*speed = SPEED_10M;
+	}else {
+		*speed = SPEED_UNKNOWN;
+		return SYS_E_PARAM;
+	}
+
+    return ret;
+}
+
+
+/*
+ * this function get the state of autoneg for both UTP and fiber
+ * input:
+ * 	lport - phy port
+ * 	speed: speed_1000M or speed_100M, for fiber only
+ * output:
+ * 	aneg: 1 or 0
+ */
+int yt8614_autoneg_done_get (u32 lport, int speed, int *aneg)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+	if (!phy_info)
+		return SYS_E_PARAM;
+
+	/*it should be used for 8614 fiber*/
+	if((32 == driver_link_mode_8614[lport]) && (SPEED_100M == speed))
+	{
+		*aneg = TRUE;
+		return SYS_E_NONE;
+	}
+
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = MII_BMSR;
+    data.regType = YT8614_TYPE_SDS_SGMII_MII;
+    ret = phy_info->read(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+
+	*aneg = !!(data.val & (BMSR_ANEGCOMPLETE));
+	return ret;
+}
+
+/* this function used to double check the speed. for fiber, this is no 10M */
+static int yt8614_adjust_status(u32 lport, int val, int is_utp, int* speed, int* duplex)
+{
+	int speed_mode;
+
+	//printk ("8614 status adjust call in...\n");
+	*speed = -1;
+	*duplex = (val & BIT(YT8614_DUPLEX_BIT)) >> YT8614_DUPLEX_BIT;
+	speed_mode = (val & YT8614_SPEED_MODE) >> YT8614_SPEED_MODE_BIT;
+	switch (speed_mode) {
+	case 0:
+		if (is_utp)
+			*speed = SPEED_10M;
+		break;
+	case 1:
+		*speed = SPEED_100M;
+		break;
+	case 2:
+		*speed = SPEED_1000M;
+		break;
+	case 3:
+		break;
+	default:
+		break;
+	}
+	//printk (KERN_INFO "yzhang..8521 status adjust call out,regval=0x%04x,mode=%s,speed=%dm...\n", val,is_utp?"utp":"fiber", phydev->speed);
+
+	return 0;
+}
+
+/*
+ * input: lport - port id, 0 based.
+ * output:
+ * 		speed: SPEED_10M, SPEED_100M, SPEED_1000M or -1;
+ *		duplex: 0 or 1, see reg 0x11, bit YT8614_DUPLEX_BIT.
+ *		ret_link: 0 or 1, link down or up.
+ *		media: only valid when ret_link=1, (YT8614_SMI_SEL_SDS_SGMII + 1) for fiber; (YT8614_SMI_SEL_PHY + 1) for utp. -1 for link down.
+ */
+int yt8614_media_status_get(u32 lport, int* speed, int* duplex, int* ret_link, int *media)
+{
+    s32 ret = SYS_E_NONE;
+    phy_data_s data;
+    phy_info_s *phy_info = yt8614_app_get_phy_info(lport);
+
+	volatile int val, yt8614_fiber_latch_val, yt8614_fiber_curr_val;
+	volatile int link;
+	int link_utp = 0, link_fiber = 0;
+
+	if (!phy_info)
+		return SYS_E_PARAM;
+
+#if (YT8614_PHY_MODE_CURR != YT8614_PHY_MODE_FIBER)
+
+	/* switch to utp and reading regs  */
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = 0xa000;
+    data.regType = YT8614_TYPE_UTP_EXT;
+    data.val     = 0x0;
+    
+    ret = phy_info->write(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+	if (ret)
+		return ret;
+
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = REG_PHY_SPEC_STATUS;
+    data.regType = YT8614_TYPE_UTP_MII;
+    ret = phy_info->read(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+	if (ret)
+		return ret;
+
+	link = data.val & (BIT(YT8614_LINK_STATUS_BIT));
+	if (link) {
+		link_utp = 1;
+		yt8614_adjust_status(lport, data.val, 1, speed, duplex);
+	} else {
+		link_utp = 0;
+	}
+#endif //(YT8614_PHY_MODE_CURR != YT8521_PHY_MODE_FIBER)
+
+#if (YT8614_PHY_MODE_CURR != YT8614_PHY_MODE_UTP)
+	/* reading Fiber/sgmii */
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = 0xa000;
+    data.regType = YT8614_TYPE_UTP_EXT;
+    data.val     = 0x3;
+    
+    ret = phy_info->write(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+	if (ret)
+		return ret;
+
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = REG_PHY_SPEC_STATUS;
+    data.regType = YT8614_TYPE_SDS_SGMII_MII;
+    ret = phy_info->read(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+	if (ret)
+		return ret;
+
+	//printk (KERN_INFO "yt8614 read fiber status=%04x\n", data.val,(unsigned long)phydev->attached_dev);
+
+	/* for fiber, from 1000m to 100m, there is not link down from 0x11, and check reg 1 to identify such case */	
+	val = data.val;
+
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = MII_BMSR/*reg 0x1*/;
+    data.regType = YT8614_TYPE_SDS_SGMII_MII;
+    ret = phy_info->read(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+	if (ret)
+		return ret;
+	
+	yt8614_fiber_latch_val = data.val;
+
+    memset(&data, 0, sizeof(phy_data_s));
+    data.reg     = MII_BMSR/*reg 0x1*/;
+    data.regType = YT8614_TYPE_SDS_SGMII_MII;
+    ret = phy_info->read(phy_info, &data);    
+    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+	if (ret)
+		return ret;
+
+	yt8614_fiber_curr_val = data.val;
+
+	link = val & (BIT(YT8614_LINK_STATUS_BIT));
+	if((link) && (yt8614_fiber_latch_val != yt8614_fiber_curr_val))
+	{
+		link = 0;
+		SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "yzhang..8614 fiber link down detect,latch=%04x,curr=%04x\n", yt8614_fiber_latch_val,yt8614_fiber_curr_val);
+	}
+	
+	if (link) {
+		link_fiber = 1;
+		yt8614_adjust_status(lport, val, 0, speed, duplex);
+		driver_link_mode_8614[lport] = 32; //fiber mode. used only for fiber 100M
+
+	} else {
+		link_fiber = 0;
+	}
+#endif //(YT8521_PHY_MODE_CURR != YT8521_PHY_MODE_UTP)
+
+	if (link_utp || link_fiber) {
+		memset(&data, 0, sizeof(phy_data_s));
+		data.reg	 = YT8614_REG_COM_HIDE_SPEED;
+		data.regType = YT8614_TYPE_COMMON;
+		ret = phy_info->read(phy_info, &data);	  
+		SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+		if (ret)
+			return ret;
+
+		if(data.val & (YT8614_REG_COM_HIDE_SPEED_CMB_PRI)) {
+			/* case of fiber of priority */
+			if(link_utp) *media = (YT8614_SMI_SEL_PHY + 1);
+			if(link_fiber) *media = (YT8614_SMI_SEL_SDS_SGMII + 1);
+		} else {
+			/* case of utp of priority */
+			if(link_fiber) *media = (YT8614_SMI_SEL_SDS_SGMII + 1);
+			if(link_utp) *media = (YT8614_SMI_SEL_PHY + 1);
+		}
+		*ret_link = TRUE;
+		
+	} else {
+		*ret_link = FALSE;
+		*media = -1;
+              *speed= -1;
+              *duplex = -1;
+		driver_link_mode_8614[lport] = 0;
+	}
+
+	if (link_utp) {
+	    memset(&data, 0, sizeof(phy_data_s));
+	    data.reg     = 0xa000;
+	    data.regType = YT8614_TYPE_UTP_EXT;
+	    data.val     = 0x0;
+	    
+	    ret = phy_info->write(phy_info, &data);    
+	    SWDRV_ERR_PRINT_VALUE_RET_T(ret, SYS_E_NONE, ret, "lport:%d", lport);
+		if (ret)
+			return ret;
+	}
+	//printk (KERN_INFO "yzhang..8614 read status call out,link=%d,linkmode=%d\n", ret_link, link_mode_8614[lport] );
+
+	return 0;
+}
+
+
+/*
+ * customer should overwirte this function according to there system
+ */
+phy_info_s * yt8614_app_get_phy_info(u32 lport)
+{
+	g_phy_info[0].lport = lport;
+	g_phy_info[0].phy_addr = (YT8614_PHY_BASE_PHY_ADDR + lport) & 0x1F;
+    return &g_phy_info[0];
+}
+
+s32 yt8614_app_init(void)
+{
+    s32 ret = SYS_E_NONE;
+    
+    memset(g_phy_info, 0, sizeof(g_phy_info));
+	g_phy_info[0].read	= yt8614_read_reg;
+	g_phy_info[0].write = yt8614_write_reg;
+	g_phy_info[0].lport = 0xFF; //invalid port
+	g_phy_info[0].bus_id = 0;
+	g_phy_info[0].phy_addr = YT8614_PHY_BASE_PHY_ADDR;
+	
+    return ret;
+}
+
diff --git a/drivers/net/phy/yt8614-phy.h b/drivers/net/phy/yt8614-phy.h
new file mode 100644
index 000000000..6244ab69f
--- /dev/null
+++ b/drivers/net/phy/yt8614-phy.h
@@ -0,0 +1,491 @@
+#ifndef _PHY_H_
+#define _PHY_H_
+
+
+/* configuration for driver */
+
+#define YT8614_MAX_LPORT_ID		3
+
+#define YT8614_PHY_MODE_FIBER	1 //fiber mode only
+#define YT8614_PHY_MODE_UTP		2 //utp mode only
+#define YT8614_PHY_MODE_POLL	3 //fiber and utp, poll mode
+
+/* please make choice according to system design
+ * for Fiber only system, please define YT8614_PHY_MODE_CURR 1
+ * for UTP only system, please define YT8614_PHY_MODE_CURR 2
+ * for combo system, please define YT8614_PHY_MODE_CURR 3 
+ */
+#define YT8614_PHY_MODE_CURR	3
+
+
+
+/* pls dont modify below lines */
+
+#define PHY_ID_YT8614  0x4F51E899 //serdes
+#define MOTORCOMM_MPHY_ID_MASK_8614 0xffffffff
+
+#ifndef BOOL
+#define BOOL unsigned int
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef SPEED_1000M
+#define SPEED_1000M     2
+#endif
+#ifndef SPEED_100M
+#define SPEED_100M     	1
+#endif
+#ifndef SPEED_10M
+#define SPEED_10M     	0
+#endif
+
+#ifndef SPEED_UNKNOWN
+#define SPEED_UNKNOWN   0xffff
+#endif
+
+#ifndef DUPLEX_FULL
+#define DUPLEX_FULL		1	
+#endif
+#ifndef DUPLEX_HALF
+#define DUPLEX_HALF		0	
+#endif
+
+#ifndef BIT
+#define BIT(n) (0x1<<(n))
+#endif
+#ifndef s32
+typedef int  s32;
+typedef unsigned int  u32;
+typedef unsigned short  u16;
+typedef unsigned char  u8;
+#endif
+
+#ifndef REG_PHY_SPEC_STATUS
+#define REG_PHY_SPEC_STATUS		0x11
+#define REG_DEBUG_ADDR_OFFSET		0x1e
+#define REG_DEBUG_DATA			0x1f
+#endif
+
+/**********YT8614************************************************/
+
+#define YT8614_SMI_SEL_PHY        0x0
+#define YT8614_SMI_SEL_SDS_QSGMII 0x02
+#define YT8614_SMI_SEL_SDS_SGMII  0x03
+
+/* yt8614 register type */
+#define YT8614_TYPE_COMMON         0x01
+#define YT8614_TYPE_UTP_MII        0x02
+#define YT8614_TYPE_UTP_EXT        0x03
+#define YT8614_TYPE_LDS_MII        0x04
+#define YT8614_TYPE_UTP_MMD        0x05
+#define YT8614_TYPE_SDS_QSGMII_MII 0x06
+#define YT8614_TYPE_SDS_SGMII_MII  0x07
+#define YT8614_TYPE_SDS_QSGMII_EXT 0x08
+#define YT8614_TYPE_SDS_SGMII_EXT  0x09
+
+/* YT8614 extended common register */
+#define YT8614_REG_COM_SMI_MUX        0xA000
+#define YT8614_REG_COM_SLED_CFG0      0xA001
+#define YT8614_REG_COM_PHY_ID         0xA002
+#define YT8614_REG_COM_CHIP_VER       0xA003
+#define YT8614_REG_COM_SLED_CFG       0xA004
+#define YT8614_REG_COM_MODE_CHG_RESET 0xA005
+#define YT8614_REG_COM_SYNCE0_CFG     0xA006
+#define YT8614_REG_COM_CHIP_MODE      0xA007
+
+#define YT8614_REG_COM_HIDE_SPEED     0xA009
+
+#define YT8614_REG_COM_SYNCE1_CFG     0xA00E
+
+#define YT8614_REG_COM_HIDE_FIBER_MODE 0xA019
+
+
+#define YT8614_REG_COM_HIDE_SEL1      0xA054
+#define YT8614_REG_COM_HIDE_LED_CFG2  0xB8
+#define YT8614_REG_COM_HIDE_LED_CFG3  0xB9
+#define YT8614_REG_COM_HIDE_LED_CFG5  0xBB
+
+#define YT8614_REG_COM_HIDE_LED_CFG4  0xBA //not used currently
+
+#if 0
+#define YT8614_REG_COM_HIDE_LED12_CFG 0xA060 //not used currently
+#define YT8614_REG_COM_HIDE_LED13_CFG 0xA061
+#define YT8614_REG_COM_HIDE_LED14_CFG 0xA062
+#define YT8614_REG_COM_HIDE_LED15_CFG 0xA063
+#define YT8614_REG_COM_HIDE_LED16_CFG 0xA064
+#define YT8614_REG_COM_HIDE_LED17_CFG 0xA065
+#define YT8614_REG_COM_HIDE_LED18_CFG 0xA066
+#define YT8614_REG_COM_HIDE_LED19_CFG 0xA067
+#define YT8614_REG_COM_HIDE_LED20_CFG 0xA068
+#define YT8614_REG_COM_HIDE_LED21_CFG 0xA069
+#define YT8614_REG_COM_HIDE_LED22_CFG 0xA06A
+#define YT8614_REG_COM_HIDE_LED23_CFG 0xA06B
+#define YT8614_REG_COM_HIDE_LED24_CFG 0xA06C
+#define YT8614_REG_COM_HIDE_LED25_CFG 0xA06D
+#define YT8614_REG_COM_HIDE_LED26_CFG 0xA06E
+#define YT8614_REG_COM_HIDE_LED27_CFG 0xA06F
+#endif
+
+#define YT8614_REG_COM_HIDE_LED28_CFG 0xA070
+#define YT8614_REG_COM_HIDE_LED29_CFG 0xA071
+#define YT8614_REG_COM_HIDE_LED30_CFG 0xA072
+#define YT8614_REG_COM_HIDE_LED31_CFG 0xA073
+#define YT8614_REG_COM_HIDE_LED32_CFG 0xA074
+#define YT8614_REG_COM_HIDE_LED33_CFG 0xA075
+#define YT8614_REG_COM_HIDE_LED34_CFG 0xA076
+#define YT8614_REG_COM_HIDE_LED35_CFG 0xA077
+
+#define YT8614_REG_COM_PKG_CFG0       0xA0A0
+#define YT8614_REG_COM_PKG_CFG1       0xA0A1
+#define YT8614_REG_COM_PKG_CFG2       0xA0A2
+#define YT8614_REG_COM_PKG_RX_VALID0  0xA0A3
+#define YT8614_REG_COM_PKG_RX_VALID1  0xA0A4
+#define YT8614_REG_COM_PKG_RX_OS0     0xA0A5
+#define YT8614_REG_COM_PKG_RX_OS1     0xA0A6
+#define YT8614_REG_COM_PKG_RX_US0     0xA0A7
+#define YT8614_REG_COM_PKG_RX_US1     0xA0A8
+#define YT8614_REG_COM_PKG_RX_ERR     0xA0A9
+#define YT8614_REG_COM_PKG_RX_OS_BAD  0xA0AA
+#define YT8614_REG_COM_PKG_RX_FRAG    0xA0AB
+#define YT8614_REG_COM_PKG_RX_NOSFD   0xA0AC
+#define YT8614_REG_COM_PKG_TX_VALID0  0xA0AD
+#define YT8614_REG_COM_PKG_TX_VALID1  0xA0AE
+#define YT8614_REG_COM_PKG_TX_OS0     0xA0AF
+
+#define YT8614_REG_COM_PKG_TX_OS1     0xA0B0
+#define YT8614_REG_COM_PKG_TX_US0     0xA0B1
+#define YT8614_REG_COM_PKG_TX_US1     0xA0B2
+#define YT8614_REG_COM_PKG_TX_ERR     0xA0B3
+#define YT8614_REG_COM_PKG_TX_OS_BAD  0xA0B4
+#define YT8614_REG_COM_PKG_TX_FRAG    0xA0B5
+#define YT8614_REG_COM_PKG_TX_NOSFD   0xA0B6
+#define YT8614_REG_COM_PKG_CFG3       0xA0B7
+#define YT8614_REG_COM_PKG_AZ_CFG     0xA0B8
+#define YT8614_REG_COM_PKG_DA_SA_CFG3 0xA0B9
+
+#define YT8614_REG_COM_MANU_HW_RESET  0xA0C0
+
+/* YT8614 UTP MII register: same as generic phy register definitions */
+#define REG_MII_BMCR          0x00    /* Basic mode control register */
+#define REG_MII_BMSR          0x01    /* Basic mode status register  */
+#define REG_MII_PHYSID1       0x02    /* PHYS ID 1                   */
+#define REG_MII_PHYSID2       0x03    /* PHYS ID 2                   */
+#define REG_MII_ADVERTISE     0x04    /* Advertisement control reg   */
+#define REG_MII_LPA           0x05    /* Link partner ability reg    */
+#define REG_MII_EXPANSION     0x06    /* Expansion register          */
+#define REG_MII_NEXT_PAGE     0x07    /* Next page register          */
+#define REG_MII_LPR_NEXT_PAGE 0x08    /* LPR next page register      */
+#define REG_MII_CTRL1000      0x09    /* 1000BASE-T control          */
+#define REG_MII_STAT1000      0x0A    /* 1000BASE-T status           */
+
+#define REG_MII_MMD_CTRL      0x0D    /* MMD access control register */
+#define REG_MII_MMD_DATA      0x0E    /* MMD access data register    */
+
+#define REG_MII_ESTATUS       0x0F    /* Extended Status             */
+#define REG_MII_SPEC_CTRL     0x10    /* PHY specific func control   */
+#define REG_MII_SPEC_STATUS   0x11    /* PHY specific status         */
+#define REG_MII_INT_MASK      0x12    /* Interrupt mask register     */
+#define REG_MII_INT_STATUS    0x13    /* Interrupt status register   */
+#define REG_MII_DOWNG_CTRL    0x14    /* Speed auto downgrade control*/
+#define REG_MII_RERRCOUNTER   0x15    /* Receive error counter       */
+
+#define REG_MII_EXT_ADDR      0x1E    /* Extended reg's address      */
+#define REG_MII_EXT_DATA      0x1F    /* Extended reg's date         */
+
+#ifndef MII_BMSR
+#define MII_BMSR						REG_MII_BMSR
+#endif
+
+#ifndef YT8614_SPEED_MODE_BIT
+#define YT8614_SPEED_MODE		0xc000
+#define YT8614_DUPLEX			0x2000
+#define YT8614_SPEED_MODE_BIT		14
+#define YT8614_DUPLEX_BIT		13
+#define YT8614_LINK_STATUS_BIT		10
+
+#endif
+
+#define YT8614_REG_COM_HIDE_SPEED_CMB_PRI		0x2000
+
+/* YT8614 UTP MMD register  */
+#define YT8614_REG_UTP_MMD_CTRL1           0x00    /* PCS control 1 register     */
+#define YT8614_REG_UTP_MMD_STATUS1         0x01    /* PCS status 1 register      */
+#define YT8614_REG_UTP_MMD_EEE_CTRL        0x14    /* EEE control and capability */
+#define YT8614_REG_UTP_MMD_EEE_WK_ERR_CNT  0x16    /* EEE wake error counter     */
+#define YT8614_REG_UTP_MMD_EEE_LOCAL_ABI   0x3C    /* local device EEE ability   */
+#define YT8614_REG_UTP_MMD_EEE_LP_ABI      0x3D    /* link partner EEE ability   */
+#define YT8614_REG_UTP_MMD_EEE_AUTONEG_RES 0x8000  /* autoneg result of EEE      */
+
+/* YT8614 UTP EXT register  */
+#define YT8614_REG_UTP_EXT_LPBK        0x0A
+#define YT8614_REG_UTP_EXT_SLEEP_CTRL1 0x27
+#define YT8614_REG_UTP_EXT_DEBUG_MON1  0x5A
+#define YT8614_REG_UTP_EXT_DEBUG_MON2  0x5B
+#define YT8614_REG_UTP_EXT_DEBUG_MON3  0x5C
+#define YT8614_REG_UTP_EXT_DEBUG_MON4  0x5D
+
+/* YT8614 SDS(1.25G/5G) MII register: same as YT8521S */
+#define REG_SDS_BMCR          0x00    /* Basic mode control register */
+#define REG_SDS_BMSR          0x01    /* Basic mode status register  */
+#define REG_SDS_PHYSID1       0x02    /* PHYS ID 1                   */
+#define REG_SDS_PHYSID2       0x03    /* PHYS ID 2                   */
+#define REG_SDS_ADVERTISE     0x04    /* Advertisement control reg   */
+#define REG_SDS_LPA           0x05    /* Link partner ability reg    */
+#define REG_SDS_EXPANSION     0x06    /* Expansion register          */
+#define REG_SDS_NEXT_PAGE     0x07    /* Next page register          */
+#define REG_SDS_LPR_NEXT_PAGE 0x08    /* LPR next page register      */
+
+#define REG_SDS_ESTATUS       0x0F    /* Extended Status             */
+#define REG_SDS_SPEC_STATUS   0x11    /* SDS specific status         */
+
+#define REG_SDS_100FX_CFG     0x14    /* 100fx cfg                   */
+#define REG_SDS_RERRCOUNTER   0x15    /* Receive error counter       */
+#define REG_SDS_LINT_FAIL_CNT 0x16    /* Lint fail counter mon       */
+
+/* YT8614 SDS(5G) EXT register */
+#define YT8614_REG_QSGMII_EXT_ANA_DIG_CFG 0x02    /* sds analog digital interface cfg */
+#define YT8614_REG_QSGMII_EXT_PRBS_CFG1   0x05    /* sds prbs cfg1 */
+#define YT8614_REG_QSGMII_EXT_PRBS_CFG2_1 0x06    /* sds prbs cfg2 */
+#define YT8614_REG_QSGMII_EXT_PRBS_CFG2_2 0x07    /* sds prbs cfg2 */
+#define YT8614_REG_QSGMII_EXT_PRBS_MON1   0x08    /* sds prbs mon1 */
+#define YT8614_REG_QSGMII_EXT_PRBS_MON2   0x09    /* sds prbs mon2 */
+#define YT8614_REG_QSGMII_EXT_PRBS_MON3   0x0A    /* sds prbs mon3 */
+#define YT8614_REG_QSGMII_EXT_PRBS_MON4   0x0B    /* sds prbs mon4 */
+#define YT8614_REG_QSGMII_EXT_PRBS_MON5   0x0C    /* sds prbs mon5 */
+#define YT8614_REG_QSGMII_EXT_ANA_CFG2    0xA1    /* Analog cfg2   */
+
+/* YT8614 SDS(1.25G) EXT register */
+#define YT8614_REG_SGMII_EXT_PRBS_CFG1    0x05    /* sds prbs cfg1 */
+#define YT8614_REG_SGMII_EXT_PRBS_CFG2    0x06    /* sds prbs cfg2 */
+#define YT8614_REG_SGMII_EXT_PRBS_MON1    0x08    /* sds prbs mon1 */
+#define YT8614_REG_SGMII_EXT_PRBS_MON2    0x09    /* sds prbs mon2 */
+#define YT8614_REG_SGMII_EXT_PRBS_MON3    0x0A    /* sds prbs mon3 */
+#define YT8614_REG_SGMII_EXT_PRBS_MON4    0x0B    /* sds prbs mon4 */
+#define YT8614_REG_SGMII_EXT_PRBS_MON5    0x0C    /* sds prbs mon5 */
+#define YT8614_REG_SGMII_EXT_ANA_CFG2     0xA1    /* Analog cfg2   */
+#define YT8614_REG_SGMII_EXT_HIDE_AUTO_SEN 0xA5   /* Fiber auto sensing */
+
+////////////////////////////////////////////////////////////////////
+#define YT8614_MMD_DEV_ADDR1     0x1
+#define YT8614_MMD_DEV_ADDR3     0x3
+#define YT8614_MMD_DEV_ADDR7     0x7
+#define YT8614_MMD_DEV_ADDR_NONE 0xFF
+
+/**********YT8521S************************************************/
+/* Basic mode control register(0x00) */
+#define BMCR_RESV         0x003f  /* Unused...                   */
+#define BMCR_SPEED1000    0x0040  /* MSB of Speed (1000)         */
+#define BMCR_CTST         0x0080  /* Collision test              */
+#define BMCR_FULLDPLX     0x0100  /* Full duplex                 */
+#define BMCR_ANRESTART    0x0200  /* Auto negotiation restart    */
+#define BMCR_ISOLATE      0x0400  /* Disconnect DP83840 from MII */
+#define BMCR_PDOWN        0x0800  /* Powerdown the DP83840       */
+#define BMCR_ANENABLE     0x1000  /* Enable auto negotiation     */
+#define BMCR_SPEED100     0x2000  /* Select 100Mbps              */
+#define BMCR_LOOPBACK     0x4000  /* TXD loopback bits           */
+#define BMCR_RESET        0x8000  /* Reset the DP83840           */
+
+/* Basic mode status register(0x01) */
+#define BMSR_ERCAP        0x0001  /* Ext-reg capability          */
+#define BMSR_JCD          0x0002  /* Jabber detected             */
+#define BMSR_LSTATUS      0x0004  /* Link status                 */
+#define BMSR_ANEGCAPABLE  0x0008  /* Able to do auto-negotiation */
+#define BMSR_RFAULT       0x0010  /* Remote fault detected       */
+#define BMSR_ANEGCOMPLETE 0x0020  /* Auto-negotiation complete   */
+#define BMSR_RESV         0x00c0  /* Unused...                   */
+#define BMSR_ESTATEN      0x0100  /* Extended Status in R15      */
+#define BMSR_100HALF2     0x0200  /* Can do 100BASE-T2 HDX       */
+#define BMSR_100FULL2     0x0400  /* Can do 100BASE-T2 FDX       */
+#define BMSR_10HALF       0x0800  /* Can do 10mbps, half-duplex  */
+#define BMSR_10FULL       0x1000  /* Can do 10mbps, full-duplex  */
+#define BMSR_100HALF      0x2000  /* Can do 100mbps, half-duplex */
+#define BMSR_100FULL      0x4000  /* Can do 100mbps, full-duplex */
+#define BMSR_100BASE4     0x8000  /* Can do 100mbps, 4k packets  */
+
+/* Advertisement control register(0x04) */
+#define ADVERTISE_SLCT          0x001f  /* Selector bits               */
+#define ADVERTISE_CSMA          0x0001  /* Only selector supported     */
+#define ADVERTISE_10HALF        0x0020  /* Try for 10mbps half-duplex  */
+#define ADVERTISE_1000XFULL     0x0020  /* Try for 1000BASE-X full-duplex */
+#define ADVERTISE_10FULL        0x0040  /* Try for 10mbps full-duplex  */
+#define ADVERTISE_1000XHALF     0x0040  /* Try for 1000BASE-X half-duplex */
+#define ADVERTISE_100HALF       0x0080  /* Try for 100mbps half-duplex */
+#define ADVERTISE_1000XPAUSE    0x0080  /* Try for 1000BASE-X pause    */
+#define ADVERTISE_100FULL       0x0100  /* Try for 100mbps full-duplex */
+#define ADVERTISE_1000XPSE_ASYM 0x0100  /* Try for 1000BASE-X asym pause */
+#define ADVERTISE_100BASE4      0x0200  /* Try for 100mbps 4k packets  */
+#define ADVERTISE_PAUSE_CAP     0x0400  /* Try for pause               */
+#define ADVERTISE_PAUSE_ASYM    0x0800  /* Try for asymetric pause     */
+#define ADVERTISE_RESV          0x1000  /* Unused...                   */
+#define ADVERTISE_RFAULT        0x2000  /* Say we can detect faults    */
+#define ADVERTISE_LPACK         0x4000  /* Ack link partners response  */
+#define ADVERTISE_NPAGE         0x8000  /* Next page bit               */
+
+#define ADVERTISE_FULL (ADVERTISE_100FULL | ADVERTISE_10FULL | ADVERTISE_CSMA)
+#define ADVERTISE_ALL  (ADVERTISE_10HALF  | ADVERTISE_10FULL | \
+                        ADVERTISE_100HALF | ADVERTISE_100FULL)
+
+/* Link partner ability register(0x05) */
+#define LPA_SLCT              0x001f  /* Same as advertise selector    */
+#define LPA_10HALF            0x0020  /* Can do 10mbps half-duplex     */
+#define LPA_1000XFULL         0x0020  /* Can do 1000BASE-X full-duplex */
+#define LPA_10FULL            0x0040  /* Can do 10mbps full-duplex     */
+#define LPA_1000XHALF         0x0040  /* Can do 1000BASE-X half-duplex */
+#define LPA_100HALF           0x0080  /* Can do 100mbps half-duplex    */
+#define LPA_1000XPAUSE        0x0080  /* Can do 1000BASE-X pause       */
+#define LPA_100FULL           0x0100  /* Can do 100mbps full-duplex    */
+#define LPA_1000XPAUSE_ASYM   0x0100  /* Can do 1000BASE-X pause asym  */
+#define LPA_100BASE4          0x0200  /* Can do 100mbps 4k packets     */
+#define LPA_PAUSE_CAP         0x0400  /* Can pause                     */
+#define LPA_PAUSE_ASYM        0x0800  /* Can pause asymetrically       */
+#define LPA_RESV              0x1000  /* Unused...                     */
+#define LPA_RFAULT            0x2000  /* Link partner faulted          */
+#define LPA_LPACK             0x4000  /* Link partner acked us         */
+#define LPA_NPAGE             0x8000  /* Next page bit                 */
+
+/* 1000BASE-T Control register(0x09) */
+#define ADVERTISE_1000FULL    0x0200  /* Advertise 1000BASE-T full duplex */
+#define ADVERTISE_1000HALF    0x0100  /* Advertise 1000BASE-T half duplex */
+#define CTL1000_AS_MASTER     0x0800
+#define CTL1000_ENABLE_MASTER 0x1000
+
+/* 1000BASE-T Status register(0x0A) */
+#define LPA_1000LOCALRXOK     0x2000  /* Link partner local receiver status  */
+#define LPA_1000REMRXOK       0x1000  /* Link partner remote receiver status */
+#define LPA_1000FULL          0x0800  /* Link partner 1000BASE-T full duplex */
+#define LPA_1000HALF          0x0400  /* Link partner 1000BASE-T half duplex */
+
+/**********YT8614************************************************/
+/* Basic mode control register(0x00) */
+#define FIBER_BMCR_RESV        0x001f  /* b[4:0] Unused...                      */
+#define FIBER_BMCR_EN_UNIDIR   0x0020  /* b[5]   Valid when bit 0.12 is zero and bit 0.8 is one */
+#define FIBER_BMCR_SPEED1000   0x0040  /* b[6]   MSB of Speed (1000)            */
+#define FIBER_BMCR_CTST        0x0080  /* b[7]   Collision test                 */
+#define FIBER_BMCR_DUPLEX_MODE 0x0100  /* b[8]   Duplex mode                    */
+#define FIBER_BMCR_ANRESTART   0x0200  /* b[9]   Auto negotiation restart       */
+#define FIBER_BMCR_ISOLATE     0x0400  /* b[10]  Isolate phy from RGMII/SGMII/FIBER */
+#define FIBER_BMCR_PDOWN       0x0800  /* b[11]  1: Power down                  */
+#define FIBER_BMCR_ANENABLE    0x1000  /* b[12]  Enable auto negotiation        */
+#define FIBER_BMCR_SPEED100    0x2000  /* b[13]  LSB of Speed (100)             */
+#define FIBER_BMCR_LOOPBACK    0x4000  /* b[14]  Internal loopback control      */
+#define FIBER_BMCR_RESET       0x8000  /* b[15]  PHY Software Reset(self-clear) */
+
+/* Sds specific status register(0x11) */
+#define FIBER_SSR_ERCAP          0x0001  /* b[0]     realtime syncstatus */
+#define FIBER_SSR_XMIT           0x000E  /* b[3:1]   realtime transmit statemachine.
+                                                     001: Xmit Idle;
+                                                     010: Xmit Config; 
+                                                     100: Xmit Data. */
+#define FIBER_SSR_SER_MODE_CFG   0x0030  /* b[5:4]   realtime serdes working mode.
+                                                     00: SG_MAC;
+                                                     01: SG_PHY;
+                                                     10: FIB_1000;
+                                                     11: FIB_100. */
+#define FIBER_SSR_EN_FLOWCTRL_TX 0x0040  /* b[6]     realtime en_flowctrl_tx */
+#define FIBER_SSR_EN_FLOWCTRL_RX 0x0080  /* b[7]     realtime en_flowctrl_rx */
+#define FIBER_SSR_DUPLEX_ERROR   0x0100  /* b[8]     realtime deplex error */
+#define FIBER_SSR_RX_LPI_ACTIVE  0x0200  /* b[9]     rx lpi is active */
+#define FIBER_SSR_LSTATUS        0x0400  /* b[10]    Link status real-time */
+#define FIBER_SSR_PAUSE          0x1800  /* b[12:11] Pause to mac */
+#define FIBER_SSR_DUPLEX         0x2000  /* b[13]    This status bit is valid only when bit10 is 1.
+                                                     1: full duplex 
+                                                     0: half duplex */
+#define FIBER_SSR_SPEED_MODE     0xC000  /* b[15:14] These status bits are valid only when bit10 is 1.
+                                                     10---1000M 
+                                                     01---100M */
+
+/* SLED cfg0 (ext 0xA001) */
+#define FIBER_SLED_CFG0_EN_CTRL  0x00FF  /* b[7:0]   Control to enable the eight ports' SLED */
+#define FIBER_SLED_CFG0_BIT_MASK 0x0700  /* b[10:8]  1: enable the pin output */
+#define FIBER_SLED_CFG0_ACT_LOW  0x0800  /* b[11]    control SLED's polarity. 1: active low; 0: active high */
+#define FIBER_SLED_CFG0_MANU_ST  0x7000  /* b[14:12] SLEDs' manul status, corresponding to each port's 3 SLEDs */
+#define FIBER_SLED_CFG0_MANU_EN  0x8000  /* b[15]    to control serial LEDs status manually */
+
+/**********YT8614************************************************/
+/* Fiber auto sensing(sgmii ext 0xA5) */
+#define FIBER_AUTO_SEN_ENABLE    0x8000  /* b[15]  Enable fiber auto sensing */
+
+/* Fiber force speed(common ext 0xA009) */
+#define FIBER_FORCE_1000M        0x0001  /* b[0]  1:1000BX 0:100FX */
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+/* errno */
+enum ytphy_8614_errno_e
+{
+	SYS_E_NONE,
+	SYS_E_PARAM,
+	SYS_E_MAX
+};
+
+/* errno */
+enum ytphy_8614_combo_speed_e
+{
+	YT8614_COMBO_FIBER_1000M,
+	YT8614_COMBO_FIBER_100M,
+	YT8614_COMBO_UTP_ONLY,
+	YT8614_COMBO_SPEED_MAX
+};
+
+/* definition for porting */
+/* phy registers access */
+typedef struct
+{
+    u16 reg;     /* the offset of the phy internal address */
+    u16 val;     /* the value of the register */
+    u8  regType; /* register type */
+} phy_data_s;
+
+/* for porting use.
+ * pls over-write member function read/write for mdio access
+ */
+typedef struct phy_info_str
+{
+#if 0
+    struct phy_device *phydev;
+	int mdio_base;
+#endif
+	unsigned int lport;
+	unsigned int bus_id;
+	unsigned int phy_addr;
+
+    s32 (*read)(struct phy_info_str *info, phy_data_s *param);
+    s32 (*write)(struct phy_info_str *info, phy_data_s *param);
+}phy_info_s;
+
+/* get phy access method */
+s32 yt8614_read_reg(struct phy_info_str *info, phy_data_s *param);
+s32 yt8614_write_reg(struct phy_info_str *info, phy_data_s *param);
+s32 yt8614_phy_soft_reset(u32 lport);
+s32 yt8614_phy_init(u32 lport);
+s32 yt8614_fiber_enable(u32 lport, BOOL enable);
+s32 yt8614_utp_enable(u32 lport, BOOL enable);
+s32 yt8614_fiber_unidirection_set(u32 lport, int speed, BOOL enable);
+s32 yt8614_fiber_autosensing_set(u32 lport, BOOL enable);
+s32 yt8614_fiber_speed_set(u32 lport, int fiber_speed);
+s32 yt8614_qsgmii_autoneg_set(u32 lport, BOOL enable);
+s32 yt8614_sgmii_autoneg_set(u32 lport, BOOL enable);
+s32 yt8614_qsgmii_sgmii_link_status_get(u32 lport, BOOL *enable, BOOL if_qsgmii);
+int yt8614_combo_media_priority_set (u32 lport, int fiber);
+int yt8614_combo_media_priority_get (u32 lport, int *fiber);
+s32 yt8614_utp_autoneg_set(u32 lport, BOOL enable);
+s32 yt8614_utp_autoneg_get(u32 lport, BOOL *enable);
+s32 yt8614_utp_autoneg_ability_set(u32 lport, unsigned int cap_mask);
+s32 yt8614_utp_autoneg_ability_get(u32 lport, unsigned int *cap_mask);
+s32 yt8614_utp_force_duplex_set(u32 lport, BOOL full);
+s32 yt8614_utp_force_duplex_get(u32 lport, BOOL *full);
+s32 yt8614_utp_force_speed_set(u32 lport, unsigned int speed);
+s32 yt8614_utp_force_speed_get(u32 lport, unsigned int *speed);
+int yt8614_autoneg_done_get (u32 lport, int speed, int *aneg);
+int yt8614_media_status_get(u32 lport, int* speed, int* duplex, int* ret_link, int *media);
+
+#endif
diff --git a/include/linux/motorcomm_phy.h b/include/linux/motorcomm_phy.h
new file mode 100644
index 000000000..5c769a9dd
--- /dev/null
+++ b/include/linux/motorcomm_phy.h
@@ -0,0 +1,118 @@
+/*
+ * include/linux/motorcomm_phy.h
+ *
+ * Motorcomm PHY IDs
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef _MOTORCOMM_PHY_H
+#define _MOTORCOMM_PHY_H
+
+#define MOTORCOMM_PHY_ID_MASK	0x00000fff
+#define MOTORCOMM_PHY_ID_8531_MASK	0xffffffff
+#define MOTORCOMM_MPHY_ID_MASK	0x0000ffff
+
+#define PHY_ID_YT8010		0x00000309
+#define PHY_ID_YT8510		0x00000109
+#define PHY_ID_YT8511		0x0000010a
+#define PHY_ID_YT8512		0x00000118
+#define PHY_ID_YT8512B		0x00000128
+#define PHY_ID_YT8521		0x0000011a
+#define PHY_ID_YT8531S		0x4f51e91a
+#define PHY_ID_YT8531		0x4f51e91b
+//#define PHY_ID_YT8614		0x0000e899
+#define PHY_ID_YT8618		0x0000e889
+
+#define REG_PHY_SPEC_STATUS		0x11
+#define REG_DEBUG_ADDR_OFFSET		0x1e
+#define REG_DEBUG_DATA			0x1f
+
+#define YT8512_EXTREG_AFE_PLL		0x50
+#define YT8512_EXTREG_EXTEND_COMBO	0x4000
+#define YT8512_EXTREG_LED0		0x40c0
+#define YT8512_EXTREG_LED1		0x40c3
+
+#define YT8512_EXTREG_SLEEP_CONTROL1	0x2027
+
+#define YT_SOFTWARE_RESET		0x8000
+
+#define YT8512_CONFIG_PLL_REFCLK_SEL_EN	0x0040
+#define YT8512_CONTROL1_RMII_EN		0x0001
+#define YT8512_LED0_ACT_BLK_IND		0x1000
+#define YT8512_LED0_DIS_LED_AN_TRY	0x0001
+#define YT8512_LED0_BT_BLK_EN		0x0002
+#define YT8512_LED0_HT_BLK_EN		0x0004
+#define YT8512_LED0_COL_BLK_EN		0x0008
+#define YT8512_LED0_BT_ON_EN		0x0010
+#define YT8512_LED1_BT_ON_EN		0x0010
+#define YT8512_LED1_TXACT_BLK_EN	0x0100
+#define YT8512_LED1_RXACT_BLK_EN	0x0200
+#define YT8512_SPEED_MODE		0xc000
+#define YT8512_DUPLEX			0x2000
+
+#define YT8512_SPEED_MODE_BIT		14
+#define YT8512_DUPLEX_BIT		13
+#define YT8512_EN_SLEEP_SW_BIT		15
+
+#define YT8521_EXTREG_SLEEP_CONTROL1	0x27
+#define YT8521_EN_SLEEP_SW_BIT		15
+
+#define YT8521_SPEED_MODE		0xc000
+#define YT8521_DUPLEX			0x2000
+#define YT8521_SPEED_MODE_BIT		14
+#define YT8521_DUPLEX_BIT		13
+#define YT8521_LINK_STATUS_BIT		10
+
+/* based on yt8521 wol config register */
+#define YTPHY_UTP_INTR_REG             0x12
+/* WOL Event Interrupt Enable */
+#define YTPHY_WOL_INTR            BIT(6)
+
+/* Magic Packet MAC address registers */
+#define YTPHY_MAGIC_PACKET_MAC_ADDR2                 0xa007
+#define YTPHY_MAGIC_PACKET_MAC_ADDR1                 0xa008
+#define YTPHY_MAGIC_PACKET_MAC_ADDR0                 0xa009
+
+#define YTPHY_WOL_CFG_REG		0xa00a
+#define YTPHY_WOL_CFG_TYPE		BIT(0)	/* WOL TYPE */
+#define YTPHY_WOL_CFG_EN		BIT(3)	/* WOL Enable */
+#define YTPHY_WOL_CFG_INTR_SEL	BIT(6)	/* WOL Event Interrupt Enable */
+#define YTPHY_WOL_CFG_WIDTH1	BIT(1)	/* WOL Pulse Width */
+#define YTPHY_WOL_CFG_WIDTH2	BIT(2)
+
+#define YTPHY_REG_SPACE_UTP             0
+#define YTPHY_REG_SPACE_FIBER           2
+
+enum ytphy_wol_type_e
+{
+    YTPHY_WOL_TYPE_LEVEL,
+    YTPHY_WOL_TYPE_PULSE,
+    YTPHY_WOL_TYPE_MAX
+};
+typedef enum ytphy_wol_type_e ytphy_wol_type_t;
+
+enum ytphy_wol_width_e
+{
+    YTPHY_WOL_WIDTH_84MS,
+    YTPHY_WOL_WIDTH_168MS,
+    YTPHY_WOL_WIDTH_336MS,
+    YTPHY_WOL_WIDTH_672MS,
+    YTPHY_WOL_WIDTH_MAX
+};
+typedef enum ytphy_wol_width_e ytphy_wol_width_t;
+
+struct ytphy_wol_cfg_s
+{
+    int enable;
+    int type;
+    int width;
+};
+typedef struct ytphy_wol_cfg_s ytphy_wol_cfg_t;
+
+#endif /* _MOTORCOMM_PHY_H */
+
-- 
2.25.1

