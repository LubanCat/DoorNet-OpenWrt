diff -urN u-boot-2016.03/arch/arm/cpu/armv7/mx6/bee.c ebf_6ull_uboot/arch/arm/cpu/armv7/mx6/bee.c
--- u-boot-2016.03/arch/arm/cpu/armv7/mx6/bee.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/cpu/armv7/mx6/bee.c	2021-04-16 14:42:14.664580642 +0800
@@ -0,0 +1,462 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/io.h>
+#include <asm/arch/mx6_bee.h>
+#include <asm-generic/errno.h>
+#include <asm/system.h>
+#include <common.h>
+#include <command.h>
+#include <fuse.h>
+#include <asm/arch/sys_proto.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if (defined(CONFIG_SYS_DCACHE_OFF) || defined(CONFIG_SYS_ICACHE_OFF))
+#error "Bee needs Cache Open"
+#endif
+
+struct bee_parameters {
+	int key_method;
+	int mode;
+	u32 start1;
+	u32 size1;
+	u32 start2;
+	u32 size2;
+};
+
+#define SOFT_KEY 0
+#define SNVS_KEY 1
+
+#define ECB_MODE 0
+#define CTR_MODE 1
+
+#define AES_REGION0_ADDR	0x10000000
+#define AES_REGION1_ADDR	0x30000000
+
+static struct bee_parameters para;
+static int bee_inited;
+
+union key_soft {
+	u8 s_key[16];
+	u32 b_key[4];
+};
+
+union key_soft key_bad;
+
+/* software version */
+u8 hw_get_random_byte(void)
+{
+	static u32 lcg_state;
+	static u32 nb_soft = 9876543;
+#define MAX_SOFT_RNG 1024
+	static const u32 a = 1664525;
+	static const u32 c = 1013904223;
+	nb_soft = (nb_soft + 1) % MAX_SOFT_RNG;
+	lcg_state = (a * lcg_state + c);
+	return (u8) (lcg_state >> 24);
+}
+
+/*
+ * Lock bee GPR0 bits
+ * Only reset can release these bits.
+ */
+static int bee_lock(void)
+{
+	int val;
+
+	val = readl(BEE_BASE_ADDR + GPR0);
+	val |= (GPR0_CTRL_CLK_EN_LOCK | GPR0_CTRL_SFTRST_N_LOCK |
+		GPR0_CTRL_AES_MODE_LOCK | GPR0_SEC_LEVEL_LOCK |
+		GPR0_AES_KEY_SEL_LOCK | GPR0_BEE_ENABLE_LOCK);
+	writel(val, BEE_BASE_ADDR + GPR0);
+
+	return 0;
+}
+
+/* Only check bee enable lock is enough */
+static int bee_locked(void)
+{
+	int val;
+
+	val = readl(BEE_BASE_ADDR + GPR0);
+
+	return val & GPR0_BEE_ENABLE_LOCK ? 1 : 0;
+}
+
+int bee_init(struct bee_parameters *p)
+{
+	int i;
+	union key_soft *key = &key_bad;
+	u32 value;
+
+	if (bee_locked()) {
+		printf("BEE already enabled and locked.\n");
+		return CMD_RET_FAILURE;
+	}
+
+	/* CLKGATE, SFTRST */
+	writel(GPR0_CTRL_CLK_EN | GPR0_CTRL_SFTRST_N, BEE_BASE_ADDR + GPR0);
+	/* OFFSET_ADDR0 */
+	writel(p->start1 >> 16, BEE_BASE_ADDR + GPR1);
+	/*
+	 * OFFSET_ADDR1
+	 * Default protect IRAM region, if what you want to protect
+	 * bigger that 512M which is the max size that one AES region
+	 * can protect, we need AES region 1 to cover.
+	 */
+	writel(p->start2 >> 16, BEE_BASE_ADDR + GPR2);
+
+	if (p->key_method == SOFT_KEY) {
+		for (i = 0; i < 16; i++)
+			key->s_key[i] = hw_get_random_byte();
+		/* AES 128 key from software */
+		/* aes0_key0_w0 */
+		writel(key->b_key[0], BEE_BASE_ADDR + GPR3);
+		/* aes0_key0_w1 */
+		writel(key->b_key[1], BEE_BASE_ADDR + GPR4);
+		/* aes0_key0_w2 */
+		writel(key->b_key[2], BEE_BASE_ADDR + GPR5);
+		/* aes0_key0_w3 */
+		writel(key->b_key[3], BEE_BASE_ADDR + GPR6);
+	}
+
+	if (p->mode == ECB_MODE) {
+		value = GPR0_CTRL_CLK_EN | GPR0_CTRL_SFTRST_N |
+			GPR0_SEC_LEVEL_3 | GPR0_AES_KEY_SEL_SNVS |
+			GPR0_BEE_ENABLE | GPR0_CTRL_AES_MODE_ECB;
+		if (p->key_method == SOFT_KEY)
+			value = GPR0_CTRL_CLK_EN | GPR0_CTRL_SFTRST_N |
+				GPR0_SEC_LEVEL_3 | GPR0_AES_KEY_SEL_SOFT |
+				GPR0_BEE_ENABLE | GPR0_CTRL_AES_MODE_ECB;
+		writel(value, BEE_BASE_ADDR + GPR0);
+	} else {
+		for (i = 0; i < 16; i++)
+			key->s_key[i] = hw_get_random_byte();
+		/* aes_key1_w0 */
+		writel(key->b_key[0], BEE_BASE_ADDR + GPR8);
+		/* aes_key1_w1 */
+		writel(key->b_key[1], BEE_BASE_ADDR + GPR9);
+		/* aes_key1_w2 */
+		writel(key->b_key[2], BEE_BASE_ADDR + GPR10);
+		/* aes_key1_w3 */
+		writel(key->b_key[3], BEE_BASE_ADDR + GPR11);
+
+		value = GPR0_CTRL_CLK_EN | GPR0_CTRL_SFTRST_N |
+			GPR0_SEC_LEVEL_3 | GPR0_AES_KEY_SEL_SNVS |
+			GPR0_BEE_ENABLE | GPR0_CTRL_AES_MODE_CTR;
+		if (p->key_method == SOFT_KEY)
+			value = GPR0_CTRL_CLK_EN | GPR0_CTRL_SFTRST_N |
+				GPR0_SEC_LEVEL_3 | GPR0_AES_KEY_SEL_SOFT |
+				GPR0_BEE_ENABLE | GPR0_CTRL_AES_MODE_CTR;
+		writel(value, BEE_BASE_ADDR + GPR0);
+	}
+
+	bee_lock();
+
+	printf("BEE is settings as: %s mode, %s %d key\n",
+	       (p->mode == ECB_MODE) ? "ECB" : "CTR",
+	       (p->key_method == SOFT_KEY) ? "SOFT" : "SNVS HW",
+	       (p->mode == ECB_MODE) ? 128 : 256);
+
+	return CMD_RET_SUCCESS;
+}
+
+int bee_test(struct bee_parameters *p, int region)
+{
+	u32 result = 0, range, address;
+	int i, val;
+	/*
+	 * Test instruction running in AES Region:
+	 * int test(void)
+	 * {
+	 *	return 0x55aa55aa;
+	 * }
+	 * Assemble:
+	 * 0xe59f0000: ldr r0, [pc]
+	 * 0xe12fff1e: bx lr
+	 * 0x55aa55aa: 0x55aa55aa
+	 */
+	u32 inst[3] = {0xe59f0000, 0xe12fff1e, 0x55aa55aa};
+
+	/* Cache enabled? */
+	if ((get_cr() & (CR_I | CR_C)) != (CR_I | CR_C)) {
+		printf("Enable dcache and icache first!\n");
+		return CMD_RET_FAILURE;
+	}
+
+	printf("Test Region %d\nBegin Data test: Writing... ", region);
+
+	range = (region == 0) ? p->size1 : p->size2;
+	address = (region == 0) ? AES_REGION0_ADDR : AES_REGION1_ADDR;
+	for (i = 0; i < range; i = i + 4)
+		writel(i, address + i);
+
+	printf("Finshed Write!\n");
+
+	flush_dcache_range(address, address + range);
+
+	printf("Reading... ");
+	for (i = 0; i < range; i = i + 4) {
+		val = readl(address + i);
+		if (val != i)
+			result++;
+	}
+	printf("Finshed Read!\n");
+
+	if (result > 0)
+		printf("BEE Data Test check Failed!\n");
+	else
+		printf("BEE Data Test Check Passed!\n");
+
+	for (i = 0; i < ARRAY_SIZE(inst); i++)
+		writel(inst[i], address + (i * 4));
+
+	flush_dcache_range(address, address + sizeof(inst));
+
+	val = ((int (*)(void))address)();
+
+	printf("\nBee Instruction test, Program:\n"
+	       "int test(void)\n"
+	       "{\n"
+	       "      return 0x55aa55aa;\n"
+	       "}\n"
+	       "Assemble:\n"
+	       "0xe59f0000: ldr r0, [pc]\n"
+	       "0xe12fff1e: bx lr\n"
+	       "0x55aa55aa: 0x55aa55aa\n"
+	       "Runnint at 0x%x\n", address);
+	if (val == 0x55aa55aa)
+		printf("Bee Instruction Test Passed!\n");
+	else
+		printf("Bee Instruction Test Failed!\n");
+
+	return CMD_RET_SUCCESS;
+}
+
+static int region_valid(u32 start, u32 size)
+{
+	if ((start < PHYS_SDRAM) || (start >= (start + size - 1)) ||
+	    (start >= (PHYS_SDRAM + PHYS_SDRAM_SIZE - 1))) {
+		printf("Invalid start 0x%x, size 0x%x\n", start, size);
+		return -EINVAL;
+	}
+
+	if (size > SZ_512M) {
+		printf("The region size exceeds SZ_512M\n");
+		return -EINVAL;
+	}
+
+	if ((start & 0xFFFF) && (size & 0xFFFF)) {
+		printf("start or size not 64KB aligned!\n");
+		return -EINVAL;
+	}
+
+	if ((start + size - 1) >= (gd->start_addr_sp - CONFIG_STACKSIZE)) {
+		printf("Overlap with uboot execution environment!\n"
+		       "Decrease size or start\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int do_bee_init(cmd_tbl_t *cmdtp, int flag, int argc,
+		       char * const argv[])
+{
+	u32 start, size;
+	int ret;
+	struct bee_parameters *p = &para;
+
+#if defined(CONFIG_SYS_ARM_CACHE_WRITETHROUGH)
+	enum dcache_option option = DCACHE_WRITETHROUGH;
+#else
+	enum dcache_option option = DCACHE_WRITEBACK;
+#endif
+
+	if (argc > 5)
+		return CMD_RET_USAGE;
+
+#ifdef CONFIG_MX6
+	if (check_module_fused(MX6_MODULE_BEE)) {
+		printf("BEE is fused, disable it!\n");
+		return CMD_RET_FAILURE;
+	}
+#endif
+
+	/* Cache enabled? */
+	if ((get_cr() & (CR_I | CR_C)) != (CR_I | CR_C)) {
+		/*
+		 * Here we need icache and dcache both enabled, because
+		 * we may take the protected region for instruction and
+		 * data usage. And icache and dcache both enabled are
+		 * better for performance.
+		 */
+		printf("Please enable dcache and icache first!\n");
+		return CMD_RET_FAILURE;
+	}
+
+	p->key_method = SOFT_KEY;
+	p->mode = ECB_MODE;
+	p->start1 = PHYS_SDRAM;
+	p->size1 = SZ_512M;
+	p->start2 = IRAM_BASE_ADDR;
+	p->size2 = IRAM_SIZE;
+
+	if (argc == 2) {
+		p->key_method = (int)simple_strtoul(argv[1], NULL, 16);
+		p->mode = ECB_MODE;
+		p->start1 = PHYS_SDRAM;
+		p->size1 = SZ_512M;
+	} else if (argc == 3) {
+		p->key_method = (int)simple_strtoul(argv[1], NULL, 16);
+		p->mode = (int)simple_strtoul(argv[2], NULL, 10);
+		p->start1 = PHYS_SDRAM;
+		p->size1 = SZ_512M;
+	} else if ((argc == 4) || (argc == 5)) {
+		p->key_method = (int)simple_strtoul(argv[1], NULL, 16);
+		p->mode = (int)simple_strtoul(argv[2], NULL, 10);
+		start = (u32)simple_strtoul(argv[3], NULL, 16);
+		/* Default size that AES Region0 can protected */
+		size = SZ_512M;
+		if (argc == 5)
+			size = (u32)simple_strtoul(argv[4], NULL, 16);
+		p->start1 = start;
+		p->size1 = size;
+	}
+
+	if ((p->key_method != SOFT_KEY) && (p->key_method != SNVS_KEY))
+		return CMD_RET_USAGE;
+
+	if ((p->mode != ECB_MODE) && (p->mode != CTR_MODE))
+		return CMD_RET_USAGE;
+
+	/*
+	 * No need to check region valid for IRAM, since it is fixed.
+	 * Only check DRAM region here.
+	 */
+	if (region_valid(p->start1, p->size1))
+		return CMD_RET_FAILURE;
+
+	ret = bee_init(p);
+	if (ret)
+		return CMD_RET_FAILURE;
+
+	/*
+	 * Set DCACHE OFF to AES REGION0 and AES REGION1 first
+	 * to avoid possible unexcepted cache settings.
+	 */
+	mmu_set_region_dcache_behaviour(AES_REGION0_ADDR, SZ_1G, DCACHE_OFF);
+
+	mmu_set_region_dcache_behaviour(AES_REGION0_ADDR, p->size1, option);
+
+	mmu_set_region_dcache_behaviour(AES_REGION1_ADDR, p->size2, option);
+
+	printf("Access Region 0x%x - 0x%x to protect 0x%x - 0x%x\n"
+	       "Do not directly access 0x%x - 0x%x\n"
+	       "Access Region 0x%x - 0x%x to protect 0x%x - 0x%x\n"
+	       "Do not directly access 0x%x - 0x%x\n",
+	       AES_REGION0_ADDR, AES_REGION0_ADDR + p->size1 - 1,
+	       p->start1, p->start1 + p->size1 - 1,
+	       p->start1, p->start1 + p->size1 - 1,
+	       AES_REGION1_ADDR, AES_REGION1_ADDR + p->size2 - 1,
+	       p->start2, p->start2 + p->size2 - 1,
+	       p->start2, p->start2 + p->size2 - 1);
+
+	bee_inited = 1;
+
+	return CMD_RET_SUCCESS;
+}
+
+static int do_bee_test(cmd_tbl_t *cmdtp, int flag, int argc,
+		       char * const argv[])
+{
+	int ret;
+	int region;
+
+	if (bee_inited == 0) {
+		printf("Bee not initialized, run bee init first!\n");
+		return CMD_RET_FAILURE;
+	}
+	if (argc > 2)
+		return CMD_RET_USAGE;
+
+	region = 0;
+	if (argc == 2)
+		region = (int)simple_strtoul(argv[1], NULL, 16);
+	/* Only two regions are supported, 0 and 1 */
+	if (region >= 2)
+		return CMD_RET_USAGE;
+
+	ret = bee_test(&para, region);
+	if (ret)
+		return CMD_RET_FAILURE;
+
+	return CMD_RET_SUCCESS;
+}
+
+static cmd_tbl_t cmd_bmp_sub[] = {
+	U_BOOT_CMD_MKENT(init, 5, 0, do_bee_init, "", ""),
+	U_BOOT_CMD_MKENT(test, 2, 0, do_bee_test, "", ""),
+};
+
+static int do_bee_ops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	cmd_tbl_t *c;
+
+	c = find_cmd_tbl(argv[1], &cmd_bmp_sub[0], ARRAY_SIZE(cmd_bmp_sub));
+
+	/* Drop off the 'bee' command argument */
+	argc--;
+	argv++;
+
+	if (c)
+		return  c->cmd(cmdtp, flag, argc, argv);
+	else
+		return CMD_RET_USAGE;
+}
+
+U_BOOT_CMD(
+	bee, CONFIG_SYS_MAXARGS, 1, do_bee_ops,
+	"BEE function test",
+	"init [key] [mode] [start] [size]	- BEE block initial\n"
+	"  key: 0 | 1, 0 means software key, 1 means SNVS random key\n"
+	"  mode: 0 | 1, 0 means ECB mode, 1 means CTR mode\n"
+	"  start: start address that you want to protect\n"
+	"  size: The size of the area that you want to protect\n"
+	"  start and end(start + size) addr both should be 64KB aligned.\n"
+	"\n"
+	" After initialization, the mapping:\n"
+	" 1. [0x10000000 - (0x10000000 + size - 1)] <--->\n"
+	"    [start - (start + size - 1)]\n"
+	"    Here [start - (start + size -1)] is fixed mapping to\n"
+	"    [0x10000000 - (0x10000000 + size - 1)], whatever start is.\n"
+	" 2. [0x30000000 - (0x30000000 + IRAM_SIZE - 1)] <--->\n"
+	"    [IRAM_BASE_ADDR - (IRAM_BASE_ADDR + IRAM_SIZE - 1)]\n"
+	"\n"
+	" Note: Here we only use AES region 0 to protect the DRAM\n"
+	"       area that you specified, max size SZ_512M.\n"
+	"       AES region 1 is used to protect IRAM area.\n"
+	" Example:\n"
+	" 1. bee init 1 1 0xa0000000 0x10000\n"
+	"    Access 0x10000000 - 0x10010000 to protect 0xa0000000 - 0xa0010000\n"
+	" 2. bee init 1 1 0x80000000 0x20000\n"
+	"    Access 0x10000000 - 0x10020000 to protect 0x80000000 - 0x80020000\n"
+	"\n"
+	" Default configuration if only `bee init` without any args:\n"
+	" 1. software key\n"
+	" 2. ECB mode\n"
+	" 3. Address protected:\n"
+	"   Remapped Region0: PHYS_SDRAM - PHYS_SDRAM + SZ_512M\n"
+	"   Remapped Region1: IRAM_BASE_ADDR - IRAM_BASE_ADDR + IRAM_SIZE\n"
+	" 4. Default Mapping for 6UL:\n"
+	"   [0x10000000 - 0x2FFFFFFF] <-> [0x80000000 - 0x9FFFFFFF]\n"
+	"   [0x30000000 - 0x3001FFFF] <-> [0x00900000 - 0x0091FFFF]\n"
+	"\n"
+	"bee test [region]			- BEE function test\n"
+	"  region: 0 | 1, 0 means region0, 1 means regions1\n"
+);
+
diff -urN u-boot-2016.03/arch/arm/cpu/armv7/mx6/clock.c ebf_6ull_uboot/arch/arm/cpu/armv7/mx6/clock.c
--- u-boot-2016.03/arch/arm/cpu/armv7/mx6/clock.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/cpu/armv7/mx6/clock.c	2021-04-16 14:42:14.664580642 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -59,6 +59,19 @@
 			cfg);
 
 	setbits_le32(&imx_ccm->CCGR4, MXC_CCM_CCGR4_QSPI2_ENFC_MASK);
+#elif defined(CONFIG_MX6UL)
+	/*
+	 * config gpmi and bch clock to 100 MHz
+	 * bch/gpmi select PLL2 PFD2 400M
+	 * 100M = 400M / 4
+	 */
+	clrbits_le32(&imx_ccm->cscmr1,
+		     MXC_CCM_CSCMR1_BCH_CLK_SEL |
+		     MXC_CCM_CSCMR1_GPMI_CLK_SEL);
+	clrsetbits_le32(&imx_ccm->cscdr1,
+			MXC_CCM_CSCDR1_BCH_PODF_MASK |
+			MXC_CCM_CSCDR1_GPMI_PODF_MASK,
+			cfg);
 #else
 	clrbits_le32(&imx_ccm->CCGR2, MXC_CCM_CCGR2_IOMUX_IPT_CLK_IO_MASK);
 
@@ -97,7 +110,10 @@
 {
 	u32 mask, *addr;
 
-	if (is_cpu_type(MXC_CPU_MX6UL)) {
+	if (is_cpu_type(MXC_CPU_MX6ULL)) {
+		mask = MXC_CCM_CCGR0_ENET_CLK_ENABLE_MASK;
+		addr = &imx_ccm->CCGR0;
+	} else if (is_cpu_type(MXC_CPU_MX6UL)) {
 		mask = MXC_CCM_CCGR3_ENET_MASK;
 		addr = &imx_ccm->CCGR3;
 	} else {
@@ -117,7 +133,7 @@
 {
 	u32 mask;
 
-	if (is_cpu_type(MXC_CPU_MX6UL))
+	if (is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL))
 		mask = MXC_CCM_CCGR5_UART_MASK;
 	else
 		mask = MXC_CCM_CCGR5_UART_MASK | MXC_CCM_CCGR5_UART_SERIAL_MASK;
@@ -168,7 +184,10 @@
 			reg &= ~mask;
 		__raw_writel(reg, &imx_ccm->CCGR2);
 	} else {
-		if (is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL)) {
+		if (is_cpu_type(MXC_CPU_MX6SLL))
+			return -EINVAL;
+		if (is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL) ||
+		    is_cpu_type(MXC_CPU_MX6ULL)) {
 			mask = MXC_CCM_CCGR6_I2C4_MASK;
 			addr = &imx_ccm->CCGR6;
 		} else {
@@ -279,7 +298,8 @@
 
 	switch (pll) {
 	case PLL_BUS:
-		if (!is_cpu_type(MXC_CPU_MX6UL)) {
+		if (!is_cpu_type(MXC_CPU_MX6UL) &&
+		    !is_cpu_type(MXC_CPU_MX6ULL)) {
 			if (pfd_num == 3) {
 				/* No PFD3 on PPL2 */
 				return 0;
@@ -379,8 +399,9 @@
 	u32 reg, perclk_podf;
 
 	reg = __raw_readl(&imx_ccm->cscmr1);
-	if (is_cpu_type(MXC_CPU_MX6SL) || is_cpu_type(MXC_CPU_MX6SX) ||
-	    is_mx6dqp() || is_cpu_type(MXC_CPU_MX6UL)) {
+	if (is_cpu_type(MXC_CPU_MX6SLL) || is_cpu_type(MXC_CPU_MX6SL) ||
+	    is_cpu_type(MXC_CPU_MX6SX) || is_mx6dqp() ||
+	    is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL)) {
 		if (reg & MXC_CCM_CSCMR1_PER_CLK_SEL_MASK)
 			return MXC_HCLK; /* OSC 24Mhz */
 	}
@@ -396,8 +417,9 @@
 	u32 freq = decode_pll(PLL_USBOTG, MXC_HCLK) / 6; /* static divider */
 	reg = __raw_readl(&imx_ccm->cscdr1);
 
-	if (is_cpu_type(MXC_CPU_MX6SL) || is_cpu_type(MXC_CPU_MX6SX) ||
-	    is_mx6dqp() || is_cpu_type(MXC_CPU_MX6UL)) {
+	if (is_cpu_type(MXC_CPU_MX6SLL) || is_cpu_type(MXC_CPU_MX6SL) ||
+	    is_cpu_type(MXC_CPU_MX6SX) || is_mx6dqp() ||
+	    is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL)) {
 		if (reg & MXC_CCM_CSCDR1_UART_CLK_SEL)
 			freq = MXC_HCLK;
 	}
@@ -416,8 +438,9 @@
 	cspi_podf = (reg & MXC_CCM_CSCDR2_ECSPI_CLK_PODF_MASK) >>
 		     MXC_CCM_CSCDR2_ECSPI_CLK_PODF_OFFSET;
 
-	if (is_mx6dqp() || is_cpu_type(MXC_CPU_MX6SL) ||
-	    is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL)) {
+	if (is_mx6dqp() || is_cpu_type(MXC_CPU_MX6SL) || is_cpu_type(MXC_CPU_MX6SLL) ||
+	    is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL) ||
+	    is_cpu_type(MXC_CPU_MX6ULL)) {
 		if (reg & MXC_CCM_CSCDR2_ECSPI_CLK_SEL_MASK)
 			return MXC_HCLK / (cspi_podf + 1);
 	}
@@ -435,9 +458,9 @@
 
 	if (cbcdr & MXC_CCM_CBCDR_AXI_SEL) {
 		if (cbcdr & MXC_CCM_CBCDR_AXI_ALT_SEL)
-			root_freq = mxc_get_pll_pfd(PLL_BUS, 2);
-		else
 			root_freq = mxc_get_pll_pfd(PLL_USBOTG, 1);
+		else
+			root_freq = mxc_get_pll_pfd(PLL_BUS, 2);
 	} else
 		root_freq = get_periph_clk();
 
@@ -480,7 +503,8 @@
 	u32 freq, podf, per2_clk2_podf, pmu_misc2_audio_div;
 
 	if (is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL) ||
-	    is_cpu_type(MXC_CPU_MX6SL)) {
+	    is_cpu_type(MXC_CPU_MX6SL) || is_cpu_type(MXC_CPU_MX6ULL) ||
+	    is_cpu_type(MXC_CPU_MX6SLL)) {
 		podf = (cbcdr & MXC_CCM_CBCDR_MMDC_CH1_PODF_MASK) >>
 			MXC_CCM_CBCDR_MMDC_CH1_PODF_OFFSET;
 		if (cbcdr & MXC_CCM_CBCDR_PERIPH2_CLK_SEL) {
@@ -512,6 +536,11 @@
 				freq = mxc_get_pll_pfd(PLL_BUS, 0);
 				break;
 			case 3:
+				if (is_cpu_type(MXC_CPU_MX6SL)) {
+					freq = mxc_get_pll_pfd(PLL_BUS, 2) >> 1;
+					break;
+				}
+
 				pmu_misc2_audio_div = PMU_MISC2_AUDIO_DIV(__raw_readl(&imx_ccm->pmu_misc2));
 				switch (pmu_misc2_audio_div) {
 				case 0:
@@ -539,6 +568,57 @@
 }
 
 #if defined(CONFIG_VIDEO_MXS)
+
+static int disable_lcdif_clock(u32 base_addr)
+{
+	u32 reg = 0;
+	u32 lcdif_ccgr3_mask;
+
+	if (is_cpu_type(MXC_CPU_MX6SX)) {
+		if ((base_addr != LCDIF1_BASE_ADDR) &&
+		    (base_addr != LCDIF2_BASE_ADDR)) {
+			puts("Wrong LCD interface!\n");
+			return -EINVAL;
+		}
+		lcdif_ccgr3_mask = (base_addr == LCDIF2_BASE_ADDR) ?
+			(MXC_CCM_CCGR3_LCDIF2_PIX_MASK |
+			 MXC_CCM_CCGR3_DISP_AXI_MASK) :
+			(MXC_CCM_CCGR3_LCDIF1_PIX_MASK |
+			 MXC_CCM_CCGR3_DISP_AXI_MASK);
+	} else if (is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL)
+			|| is_cpu_type(MXC_CPU_MX6SLL)) {
+		if (base_addr != LCDIF1_BASE_ADDR) {
+			puts("Wrong LCD interface!\n");
+			return -EINVAL;
+		}
+		lcdif_ccgr3_mask =  MXC_CCM_CCGR3_LCDIF1_PIX_MASK;
+	} else if (is_cpu_type(MXC_CPU_MX6SL)) {
+		if (base_addr != LCDIF1_BASE_ADDR) {
+			puts("Wrong LCD interface!\n");
+			return -EINVAL;
+		}
+
+		reg = readl(&imx_ccm->CCGR3);
+		reg &= ~(MXC_CCM_CCGR3_LCDIF_AXI_MASK | MXC_CCM_CCGR3_LCDIF_PIX_MASK);
+		writel(reg, &imx_ccm->CCGR3);
+		return 0;
+
+	} else {
+		return -EINVAL;
+	}
+
+	/* Gate LCDIF clock first */
+	reg = readl(&imx_ccm->CCGR3);
+	reg &= ~lcdif_ccgr3_mask;
+	writel(reg, &imx_ccm->CCGR3);
+
+	reg = readl(&imx_ccm->CCGR2);
+	reg &= ~MXC_CCM_CCGR2_LCD_MASK;
+	writel(reg, &imx_ccm->CCGR2);
+
+	return 0;
+}
+
 static int enable_pll_video(u32 pll_div, u32 pll_num, u32 pll_denom,
 			    u32 post_div)
 {
@@ -618,23 +698,25 @@
 
 	debug("mxs_set_lcdclk, freq = %dKHz\n", freq);
 
-	if ((!is_cpu_type(MXC_CPU_MX6SX)) && !is_cpu_type(MXC_CPU_MX6UL)) {
+	if ((!is_cpu_type(MXC_CPU_MX6SX)) && !is_cpu_type(MXC_CPU_MX6UL) &&
+	    !is_cpu_type(MXC_CPU_MX6ULL) && !is_cpu_type(MXC_CPU_MX6SL) &&
+	    !is_cpu_type(MXC_CPU_MX6SLL)) {
 		debug("This chip not support lcd!\n");
 		return;
 	}
 
-	if (base_addr == LCDIF1_BASE_ADDR) {
-		reg = readl(&imx_ccm->cscdr2);
-		/* Can't change clocks when clock not from pre-mux */
-		if ((reg & MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_MASK) != 0)
-			return;
-	}
-
-	if (is_cpu_type(MXC_CPU_MX6SX)) {
-		reg = readl(&imx_ccm->cscdr2);
-		/* Can't change clocks when clock not from pre-mux */
-		if ((reg & MXC_CCM_CSCDR2_LCDIF2_CLK_SEL_MASK) != 0)
-			return;
+	if (!is_cpu_type(MXC_CPU_MX6SL)) {
+		if (base_addr == LCDIF1_BASE_ADDR) {
+			reg = readl(&imx_ccm->cscdr2);
+			/* Can't change clocks when clock not from pre-mux */
+			if ((reg & MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_MASK) != 0)
+				return;
+		} else if (is_cpu_type(MXC_CPU_MX6SX)) {
+			reg = readl(&imx_ccm->cscdr2);
+			/* Can't change clocks when clock not from pre-mux */
+			if ((reg & MXC_CCM_CSCDR2_LCDIF2_CLK_SEL_MASK) != 0)
+				return;
+		}
 	}
 
 	temp = freq * max_pred * max_postd;
@@ -698,24 +780,47 @@
 		if (enable_pll_video(pll_div, pll_num, pll_denom, post_div))
 			return;
 
-		/* Select pre-lcd clock to PLL5 and set pre divider */
-		clrsetbits_le32(&imx_ccm->cscdr2,
-				MXC_CCM_CSCDR2_LCDIF1_PRED_SEL_MASK |
-				MXC_CCM_CSCDR2_LCDIF1_PRE_DIV_MASK,
-				(0x2 << MXC_CCM_CSCDR2_LCDIF1_PRED_SEL_OFFSET) |
-				((pred - 1) <<
-				 MXC_CCM_CSCDR2_LCDIF1_PRE_DIV_OFFSET));
+		disable_lcdif_clock(base_addr);
+
+		if (!is_cpu_type(MXC_CPU_MX6SL)) {
+
+			/* Select pre-lcd clock to PLL5 and set pre divider */
+			clrsetbits_le32(&imx_ccm->cscdr2,
+					MXC_CCM_CSCDR2_LCDIF1_PRED_SEL_MASK |
+					MXC_CCM_CSCDR2_LCDIF1_PRE_DIV_MASK,
+					(0x2 << MXC_CCM_CSCDR2_LCDIF1_PRED_SEL_OFFSET) |
+					((pred - 1) <<
+					 MXC_CCM_CSCDR2_LCDIF1_PRE_DIV_OFFSET));
+
+			/* Set the post divider */
+			clrsetbits_le32(&imx_ccm->cbcmr,
+					MXC_CCM_CBCMR_LCDIF1_PODF_MASK,
+					((postd - 1) <<
+					 MXC_CCM_CBCMR_LCDIF1_PODF_OFFSET));
+		} else {
+			/* Select pre-lcd clock to PLL5 and set pre divider */
+			clrsetbits_le32(&imx_ccm->cscdr2,
+					MXC_CCM_CSCDR2_LCDIF_PIX_CLK_SEL_MASK |
+					MXC_CCM_CSCDR2_LCDIF_PIX_PRE_DIV_MASK,
+					(0x2 << MXC_CCM_CSCDR2_LCDIF_PIX_CLK_SEL_OFFSET) |
+					((pred - 1) <<
+					 MXC_CCM_CSCDR2_LCDIF_PIX_PRE_DIV_OFFSET));
+
+			/* Set the post divider */
+			clrsetbits_le32(&imx_ccm->cscmr1,
+					MXC_CCM_CSCMR1_LCDIF_PIX_PODF_MASK,
+					(((postd - 1)^0x6) <<
+					 MXC_CCM_CSCMR1_LCDIF_PIX_PODF_OFFSET));
+		}
+		enable_lcdif_clock(base_addr);
 
-		/* Set the post divider */
-		clrsetbits_le32(&imx_ccm->cbcmr,
-				MXC_CCM_CBCMR_LCDIF1_PODF_MASK,
-				((postd - 1) <<
-				 MXC_CCM_CBCMR_LCDIF1_PODF_OFFSET));
 	} else if (is_cpu_type(MXC_CPU_MX6SX)) {
 		/* Setting LCDIF2 for i.MX6SX */
 		if (enable_pll_video(pll_div, pll_num, pll_denom, post_div))
 			return;
 
+		disable_lcdif_clock(base_addr);
+
 		/* Select pre-lcd clock to PLL5 and set pre divider */
 		clrsetbits_le32(&imx_ccm->cscdr2,
 				MXC_CCM_CSCDR2_LCDIF2_PRED_SEL_MASK |
@@ -729,6 +834,8 @@
 				MXC_CCM_CSCMR1_LCDIF2_PODF_MASK,
 				((postd - 1) <<
 				 MXC_CCM_CSCMR1_LCDIF2_PODF_OFFSET));
+
+		enable_lcdif_clock(base_addr);
 	}
 }
 
@@ -752,7 +859,8 @@
 			 MXC_CCM_CCGR3_DISP_AXI_MASK) :
 			(MXC_CCM_CCGR3_LCDIF1_PIX_MASK |
 			 MXC_CCM_CCGR3_DISP_AXI_MASK);
-	} else if (is_cpu_type(MXC_CPU_MX6UL)) {
+	} else if (is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL)
+		|| is_cpu_type(MXC_CPU_MX6SLL)) {
 		if (base_addr != LCDIF1_BASE_ADDR) {
 			puts("Wrong LCD interface!\n");
 			return -EINVAL;
@@ -760,10 +868,40 @@
 		/* Set to pre-mux clock at default */
 		lcdif_clk_sel_mask = MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_MASK;
 		lcdif_ccgr3_mask =  MXC_CCM_CCGR3_LCDIF1_PIX_MASK;
-	} else {
+	} else if (is_cpu_type(MXC_CPU_MX6SL)) {
+		if (base_addr != LCDIF1_BASE_ADDR) {
+			puts("Wrong LCD interface!\n");
+			return -EINVAL;
+		}
+
+		reg = readl(&imx_ccm->CCGR3);
+		reg &= ~(MXC_CCM_CCGR3_LCDIF_AXI_MASK | MXC_CCM_CCGR3_LCDIF_PIX_MASK);
+		writel(reg, &imx_ccm->CCGR3);
+
+		reg = readl(&imx_ccm->cscdr3);
+		reg &= ~MXC_CCM_CSCDR3_LCDIF_AXI_CLK_SEL_MASK;
+		reg |= 1 << MXC_CCM_CSCDR3_LCDIF_AXI_CLK_SEL_OFFSET;
+		writel(reg, &imx_ccm->cscdr3);
+
+		reg = readl(&imx_ccm->CCGR3);
+		reg |= MXC_CCM_CCGR3_LCDIF_AXI_MASK | MXC_CCM_CCGR3_LCDIF_PIX_MASK;
+		writel(reg, &imx_ccm->CCGR3);
 		return 0;
+
+	} else {
+		return -EINVAL;
 	}
 
+	/* Gate LCDIF clock first */
+	reg = readl(&imx_ccm->CCGR3);
+	reg &= ~lcdif_ccgr3_mask;
+	writel(reg, &imx_ccm->CCGR3);
+
+	reg = readl(&imx_ccm->CCGR2);
+	reg &= ~MXC_CCM_CCGR2_LCD_MASK;
+	writel(reg, &imx_ccm->CCGR2);
+
+	/* Select pre-mux */
 	reg = readl(&imx_ccm->cscdr2);
 	reg &= ~lcdif_clk_sel_mask;
 	writel(reg, &imx_ccm->cscdr2);
@@ -779,6 +917,65 @@
 
 	return 0;
 }
+
+int enable_lvds_bridge(u32 lcd_base_addr)
+{
+	u32 reg = 0;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	if (is_cpu_type(MXC_CPU_MX6SX)) {
+		if ((lcd_base_addr != LCDIF1_BASE_ADDR) &&
+		    (lcd_base_addr != LCDIF2_BASE_ADDR)) {
+			puts("Wrong LCD interface!\n");
+			return -EINVAL;
+		}
+	} else {
+		debug("This chip not support lvds bridge!\n");
+		return 0;
+	}
+
+	/* Turn on LDB DI0 clocks */
+	reg = readl(&imx_ccm->CCGR3);
+	reg |=  MXC_CCM_CCGR3_LDB_DI0_MASK;
+	writel(reg, &imx_ccm->CCGR3);
+
+	/* set LDB DI0 clk select to 011 PLL2 PFD3 200M*/
+	reg = readl(&imx_ccm->cs2cdr);
+	reg &= ~MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK;
+	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET);
+	writel(reg, &imx_ccm->cs2cdr);
+
+	reg = readl(&imx_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV;
+	writel(reg, &imx_ccm->cscmr2);
+
+	/* set LDB DI0 clock for LCDIF PIX clock */
+	reg = readl(&imx_ccm->cscdr2);
+	if (lcd_base_addr == LCDIF1_BASE_ADDR) {
+		reg &= ~MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_MASK;
+		reg |= (0x3 << MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_OFFSET);
+	} else {
+		reg &= ~MXC_CCM_CSCDR2_LCDIF2_CLK_SEL_MASK;
+		reg |= (0x3 << MXC_CCM_CSCDR2_LCDIF2_CLK_SEL_OFFSET);
+	}
+	writel(reg, &imx_ccm->cscdr2);
+
+	reg = IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+		| IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+		| IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
+		| IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0;
+	writel(reg, &iomux->gpr[6]);
+
+	reg = readl(&iomux->gpr[5]);
+	if (lcd_base_addr == LCDIF1_BASE_ADDR)
+		reg &= ~0x8;  /* MUX LVDS to LCDIF1 */
+	else
+		reg |= 0x8; /* MUX LVDS to LCDIF2 */
+	writel(reg, &iomux->gpr[5]);
+
+	return 0;
+}
+
 #endif
 
 #ifdef CONFIG_FSL_QSPI
@@ -831,6 +1028,18 @@
 }
 #endif
 
+#if defined(CONFIG_VIDEO_GIS)
+void mxs_set_vadcclk()
+{
+	u32 reg = 0;
+
+	reg = readl(&imx_ccm->cscmr2);
+	reg &= ~MXC_CCM_CSCMR2_VID_CLK_SEL_MASK;
+	reg |= 0x19 << MXC_CCM_CSCMR2_VID_CLK_SEL_OFFSET;
+	writel(reg, &imx_ccm->cscmr2);
+}
+#endif
+
 #ifdef CONFIG_FEC_MXC
 int enable_fec_anatop_clock(int fec_id, enum enet_freq freq)
 {
@@ -851,7 +1060,8 @@
 	} else if (fec_id == 1) {
 		/* Only i.MX6SX/UL support ENET2 */
 		if (!(is_cpu_type(MXC_CPU_MX6SX) ||
-		      is_cpu_type(MXC_CPU_MX6UL)))
+		      is_cpu_type(MXC_CPU_MX6UL) ||
+		      is_cpu_type(MXC_CPU_MX6ULL)))
 			return -EINVAL;
 		reg &= ~BM_ANADIG_PLL_ENET2_DIV_SELECT;
 		reg |= BF_ANADIG_PLL_ENET2_DIV_SELECT(freq);
@@ -880,6 +1090,11 @@
 	writel(reg, &anatop->pll_enet);
 
 #ifdef CONFIG_MX6SX
+	/* Disable enet system clcok before switching clock parent */
+	reg = readl(&imx_ccm->CCGR3);
+	reg &= ~MXC_CCM_CCGR3_ENET_MASK;
+	writel(reg, &imx_ccm->CCGR3);
+
 	/*
 	 * Set enet ahb clock to 200MHz
 	 * pll2_pfd2_396m-> ENET_PODF-> ENET_AHB
@@ -910,6 +1125,12 @@
 	u32 cscmr1 = __raw_readl(&imx_ccm->cscmr1);
 	u32 cscdr1 = __raw_readl(&imx_ccm->cscdr1);
 
+	if (is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL))
+		if (port > 1)
+			return 0;
+	if (is_cpu_type(MXC_CPU_MX6SLL))
+		if (port > 2)
+			return 0;
 	switch (port) {
 	case 0:
 		usdhc_podf = (cscdr1 & MXC_CCM_CSCDR1_USDHC1_PODF_MASK) >>
@@ -1010,6 +1231,15 @@
 #endif
 
 #ifdef CONFIG_PCIE_IMX
+static void ungate_disp_axi_clock(void)
+{
+	struct mxc_ccm_reg *const imx_ccm =
+		(struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* Enable display axi clock. */
+	setbits_le32(&imx_ccm->CCGR3, MXC_CCM_CCGR3_DISP_AXI_MASK);
+}
+
 static void ungate_pcie_clock(void)
 {
 	struct mxc_ccm_reg *const imx_ccm =
@@ -1057,14 +1287,22 @@
 	/* PCIe reference clock sourced from AXI. */
 	clrbits_le32(&ccm_regs->cbcmr, MXC_CCM_CBCMR_PCIE_AXI_CLK_SEL);
 
-	/* Party time! Ungate the clock to the PCIe. */
+	if (!is_cpu_type(MXC_CPU_MX6SX)) {
+		/* Party time! Ungate the clock to the PCIe. */
 #ifdef CONFIG_CMD_SATA
-	ungate_sata_clock();
+		ungate_sata_clock();
 #endif
-	ungate_pcie_clock();
+		ungate_pcie_clock();
+
+		return enable_enet_pll(BM_ANADIG_PLL_ENET_ENABLE_SATA |
+				       BM_ANADIG_PLL_ENET_ENABLE_PCIE);
+	} else {
+		/* Party time! Ungate the clock to the PCIe. */
+		ungate_disp_axi_clock();
+		ungate_pcie_clock();
 
-	return enable_enet_pll(BM_ANADIG_PLL_ENET_ENABLE_SATA |
-			       BM_ANADIG_PLL_ENET_ENABLE_PCIE);
+		return enable_enet_pll(BM_ANADIG_PLL_ENET_ENABLE_PCIE);
+	}
 }
 #endif
 
@@ -1073,17 +1311,27 @@
 {
 	u32 reg;
 
-	/* CG4 ~ CG6, CAAM clocks */
-	reg = __raw_readl(&imx_ccm->CCGR0);
-	if (enable)
-		reg |= (MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_MASK |
-			MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_MASK |
-			MXC_CCM_CCGR0_CAAM_SECURE_MEM_MASK);
-	else
-		reg &= ~(MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_MASK |
-			MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_MASK |
-			MXC_CCM_CCGR0_CAAM_SECURE_MEM_MASK);
-	__raw_writel(reg, &imx_ccm->CCGR0);
+	if (is_cpu_type(MXC_CPU_MX6ULL) || is_cpu_type(MXC_CPU_MX6SLL)) {
+		/* CG5, DCP clock */
+		reg = __raw_readl(&imx_ccm->CCGR0);
+		if (enable)
+			reg |= MXC_CCM_CCGR0_DCP_CLK_MASK;
+		else
+			reg &= ~MXC_CCM_CCGR0_DCP_CLK_MASK;
+		__raw_writel(reg, &imx_ccm->CCGR0);
+	} else {
+		/* CG4 ~ CG6, CAAM clocks */
+		reg = __raw_readl(&imx_ccm->CCGR0);
+		if (enable)
+			reg |= (MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_MASK |
+				MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_MASK |
+				MXC_CCM_CCGR0_CAAM_SECURE_MEM_MASK);
+		else
+			reg &= ~(MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_MASK |
+				MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_MASK |
+				MXC_CCM_CCGR0_CAAM_SECURE_MEM_MASK);
+		__raw_writel(reg, &imx_ccm->CCGR0);
+	}
 
 	/* EMI slow clk */
 	reg = __raw_readl(&imx_ccm->CCGR6);
@@ -1201,7 +1449,30 @@
 	return 0;
 }
 
-#ifndef CONFIG_MX6SX
+static void pre_misc_setting(void)
+{
+	/* Bypass IPU1 QoS generator */
+	writel(0x00000002, 0x00bb048c);
+	/* Bypass IPU2 QoS generator */
+	writel(0x00000002, 0x00bb050c);
+	/* Bandwidth THR for of PRE0 */
+	writel(0x00000200, 0x00bb0690);
+	/* Bandwidth THR for of PRE1 */
+	writel(0x00000200, 0x00bb0710);
+	/* Bandwidth THR for of PRE2 */
+	writel(0x00000200, 0x00bb0790);
+	/* Bandwidth THR for of PRE3 */
+	writel(0x00000200, 0x00bb0810);
+	/* Saturation THR for of PRE0 */
+	writel(0x00000010, 0x00bb0694);
+	/* Saturation THR for of PRE1 */
+	writel(0x00000010, 0x00bb0714);
+	/* Saturation THR for of PRE2 */
+	writel(0x00000010, 0x00bb0794);
+	/* Saturation THR for of PRE */
+	writel(0x00000010, 0x00bb0814);
+}
+
 void enable_ipu_clock(void)
 {
 	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
@@ -1213,9 +1484,47 @@
 	if (is_mx6dqp()) {
 		setbits_le32(&mxc_ccm->CCGR6, MXC_CCM_CCGR6_PRG_CLK0_MASK);
 		setbits_le32(&mxc_ccm->CCGR3, MXC_CCM_CCGR3_IPU2_IPU_MASK);
+
+		/*
+		 * Since CONFIG_VIDEO_IPUV3 is always set in mx6sabre_common.h and
+		 * this misc setting is a must for mx6qp, this position is ok
+		 * to do such settings.
+		 */
+		pre_misc_setting();
 	}
 }
+
+#if defined(CONFIG_MXC_EPDC)
+#if defined(CONFIG_MX6ULL) || defined(CONFIG_MX6SLL)
+void enable_epdc_clock(void)
+{
+	u32 reg = 0;
+
+	/* disable the clock gate first */
+	clrbits_le32(&imx_ccm->CCGR3, MXC_CCM_CCGR3_EPDC_CLK_ENABLE_MASK);
+
+	/* PLL3_PFD2 */
+	reg = readl(&imx_ccm->chsccdr);
+	reg &= ~MXC_CCM_CHSCCDR_EPDC_PRE_CLK_SEL_MASK;
+	reg |= 5 << MXC_CCM_CHSCCDR_EPDC_PRE_CLK_SEL_OFFSET;
+	writel(reg, &imx_ccm->chsccdr);
+
+	reg = readl(&imx_ccm->chsccdr);
+	reg &= ~MXC_CCM_CHSCCDR_EPDC_PODF_MASK;
+	reg |= 7 << MXC_CCM_CHSCCDR_EPDC_PODF_OFFSET;
+	writel(reg, &imx_ccm->chsccdr);
+
+	reg = readl(&imx_ccm->chsccdr);
+	reg &= ~MXC_CCM_CHSCCDR_EPDC_CLK_SEL_MASK;
+	reg |= 0 <<MXC_CCM_CHSCCDR_EPDC_CLK_SEL_OFFSET;
+	writel(reg, &imx_ccm->chsccdr);
+
+	/* enable the clock gate */
+	setbits_le32(&imx_ccm->CCGR3, MXC_CCM_CCGR3_EPDC_CLK_ENABLE_MASK);
+}
 #endif
+#endif
+
 /***************************************************/
 
 U_BOOT_CMD(
diff -urN u-boot-2016.03/arch/arm/cpu/armv7/mx6/ddr.c ebf_6ull_uboot/arch/arm/cpu/armv7/mx6/ddr.c
--- u-boot-2016.03/arch/arm/cpu/armv7/mx6/ddr.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/cpu/armv7/mx6/ddr.c	2021-04-16 14:42:14.664580642 +0800
@@ -1222,7 +1222,8 @@
 		mmdc1 = (struct mmdc_p_regs *)MMDC_P1_BASE_ADDR;
 
 	/* Limit mem_speed for MX6D/MX6Q */
-	if (is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D)) {
+	if (is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D) ||
+		is_cpu_type(MXC_CPU_MX6QP) || is_cpu_type(MXC_CPU_MX6DP)) {
 		if (mem_speed > 1066)
 			mem_speed = 1066; /* 1066 MT/s */
 
@@ -1241,7 +1242,8 @@
 	 * Data rate of 1066 MT/s requires 533 MHz DDR3 clock, but MX6D/Q supports
 	 * up to 528 MHz, so reduce the clock to fit chip specs
 	 */
-	if (is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D)) {
+	if (is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D) ||
+		is_cpu_type(MXC_CPU_MX6QP) || is_cpu_type(MXC_CPU_MX6DP)) {
 		if (clock > 528)
 			clock = 528; /* 528 MHz */
 	}
diff -urN u-boot-2016.03/arch/arm/cpu/armv7/mx6/Kconfig ebf_6ull_uboot/arch/arm/cpu/armv7/mx6/Kconfig
--- u-boot-2016.03/arch/arm/cpu/armv7/mx6/Kconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/cpu/armv7/mx6/Kconfig	2021-04-16 14:42:14.664580642 +0800
@@ -26,11 +26,19 @@
 	select ROM_UNIFIED_SECTIONS
 	bool
 
+config MX6SLL
+	select ROM_UNIFIED_SECTIONS
+	bool
+
 config MX6UL
 	select SYS_L2CACHE_OFF
 	select ROM_UNIFIED_SECTIONS
 	bool
 
+config MX6ULL
+	bool
+	select MX6UL
+
 choice
 	prompt "MX6 board select"
 	optional
@@ -74,6 +82,8 @@
 
 config TARGET_MX6QARM2
 	bool "mx6qarm2"
+	select DM
+	select DM_THERMAL
 
 config TARGET_MX6QSABREAUTO
 	bool "mx6qsabreauto"
@@ -89,15 +99,31 @@
 config TARGET_MX6SLEVK
 	bool "mx6slevk"
 	select SUPPORT_SPL
+	select DM
+	select DM_THERMAL
+
+config TARGET_MX6SLLEVK
+        bool "mx6sll evk"
+        select MX6SLL
+        select DM
+        select DM_THERMAL
+
+config TARGET_MX6SLL_ARM2
+	bool "mx6sll arm2"
+	select MX6SLL
+	select DM
+	select DM_THERMAL
 
 config TARGET_MX6SXSABRESD
 	bool "mx6sxsabresd"
+	select MX6SX
 	select SUPPORT_SPL
 	select DM
 	select DM_THERMAL
 
 config TARGET_MX6SXSABREAUTO
         bool "mx6sxsabreauto"
+	select MX6SX
         select DM
         select DM_THERMAL
 
@@ -115,6 +141,36 @@
 	select DM_THERMAL
 	select SUPPORT_SPL
 
+config TARGET_MX6UL_14X14_DDR3_ARM2
+	bool "mx6ul_14x14_ddr3_arm2"
+	select MX6UL
+	select DM
+	select DM_THERMAL
+
+config TARGET_MX6UL_14X14_LPDDR2_ARM2
+	bool "mx6ul_14x14_lpddr2_arm2"
+	select MX6UL
+	select DM
+	select DM_THERMAL
+
+config TARGET_MX6SX_17X17_ARM2
+	bool "mx6sx_17x17_arm2"
+	select MX6SX
+	select DM
+	select DM_THERMAL
+
+config TARGET_MX6SX_19X19_ARM2
+	bool "mx6sx_19x19_arm2"
+	select MX6SX
+	select DM
+	select DM_THERMAL
+
+config TARGET_PICOSOM_IMX6UL
+        bool "Support picosom-imx6ul"
+	select MX6UL
+	select DM
+	select DM_THERMAL
+
 config TARGET_NITROGEN6X
 	bool "nitrogen6x"
 
@@ -130,6 +186,24 @@
 	bool "platinum-titanium"
 	select SUPPORT_SPL
 
+config TARGET_MX6ULL_DDR3_ARM2
+	bool "Support mx6ull_ddr3_arm2"
+	select MX6ULL
+	select DM
+	select DM_THERMAL
+
+config TARGET_MX6ULL_14X14_EVK
+	bool "Support mx6ull_14x14_evk"
+	select MX6ULL
+	select DM
+	select DM_THERMAL
+
+config TARGET_MX6ULL_9X9_EVK
+	bool "Support mx6ull_9x9_evk"
+	select MX6ULL
+	select DM
+	select DM_THERMAL
+
 config TARGET_SECOMX6
 	bool "secomx6 boards"
 
@@ -153,6 +227,17 @@
 config TARGET_WARP
 	bool "WaRP"
 
+config TARGET_MX6DQSCM
+	bool "mx6dqscm"
+	select DM
+	select DM_THERMAL
+
+config TARGET_MX6SXSCM
+        bool "mx6sxscm"
+        select MX6SX
+        select DM
+        select DM_THERMAL
+
 endchoice
 
 config SYS_SOC
@@ -170,17 +255,28 @@
 source "board/freescale/mx6qsabreauto/Kconfig"
 source "board/freescale/mx6sabresd/Kconfig"
 source "board/freescale/mx6slevk/Kconfig"
+source "board/freescale/mx6sllevk/Kconfig"
+source "board/freescale/mx6sll_arm2/Kconfig"
 source "board/freescale/mx6sxsabresd/Kconfig"
 source "board/freescale/mx6sxsabreauto/Kconfig"
 source "board/freescale/mx6ul_14x14_evk/Kconfig"
+source "board/freescale/mx6sx_17x17_arm2/Kconfig"
+source "board/freescale/mx6sx_19x19_arm2/Kconfig"
+source "board/freescale/mx6ul_14x14_ddr3_arm2/Kconfig"
+source "board/freescale/mx6ul_14x14_lpddr2_arm2/Kconfig"
+source "board/freescale/mx6ull_ddr3_arm2/Kconfig"
+source "board/freescale/mx6ullevk/Kconfig"
 source "board/gateworks/gw_ventana/Kconfig"
 source "board/kosagi/novena/Kconfig"
 source "board/seco/Kconfig"
 source "board/solidrun/mx6cuboxi/Kconfig"
 source "board/tbs/tbs2910/Kconfig"
+source "board/technexion/picosom-imx6ul/Kconfig"
 source "board/tqc/tqma6/Kconfig"
 source "board/udoo/Kconfig"
 source "board/wandboard/Kconfig"
 source "board/warp/Kconfig"
+source "board/freescale/mx6dqscm/Kconfig"
+source "board/freescale/mx6sxscm/Kconfig"
 
 endif
diff -urN u-boot-2016.03/arch/arm/cpu/armv7/mx6/Makefile ebf_6ull_uboot/arch/arm/cpu/armv7/mx6/Makefile
--- u-boot-2016.03/arch/arm/cpu/armv7/mx6/Makefile	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/cpu/armv7/mx6/Makefile	2021-04-16 14:42:14.664580642 +0800
@@ -2,7 +2,7 @@
 # (C) Copyright 2000-2006
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
-# (C) Copyright 2011 Freescale Semiconductor, Inc.
+# (C) Copyright 2011-2016 Freescale Semiconductor, Inc.
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
@@ -10,3 +10,7 @@
 obj-y	:= soc.o clock.o
 obj-$(CONFIG_SPL_BUILD)	     += ddr.o
 obj-$(CONFIG_MP)             += mp.o
+ifdef CONFIG_MX6UL
+obj-$(CONFIG_CMD_BEE)        += bee.o
+endif
+obj-$(CONFIG_MODULE_FUSE)        += module_fuse.o
diff -urN u-boot-2016.03/arch/arm/cpu/armv7/mx6/module_fuse.c ebf_6ull_uboot/arch/arm/cpu/armv7/mx6/module_fuse.c
--- u-boot-2016.03/arch/arm/cpu/armv7/mx6/module_fuse.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/cpu/armv7/mx6/module_fuse.c	2021-04-16 14:42:14.664580642 +0800
@@ -0,0 +1,268 @@
+/*
+ * (C) Copyright 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fdt_support.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/module_fuse.h>
+
+struct fuse_entry_desc {
+	enum fuse_module_type module;
+	const char *node_path;
+	u32 fuse_word_offset;
+	u32 fuse_bit_offset;
+	u32 status;
+};
+
+static struct fuse_entry_desc mx6_fuse_descs[] = {
+#ifdef CONFIG_MX6UL
+	{MX6_MODULE_TSC, "/soc/aips-bus@02000000/tsc@02040000", 0x430, 22},
+	{MX6_MODULE_ADC2, "/soc/aips-bus@02100000/adc@0219c000", 0x430, 23},
+	{MX6_MODULE_SIM1, "/soc/aips-bus@02100000/sim@0218c000", 0x430, 24},
+	{MX6_MODULE_SIM2, "/soc/aips-bus@02100000/sim@021b4000", 0x430, 25},
+	{MX6_MODULE_FLEXCAN1, "/soc/aips-bus@02000000/can@02090000", 0x430, 26},
+	{MX6_MODULE_FLEXCAN2, "/soc/aips-bus@02000000/can@02094000", 0x430, 27},
+	{MX6_MODULE_SPDIF, "/soc/aips-bus@02000000/spba-bus@02000000/spdif@02004000", 0x440, 2},
+	{MX6_MODULE_EIM, "/soc/aips-bus@02100000/weim@021b8000", 0x440, 3},
+	{MX6_MODULE_SD1, "/soc/aips-bus@02100000/usdhc@02190000", 0x440, 4},
+	{MX6_MODULE_SD2, "/soc/aips-bus@02100000/usdhc@02194000", 0x440, 5},
+	{MX6_MODULE_QSPI1, "/soc/aips-bus@02100000/qspi@021e0000", 0x440, 6},
+	{MX6_MODULE_GPMI, "/soc/gpmi-nand@01806000", 0x440, 7},
+	{MX6_MODULE_APBHDMA, "/soc/dma-apbh@01804000", 0x440, 7},
+	{MX6_MODULE_LCDIF, "/soc/aips-bus@02100000/lcdif@021c8000", 0x440, 8},
+	{MX6_MODULE_PXP, "/soc/aips-bus@02100000/pxp@021cc000", 0x440, 9},
+	{MX6_MODULE_CSI, "/soc/aips-bus@02100000/csi@021c4000", 0x440, 10},
+	{MX6_MODULE_ADC1, "/soc/aips-bus@02100000/adc@02198000", 0x440, 11},
+	{MX6_MODULE_ENET1, "/soc/aips-bus@02100000/ethernet@02188000", 0x440, 12},
+	{MX6_MODULE_ENET2, "/soc/aips-bus@02000000/ethernet@020b4000", 0x440, 13},
+	{MX6_MODULE_CAAM, "/soc/aips-bus@02100000/caam@2140000", 0x440, 14},
+	{MX6_MODULE_USB_OTG2, "/soc/aips-bus@02100000/usb@02184200", 0x440, 15},
+	{MX6_MODULE_SAI2, "/soc/aips-bus@02000000/spba-bus@02000000/sai@0202c000", 0x440, 24},
+	{MX6_MODULE_SAI3, "/soc/aips-bus@02000000/spba-bus@02000000/sai@02030000", 0x440, 24},
+	{MX6_MODULE_BEE, "/soc/aips-bus@02000000/bee@02044000", 0x440, 25},
+	{MX6_MODULE_UART5, "/soc/aips-bus@02100000/serial@021f4000", 0x440, 26},
+	{MX6_MODULE_UART6, "/soc/aips-bus@02100000/serial@021fc000", 0x440, 26},
+	{MX6_MODULE_UART7, "/soc/aips-bus@02000000/spba-bus@02000000/serial@02018000", 0x440, 26},
+	{MX6_MODULE_UART8, "/soc/aips-bus@02000000/spba-bus@02000000/serial@02024000", 0x440, 26},
+	{MX6_MODULE_PWM5, "/soc/aips-bus@02000000/pwm@020f0000", 0x440, 27},
+	{MX6_MODULE_PWM6, "/soc/aips-bus@02000000/pwm@020f4000", 0x440, 27},
+	{MX6_MODULE_PWM7, "/soc/aips-bus@02000000/pwm@020f8000", 0x440, 27},
+	{MX6_MODULE_PWM8, "/soc/aips-bus@02000000/pwm@020fc000", 0x440, 27},
+	{MX6_MODULE_ECSPI3, "/soc/aips-bus@02000000/spba-bus@02000000/ecspi@02010000", 0x440, 28},
+	{MX6_MODULE_ECSPI4, "/soc/aips-bus@02000000/spba-bus@02000000/ecspi@02014000", 0x440, 28},
+	{MX6_MODULE_I2C3, "/soc/aips-bus@02100000/i2c@021a8000", 0x440, 29},
+	{MX6_MODULE_I2C4, "/soc/aips-bus@02100000/i2c@021f8000", 0x440, 29},
+	{MX6_MODULE_GPT2, "/soc/aips-bus@02000000/gpt@020e8000", 0x440, 30},
+	{MX6_MODULE_EPIT2, "/soc/aips-bus@02000000/epit@020d4000", 0x440, 31},
+#endif
+};
+
+u32 check_module_fused(enum fuse_module_type module)
+{
+	u32 i, reg;
+	for (i = 0; i < ARRAY_SIZE(mx6_fuse_descs); i++) {
+		if (mx6_fuse_descs[i].module == module) {
+			reg = readl(OCOTP_BASE_ADDR + mx6_fuse_descs[i].fuse_word_offset);
+			if (reg & (1 << mx6_fuse_descs[i].fuse_bit_offset))
+				return 1; /* disabled */
+			else
+				return 0; /* enabled */
+		}
+	}
+
+	return  0; /* Not has a fuse, always enabled */
+}
+
+#ifdef DEBUG
+void print_fuse_status()
+{
+	u32 i, reg;
+
+	for (i = 0; i < ARRAY_SIZE(mx6_fuse_descs); i++) {
+		reg = readl(OCOTP_BASE_ADDR + mx6_fuse_descs[i].fuse_word_offset);
+		if (reg & (1 << mx6_fuse_descs[i].fuse_bit_offset))
+			printf("%s, disabled\n", mx6_fuse_descs[i].node_path);
+	}
+}
+
+void simulate_fuse()
+{
+	u32 i, reg;
+
+    for (i = 0; i < ARRAY_SIZE(mx6_fuse_descs); i++) {
+		if (MX6_MODULE_SD2 == mx6_fuse_descs[i].module)
+			continue;
+
+		reg = readl(OCOTP_BASE_ADDR + mx6_fuse_descs[i].fuse_word_offset);
+		reg |= (1 << mx6_fuse_descs[i].fuse_bit_offset);
+		writel(reg, OCOTP_BASE_ADDR + mx6_fuse_descs[i].fuse_word_offset);
+    }
+}
+#endif
+
+#ifdef CONFIG_OF_SYSTEM_SETUP
+int ft_system_setup(void *blob, bd_t *bd)
+{
+	u32 i, reg;
+	const char *status = "disabled";
+	int rc;
+
+	for (i = 0; i < ARRAY_SIZE(mx6_fuse_descs); i++) {
+		reg = readl(OCOTP_BASE_ADDR + mx6_fuse_descs[i].fuse_word_offset);
+		if (reg & (1 << mx6_fuse_descs[i].fuse_bit_offset)) {
+
+			int nodeoff = fdt_path_offset(blob, mx6_fuse_descs[i].node_path);
+			if (nodeoff < 0)
+				continue; /* Not found, skip it */
+add_status:
+			rc = fdt_setprop(blob, nodeoff, "status", status, strlen(status) + 1);
+			if (rc) {
+				if (rc == -FDT_ERR_NOSPACE) {
+					rc = fdt_increase_size(blob, 512);
+					if (!rc)
+						goto add_status;
+				}
+				printf("Unable to update property %s:%s, err=%s\n",
+					mx6_fuse_descs[i].node_path, "status", fdt_strerror(rc));
+			} else {
+				printf("Modify %s:%s disabled\n",
+					mx6_fuse_descs[i].node_path, "status");
+			}
+		}
+	}
+
+	printf("ft_system_setup for mx6\n");
+
+	return 0;
+}
+#endif
+
+u32 mx6_esdhc_fused(u32 base_addr)
+{
+	switch (base_addr) {
+	case USDHC1_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_SD1);
+	case USDHC2_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_SD2);
+#ifdef USDHC3_BASE_ADDR
+	case USDHC3_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_SD3);
+#endif
+#ifdef USDHC4_BASE_ADDR
+	case USDHC4_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_SD4);
+#endif
+	default:
+		return 0;
+	}
+}
+
+u32 mx6_ecspi_fused(u32 base_addr)
+{
+	switch (base_addr) {
+	case ECSPI1_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_ECSPI1);
+	case ECSPI2_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_ECSPI2);
+	case ECSPI3_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_ECSPI3);
+	case ECSPI4_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_ECSPI4);
+#ifdef ECSPI5_BASE_ADDR
+	case ECSPI5_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_ECSPI5);
+#endif
+	default:
+		return 0;
+	}
+}
+
+u32 mx6_uart_fused(u32 base_addr)
+{
+	switch (base_addr) {
+	case UART1_BASE:
+		return check_module_fused(MX6_MODULE_UART1);
+	case UART2_BASE:
+		return check_module_fused(MX6_MODULE_UART2);
+	case UART3_BASE:
+		return check_module_fused(MX6_MODULE_UART3);
+	case UART4_BASE:
+		return check_module_fused(MX6_MODULE_UART4);
+	case UART5_BASE:
+		return check_module_fused(MX6_MODULE_UART5);
+	case MX6UL_UART6_BASE_ADDR:
+	case MX6SX_UART6_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_UART6);
+#ifdef UART7_IPS_BASE_ADDR
+	case UART7_IPS_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_UART7);
+#endif
+#ifdef UART8_IPS_BASE_ADDR
+	case UART8_IPS_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_UART8);
+#endif
+	}
+
+	return 0;
+}
+
+u32 mx6_usb_fused(u32 base_addr)
+{
+	int i = (base_addr - USB_BASE_ADDR) / 0x200;
+	return check_module_fused(MX6_MODULE_USB_OTG1 + i);
+}
+
+u32 mx6_qspi_fused(u32 base_addr)
+{
+	switch (base_addr) {
+#ifdef QSPI1_BASE_ADDR
+	case QSPI1_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_QSPI1);
+#endif
+
+#ifdef QSPI2_BASE_ADDR
+	case QSPI2_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_QSPI2);
+#endif
+	default:
+		return 0;
+	}
+}
+
+u32 mx6_i2c_fused(u32 base_addr)
+{
+	switch (base_addr) {
+	case I2C1_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_I2C1);
+	case I2C2_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_I2C2);
+	case I2C3_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_I2C3);
+#ifdef I2C4_BASE_ADDR
+	case I2C4_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_I2C4);
+#endif
+	}
+
+	return 0;
+}
+
+u32 mx6_enet_fused(u32 base_addr)
+{
+	switch (base_addr) {
+	case ENET_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_ENET1);
+#ifdef ENET2_BASE_ADDR
+	case ENET2_BASE_ADDR:
+		return check_module_fused(MX6_MODULE_ENET2);
+#endif
+	default:
+		return 0;
+	}
+}
diff -urN u-boot-2016.03/arch/arm/cpu/armv7/mx6/soc.c ebf_6ull_uboot/arch/arm/cpu/armv7/mx6/soc.c
--- u-boot-2016.03/arch/arm/cpu/armv7/mx6/soc.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/cpu/armv7/mx6/soc.c	2021-04-16 14:42:14.664580642 +0800
@@ -2,7 +2,7 @@
  * (C) Copyright 2007
  * Sascha Hauer, Pengutronix
  *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
+ * (C) Copyright 2009-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -22,6 +22,10 @@
 #include <dm.h>
 #include <imx_thermal.h>
 #include <mmc.h>
+#if defined(CONFIG_FSL_FASTBOOT) && defined(CONFIG_ANDROID_RECOVERY)
+#include <recovery.h>
+#endif
+
 
 enum ldo_reg {
 	LDO_ARM,
@@ -108,6 +112,12 @@
 #define OCOTP_CFG3_SPEED_1GHZ	2
 #define OCOTP_CFG3_SPEED_1P2GHZ	3
 
+/*
+ * For i.MX6UL
+ */
+#define OCOTP_CFG3_SPEED_528MHZ 1
+#define OCOTP_CFG3_SPEED_696MHZ 2
+
 u32 get_cpu_speed_grade_hz(void)
 {
 	struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
@@ -120,17 +130,28 @@
 	val >>= OCOTP_CFG3_SPEED_SHIFT;
 	val &= 0x3;
 
+	if (is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL)) {
+		if (val == OCOTP_CFG3_SPEED_528MHZ)
+			return 528000000;
+		else if (val == OCOTP_CFG3_SPEED_696MHZ)
+			return 69600000;
+		else
+			return 0;
+	}
+
 	switch (val) {
 	/* Valid for IMX6DQ */
 	case OCOTP_CFG3_SPEED_1P2GHZ:
-		if (is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D))
+		if (is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D) ||
+			is_cpu_type(MXC_CPU_MX6QP) || is_cpu_type(MXC_CPU_MX6DP))
 			return 1200000000;
 	/* Valid for IMX6SX/IMX6SDL/IMX6DQ */
 	case OCOTP_CFG3_SPEED_1GHZ:
 		return 996000000;
 	/* Valid for IMX6DQ */
 	case OCOTP_CFG3_SPEED_850MHZ:
-		if (is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D))
+		if (is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D) ||
+			is_cpu_type(MXC_CPU_MX6QP) || is_cpu_type(MXC_CPU_MX6DP))
 			return 852000000;
 	/* Valid for IMX6SX/IMX6SDL/IMX6DQ */
 	case OCOTP_CFG3_SPEED_800MHZ:
@@ -188,6 +209,9 @@
 	if (type == MXC_CPU_MX6D)
 		cpurev = (MXC_CPU_MX6Q) << 12 | (cpurev & 0xFFF);
 
+	if (type == MXC_CPU_MX6QP || type == MXC_CPU_MX6DP)
+		cpurev = (MXC_CPU_MX6Q) << 12 | ((cpurev + 0x10) & 0xFFF);
+
 	return cpurev;
 }
 #endif
@@ -219,6 +243,10 @@
 	u32 val, step, old, reg = readl(&anatop->reg_core);
 	u8 shift;
 
+	/* No LDO_SOC/PU/ARM */
+	if (is_cpu_type(MXC_CPU_MX6SLL))
+		return 0;
+
 	if (mv < 725)
 		val = 0x00;	/* Power gated off */
 	else if (mv > 1450)
@@ -278,13 +306,26 @@
 	reg = readl(&mxc_ccm->ccdr);
 
 	/* Clear MMDC channel mask */
-	reg &= ~(MXC_CCM_CCDR_MMDC_CH1_HS_MASK | MXC_CCM_CCDR_MMDC_CH0_HS_MASK);
+	if (is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL) ||
+	    is_cpu_type(MXC_CPU_MX6SL) || is_cpu_type(MXC_CPU_MX6ULL) ||
+	    is_cpu_type(MXC_CPU_MX6SLL))
+		reg &= ~(MXC_CCM_CCDR_MMDC_CH1_HS_MASK);
+	else
+		reg &= ~(MXC_CCM_CCDR_MMDC_CH1_HS_MASK | MXC_CCM_CCDR_MMDC_CH0_HS_MASK);
 	writel(reg, &mxc_ccm->ccdr);
 }
 
+#define OCOTP_MEM0_REFTOP_TRIM_SHIFT          8
+
 static void init_bandgap(void)
 {
 	struct anatop_regs *anatop = (struct anatop_regs *)ANATOP_BASE_ADDR;
+	struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
+	struct fuse_bank *bank = &ocotp->bank[1];
+	struct fuse_bank1_regs *fuse =
+		(struct fuse_bank1_regs *)bank->fuse_regs;
+	uint32_t val;
+
 	/*
 	 * Ensure the bandgap has stabilized.
 	 */
@@ -296,6 +337,26 @@
 	 * be set.
 	 */
 	writel(BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF, &anatop->ana_misc0_set);
+	/*
+	 * On i.MX6ULL,we need to set VBGADJ bits according to the
+	 * REFTOP_TRIM[3:0] in fuse table
+	 *	000 - set REFTOP_VBGADJ[2:0] to 3b'110,
+	 *	110 - set REFTOP_VBGADJ[2:0] to 3b'000,
+	 *	001 - set REFTOP_VBGADJ[2:0] to 3b'001,
+	 *	010 - set REFTOP_VBGADJ[2:0] to 3b'010,
+	 *	011 - set REFTOP_VBGADJ[2:0] to 3b'011,
+	 *	100 - set REFTOP_VBGADJ[2:0] to 3b'100,
+	 *	101 - set REFTOP_VBGADJ[2:0] to 3b'101,
+	 *	111 - set REFTOP_VBGADJ[2:0] to 3b'111,
+	 */
+	if (is_cpu_type(MXC_CPU_MX6ULL)) {
+		val = readl(&fuse->mem0);
+		val >>= OCOTP_MEM0_REFTOP_TRIM_SHIFT;
+		val &= 0x7;
+
+		writel(val << BM_ANADIG_ANA_MISC0_REFTOP_VBGADJ_SHIFT,
+		       &anatop->ana_misc0_set);
+	}
 }
 
 
@@ -311,8 +372,137 @@
 }
 #endif
 
+#ifdef CONFIG_MX6SX
+void vadc_power_up(void)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	u32 val;
+
+	/* csi0 */
+	val = readl(&iomux->gpr[5]);
+	val &= ~IMX6SX_GPR5_CSI1_MUX_CTRL_MASK,
+	val |= IMX6SX_GPR5_CSI1_MUX_CTRL_CVD;
+	writel(val, &iomux->gpr[5]);
+
+	/* Power on vadc analog
+	 * Power down vadc ext power */
+	val = readl(GPC_BASE_ADDR + 0);
+	val &= ~0x60000;
+	writel(val, GPC_BASE_ADDR + 0);
+
+	/* software reset afe  */
+	val = readl(&iomux->gpr[1]);
+	writel(val | 0x80000, &iomux->gpr[1]);
+
+	udelay(10*1000);
+
+	/* Release reset bit  */
+	writel(val & ~0x80000, &iomux->gpr[1]);
+
+	/* Power on vadc ext power */
+	val = readl(GPC_BASE_ADDR + 0);
+	val |= 0x40000;
+	writel(val, GPC_BASE_ADDR + 0);
+}
+
+void vadc_power_down(void)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	u32 val;
+
+	/* Power down vadc ext power
+	 * Power off vadc analog */
+	val = readl(GPC_BASE_ADDR + 0);
+	val &= ~0x40000;
+	val |= 0x20000;
+	writel(val, GPC_BASE_ADDR + 0);
+
+	/* clean csi0 connect to vadc  */
+	val = readl(&iomux->gpr[5]);
+	val &= ~IMX6SX_GPR5_CSI1_MUX_CTRL_MASK,
+	writel(val, &iomux->gpr[5]);
+}
+
+void pcie_power_up(void)
+{
+	set_ldo_voltage(LDO_PU, 1100);	/* Set VDDPU to 1.1V */
+}
+
+void pcie_power_off(void)
+{
+	set_ldo_voltage(LDO_PU, 0);	/* Set VDDPU to 1.1V */
+}
+#endif
+
+static void set_uart_from_osc(void)
+{
+	u32 reg;
+
+	/* set uart clk to OSC */
+	reg = readl(CCM_BASE_ADDR + 0x24);
+	reg |= MXC_CCM_CSCDR1_UART_CLK_SEL;
+	writel(reg, CCM_BASE_ADDR + 0x24);
+}
+
+static void imx_set_vddpu_power_down(void)
+{
+	struct anatop_regs *anatop = (struct anatop_regs *)ANATOP_BASE_ADDR;
+	u32 val;
+
+	/* need to power down xPU in GPC before turn off PU LDO */
+	val = readl(GPC_BASE_ADDR + 0x260);
+	writel(val | 0x1, GPC_BASE_ADDR + 0x260);
+
+	val = readl(GPC_BASE_ADDR + 0x0);
+	writel(val | 0x1, GPC_BASE_ADDR + 0x0);
+	while (readl(GPC_BASE_ADDR + 0x0) & 0x1)
+		;
+
+	/* disable VDDPU */
+	val = 0x3e00;
+	writel(val, &anatop->reg_core_clr);
+}
+
+static void imx_set_pcie_phy_power_down(void)
+{
+	u32 val;
+
+	if (!is_cpu_type(MXC_CPU_MX6SX)) {
+		val = readl(IOMUXC_BASE_ADDR + 0x4);
+		val |= 0x1 << 18;
+		writel(val, IOMUXC_BASE_ADDR + 0x4);
+	} else {
+		val = readl(IOMUXC_GPR_BASE_ADDR + 0x30);
+		val |= 0x1 << 30;
+		writel(val, IOMUXC_GPR_BASE_ADDR + 0x30);
+	}
+}
+
 int arch_cpu_init(void)
 {
+	if (!is_cpu_type(MXC_CPU_MX6SL) && !is_cpu_type(MXC_CPU_MX6SX)
+	    && !is_cpu_type(MXC_CPU_MX6UL) && !is_cpu_type(MXC_CPU_MX6ULL)
+	    && !is_cpu_type(MXC_CPU_MX6SLL)) {
+		/*
+		 * imx6sl doesn't have pcie at all.
+		 * this bit is not used by imx6sx anymore
+		 */
+		u32 val;
+
+		/*
+		 * There are about 0.02% percentage, random pcie link down
+		 * when warm-reset is used.
+		 * clear the ref_ssp_en bit16 of gpr1 to workaround it.
+		 * then warm-reset imx6q/dl/solo again.
+		 */
+		val = readl(IOMUXC_BASE_ADDR + 0x4);
+		if (val & (0x1 << 16)) {
+			val &= ~(0x1 << 16);
+			writel(val, IOMUXC_BASE_ADDR + 0x4);
+			reset_cpu(0);
+		}
+	}
+
 	init_aips();
 
 	/* Need to clear MMDC_CHx_MASK to make warm reset work. */
@@ -325,21 +515,68 @@
 	 */
 	init_bandgap();
 
-	/*
-	 * When low freq boot is enabled, ROM will not set AHB
-	 * freq, so we need to ensure AHB freq is 132MHz in such
-	 * scenario.
-	 */
-	if (mxc_get_clock(MXC_ARM_CLK) == 396000000)
-		set_ahb_rate(132000000);
+	if (!is_cpu_type(MXC_CPU_MX6UL) && !is_cpu_type(MXC_CPU_MX6ULL)) {
+		/*
+		 * When low freq boot is enabled, ROM will not set AHB
+		 * freq, so we need to ensure AHB freq is 132MHz in such
+		 * scenario.
+		 */
+		if (mxc_get_clock(MXC_ARM_CLK) == 396000000)
+			set_ahb_rate(132000000);
+	}
+
+	if (is_cpu_type(MXC_CPU_MX6UL)) {
+		if (is_soc_rev(CHIP_REV_1_0)) {
+			/*
+			 * According to the design team's requirement on i.MX6UL,
+			 * the PMIC_STBY_REQ PAD should be configured as open
+			 * drain 100K (0x0000b8a0).
+			 */
+			writel(0x0000b8a0, IOMUXC_BASE_ADDR + 0x29c);
+		} else {
+			/*
+			 * From TO1.1, SNVS adds internal pull up control for POR_B,
+			 * the register filed is GPBIT[1:0], after system boot up,
+			 * it can be set to 2b'01 to disable internal pull up.
+			 * It can save about 30uA power in SNVS mode.
+			 */
+			writel((readl(MX6UL_SNVS_LP_BASE_ADDR + 0x10) & (~0x1400)) | 0x400,
+				MX6UL_SNVS_LP_BASE_ADDR + 0x10);
+		}
+	}
+
+	if (is_cpu_type(MXC_CPU_MX6ULL)) {
+		/*
+		 * GPBIT[1:0] is suggested to set to 2'b11:
+		 * 2'b00 : always PUP100K
+		 * 2'b01 : PUP100K when PMIC_ON_REQ or SOC_NOT_FAIL
+		 * 2'b10 : always disable PUP100K
+		 * 2'b11 : PDN100K when SOC_FAIL, PUP100K when SOC_NOT_FAIL
+		 * register offset is different from i.MX6UL, since
+		 * i.MX6UL is fixed by ECO.
+		 */
+		writel(readl(MX6UL_SNVS_LP_BASE_ADDR) |
+			0x3, MX6UL_SNVS_LP_BASE_ADDR);
+	}
 
 		/* Set perclk to source from OSC 24MHz */
 #if defined(CONFIG_MX6SL)
 	set_preclk_from_osc();
 #endif
 
+	if (is_cpu_type(MXC_CPU_MX6SX))
+		set_uart_from_osc();
+
 	imx_set_wdog_powerdown(false); /* Disable PDE bit of WMCR register */
 
+	if (!is_cpu_type(MXC_CPU_MX6SL) && !is_cpu_type(MXC_CPU_MX6UL) &&
+	    !is_cpu_type(MXC_CPU_MX6ULL) && !is_cpu_type(MXC_CPU_MX6SLL))
+		imx_set_pcie_phy_power_down();
+
+	if (!is_mx6dqp() && !is_cpu_type(MXC_CPU_MX6UL) &&
+	    !is_cpu_type(MXC_CPU_MX6ULL) && !is_cpu_type(MXC_CPU_MX6SLL))
+		imx_set_vddpu_power_down();
+
 #ifdef CONFIG_APBH_DMA
 	/* Start APBH DMA */
 	mxs_dma_init();
@@ -347,6 +584,9 @@
 
 	init_src();
 
+	if (is_mx6dqp())
+		writel(0x80000201, 0xbb0608);
+
 	return 0;
 }
 
@@ -413,11 +653,28 @@
 
 int board_postclk_init(void)
 {
+	/* NO LDO SOC on i.MX6SLL */
+	if (is_cpu_type(MXC_CPU_MX6SLL))
+		return 0;
+
 	set_ldo_voltage(LDO_SOC, 1175);	/* Set VDDSOC to 1.175V */
 
 	return 0;
 }
 
+#ifdef CONFIG_SERIAL_TAG
+void get_board_serial(struct tag_serialnr *serialnr)
+{
+	struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
+	struct fuse_bank *bank = &ocotp->bank[0];
+	struct fuse_bank0_regs *fuse =
+		(struct fuse_bank0_regs *)bank->fuse_regs;
+
+	serialnr->low = fuse->uid_low;
+	serialnr->high = fuse->uid_high;
+}
+#endif
+
 #if defined(CONFIG_FEC_MXC)
 void imx_get_mac_from_fuse(int dev_id, unsigned char *mac)
 {
@@ -426,8 +683,8 @@
 	struct fuse_bank4_regs *fuse =
 			(struct fuse_bank4_regs *)bank->fuse_regs;
 
-	if ((is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL)) && 
-		dev_id == 1) {
+	if ((is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL) ||
+	    is_cpu_type(MXC_CPU_MX6ULL)) && dev_id == 1) {
 		u32 value = readl(&fuse->mac_addr2);
 		mac[0] = value >> 24 ;
 		mac[1] = value >> 16 ;
@@ -437,7 +694,7 @@
 		value = readl(&fuse->mac_addr1);
 		mac[4] = value >> 24 ;
 		mac[5] = value >> 16 ;
-		
+
 	} else {
 		u32 value = readl(&fuse->mac_addr1);
 		mac[0] = (value >> 8);
@@ -476,6 +733,71 @@
 	{NULL,		0},
 };
 
+enum boot_device get_boot_device(void)
+{
+	enum boot_device boot_dev = UNKNOWN_BOOT;
+	uint soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	uint bt_mem_ctl = (soc_sbmr & 0x000000FF) >> 4 ;
+	uint bt_mem_type = (soc_sbmr & 0x00000008) >> 3;
+	uint bt_dev_port = (soc_sbmr & 0x00001800) >> 11;
+
+	switch (bt_mem_ctl) {
+	case 0x0:
+		if (bt_mem_type)
+			boot_dev = ONE_NAND_BOOT;
+		else
+			boot_dev = WEIM_NOR_BOOT;
+		break;
+	case 0x2:
+			boot_dev = SATA_BOOT;
+		break;
+	case 0x3:
+		if (bt_mem_type)
+			boot_dev = I2C_BOOT;
+		else
+			boot_dev = SPI_NOR_BOOT;
+		break;
+	case 0x4:
+	case 0x5:
+		boot_dev = bt_dev_port + SD1_BOOT;
+		break;
+	case 0x6:
+	case 0x7:
+		boot_dev = bt_dev_port + MMC1_BOOT;
+		break;
+	case 0x8 ... 0xf:
+		boot_dev = NAND_BOOT;
+		break;
+	default:
+		boot_dev = UNKNOWN_BOOT;
+		break;
+	}
+
+    return boot_dev;
+}
+
+void set_wdog_reset(struct wdog_regs *wdog)
+{
+	u32 reg = readw(&wdog->wcr);
+	/*
+	 * use WDOG_B mode to reset external pmic because it's risky for the
+	 * following watchdog reboot in case of cpu freq at lowest 400Mhz with
+	 * ldo-bypass mode. Because boot frequency maybe higher 800Mhz i.e. So
+	 * in ldo-bypass mode watchdog reset will only triger POR reset, not
+	 * WDOG reset. But below code depends on hardware design, if HW didn't
+	 * connect WDOG_B pin to external pmic such as i.mx6slevk, we can skip
+	 * these code since it assumed boot from 400Mhz always.
+	 */
+	reg = readw(&wdog->wcr);
+	reg |= 1 << 3;
+	/*
+	 * WDZST bit is write-once only bit. Align this bit in kernel,
+	 * otherwise kernel code will have no chance to set this bit.
+	 */
+	reg |= 1 << 0;
+	writew(reg, &wdog->wcr);
+}
+
 void reset_misc(void)
 {
 #ifdef CONFIG_VIDEO_MXS
@@ -491,7 +813,8 @@
 	u32 mask528;
 	u32 reg, periph1, periph2;
 
-	if (is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL))
+	if (is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL) ||
+	    is_cpu_type(MXC_CPU_MX6ULL) || is_cpu_type(MXC_CPU_MX6SLL))
 		return;
 
 	/* Due to hardware limitation, on MX6Q we need to gate/ungate all PFDs
@@ -548,7 +871,8 @@
 {
 	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
 	struct hdmi_regs *hdmi  = (struct hdmi_regs *)HDMI_ARB_BASE_ADDR;
-	int reg;
+	int reg, count;
+	u8 val;
 
 	/* Turn on HDMI PHY clock */
 	reg = readl(&mxc_ccm->CCGR2);
@@ -565,6 +889,15 @@
 		 |(CHSCCDR_IPU_PRE_CLK_540M_PFD
 		 << MXC_CCM_CHSCCDR_IPU1_DI0_PRE_CLK_SEL_OFFSET);
 	writel(reg, &mxc_ccm->chsccdr);
+
+	/* Workaround to clear the overflow condition */
+	if (readb(&hdmi->ih_fc_stat2) & HDMI_IH_FC_STAT2_OVERFLOW_MASK) {
+		/* TMDS software reset */
+		writeb((u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ, &hdmi->mc_swrstz);
+		val = readb(&hdmi->fc_invidconf);
+		for (count = 0 ; count < 5 ; count++)
+			writeb(val, &hdmi->fc_invidconf);
+	}
 }
 #endif
 
@@ -605,3 +938,175 @@
 	return 1;
 }
 #endif
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+DECLARE_GLOBAL_DATA_PTR;
+static int ldo_bypass;
+
+int check_ldo_bypass(void)
+{
+	const int *ldo_mode;
+	int node;
+
+	/* get the right fdt_blob from the global working_fdt */
+	gd->fdt_blob = working_fdt;
+	/* Get the node from FDT for anatop ldo-bypass */
+	node = fdt_node_offset_by_compatible(gd->fdt_blob, -1,
+		"fsl,imx6q-gpc");
+	if (node < 0) {
+		printf("No gpc device node %d, force to ldo-enable.\n", node);
+		return 0;
+	}
+	ldo_mode = fdt_getprop(gd->fdt_blob, node, "fsl,ldo-bypass", NULL);
+	/*
+	 * return 1 if "fsl,ldo-bypass = <1>", else return 0 if
+	 * "fsl,ldo-bypass = <0>" or no "fsl,ldo-bypass" property
+	 */
+	ldo_bypass = fdt32_to_cpu(*ldo_mode) == 1 ? 1 : 0;
+
+	return ldo_bypass;
+}
+
+int check_1_2G(void)
+{
+	u32 reg;
+	int result = 0;
+	struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
+	struct fuse_bank *bank = &ocotp->bank[0];
+	struct fuse_bank0_regs *fuse_bank0 =
+			(struct fuse_bank0_regs *)bank->fuse_regs;
+
+	reg = readl(&fuse_bank0->cfg3);
+	if (((reg >> 16) & 0x3) == 0x3) {
+		if (ldo_bypass) {
+			printf("Wrong dtb file used! i.MX6Q@1.2Ghz only "
+				"works with ldo-enable mode!\n");
+			/*
+			 * Currently, only imx6q-sabresd board might be here,
+			 * since only i.MX6Q support 1.2G and only Sabresd board
+			 * support ldo-bypass mode. So hardcode here.
+			 * You can also modify your board(i.MX6Q) dtb name if it
+			 * supports both ldo-bypass and ldo-enable mode.
+			 */
+			printf("Please use imx6q-sabresd-ldo.dtb!\n");
+			hang();
+		}
+		result = 1;
+	}
+
+	return result;
+}
+
+static int arm_orig_podf;
+void set_arm_freq_400M(bool is_400M)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	if (is_400M)
+		writel(0x1, &mxc_ccm->cacrr);
+	else
+		writel(arm_orig_podf, &mxc_ccm->cacrr);
+}
+
+void prep_anatop_bypass(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	arm_orig_podf = readl(&mxc_ccm->cacrr);
+	/*
+	 * Downgrade ARM speed to 400Mhz as half of boot 800Mhz before ldo
+	 * bypassed, also downgrade internal vddarm ldo to 0.975V.
+	 * VDDARM_IN 0.975V + 125mV = 1.1V < Max(1.3V)
+	 * otherwise at 800Mhz(i.mx6dl):
+	 * VDDARM_IN 1.175V + 125mV = 1.3V = Max(1.3V)
+	 * We need provide enough gap in this case.
+	 * skip if boot from 400M.
+	 */
+	if (!arm_orig_podf)
+		set_arm_freq_400M(true);
+
+	if (!is_cpu_type(MXC_CPU_MX6DL) && !is_cpu_type(MXC_CPU_MX6SX))
+		set_ldo_voltage(LDO_ARM, 975);
+	else
+		set_ldo_voltage(LDO_ARM, 1150);
+}
+
+int set_anatop_bypass(int wdog_reset_pin)
+{
+	struct anatop_regs *anatop = (struct anatop_regs *)ANATOP_BASE_ADDR;
+	struct wdog_regs *wdog;
+	u32 reg = readl(&anatop->reg_core);
+
+	/* bypass VDDARM/VDDSOC */
+	reg = reg | (0x1F << 18) | 0x1F;
+	writel(reg, &anatop->reg_core);
+
+	if (wdog_reset_pin == 2)
+		wdog = (struct wdog_regs *) WDOG2_BASE_ADDR;
+	else if (wdog_reset_pin == 1)
+		wdog = (struct wdog_regs *) WDOG1_BASE_ADDR;
+	else
+		return arm_orig_podf;
+	set_wdog_reset(wdog);
+	return arm_orig_podf;
+}
+
+void finish_anatop_bypass(void)
+{
+	if (!arm_orig_podf)
+		set_arm_freq_400M(false);
+}
+#endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+
+#ifdef CONFIG_ANDROID_RECOVERY
+#define ANDROID_RECOVERY_BOOT  (1 << 7)
+/* check if the recovery bit is set by kernel, it can be set by kernel
+ * issue a command '# reboot recovery' */
+int recovery_check_and_clean_flag(void)
+{
+	int flag_set = 0;
+	u32 reg;
+	reg = readl(SNVS_BASE_ADDR + SNVS_LPGPR);
+
+	flag_set = !!(reg & ANDROID_RECOVERY_BOOT);
+    printf("check_and_clean: reg %x, flag_set %d\n", reg, flag_set);
+	/* clean it in case looping infinite here.... */
+	if (flag_set) {
+		reg &= ~ANDROID_RECOVERY_BOOT;
+		writel(reg, SNVS_BASE_ADDR + SNVS_LPGPR);
+	}
+
+	return flag_set;
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#define ANDROID_FASTBOOT_BOOT  (1 << 8)
+/* check if the recovery bit is set by kernel, it can be set by kernel
+ * issue a command '# reboot fastboot' */
+int fastboot_check_and_clean_flag(void)
+{
+	int flag_set = 0;
+	u32 reg;
+
+	reg = readl(SNVS_BASE_ADDR + SNVS_LPGPR);
+
+	flag_set = !!(reg & ANDROID_FASTBOOT_BOOT);
+
+	/* clean it in case looping infinite here.... */
+	if (flag_set) {
+		reg &= ~ANDROID_FASTBOOT_BOOT;
+		writel(reg, SNVS_BASE_ADDR + SNVS_LPGPR);
+	}
+
+	return flag_set;
+}
+
+void fastboot_enable_flag(void)
+{
+	setbits_le32(SNVS_BASE_ADDR + SNVS_LPGPR,
+		ANDROID_FASTBOOT_BOOT);
+}
+#endif /*CONFIG_FSL_FASTBOOT*/
+
diff -urN u-boot-2016.03/arch/arm/cpu/armv7/mx7/clock_slice.c ebf_6ull_uboot/arch/arm/cpu/armv7/mx7/clock_slice.c
--- u-boot-2016.03/arch/arm/cpu/armv7/mx7/clock_slice.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/cpu/armv7/mx7/clock_slice.c	2021-04-16 14:42:14.668580662 +0800
@@ -55,7 +55,7 @@
 	  PLL_ENET_MAIN_250M_CLK, PLL_AUDIO_MAIN_CLK}
 	},
 	{AHB_CLK_ROOT, CCM_AHB_CHANNEL,
-	 {OSC_24M_CLK, PLL_SYS_PFD2_135M_CLK, PLL_DRAM_MAIN_533M_CLK,
+	 {OSC_24M_CLK, PLL_SYS_PFD2_270M_CLK, PLL_DRAM_MAIN_533M_CLK,
 	  PLL_SYS_PFD0_392M_CLK, PLL_ENET_MAIN_125M_CLK, PLL_USB_MAIN_480M_CLK,
 	  PLL_AUDIO_MAIN_CLK, PLL_VIDEO_MAIN_CLK}
 	},
diff -urN u-boot-2016.03/arch/arm/cpu/armv7/mx7/Kconfig ebf_6ull_uboot/arch/arm/cpu/armv7/mx7/Kconfig
--- u-boot-2016.03/arch/arm/cpu/armv7/mx7/Kconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/cpu/armv7/mx7/Kconfig	2021-04-16 14:42:14.664580642 +0800
@@ -2,7 +2,6 @@
 
 config MX7
 	bool
-	select ROM_UNIFIED_SECTIONS
 	default y
 
 config MX7D
@@ -15,6 +14,37 @@
 
 config TARGET_MX7DSABRESD
 	bool "mx7dsabresd"
+	select MX7D
+	select DM
+	select DM_THERMAL
+
+config TARGET_MX7D_12X12_LPDDR3_ARM2
+	bool "mx7d_12x12_lpddr3_arm2"
+	select MX7D
+	select DM
+	select DM_THERMAL
+
+config TARGET_MX7D_12X12_DDR3_ARM2
+	bool "mx7d_12x12_ddr3_arm2"
+	select MX7D
+	select DM
+	select DM_THERMAL
+
+config TARGET_MX7D_19X19_LPDDR2_ARM2
+	bool "mx7d_19x19_lpddr3_arm2"
+	select MX7D
+	select DM
+	select DM_THERMAL
+
+config TARGET_MX7D_19X19_LPDDR3_ARM2
+	bool "mx7d_19x19_lpddr3_arm2"
+	select MX7D
+	select DM
+	select DM_THERMAL
+
+config TARGET_MX7D_19X19_DDR3_ARM2
+	bool "mx7d_19x19_ddr3_arm2"
+	select MX7D
 	select DM
 	select DM_THERMAL
 
@@ -24,5 +54,9 @@
 	default "mx7"
 
 source "board/freescale/mx7dsabresd/Kconfig"
+source "board/freescale/mx7d_12x12_lpddr3_arm2/Kconfig"
+source "board/freescale/mx7d_12x12_ddr3_arm2/Kconfig"
+source "board/freescale/mx7d_19x19_lpddr3_arm2/Kconfig"
+source "board/freescale/mx7d_19x19_ddr3_arm2/Kconfig"
 
 endif
diff -urN u-boot-2016.03/arch/arm/cpu/armv7/mx7/soc.c ebf_6ull_uboot/arch/arm/cpu/armv7/mx7/soc.c
--- u-boot-2016.03/arch/arm/cpu/armv7/mx7/soc.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/cpu/armv7/mx7/soc.c	2021-04-16 14:42:14.668580662 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -17,6 +17,11 @@
 #include <asm/arch/crm_regs.h>
 #include <dm.h>
 #include <imx_thermal.h>
+#include <mxsfb.h>
+#if defined(CONFIG_FSL_FASTBOOT) && defined(CONFIG_ANDROID_RECOVERY)
+#include <recovery.h>
+#endif
+
 
 #if defined(CONFIG_IMX_THERMAL)
 static const struct imx_thermal_plat imx7_thermal_plat = {
@@ -209,6 +214,35 @@
 	}
 }
 
+static void set_epdc_qos(void)
+{
+#define REGS_QOS_BASE     QOSC_IPS_BASE_ADDR
+#define REGS_QOS_EPDC     (QOSC_IPS_BASE_ADDR + 0x3400)
+#define REGS_QOS_PXP0     (QOSC_IPS_BASE_ADDR + 0x2C00)
+#define REGS_QOS_PXP1     (QOSC_IPS_BASE_ADDR + 0x3C00)
+
+	writel(0, REGS_QOS_BASE);  /*  Disable clkgate & soft_reset */
+	writel(0, REGS_QOS_BASE + 0x60);  /*  Enable all masters */
+	writel(0, REGS_QOS_EPDC);   /*  Disable clkgate & soft_reset */
+	writel(0, REGS_QOS_PXP0);   /*  Disable clkgate & soft_reset */
+	writel(0, REGS_QOS_PXP1);   /*  Disable clkgate & soft_reset */
+
+	writel(0x0f020722, REGS_QOS_EPDC + 0xd0);   /*  WR, init = 7 with red flag */
+	writel(0x0f020722, REGS_QOS_EPDC + 0xe0);   /*  RD,  init = 7 with red flag */
+
+	writel(1, REGS_QOS_PXP0);   /*  OT_CTRL_EN =1 */
+	writel(1, REGS_QOS_PXP1);   /*  OT_CTRL_EN =1 */
+
+	writel(0x0f020222, REGS_QOS_PXP0 + 0x50);   /*  WR,  init = 2 with red flag */
+	writel(0x0f020222, REGS_QOS_PXP1 + 0x50);   /*  WR,  init = 2 with red flag */
+	writel(0x0f020222, REGS_QOS_PXP0 + 0x60);   /*  rD,  init = 2 with red flag */
+	writel(0x0f020222, REGS_QOS_PXP1 + 0x60);   /*  rD,  init = 2 with red flag */
+	writel(0x0f020422, REGS_QOS_PXP0 + 0x70);   /*  tOTAL,  init = 4 with red flag */
+	writel(0x0f020422, REGS_QOS_PXP1 + 0x70);   /*  TOTAL,  init = 4 with red flag */
+
+	writel(0xe080, IOMUXC_GPR_BASE_ADDR + 0x0034); /* EPDC AW/AR CACHE ENABLE */
+}
+
 int arch_cpu_init(void)
 {
 	init_aips();
@@ -219,13 +253,16 @@
 
 	imx_enet_mdio_fixup();
 
+	set_epdc_qos();
+
 #ifdef CONFIG_APBH_DMA
 	/* Start APBH DMA */
 	mxs_dma_init();
 #endif
 
-	if (IS_ENABLED(CONFIG_IMX_RDC))
-		isolate_resource();
+#ifdef CONFIG_IMX_RDC
+	isolate_resource();
+#endif
 
 	return 0;
 }
@@ -423,3 +460,66 @@
 
 	return;
 }
+
+void reset_misc(void)
+{
+#ifdef CONFIG_VIDEO_MXS
+	lcdif_power_down();
+#endif
+}
+
+#ifdef CONFIG_FSL_FASTBOOT
+#ifdef CONFIG_ANDROID_RECOVERY
+#define ANDROID_RECOVERY_BOOT	(1 << 7)
+/*
+ * check if the recovery bit is set by kernel, it can be set by kernel
+ * issue a command '# reboot recovery'
+ */
+int recovery_check_and_clean_flag(void)
+{
+	int flag_set = 0;
+	u32 reg;
+	reg = readl(SNVS_BASE_ADDR + SNVS_LPGPR);
+
+	flag_set = !!(reg & ANDROID_RECOVERY_BOOT);
+	printf("check_and_clean: reg %x, flag_set %d\n", reg, flag_set);
+	/* clean it in case looping infinite here.... */
+	if (flag_set) {
+		reg &= ~ANDROID_RECOVERY_BOOT;
+		writel(reg, SNVS_BASE_ADDR + SNVS_LPGPR);
+	}
+
+	return flag_set;
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#define ANDROID_FASTBOOT_BOOT  (1 << 8)
+/*
+ * check if the recovery bit is set by kernel, it can be set by kernel
+ * issue a command '# reboot fastboot'
+ */
+int fastboot_check_and_clean_flag(void)
+{
+	int flag_set = 0;
+	u32 reg;
+
+	reg = readl(SNVS_BASE_ADDR + SNVS_LPGPR);
+
+	flag_set = !!(reg & ANDROID_FASTBOOT_BOOT);
+
+	/* clean it in case looping infinite here.... */
+	if (flag_set) {
+		reg &= ~ANDROID_FASTBOOT_BOOT;
+		writel(reg, SNVS_BASE_ADDR + SNVS_LPGPR);
+	}
+
+	return flag_set;
+}
+
+void fastboot_enable_flag(void)
+{
+	setbits_le32(SNVS_BASE_ADDR + SNVS_LPGPR,
+		ANDROID_FASTBOOT_BOOT);
+}
+#endif /*CONFIG_FSL_FASTBOOT*/
+
diff -urN u-boot-2016.03/arch/arm/cpu/armv7/start.S ebf_6ull_uboot/arch/arm/cpu/armv7/start.S
--- u-boot-2016.03/arch/arm/cpu/armv7/start.S	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/cpu/armv7/start.S	2021-04-16 14:42:14.672580684 +0800
@@ -9,6 +9,7 @@
  * Copyright (c) 2003	Richard Woodruff <r-woodruff2@ti.com>
  * Copyright (c) 2003	Kshitij <kshitij@ti.com>
  * Copyright (c) 2006-2008 Syed Mohammed Khasim <x0khasim@ti.com>
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -163,6 +164,11 @@
 	orr	r0, r0, #1 << 21	@ set bit #21
 	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
 #endif
+#ifdef CONFIG_ARM_ERRATA_845369
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 22	@ set bit #22
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
 
 	mov	r5, lr			@ Store my Caller
 	mrc	p15, 0, r1, c0, c0, 0	@ r1 has Read Main ID Register (MIDR)
diff -urN u-boot-2016.03/arch/arm/imx-common/cache.c ebf_6ull_uboot/arch/arm/imx-common/cache.c
--- u-boot-2016.03/arch/arm/imx-common/cache.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/imx-common/cache.c	2021-04-16 14:42:14.684580745 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2015 Freescale Semiconductor, Inc.
+ * Copyright 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -39,17 +39,23 @@
 void v7_outer_cache_enable(void)
 {
 	struct pl310_regs *const pl310 = (struct pl310_regs *)L2_PL310_BASE;
-	unsigned int val;
+	unsigned int val, cache_id;
 
 
 	/*
+	 * Must disable the L2 before changing the latency parameters
+	 * and auxiliary control register.
+	 */
+	clrbits_le32(&pl310->pl310_ctrl, L2X0_CTRL_EN);
+
+	/*
 	 * Set bit 22 in the auxiliary control register. If this bit
 	 * is cleared, PL310 treats Normal Shared Non-cacheable
 	 * accesses as Cacheable no-allocate.
 	 */
 	setbits_le32(&pl310->pl310_aux_ctrl, L310_SHARED_ATT_OVERRIDE_ENABLE);
 
-#if defined CONFIG_MX6SL
+#if defined(CONFIG_MX6SL) || defined(CONFIG_MX6SLL)
 	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
 	val = readl(&iomux->gpr[11]);
 	if (val & IOMUXC_GPR11_L2CACHE_AS_OCRAM) {
@@ -59,30 +65,29 @@
 	}
 #endif
 
-	/* Must disable the L2 before changing the latency parameters */
-	clrbits_le32(&pl310->pl310_ctrl, L2X0_CTRL_EN);
-
 	writel(0x132, &pl310->pl310_tag_latency_ctrl);
 	writel(0x132, &pl310->pl310_data_latency_ctrl);
 
 	val = readl(&pl310->pl310_prefetch_ctrl);
 
-	/* Turn on the L2 I/D prefetch */
-	val |= 0x30000000;
+	/* Turn on the L2 I/D prefetch, double linefill */
+	/* Set prefetch offset with any value except 23 as per errata 765569 */
+	val |= 0x7000000f;
 
 	/*
 	 * The L2 cache controller(PL310) version on the i.MX6D/Q is r3p1-50rel0
-	 * The L2 cache controller(PL310) version on the i.MX6DL/SOLO/SL is r3p2
+	 * The L2 cache controller(PL310) version on the i.MX6DL/SOLO/SL/SX/DQP
+	 * is r3p2.
 	 * But according to ARM PL310 errata: 752271
 	 * ID: 752271: Double linefill feature can cause data corruption
 	 * Fault Status: Present in: r3p0, r3p1, r3p1-50rel0. Fixed in r3p2
 	 * Workaround: The only workaround to this erratum is to disable the
 	 * double linefill feature. This is the default behavior.
 	 */
-
-#ifndef CONFIG_MX6Q
-	val |= 0x40800000;
-#endif
+	cache_id = readl(&pl310->pl310_cache_id);
+	if (((cache_id & L2X0_CACHE_ID_PART_MASK) == L2X0_CACHE_ID_PART_L310)
+	    && ((cache_id & L2X0_CACHE_ID_RTL_MASK) < L2X0_CACHE_ID_RTL_R3P2))
+		val &= ~(1 << 30);
 	writel(val, &pl310->pl310_prefetch_ctrl);
 
 	val = readl(&pl310->pl310_power_ctrl);
diff -urN u-boot-2016.03/arch/arm/imx-common/cpu.c ebf_6ull_uboot/arch/arm/imx-common/cpu.c
--- u-boot-2016.03/arch/arm/imx-common/cpu.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/imx-common/cpu.c	2021-04-16 14:42:14.684580745 +0800
@@ -2,7 +2,7 @@
  * (C) Copyright 2007
  * Sascha Hauer, Pengutronix
  *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
+ * (C) Copyright 2009-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -21,6 +21,10 @@
 #include <thermal.h>
 #include <sata.h>
 
+#ifdef CONFIG_VIDEO_GIS
+#include <gis.h>
+#endif
+
 #ifdef CONFIG_FSL_ESDHC
 #include <fsl_esdhc.h>
 #endif
@@ -151,12 +155,16 @@
 		return "6DL";	/* Dual Lite version of the mx6 */
 	case MXC_CPU_MX6SOLO:
 		return "6SOLO";	/* Solo version of the mx6 */
+	case MXC_CPU_MX6SLL:
+		return "6SLL";	/* Solo-Lite-Lite version of the mx6 */
 	case MXC_CPU_MX6SL:
 		return "6SL";	/* Solo-Lite version of the mx6 */
 	case MXC_CPU_MX6SX:
 		return "6SX";   /* SoloX version of the mx6 */
 	case MXC_CPU_MX6UL:
 		return "6UL";   /* Ultra-Lite version of the mx6 */
+	case MXC_CPU_MX6ULL:
+		return "6ULL";	/* ULL version of the mx6 */
 	case MXC_CPU_MX51:
 		return "51";
 	case MXC_CPU_MX53:
@@ -170,6 +178,10 @@
 {
 	u32 cpurev;
 	__maybe_unused u32 max_freq;
+#if defined(CONFIG_DBG_MONITOR)
+	struct dbg_monitor_regs *dbg =
+		(struct dbg_monitor_regs *)DEBUG_MONITOR_BASE_ADDR;
+#endif
 
 	cpurev = get_cpu_rev();
 
@@ -226,6 +238,14 @@
 	}
 #endif
 
+#if defined(CONFIG_DBG_MONITOR)
+	if (readl(&dbg->snvs_addr))
+		printf("DBG snvs regs addr 0x%x, data 0x%x, info 0x%x\n",
+		       readl(&dbg->snvs_addr),
+		       readl(&dbg->snvs_data),
+		       readl(&dbg->snvs_info));
+#endif
+
 	printf("Reset cause: %s\n", get_reset_cause());
 	return 0;
 }
@@ -275,10 +295,17 @@
 	disable_sata_clock();
 #endif
 #endif
+#if defined(CONFIG_LDO_BYPASS_CHECK)
+	ldo_mode_set(check_ldo_bypass());
+#endif
 #if defined(CONFIG_VIDEO_IPUV3)
 	/* disable video before launching O/S */
 	ipuv3_fb_shutdown();
 #endif
+#ifdef CONFIG_VIDEO_GIS
+	/* Entry for GIS */
+	mxc_disable_gis();
+#endif
 #if defined(CONFIG_VIDEO_MXS)
 	lcdif_power_down();
 #endif
diff -urN u-boot-2016.03/arch/arm/imx-common/hab.c ebf_6ull_uboot/arch/arm/imx-common/hab.c
--- u-boot-2016.03/arch/arm/imx-common/hab.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/imx-common/hab.c	2021-04-16 14:42:14.684580745 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:    GPL-2.0+
  */
@@ -17,11 +17,15 @@
 
 #define hab_rvt_report_event_p					\
 (								\
+	(is_cpu_type(MXC_CPU_MX6QP) ||				\
+	  is_cpu_type(MXC_CPU_MX6DP)) ?				\
+	((hab_rvt_report_event_t *)HAB_RVT_REPORT_EVENT_NEW) :	\
 	((is_cpu_type(MXC_CPU_MX6Q) ||				\
 	  is_cpu_type(MXC_CPU_MX6D)) &&				\
 	  (soc_rev() >= CHIP_REV_1_5)) ?			\
 	((hab_rvt_report_event_t *)HAB_RVT_REPORT_EVENT_NEW) :	\
-	(is_cpu_type(MXC_CPU_MX6DL) &&				\
+	((is_cpu_type(MXC_CPU_MX6DL) ||				\
+	  is_cpu_type(MXC_CPU_MX6SOLO)) &&				\
 	 (soc_rev() >= CHIP_REV_1_2)) ?				\
 	((hab_rvt_report_event_t *)HAB_RVT_REPORT_EVENT_NEW) :	\
 	((hab_rvt_report_event_t *)HAB_RVT_REPORT_EVENT)	\
@@ -29,11 +33,15 @@
 
 #define hab_rvt_report_status_p					\
 (								\
+	(is_cpu_type(MXC_CPU_MX6QP) ||				\
+	  is_cpu_type(MXC_CPU_MX6DP)) ?				\
+	((hab_rvt_report_status_t *)HAB_RVT_REPORT_STATUS_NEW) :\
 	((is_cpu_type(MXC_CPU_MX6Q) ||				\
 	  is_cpu_type(MXC_CPU_MX6D)) &&				\
 	  (soc_rev() >= CHIP_REV_1_5)) ?			\
 	((hab_rvt_report_status_t *)HAB_RVT_REPORT_STATUS_NEW) :\
-	(is_cpu_type(MXC_CPU_MX6DL) &&				\
+	((is_cpu_type(MXC_CPU_MX6DL) ||				\
+	  is_cpu_type(MXC_CPU_MX6SOLO)) &&				\
 	 (soc_rev() >= CHIP_REV_1_2)) ?				\
 	((hab_rvt_report_status_t *)HAB_RVT_REPORT_STATUS_NEW) :\
 	((hab_rvt_report_status_t *)HAB_RVT_REPORT_STATUS)	\
@@ -41,11 +49,15 @@
 
 #define hab_rvt_authenticate_image_p				\
 (								\
+	(is_cpu_type(MXC_CPU_MX6QP) ||				\
+	  is_cpu_type(MXC_CPU_MX6DP)) ?				\
+	((hab_rvt_authenticate_image_t *)HAB_RVT_AUTHENTICATE_IMAGE_NEW) : \
 	((is_cpu_type(MXC_CPU_MX6Q) ||				\
 	  is_cpu_type(MXC_CPU_MX6D)) &&				\
 	  (soc_rev() >= CHIP_REV_1_5)) ?			\
 	((hab_rvt_authenticate_image_t *)HAB_RVT_AUTHENTICATE_IMAGE_NEW) : \
-	(is_cpu_type(MXC_CPU_MX6DL) &&				\
+	((is_cpu_type(MXC_CPU_MX6DL) ||				\
+	  is_cpu_type(MXC_CPU_MX6SOLO)) &&				\
 	 (soc_rev() >= CHIP_REV_1_2)) ?				\
 	((hab_rvt_authenticate_image_t *)HAB_RVT_AUTHENTICATE_IMAGE_NEW) : \
 	((hab_rvt_authenticate_image_t *)HAB_RVT_AUTHENTICATE_IMAGE)	\
@@ -53,11 +65,15 @@
 
 #define hab_rvt_entry_p						\
 (								\
+	(is_cpu_type(MXC_CPU_MX6QP) ||				\
+	  is_cpu_type(MXC_CPU_MX6DP)) ?				\
+	((hab_rvt_entry_t *)HAB_RVT_ENTRY_NEW) :		\
 	((is_cpu_type(MXC_CPU_MX6Q) ||				\
 	  is_cpu_type(MXC_CPU_MX6D)) &&				\
 	  (soc_rev() >= CHIP_REV_1_5)) ?			\
 	((hab_rvt_entry_t *)HAB_RVT_ENTRY_NEW) :		\
-	(is_cpu_type(MXC_CPU_MX6DL) &&				\
+	((is_cpu_type(MXC_CPU_MX6DL) ||				\
+	  is_cpu_type(MXC_CPU_MX6SOLO)) &&				\
 	 (soc_rev() >= CHIP_REV_1_2)) ?				\
 	((hab_rvt_entry_t *)HAB_RVT_ENTRY_NEW) :		\
 	((hab_rvt_entry_t *)HAB_RVT_ENTRY)			\
@@ -65,11 +81,15 @@
 
 #define hab_rvt_exit_p						\
 (								\
+	(is_cpu_type(MXC_CPU_MX6QP) ||				\
+	  is_cpu_type(MXC_CPU_MX6DP)) ?			\
+	((hab_rvt_exit_t *)HAB_RVT_EXIT_NEW) :			\
 	((is_cpu_type(MXC_CPU_MX6Q) ||				\
 	  is_cpu_type(MXC_CPU_MX6D)) &&				\
 	  (soc_rev() >= CHIP_REV_1_5)) ?			\
 	((hab_rvt_exit_t *)HAB_RVT_EXIT_NEW) :			\
-	(is_cpu_type(MXC_CPU_MX6DL) &&				\
+	((is_cpu_type(MXC_CPU_MX6DL) ||				\
+	  is_cpu_type(MXC_CPU_MX6SOLO)) &&				\
 	 (soc_rev() >= CHIP_REV_1_2)) ?				\
 	((hab_rvt_exit_t *)HAB_RVT_EXIT_NEW) :			\
 	((hab_rvt_exit_t *)HAB_RVT_EXIT)			\
@@ -432,8 +452,7 @@
 					 * do cache flushes. don't think any
 					 * exist, so we ignore them.
 					 */
-					if (!is_mx6dqp())
-						writel(1, MX6DQ_PU_IROM_MMU_EN_VAR);
+					writel(1, MX6DQ_PU_IROM_MMU_EN_VAR);
 				} else if (is_cpu_type(MXC_CPU_MX6DL) ||
 					   is_cpu_type(MXC_CPU_MX6SOLO)) {
 					writel(1, MX6DLS_PU_IROM_MMU_EN_VAR);
diff -urN u-boot-2016.03/arch/arm/imx-common/i2c-mxv7.c ebf_6ull_uboot/arch/arm/imx-common/i2c-mxv7.c
--- u-boot-2016.03/arch/arm/imx-common/i2c-mxv7.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/imx-common/i2c-mxv7.c	2021-04-16 14:42:14.684580745 +0800
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2012 Boundary Devices Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -33,13 +34,36 @@
 
 	printf("%s: sda=%d scl=%d sda.gp=0x%x scl.gp=0x%x\n", __func__,
 		sda, scl, p->sda.gp, p->scl.gp);
+	gpio_direction_output(p->scl.gp, 1);
+	udelay(1000);
 	/* Send high and low on the SCL line */
 	for (i = 0; i < 9; i++) {
-		gpio_direction_output(p->scl.gp, 0);
+		gpio_direction_output(p->scl.gp, 1);
 		udelay(50);
-		gpio_direction_input(p->scl.gp);
+		gpio_direction_output(p->scl.gp, 0);
 		udelay(50);
 	}
+
+	/* Simulate the NACK */
+	gpio_direction_output(p->sda.gp, 1);
+	udelay(50);
+	gpio_direction_output(p->scl.gp, 1);
+	udelay(50);
+	gpio_direction_output(p->scl.gp, 0);
+	udelay(50);
+
+	/* Simulate the STOP signal */
+	gpio_direction_output(p->sda.gp, 0);
+	udelay(50);
+	gpio_direction_output(p->scl.gp, 1);
+	udelay(50);
+	gpio_direction_output(p->sda.gp, 1);
+	udelay(50);
+
+	/* Get the bus status */
+	gpio_direction_input(p->sda.gp);
+	gpio_direction_input(p->scl.gp);
+
 	start_time = get_timer(0);
 	for (;;) {
 		sda = gpio_get_value(p->sda.gp);
diff -urN u-boot-2016.03/arch/arm/imx-common/init.c ebf_6ull_uboot/arch/arm/imx-common/init.c
--- u-boot-2016.03/arch/arm/imx-common/init.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/imx-common/init.c	2021-04-16 14:42:14.684580745 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2015 Freescale Semiconductor, Inc.
+ * Copyright 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -44,7 +44,8 @@
 	writel(0x00000000, &aips2->opacr3);
 	writel(0x00000000, &aips2->opacr4);
 
-	if (is_cpu_type(MXC_CPU_MX6SX) || is_soc_type(MXC_SOC_MX7)) {
+	if (is_cpu_type(MXC_CPU_MX6ULL) || is_cpu_type(MXC_CPU_MX6SX) ||
+	    is_soc_type(MXC_SOC_MX7)) {
 		/*
 		 * Set all MPROTx to be non-bufferable, trusted for R/W,
 		 * not forced to user-mode.
@@ -79,7 +80,7 @@
 	writew(enable, &wdog2->wmcr);
 
 	if (is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL) ||
-			is_soc_type(MXC_SOC_MX7))
+	    is_cpu_type(MXC_CPU_MX6ULL) || is_soc_type(MXC_SOC_MX7))
 		writew(enable, &wdog3->wmcr);
 #ifdef CONFIG_MX7D
 	writew(enable, &wdog4->wmcr);
diff -urN u-boot-2016.03/arch/arm/imx-common/iomux-v3.c ebf_6ull_uboot/arch/arm/imx-common/iomux-v3.c
--- u-boot-2016.03/arch/arm/imx-common/iomux-v3.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/imx-common/iomux-v3.c	2021-04-16 14:42:14.684580745 +0800
@@ -4,7 +4,7 @@
  * Copyright (C) 2009 by Jan Weitzel Phytec Messtechnik GmbH,
  *                       <armlinux@phytec.de>
  *
- * Copyright (C) 2004-2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2004-2011, 2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -31,7 +31,7 @@
 		(pad & MUX_PAD_CTRL_OFS_MASK) >> MUX_PAD_CTRL_OFS_SHIFT;
 	u32 pad_ctrl = (pad & MUX_PAD_CTRL_MASK) >> MUX_PAD_CTRL_SHIFT;
 
-#if defined CONFIG_MX6SL
+#if defined(CONFIG_MX6SL) || defined(CONFIG_MX6SLL)
 	/* Check whether LVE bit needs to be set */
 	if (pad_ctrl & PAD_CTL_LVE) {
 		pad_ctrl &= ~PAD_CTL_LVE;
@@ -42,6 +42,7 @@
 #ifdef CONFIG_IOMUX_LPSR
 	u32 lpsr = (pad & MUX_MODE_LPSR) >> MUX_MODE_SHIFT;
 
+#ifdef CONFIG_MX7
 	if (lpsr == IOMUX_CONFIG_LPSR) {
 		base = (void *)IOMUXC_LPSR_BASE_ADDR;
 		mux_mode &= ~IOMUX_CONFIG_LPSR;
@@ -49,9 +50,18 @@
 		if (sel_input_ofs)
 			sel_input_ofs += IOMUX_LPSR_SEL_INPUT_OFS;
 	}
+#else
+	if (is_cpu_type(MXC_CPU_MX6ULL) || is_cpu_type(MXC_CPU_MX6SLL)) {
+		if (lpsr == IOMUX_CONFIG_LPSR) {
+			base = (void *)IOMUXC_SNVS_BASE_ADDR;
+			mux_mode &= ~IOMUX_CONFIG_LPSR;
+		}
+	}
+#endif
 #endif
 
-	if (is_soc_type(MXC_SOC_MX7) || mux_ctrl_ofs)
+	if (is_soc_type(MXC_SOC_MX7) || is_cpu_type(MXC_CPU_MX6ULL) ||
+	    is_cpu_type(MXC_CPU_MX6SLL) || mux_ctrl_ofs)
 		__raw_writel(mux_mode, base + mux_ctrl_ofs);
 
 	if (sel_input_ofs)
@@ -64,6 +74,10 @@
 #else
 	if (!(pad_ctrl & NO_PAD_CTRL) && pad_ctrl_ofs)
 		__raw_writel(pad_ctrl, base + pad_ctrl_ofs);
+#if defined(CONFIG_MX6SLL)
+	else if ((pad_ctrl & NO_PAD_CTRL) && pad_ctrl_ofs)
+		clrbits_le32(base + pad_ctrl_ofs, PAD_CTL_IPD_BIT);
+#endif
 #endif
 
 #ifdef CONFIG_IOMUX_LPSR
diff -urN u-boot-2016.03/arch/arm/imx-common/Makefile ebf_6ull_uboot/arch/arm/imx-common/Makefile
--- u-boot-2016.03/arch/arm/imx-common/Makefile	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/imx-common/Makefile	2021-04-16 14:42:14.684580745 +0800
@@ -2,7 +2,7 @@
 # (C) Copyright 2000-2006
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
-# (C) Copyright 2011 Freescale Semiconductor, Inc.
+# (C) Copyright 2011-2016 Freescale Semiconductor, Inc.
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
@@ -11,9 +11,12 @@
 obj-y	= iomux-v3.o
 endif
 ifeq ($(SOC),$(filter $(SOC),mx5 mx6))
-obj-y	+= timer.o cpu.o speed.o
+obj-y	+= cpu.o speed.o
 obj-$(CONFIG_SYS_I2C_MXC) += i2c-mxv7.o
 endif
+ifeq ($(SOC),$(filter $(SOC),mx5))
+obj-y  += timer.o
+endif
 ifeq ($(SOC),$(filter $(SOC),mx7 mx6 mxs))
 obj-y	+= misc.o
 obj-$(CONFIG_SPL_BUILD)	+= spl.o
@@ -21,7 +24,6 @@
 ifeq ($(SOC),$(filter $(SOC),mx7))
 obj-y 	+= cpu.o
 obj-$(CONFIG_SYS_I2C_MXC) += i2c-mxv7.o
-obj-$(CONFIG_SYSCOUNTER_TIMER) += syscounter.o
 endif
 ifeq ($(SOC),$(filter $(SOC),mx6 mx7))
 obj-y 	+= cache.o init.o
@@ -30,6 +32,8 @@
 obj-$(CONFIG_IMX_RDC) += rdc-sema.o
 obj-$(CONFIG_IMX_BOOTAUX) += imx_bootaux.o
 obj-$(CONFIG_SECURE_BOOT)    += hab.o
+obj-$(CONFIG_GPT_TIMER) += timer.o
+obj-$(CONFIG_SYSCOUNTER_TIMER) += syscounter.o
 endif
 ifeq ($(SOC),$(filter $(SOC),vf610))
 obj-y += ddrmc-vf610.o
diff -urN u-boot-2016.03/arch/arm/imx-common/sata.c ebf_6ull_uboot/arch/arm/imx-common/sata.c
--- u-boot-2016.03/arch/arm/imx-common/sata.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/imx-common/sata.c	2021-04-16 14:42:14.684580745 +0800
@@ -15,7 +15,8 @@
 	struct iomuxc *const iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
 	int ret;
 
-	if (!is_cpu_type(MXC_CPU_MX6Q) && !is_cpu_type(MXC_CPU_MX6D))
+	if (!is_cpu_type(MXC_CPU_MX6Q) && !is_cpu_type(MXC_CPU_MX6D) &&
+		!is_cpu_type(MXC_CPU_MX6QP) && !is_cpu_type(MXC_CPU_MX6DP))
 		return 1;
 
 	ret = enable_sata_clock();
diff -urN u-boot-2016.03/arch/arm/imx-common/timer.c ebf_6ull_uboot/arch/arm/imx-common/timer.c
--- u-boot-2016.03/arch/arm/imx-common/timer.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/imx-common/timer.c	2021-04-16 14:42:14.684580745 +0800
@@ -2,7 +2,7 @@
  * (C) Copyright 2007
  * Sascha Hauer, Pengutronix
  *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
+ * (C) Copyright 2009-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -43,13 +43,17 @@
 static inline int gpt_has_clk_source_osc(void)
 {
 #if defined(CONFIG_MX6)
-	if (((is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D)) &&
+	if (is_cpu_type(MXC_CPU_MX6QP) || is_cpu_type(MXC_CPU_MX6DP) ||
+	    ((is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D)) &&
 	    (soc_rev() > CHIP_REV_1_0)) || is_cpu_type(MXC_CPU_MX6DL) ||
 	     is_cpu_type(MXC_CPU_MX6SOLO) || is_cpu_type(MXC_CPU_MX6SX) ||
-	     is_cpu_type(MXC_CPU_MX6UL))
+	     is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL) ||
+	     is_cpu_type(MXC_CPU_MX6SLL))
 		return 1;
 
 	return 0;
+#elif defined(CONFIG_MX7)
+	return 1;
 #else
 	return 0;
 #endif
@@ -57,6 +61,9 @@
 
 static inline ulong gpt_get_clk(void)
 {
+#if defined(CONFIG_MX7)
+	return MXC_HCLK >> 3;
+#else
 #ifdef CONFIG_MXC_GPT_HCLK
 	if (gpt_has_clk_source_osc())
 		return MXC_HCLK >> 3;
@@ -65,6 +72,7 @@
 #else
 	return MXC_CLK32;
 #endif
+#endif
 }
 
 int timer_init(void)
@@ -85,11 +93,14 @@
 	if (gpt_has_clk_source_osc()) {
 		i |= GPTCR_CLKSOURCE_OSC | GPTCR_TEN;
 
-		/* For DL/S, SX, UL, set 24Mhz OSC Enable bit and prescaler */
+		/* For DL/S, SX, UL, ULL set 24Mhz OSC Enable bit and prescaler */
 		if (is_cpu_type(MXC_CPU_MX6DL) ||
 		    is_cpu_type(MXC_CPU_MX6SOLO) ||
 		    is_cpu_type(MXC_CPU_MX6SX) ||
-		    is_cpu_type(MXC_CPU_MX6UL)) {
+		    is_cpu_type(MXC_CPU_MX7D) ||
+		    is_cpu_type(MXC_CPU_MX6UL) ||
+		    is_cpu_type(MXC_CPU_MX6ULL) ||
+		    is_cpu_type(MXC_CPU_MX6SLL)) {
 			i |= GPTCR_24MEN;
 
 			/* Produce 3Mhz clock */
diff -urN u-boot-2016.03/arch/arm/imx-common/video.c ebf_6ull_uboot/arch/arm/imx-common/video.c
--- u-boot-2016.03/arch/arm/imx-common/video.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/imx-common/video.c	2021-04-16 14:42:14.684580745 +0800
@@ -1,4 +1,6 @@
 /*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -34,8 +36,14 @@
 	}
 
 	if (i < display_count) {
+#if defined(CONFIG_VIDEO_IPUV3)
 		ret = ipuv3_fb_init(&displays[i].mode, 0,
 				    displays[i].pixfmt);
+#elif defined(CONFIG_VIDEO_MXS)
+		ret = mxs_lcd_panel_setup(displays[i].mode,
+					displays[i].pixfmt,
+				    displays[i].bus);
+#endif
 		if (!ret) {
 			if (displays[i].enable)
 				displays[i].enable(displays + i);
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/clock.h ebf_6ull_uboot/arch/arm/include/asm/arch/clock.h
--- u-boot-2016.03/arch/arm/include/asm/arch/clock.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/clock.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,78 @@
+/*
+ * (C) Copyright 2009
+ * Stefano Babic, DENX Software Engineering, sbabic@denx.de.
+ *
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_CLOCK_H
+#define __ASM_ARCH_CLOCK_H
+
+#include <common.h>
+
+#ifdef CONFIG_SYS_MX6_HCLK
+#define MXC_HCLK	CONFIG_SYS_MX6_HCLK
+#else
+#define MXC_HCLK	24000000
+#endif
+
+#ifdef CONFIG_SYS_MX6_CLK32
+#define MXC_CLK32	CONFIG_SYS_MX6_CLK32
+#else
+#define MXC_CLK32	32768
+#endif
+
+enum mxc_clock {
+	MXC_ARM_CLK = 0,
+	MXC_PER_CLK,
+	MXC_AHB_CLK,
+	MXC_IPG_CLK,
+	MXC_IPG_PERCLK,
+	MXC_UART_CLK,
+	MXC_CSPI_CLK,
+	MXC_AXI_CLK,
+	MXC_EMI_SLOW_CLK,
+	MXC_DDR_CLK,
+	MXC_ESDHC_CLK,
+	MXC_ESDHC2_CLK,
+	MXC_ESDHC3_CLK,
+	MXC_ESDHC4_CLK,
+	MXC_SATA_CLK,
+	MXC_NFC_CLK,
+	MXC_I2C_CLK,
+};
+
+enum enet_freq {
+	ENET_25MHZ,
+	ENET_50MHZ,
+	ENET_100MHZ,
+	ENET_125MHZ,
+};
+
+u32 imx_get_uartclk(void);
+u32 imx_get_fecclk(void);
+unsigned int mxc_get_clock(enum mxc_clock clk);
+void setup_gpmi_io_clk(u32 cfg);
+void hab_caam_clock_enable(unsigned char enable);
+void enable_ocotp_clk(unsigned char enable);
+void enable_usboh3_clk(unsigned char enable);
+void enable_uart_clk(unsigned char enable);
+int enable_usdhc_clk(unsigned char enable, unsigned bus_num);
+int enable_sata_clock(void);
+void disable_sata_clock(void);
+int enable_pcie_clock(void);
+int enable_i2c_clk(unsigned char enable, unsigned i2c_num);
+int enable_spi_clk(unsigned char enable, unsigned spi_num);
+void enable_ipu_clock(void);
+int enable_fec_anatop_clock(int fec_id, enum enet_freq freq);
+void enable_enet_clk(unsigned char enable);
+int enable_lcdif_clock(u32 base_addr);
+int enable_lvds_bridge(u32 lcd_base_addr);
+void enable_qspi_clk(int qspi_num);
+void enable_thermal_clk(void);
+void enable_epdc_clock(void);
+void mxs_set_lcdclk(u32 base_addr, u32 freq);
+void mxs_set_vadcclk(void);
+#endif /* __ASM_ARCH_CLOCK_H */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/crm_regs.h ebf_6ull_uboot/arch/arm/include/asm/arch/crm_regs.h
--- u-boot-2016.03/arch/arm/include/asm/arch/crm_regs.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/crm_regs.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,1354 @@
+/*
+ * Copyright 2011-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ARCH_ARM_MACH_MX6_CCM_REGS_H__
+#define __ARCH_ARM_MACH_MX6_CCM_REGS_H__
+
+#define CCM_CCOSR		0x020c4060
+#define CCM_CCGR0		0x020C4068
+#define CCM_CCGR1		0x020C406c
+#define CCM_CCGR2		0x020C4070
+#define CCM_CCGR3		0x020C4074
+#define CCM_CCGR4		0x020C4078
+#define CCM_CCGR5		0x020C407c
+#define CCM_CCGR6		0x020C4080
+
+#define PMU_MISC2		0x020C8170
+
+#ifndef __ASSEMBLY__
+struct mxc_ccm_reg {
+	u32 ccr;	/* 0x0000 */
+	u32 ccdr;
+	u32 csr;
+	u32 ccsr;
+	u32 cacrr;	/* 0x0010*/
+	u32 cbcdr;
+	u32 cbcmr;
+	u32 cscmr1;
+	u32 cscmr2;	/* 0x0020 */
+	u32 cscdr1;
+	u32 cs1cdr;
+	u32 cs2cdr;
+	u32 cdcdr;	/* 0x0030 */
+	u32 chsccdr;
+	u32 cscdr2;
+	u32 cscdr3;
+	u32 cscdr4;	/* 0x0040 */
+	u32 resv0;
+	u32 cdhipr;
+	u32 cdcr;
+	u32 ctor;	/* 0x0050 */
+	u32 clpcr;
+	u32 cisr;
+	u32 cimr;
+	u32 ccosr;	/* 0x0060 */
+	u32 cgpr;
+	u32 CCGR0;
+	u32 CCGR1;
+	u32 CCGR2;	/* 0x0070 */
+	u32 CCGR3;
+	u32 CCGR4;
+	u32 CCGR5;
+	u32 CCGR6;	/* 0x0080 */
+	u32 CCGR7;
+	u32 cmeor;
+	u32 resv[0xfdd];
+	u32 analog_pll_sys;			/* 0x4000 */
+	u32 analog_pll_sys_set;
+	u32 analog_pll_sys_clr;
+	u32 analog_pll_sys_tog;
+	u32 analog_usb1_pll_480_ctrl;		/* 0x4010 */
+	u32 analog_usb1_pll_480_ctrl_set;
+	u32 analog_usb1_pll_480_ctrl_clr;
+	u32 analog_usb1_pll_480_ctrl_tog;
+	u32 analog_reserved0[4];
+	u32 analog_pll_528;			/* 0x4030 */
+	u32 analog_pll_528_set;
+	u32 analog_pll_528_clr;
+	u32 analog_pll_528_tog;
+	u32 analog_pll_528_ss;			/* 0x4040 */
+	u32 analog_reserved1[3];
+	u32 analog_pll_528_num;			/* 0x4050 */
+	u32 analog_reserved2[3];
+	u32 analog_pll_528_denom;		/* 0x4060 */
+	u32 analog_reserved3[3];
+	u32 analog_pll_audio;			/* 0x4070 */
+	u32 analog_pll_audio_set;
+	u32 analog_pll_audio_clr;
+	u32 analog_pll_audio_tog;
+	u32 analog_pll_audio_num;		/* 0x4080*/
+	u32 analog_reserved4[3];
+	u32 analog_pll_audio_denom;		/* 0x4090 */
+	u32 analog_reserved5[3];
+	u32 analog_pll_video;			/* 0x40a0 */
+	u32 analog_pll_video_set;
+	u32 analog_pll_video_clr;
+	u32 analog_pll_video_tog;
+	u32 analog_pll_video_num;		/* 0x40b0 */
+	u32 analog_reserved6[3];
+	u32 analog_pll_video_denom;		/* 0x40c0 */
+	u32 analog_reserved7[7];
+	u32 analog_pll_enet;			/* 0x40e0 */
+	u32 analog_pll_enet_set;
+	u32 analog_pll_enet_clr;
+	u32 analog_pll_enet_tog;
+	u32 analog_pfd_480;			/* 0x40f0 */
+	u32 analog_pfd_480_set;
+	u32 analog_pfd_480_clr;
+	u32 analog_pfd_480_tog;
+	u32 analog_pfd_528;			/* 0x4100 */
+	u32 analog_pfd_528_set;
+	u32 analog_pfd_528_clr;
+	u32 analog_pfd_528_tog;
+	/* PMU Memory Map/Register Definition */
+	u32 pmu_reg_1p1;
+	u32 pmu_reg_1p1_set;
+	u32 pmu_reg_1p1_clr;
+	u32 pmu_reg_1p1_tog;
+	u32 pmu_reg_3p0;
+	u32 pmu_reg_3p0_set;
+	u32 pmu_reg_3p0_clr;
+	u32 pmu_reg_3p0_tog;
+	u32 pmu_reg_2p5;
+	u32 pmu_reg_2p5_set;
+	u32 pmu_reg_2p5_clr;
+	u32 pmu_reg_2p5_tog;
+	u32 pmu_reg_core;
+	u32 pmu_reg_core_set;
+	u32 pmu_reg_core_clr;
+	u32 pmu_reg_core_tog;
+	u32 pmu_misc0;
+	u32 pmu_misc0_set;
+	u32 pmu_misc0_clr;
+	u32 pmu_misc0_tog;
+	u32 pmu_misc1;
+	u32 pmu_misc1_set;
+	u32 pmu_misc1_clr;
+	u32 pmu_misc1_tog;
+	u32 pmu_misc2;
+	u32 pmu_misc2_set;
+	u32 pmu_misc2_clr;
+	u32 pmu_misc2_tog;
+	/* TEMPMON Memory Map/Register Definition */
+	u32 tempsense0;
+	u32 tempsense0_set;
+	u32 tempsense0_clr;
+	u32 tempsense0_tog;
+	u32 tempsense1;
+	u32 tempsense1_set;
+	u32 tempsense1_clr;
+	u32 tempsense1_tog;
+	/* USB Analog Memory Map/Register Definition */
+	u32 usb1_vbus_detect;
+	u32 usb1_vbus_detect_set;
+	u32 usb1_vbus_detect_clr;
+	u32 usb1_vbus_detect_tog;
+	u32 usb1_chrg_detect;
+	u32 usb1_chrg_detect_set;
+	u32 usb1_chrg_detect_clr;
+	u32 usb1_chrg_detect_tog;
+	u32 usb1_vbus_det_stat;
+	u32 usb1_vbus_det_stat_set;
+	u32 usb1_vbus_det_stat_clr;
+	u32 usb1_vbus_det_stat_tog;
+	u32 usb1_chrg_det_stat;
+	u32 usb1_chrg_det_stat_set;
+	u32 usb1_chrg_det_stat_clr;
+	u32 usb1_chrg_det_stat_tog;
+	u32 usb1_loopback;
+	u32 usb1_loopback_set;
+	u32 usb1_loopback_clr;
+	u32 usb1_loopback_tog;
+	u32 usb1_misc;
+	u32 usb1_misc_set;
+	u32 usb1_misc_clr;
+	u32 usb1_misc_tog;
+	u32 usb2_vbus_detect;
+	u32 usb2_vbus_detect_set;
+	u32 usb2_vbus_detect_clr;
+	u32 usb2_vbus_detect_tog;
+	u32 usb2_chrg_detect;
+	u32 usb2_chrg_detect_set;
+	u32 usb2_chrg_detect_clr;
+	u32 usb2_chrg_detect_tog;
+	u32 usb2_vbus_det_stat;
+	u32 usb2_vbus_det_stat_set;
+	u32 usb2_vbus_det_stat_clr;
+	u32 usb2_vbus_det_stat_tog;
+	u32 usb2_chrg_det_stat;
+	u32 usb2_chrg_det_stat_set;
+	u32 usb2_chrg_det_stat_clr;
+	u32 usb2_chrg_det_stat_tog;
+	u32 usb2_loopback;
+	u32 usb2_loopback_set;
+	u32 usb2_loopback_clr;
+	u32 usb2_loopback_tog;
+	u32 usb2_misc;
+	u32 usb2_misc_set;
+	u32 usb2_misc_clr;
+	u32 usb2_misc_tog;
+	u32 digprog;
+	u32 reserved1[7];
+	/* For i.MX 6SoloLite */
+	u32 digprog_sololite;
+};
+#endif
+
+/* Define the bits in register CCR */
+#define MXC_CCM_CCR_RBC_EN				(1 << 27)
+#define MXC_CCM_CCR_REG_BYPASS_CNT_MASK			(0x3F << 21)
+#define MXC_CCM_CCR_REG_BYPASS_CNT_OFFSET		21
+/* CCR_WB does not exist on i.MX6SX/UL */
+#define MXC_CCM_CCR_WB_COUNT_MASK			0x7
+#define MXC_CCM_CCR_WB_COUNT_OFFSET			(1 << 16)
+#define MXC_CCM_CCR_COSC_EN				(1 << 12)
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CCR_OSCNT_MASK				0x7F
+#else
+#define MXC_CCM_CCR_OSCNT_MASK				0xFF
+#endif
+#define MXC_CCM_CCR_OSCNT_OFFSET			0
+
+/* Define the bits in register CCDR */
+#define MXC_CCM_CCDR_MMDC_CH1_HS_MASK			(1 << 16)
+#define MXC_CCM_CCDR_MMDC_CH0_HS_MASK			(1 << 17)
+/* Exists on i.MX6QP */
+#define MXC_CCM_CCDR_MMDC_CH1_AXI_ROOT_CG		(1 << 18)
+
+/* Define the bits in register CSR */
+#define MXC_CCM_CSR_COSC_READY				(1 << 5)
+#define MXC_CCM_CSR_REF_EN_B				(1 << 0)
+
+/* Define the bits in register CCSR */
+#define MXC_CCM_CCSR_PDF_540M_AUTO_DIS			(1 << 15)
+#define MXC_CCM_CCSR_PDF_720M_AUTO_DIS			(1 << 14)
+#define MXC_CCM_CCSR_PDF_454M_AUTO_DIS			(1 << 13)
+#define MXC_CCM_CCSR_PDF_508M_AUTO_DIS			(1 << 12)
+#define MXC_CCM_CCSR_PDF_594M_AUTO_DIS			(1 << 11)
+#define MXC_CCM_CCSR_PDF_352M_AUTO_DIS			(1 << 10)
+#define MXC_CCM_CCSR_PDF_400M_AUTO_DIS			(1 << 9)
+#define MXC_CCM_CCSR_STEP_SEL				(1 << 8)
+#define MXC_CCM_CCSR_PLL1_SW_CLK_SEL			(1 << 2)
+#define MXC_CCM_CCSR_PLL2_SW_CLK_SEL			(1 << 1)
+#define MXC_CCM_CCSR_PLL3_SW_CLK_SEL			(1 << 0)
+
+/* Define the bits in register CACRR */
+#define MXC_CCM_CACRR_ARM_PODF_OFFSET			0
+#define MXC_CCM_CACRR_ARM_PODF_MASK			0x7
+
+/* Define the bits in register CBCDR */
+#define MXC_CCM_CBCDR_PERIPH_CLK2_PODF_MASK		(0x7 << 27)
+#define MXC_CCM_CBCDR_PERIPH_CLK2_PODF_OFFSET		27
+#define MXC_CCM_CBCDR_PERIPH2_CLK_SEL			(1 << 26)
+#define MXC_CCM_CBCDR_PERIPH_CLK_SEL			(1 << 25)
+/* MMDC_CH0 not exists on i.MX6SX */
+#define MXC_CCM_CBCDR_MMDC_CH0_PODF_MASK		(0x7 << 19)
+#define MXC_CCM_CBCDR_MMDC_CH0_PODF_OFFSET		19
+#define MXC_CCM_CBCDR_AXI_PODF_MASK			(0x7 << 16)
+#define MXC_CCM_CBCDR_AXI_PODF_OFFSET			16
+#define MXC_CCM_CBCDR_AHB_PODF_MASK			(0x7 << 10)
+#define MXC_CCM_CBCDR_AHB_PODF_OFFSET			10
+#define MXC_CCM_CBCDR_IPG_PODF_MASK			(0x3 << 8)
+#define MXC_CCM_CBCDR_IPG_PODF_OFFSET			8
+#define MXC_CCM_CBCDR_AXI_ALT_SEL			(1 << 7)
+#define MXC_CCM_CBCDR_AXI_SEL				(1 << 6)
+#define MXC_CCM_CBCDR_MMDC_CH1_PODF_MASK		(0x7 << 3)
+#define MXC_CCM_CBCDR_MMDC_CH1_PODF_OFFSET		3
+#define MXC_CCM_CBCDR_PERIPH2_CLK2_PODF_MASK		(0x7 << 0)
+#define MXC_CCM_CBCDR_PERIPH2_CLK2_PODF_OFFSET		0
+
+/* Define the bits in register CBCMR */
+#define MXC_CCM_CBCMR_GPU3D_SHADER_PODF_MASK		(0x7 << 29)
+#define MXC_CCM_CBCMR_GPU3D_SHADER_PODF_OFFSET		29
+#define MXC_CCM_CBCMR_GPU3D_CORE_PODF_MASK		(0x7 << 26)
+#define MXC_CCM_CBCMR_GPU3D_CORE_PODF_OFFSET		26
+/* LCDIF on i.MX6SX/UL/SLL */
+#define MXC_CCM_CBCMR_LCDIF1_PODF_MASK                  (0x7 << 23)
+#define MXC_CCM_CBCMR_LCDIF1_PODF_OFFSET                23
+#define MXC_CCM_CBCMR_GPU2D_CORE_CLK_PODF_MASK		(0x7 << 23)
+#define MXC_CCM_CBCMR_GPU2D_CORE_CLK_PODF_OFFSET		23
+
+/* For i.MX6SL */
+#define MXC_CCM_CBCMR_GPU2D_CORE_PODF_MASK		(0x7 << 29)
+#define MXC_CCM_CBCMR_GPU2D_CORE_PODF_OFFSET		29
+#define MXC_CCM_CBCMR_GPU2D_OVG_CORE_PODF_MASK		(0x7 << 26)
+#define MXC_CCM_CBCMR_GPU2D_OVG_CORE_PODF_OFFSET		26
+#define MXC_CCM_CBCMR_EPDC_PIX_PODF_MASK		(0x7 << 23)
+#define MXC_CCM_CBCMR_EPDC_PIX_PODF_OFFSET		23
+
+#define MXC_CCM_CBCMR_PRE_PERIPH2_CLK_SEL_MASK		(0x3 << 21)
+#define MXC_CCM_CBCMR_PRE_PERIPH2_CLK_SEL_OFFSET	21
+#define MXC_CCM_CBCMR_PERIPH2_CLK2_SEL			(1 << 20)
+#define MXC_CCM_CBCMR_PRE_PERIPH_CLK_SEL_MASK		(0x3 << 18)
+#define MXC_CCM_CBCMR_PRE_PERIPH_CLK_SEL_OFFSET		18
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CBCMR_GPU2D_CLK_SEL_MASK		(0x3 << 16)
+#define MXC_CCM_CBCMR_GPU2D_CLK_SEL_OFFSET		16
+#define MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_MASK		(0x3 << 14)
+#define MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_OFFSET		14
+#endif
+#define MXC_CCM_CBCMR_PERIPH_CLK2_SEL_MASK		(0x3 << 12)
+#define MXC_CCM_CBCMR_PERIPH_CLK2_SEL_OFFSET		12
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CBCMR_VDOAXI_CLK_SEL			(1 << 11)
+#endif
+#define MXC_CCM_CBCMR_PCIE_AXI_CLK_SEL			(1 << 10)
+#define MXC_CCM_CBCMR_GPU3D_SHADER_CLK_SEL_MASK		(0x3 << 8)
+#define MXC_CCM_CBCMR_GPU3D_SHADER_CLK_SEL_OFFSET	8
+#define MXC_CCM_CBCMR_GPU3D_CORE_CLK_SEL_MASK		(0x3 << 4)
+#define MXC_CCM_CBCMR_GPU3D_CORE_CLK_SEL_OFFSET		4
+
+/* For i.MX6SL */
+#define MXC_CCM_CBCMR_GPU2D_CORE_CLK_SEL_MASK		(0x3 << 8)
+#define MXC_CCM_CBCMR_GPU2D_CORE_CLK_SEL_OFFSET	8
+#define MXC_CCM_CBCMR_GPU2D_OVG_CORE_CLK_SEL_MASK		(0x3 << 4)
+#define MXC_CCM_CBCMR_GPU2D_OVG_CORE_CLK_SEL_OFFSET		4
+
+
+/* Exists on i.MX6QP */
+#define MXC_CCM_CBCMR_PRE_CLK_SEL			(1 << 1)
+
+/* Define the bits in register CSCMR1 */
+#define MXC_CCM_CSCMR1_ACLK_EMI_SLOW_MASK		(0x3 << 29)
+#define MXC_CCM_CSCMR1_ACLK_EMI_SLOW_OFFSET		29
+/* QSPI1 exist on i.MX6SX/UL */
+#define MXC_CCM_CSCMR1_QSPI1_PODF_MASK			(0x7 << 26)
+#define MXC_CCM_CSCMR1_QSPI1_PODF_OFFSET		26
+#define MXC_CCM_CSCMR1_ACLK_EMI_MASK			(0x3 << 27)
+#define MXC_CCM_CSCMR1_ACLK_EMI_OFFSET			27
+#define MXC_CCM_CSCMR1_ACLK_EMI_SLOW_PODF_MASK		(0x7 << 23)
+#define MXC_CCM_CSCMR1_ACLK_EMI_SLOW_PODF_OFFSET	23
+/* LCFIF2_PODF on i.MX6SX */
+#define MXC_CCM_CSCMR1_LCDIF2_PODF_MASK			(0x7 << 20)
+#define MXC_CCM_CSCMR1_LCDIF2_PODF_OFFSET               20
+/* LCDIF_PIX_PODF on i.MX6SL */
+#define MXC_CCM_CSCMR1_LCDIF_PIX_PODF_MASK			(0x7 << 20)
+#define MXC_CCM_CSCMR1_LCDIF_PIX_PODF_OFFSET               20
+/* ACLK_EMI on i.MX6DQ/SDL/DQP */
+#define MXC_CCM_CSCMR1_ACLK_EMI_PODF_MASK		(0x7 << 20)
+#define MXC_CCM_CSCMR1_ACLK_EMI_PODF_OFFSET		20
+/* CSCMR1_GPMI/BCH exist on i.MX6UL */
+#define MXC_CCM_CSCMR1_GPMI_CLK_SEL			(1 << 19)
+#define MXC_CCM_CSCMR1_BCH_CLK_SEL			(1 << 18)
+#define MXC_CCM_CSCMR1_USDHC4_CLK_SEL			(1 << 19)
+#define MXC_CCM_CSCMR1_USDHC3_CLK_SEL			(1 << 18)
+#define MXC_CCM_CSCMR1_USDHC2_CLK_SEL			(1 << 17)
+#define MXC_CCM_CSCMR1_USDHC1_CLK_SEL			(1 << 16)
+#define MXC_CCM_CSCMR1_SSI3_CLK_SEL_MASK		(0x3 << 14)
+#define MXC_CCM_CSCMR1_SSI3_CLK_SEL_OFFSET		14
+#define MXC_CCM_CSCMR1_SSI2_CLK_SEL_MASK		(0x3 << 12)
+#define MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET		12
+#define MXC_CCM_CSCMR1_SSI1_CLK_SEL_MASK		(0x3 << 10)
+#define MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET		10
+/* QSPI1 exist on i.MX6SX/UL */
+#define MXC_CCM_CSCMR1_QSPI1_CLK_SEL_MASK		(0x7 << 7)
+#define MXC_CCM_CSCMR1_QSPI1_CLK_SEL_OFFSET		7
+/* CSCMR1_PER_CLK exists on i.MX6SX/SL/QP */
+#define MXC_CCM_CSCMR1_PER_CLK_SEL_MASK (1 << 6)
+#define MXC_CCM_CSCMR1_PER_CLK_SEL_OFFSET		6
+
+#define MXC_CCM_CSCMR1_PERCLK_PODF_MASK			0x3F
+
+/* Define the bits in register CSCMR2 */
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CSCMR2_VID_CLK_SEL_MASK			(0x7 << 21)
+#define MXC_CCM_CSCMR2_VID_CLK_SEL_OFFSET		21
+#endif
+#define MXC_CCM_CSCMR2_ESAI_PRE_SEL_MASK		(0x3 << 19)
+#define MXC_CCM_CSCMR2_ESAI_PRE_SEL_OFFSET		19
+#define MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV			(1 << 11)
+#define MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV			(1 << 10)
+/* CSCMR1_CAN_CLK exists on i.MX6SX/QP */
+#define MXC_CCM_CSCMR2_CAN_CLK_SEL_MASK			(0x3 << 8)
+#define MXC_CCM_CSCMR2_CAN_CLK_SEL_OFFSET		8
+
+#define MXC_CCM_CSCMR2_CAN_CLK_PODF_MASK		(0x3F << 2)
+#define MXC_CCM_CSCMR2_CAN_CLK_PODF_OFFSET		2
+
+/* Define the bits in register CSCDR1 */
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CSCDR1_VPU_AXI_PODF_MASK		(0x7 << 25)
+#define MXC_CCM_CSCDR1_VPU_AXI_PODF_OFFSET		25
+#endif
+/* CSCDR1_GPMI/BCH exist on i.MX6UL */
+#define MXC_CCM_CSCDR1_GPMI_PODF_MASK			(0x7 << 22)
+#define MXC_CCM_CSCDR1_GPMI_PODF_OFFSET			22
+#define MXC_CCM_CSCDR1_BCH_PODF_MASK			(0x7 << 19)
+#define MXC_CCM_CSCDR1_BCH_PODF_OFFSET			19
+
+#define MXC_CCM_CSCDR1_USDHC4_PODF_MASK			(0x7 << 22)
+#define MXC_CCM_CSCDR1_USDHC4_PODF_OFFSET		22
+#define MXC_CCM_CSCDR1_USDHC3_PODF_MASK			(0x7 << 19)
+#define MXC_CCM_CSCDR1_USDHC3_PODF_OFFSET		19
+#define MXC_CCM_CSCDR1_USDHC2_PODF_MASK			(0x7 << 16)
+#define MXC_CCM_CSCDR1_USDHC2_PODF_OFFSET		16
+#define MXC_CCM_CSCDR1_USDHC1_PODF_MASK			(0x7 << 11)
+#define MXC_CCM_CSCDR1_USDHC1_PODF_OFFSET		11
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET		8
+#define MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK		(0x7 << 8)
+#define MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET		6
+#define MXC_CCM_CSCDR1_USBOH3_CLK_PODF_MASK		(0x3 << 6)
+#endif
+#define MXC_CCM_CSCDR1_UART_CLK_PODF_MASK		0x3F
+#define MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET		0
+/* UART_CLK_SEL exists on i.MX6SL/SX/QP */
+#define MXC_CCM_CSCDR1_UART_CLK_SEL			(1 << 6)
+
+/* Define the bits in register CS1CDR */
+/* MX6UL, !MX6ULL */
+#define MXC_CCM_CS1CDR_SAI3_CLK_PRED_MASK		(0x7 << 22)
+#define MXC_CCM_CS1CDR_SAI3_CLK_PRED_OFFSET		22
+#define MXC_CCM_CS1CDR_SAI3_CLK_PODF_MASK		(0x3F << 16)
+#define MXC_CCM_CS1CDR_SAI3_CLK_PODF_OFFSET		16
+#define MXC_CCM_CS1CDR_SAI1_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CS1CDR_SAI1_CLK_PRED_OFFSET		6
+#define MXC_CCM_CS1CDR_SAI1_CLK_PODF_MASK		0x3F
+#define MXC_CCM_CS1CDR_SAI1_CLK_PODF_OFFSET		0
+
+#define MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK		(0x3F << 25)
+#define MXC_CCM_CS1CDR_ESAI_CLK_PODF_OFFSET		25
+#define MXC_CCM_CS1CDR_SSI3_CLK_PRED_MASK		(0x7 << 22)
+#define MXC_CCM_CS1CDR_SSI3_CLK_PRED_OFFSET		22
+#define MXC_CCM_CS1CDR_SSI3_CLK_PODF_MASK		(0x3F << 16)
+#define MXC_CCM_CS1CDR_SSI3_CLK_PODF_OFFSET		16
+#define MXC_CCM_CS1CDR_ESAI_CLK_PRED_MASK		(0x3 << 9)
+#define MXC_CCM_CS1CDR_ESAI_CLK_PRED_OFFSET		9
+#define MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET		6
+#define MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK		0x3F
+#define MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET		0
+
+/* Define the bits in register CS2CDR */
+/* QSPI2 on i.MX6SX */
+#define MXC_CCM_CS2CDR_QSPI2_CLK_PODF_MASK             (0x3F << 21)
+#define MXC_CCM_CS2CDR_QSPI2_CLK_PODF_OFFSET           21
+#define MXC_CCM_CS2CDR_QSPI2_CLK_PODF(v)                       (((v) & 0x3f) << 21)
+#define MXC_CCM_CS2CDR_QSPI2_CLK_PRED_MASK             (0x7 << 18)
+#define MXC_CCM_CS2CDR_QSPI2_CLK_PRED_OFFSET           18
+#define MXC_CCM_CS2CDR_QSPI2_CLK_PRED(v)                       (((v) & 0x7) << 18)
+#define MXC_CCM_CS2CDR_QSPI2_CLK_SEL_MASK              (0x7 << 15)
+#define MXC_CCM_CS2CDR_QSPI2_CLK_SEL_OFFSET            15
+#define MXC_CCM_CS2CDR_QSPI2_CLK_SEL(v)                        (((v) & 0x7) << 15)
+
+#define MXC_CCM_CS2CDR_ENFC_CLK_PODF_MASK		(0x3F << 21)
+#define MXC_CCM_CS2CDR_ENFC_CLK_PODF_OFFSET		21
+#define MXC_CCM_CS2CDR_ENFC_CLK_PODF(v)			(((v) & 0x3f) << 21)
+#define MXC_CCM_CS2CDR_ENFC_CLK_PRED_MASK		(0x7 << 18)
+#define MXC_CCM_CS2CDR_ENFC_CLK_PRED_OFFSET		18
+#define MXC_CCM_CS2CDR_ENFC_CLK_PRED(v)			(((v) & 0x7) << 18)
+
+#define MXC_CCM_CS2CDR_ENFC_CLK_SEL_MASK_DQP		(0x7 << 15)
+#define MXC_CCM_CS2CDR_ENFC_CLK_SEL_OFFSET_DQP		15
+#define MXC_CCM_CS2CDR_ENFC_CLK_SEL_DQP(v)		(((v) & 0x7) << 15)
+#define MXC_CCM_CS2CDR_ENFC_CLK_SEL_MASK_DQ		(0x3 << 16)
+#define MXC_CCM_CS2CDR_ENFC_CLK_SEL_OFFSET_DQ		16
+#define MXC_CCM_CS2CDR_ENFC_CLK_SEL_DQ(v)		(((v) & 0x3) << 16)
+
+#define MXC_CCM_CS2CDR_ENFC_CLK_SEL_MASK		\
+	((is_mx6dqp() || is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL)) ? \
+	 MXC_CCM_CS2CDR_ENFC_CLK_SEL_MASK_DQP :		\
+	 MXC_CCM_CS2CDR_ENFC_CLK_SEL_MASK_DQ)
+#define MXC_CCM_CS2CDR_ENFC_CLK_SEL_OFFSET		\
+	((is_mx6dqp() || is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL)) ? \
+	 MXC_CCM_CS2CDR_ENFC_CLK_SEL_OFFSET_DQP :	\
+	 MXC_CCM_CS2CDR_ENFC_CLK_SEL_OFFSET_DQ)
+#define MXC_CCM_CS2CDR_ENFC_CLK_SEL(v)			\
+	((is_mx6dqp() || is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL)) ? \
+	 MXC_CCM_CS2CDR_ENFC_CLK_SEL_DQP(v) :		\
+	 MXC_CCM_CS2CDR_ENFC_CLK_SEL_DQ(v))
+
+#define MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK		(0x7 << 12)
+#define MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET		12
+#define MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK		(0x7 << 9)
+#define MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET		9
+#define MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET		6
+#define MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK		0x3F
+#define MXC_CCM_CS2CDR_SSI2_CLK_PODF_OFFSET		0
+
+/* Define the bits in register CDCDR */
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CDCDR_HSI_TX_PODF_MASK			(0x7 << 29)
+#define MXC_CCM_CDCDR_HSI_TX_PODF_OFFSET		29
+#define MXC_CCM_CDCDR_HSI_TX_CLK_SEL			(1 << 28)
+#endif
+#define MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK		(0x7 << 25)
+#define MXC_CCM_CDCDR_SPDIF0_CLK_PRED_OFFSET		25
+#define MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK		(0x7 << 22)
+#define MXC_CCM_CDCDR_SPDIF0_CLK_PODF_OFFSET		22
+#define MXC_CCM_CDCDR_SPDIF0_CLK_SEL_MASK		(0x3 << 20)
+#define MXC_CCM_CDCDR_SPDIF0_CLK_SEL_OFFSET		20
+#define MXC_CCM_CDCDR_SPDIF1_CLK_PRED_MASK		(0x7 << 12)
+#define MXC_CCM_CDCDR_SPDIF1_CLK_PRED_OFFSET		12
+#define MXC_CCM_CDCDR_SPDIF1_CLK_PODF_MASK		(0x7 << 9)
+#define MXC_CCM_CDCDR_SPDIF1_CLK_PODF_OFFSET		9
+#define MXC_CCM_CDCDR_SPDIF1_CLK_SEL_MASK		(0x3 << 7)
+#define MXC_CCM_CDCDR_SPDIF1_CLK_SEL_OFFSET		7
+
+/* Define the bits in register CHSCCDR */
+/* i.MX 6SX */
+#define MXC_CCM_CHSCCDR_ENET_PRE_CLK_SEL_MASK		(0x7 << 15)
+#define MXC_CCM_CHSCCDR_ENET_PRE_CLK_SEL_OFFSET		15
+#define MXC_CCM_CHSCCDR_ENET_PODF_MASK			(0x7 << 12)
+#define MXC_CCM_CHSCCDR_ENET_PODF_OFFSET		12
+#define MXC_CCM_CHSCCDR_ENET_CLK_SEL_MASK		(0x7 << 9)
+#define MXC_CCM_CHSCCDR_ENET_CLK_SEL_OFFSET		9
+#define MXC_CCM_CHSCCDR_M4_PRE_CLK_SEL_MASK		(0x7 << 6)
+#define MXC_CCM_CHSCCDR_M4_PRE_CLK_SEL_OFFSET		6
+#define MXC_CCM_CHSCCDR_M4_PODF_MASK			(0x7 << 3)
+#define MXC_CCM_CHSCCDR_M4_PODF_OFFSET			3
+#define MXC_CCM_CHSCCDR_M4_CLK_SEL_MASK			(0x7)
+#define MXC_CCM_CHSCCDR_M4_CLK_SEL_OFFSET		0
+
+#define MXC_CCM_CHSCCDR_IPU1_DI1_PRE_CLK_SEL_MASK	(0x7 << 15)
+#define MXC_CCM_CHSCCDR_IPU1_DI1_PRE_CLK_SEL_OFFSET	15
+#define MXC_CCM_CHSCCDR_IPU1_DI1_PODF_MASK		(0x7 << 12)
+#define MXC_CCM_CHSCCDR_IPU1_DI1_PODF_OFFSET		12
+#define MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_MASK		(0x7 << 9)
+#define MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET		9
+#define MXC_CCM_CHSCCDR_IPU1_DI0_PRE_CLK_SEL_MASK	(0x7 << 6)
+#define MXC_CCM_CHSCCDR_IPU1_DI0_PRE_CLK_SEL_OFFSET	6
+#define MXC_CCM_CHSCCDR_IPU1_DI0_PODF_MASK		(0x7 << 3)
+#define MXC_CCM_CHSCCDR_IPU1_DI0_PODF_OFFSET		3
+#define MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_MASK		(0x7)
+#define MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET		0
+
+/* i.MX6ULL/SLL */
+#define MXC_CCM_CHSCCDR_EPDC_PRE_CLK_SEL_MASK		(0x7 << 15)
+#define MXC_CCM_CHSCCDR_EPDC_PRE_CLK_SEL_OFFSET		15
+#define MXC_CCM_CHSCCDR_EPDC_PODF_MASK			(0x7 << 12)
+#define MXC_CCM_CHSCCDR_EPDC_PODF_OFFSET			12
+#define MXC_CCM_CHSCCDR_EPDC_CLK_SEL_MASK		(0x7 << 9)
+#define MXC_CCM_CHSCCDR_EPDC_CLK_SEL_OFFSET		9
+
+#define CHSCCDR_CLK_SEL_LDB_DI0				3
+#define CHSCCDR_PODF_DIVIDE_BY_3			2
+#define CHSCCDR_IPU_PRE_CLK_540M_PFD			5
+
+/* Define the bits in register CSCDR2 */
+#define MXC_CCM_CSCDR2_ECSPI_CLK_PODF_MASK		(0x3F << 19)
+#define MXC_CCM_CSCDR2_ECSPI_CLK_PODF_OFFSET		19
+/* ECSPI_CLK_SEL exists on i.MX6SX/SL/QP */
+#define MXC_CCM_CSCDR2_ECSPI_CLK_SEL_MASK		(0x1 << 18)
+/* LCDIF1 on i.MX6SX/UL/SLL */
+#define MXC_CCM_CSCDR2_LCDIF1_PRED_SEL_MASK             (0x7 << 15)
+#define MXC_CCM_CSCDR2_LCDIF1_PRED_SEL_OFFSET           15
+#define MXC_CCM_CSCDR2_LCDIF1_PRE_DIV_MASK              (0x7 << 12)
+#define MXC_CCM_CSCDR2_LCDIF1_PRE_DIV_OFFSET            12
+#define MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_MASK              (0x7 << 9)
+#define MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_OFFSET            9
+
+/* EPDC on i.MX6SL */
+#define MXC_CCM_CSCDR2_EPDC_PIX_CLK_SEL_MASK             (0x7 << 15)
+#define MXC_CCM_CSCDR2_EPDC_PIX_CLK_SEL_OFFSET           15
+#define MXC_CCM_CSCDR2_EPDC_PIX_PRE_DIV_MASK              (0x7 << 12)
+#define MXC_CCM_CSCDR2_EPDC_PIX_PRE_DIV_OFFSET            12
+
+/* LCDIF2 on i.MX6SX */
+#define MXC_CCM_CSCDR2_LCDIF2_PRED_SEL_MASK             (0x7 << 6)
+#define MXC_CCM_CSCDR2_LCDIF2_PRED_SEL_OFFSET           6
+#define MXC_CCM_CSCDR2_LCDIF2_PRE_DIV_MASK              (0x7 << 3)
+#define MXC_CCM_CSCDR2_LCDIF2_PRE_DIV_OFFSET            3
+#define MXC_CCM_CSCDR2_LCDIF2_CLK_SEL_MASK              (0x7 << 0)
+#define MXC_CCM_CSCDR2_LCDIF2_CLK_SEL_OFFSET             0
+
+/*LCD on i.MX6SL */
+#define MXC_CCM_CSCDR2_LCDIF_PIX_CLK_SEL_MASK             (0x7 << 6)
+#define MXC_CCM_CSCDR2_LCDIF_PIX_CLK_SEL_OFFSET           6
+#define MXC_CCM_CSCDR2_LCDIF_PIX_PRE_DIV_MASK              (0x7 << 3)
+#define MXC_CCM_CSCDR2_LCDIF_PIX_PRE_DIV_OFFSET            3
+
+
+/* All IPU2_DI1 are LCDIF1 on MX6SX */
+#define MXC_CCM_CHSCCDR_IPU2_DI1_PRE_CLK_SEL_MASK	(0x7 << 15)
+#define MXC_CCM_CHSCCDR_IPU2_DI1_PRE_CLK_SEL_OFFSET	15
+#define MXC_CCM_CHSCCDR_IPU2_DI1_PODF_MASK		(0x7 << 12)
+#define MXC_CCM_CHSCCDR_IPU2_DI1_PODF_OFFSET		12
+#define MXC_CCM_CHSCCDR_IPU2_DI1_CLK_SEL_MASK		(0x7 << 9)
+#define MXC_CCM_CHSCCDR_IPU2_DI1_CLK_SEL_OFFSET		9
+/* All IPU2_DI0 are LCDIF2 on MX6SX */
+#define MXC_CCM_CHSCCDR_IPU2_DI0_PRE_CLK_SEL_MASK	(0x7 << 6)
+#define MXC_CCM_CHSCCDR_IPU2_DI0_PRE_CLK_SEL_OFFSET	6
+#define MXC_CCM_CHSCCDR_IPU2_DI0_PODF_MASK		(0x7 << 3)
+#define MXC_CCM_CHSCCDR_IPU2_DI0_PODF_OFFSET		3
+#define MXC_CCM_CHSCCDR_IPU2_DI0_CLK_SEL_MASK		0x7
+#define MXC_CCM_CHSCCDR_IPU2_DI0_CLK_SEL_OFFSET		0
+
+/* Define the bits in register CSCDR3 */
+#define MXC_CCM_CSCDR3_IPU2_HSP_PODF_MASK		(0x7 << 16)
+#define MXC_CCM_CSCDR3_IPU2_HSP_PODF_OFFSET		16
+#define MXC_CCM_CSCDR3_IPU2_HSP_CLK_SEL_MASK		(0x3 << 14)
+#define MXC_CCM_CSCDR3_IPU2_HSP_CLK_SEL_OFFSET		14
+#define MXC_CCM_CSCDR3_IPU1_HSP_PODF_MASK		(0x7 << 11)
+#define MXC_CCM_CSCDR3_IPU1_HSP_PODF_OFFSET		11
+#define MXC_CCM_CSCDR3_IPU1_HSP_CLK_SEL_MASK		(0x3 << 9)
+#define MXC_CCM_CSCDR3_IPU1_HSP_CLK_SEL_OFFSET		9
+
+/* For i.MX6SL */
+#define MXC_CCM_CSCDR3_LCDIF_AXI_PODF_MASK		(0x7 << 16)
+#define MXC_CCM_CSCDR3_LCDIF_AXI_PODF_OFFSET		16
+#define MXC_CCM_CSCDR3_LCDIF_AXI_CLK_SEL_MASK		(0x3 << 14)
+#define MXC_CCM_CSCDR3_LCDIF_AXI_CLK_SEL_OFFSET		14
+#define MXC_CCM_CSCDR3_CSI_CORE_PODF_MASK		(0x7 << 11)
+#define MXC_CCM_CSCDR3_CSI_CORE_PODF_OFFSET		11
+#define MXC_CCM_CSCDR3_CSI_CORE_CLK_SEL_MASK		(0x3 << 9)
+#define MXC_CCM_CSCDR3_CSI_CORE_CLK_SEL_OFFSET		9
+
+/* For i.MX6SLL */
+#define MXC_CCM_CSCDR3_PXP_PODF_MASK		(0x7 << 16)
+#define MXC_CCM_CSCDR3_PXP_PODF_OFFSET		16
+#define MXC_CCM_CSCDR3_PXP_CLK_SEL_MASK		(0x3 << 14)
+#define MXC_CCM_CSCDR3_PXP_CLK_SEL_OFFSET		14
+
+
+/* Define the bits in register CDHIPR */
+#define MXC_CCM_CDHIPR_ARM_PODF_BUSY			(1 << 16)
+#define MXC_CCM_CDHIPR_PERIPH_CLK_SEL_BUSY		(1 << 5)
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CDHIPR_MMDC_CH0_PODF_BUSY		(1 << 4)
+#endif
+#define MXC_CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY		(1 << 3)
+#define MXC_CCM_CDHIPR_MMDC_CH1_PODF_BUSY		(1 << 2)
+#define MXC_CCM_CDHIPR_AHB_PODF_BUSY			(1 << 1)
+#define MXC_CCM_CDHIPR_AXI_PODF_BUSY			1
+
+/* Define the bits in register CLPCR */
+#define MXC_CCM_CLPCR_MASK_L2CC_IDLE			(1 << 27)
+#define MXC_CCM_CLPCR_MASK_SCU_IDLE			(1 << 26)
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CLPCR_MASK_CORE3_WFI			(1 << 25)
+#define MXC_CCM_CLPCR_MASK_CORE2_WFI			(1 << 24)
+#define MXC_CCM_CLPCR_MASK_CORE1_WFI			(1 << 23)
+#endif
+#define MXC_CCM_CLPCR_MASK_CORE0_WFI			(1 << 22)
+#define MXC_CCM_CLPCR_BYP_MMDC_CH1_LPM_HS		(1 << 21)
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CLPCR_BYP_MMDC_CH0_LPM_HS		(1 << 19)
+#define MXC_CCM_CLPCR_WB_CORE_AT_LPM			(1 << 17)
+#endif
+#define MXC_CCM_CLPCR_WB_PER_AT_LPM			(1 << 16)
+#define MXC_CCM_CLPCR_COSC_PWRDOWN			(1 << 11)
+#define MXC_CCM_CLPCR_STBY_COUNT_MASK			(0x3 << 9)
+#define MXC_CCM_CLPCR_STBY_COUNT_OFFSET			9
+#define MXC_CCM_CLPCR_VSTBY				(1 << 8)
+#define MXC_CCM_CLPCR_DIS_REF_OSC			(1 << 7)
+#define MXC_CCM_CLPCR_SBYOS				(1 << 6)
+#define MXC_CCM_CLPCR_ARM_CLK_DIS_ON_LPM		(1 << 5)
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CLPCR_LPSR_CLK_SEL_MASK			(0x3 << 3)
+#define MXC_CCM_CLPCR_LPSR_CLK_SEL_OFFSET		3
+#define MXC_CCM_CLPCR_BYPASS_PMIC_VFUNC_READY		(1 << 2)
+#endif
+#define MXC_CCM_CLPCR_LPM_MASK				0x3
+#define MXC_CCM_CLPCR_LPM_OFFSET			0
+
+/* Define the bits in register CISR */
+#define MXC_CCM_CISR_ARM_PODF_LOADED			(1 << 26)
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CISR_MMDC_CH0_PODF_LOADED		(1 << 23)
+#endif
+#define MXC_CCM_CISR_PERIPH_CLK_SEL_LOADED		(1 << 22)
+#define MXC_CCM_CISR_MMDC_CH1_PODF_LOADED		(1 << 21)
+#define MXC_CCM_CISR_AHB_PODF_LOADED			(1 << 20)
+#define MXC_CCM_CISR_PERIPH2_CLK_SEL_LOADED		(1 << 19)
+#define MXC_CCM_CISR_AXI_PODF_LOADED			(1 << 17)
+#define MXC_CCM_CISR_COSC_READY				(1 << 6)
+#define MXC_CCM_CISR_LRF_PLL				1
+
+/* Define the bits in register CIMR */
+#define MXC_CCM_CIMR_MASK_ARM_PODF_LOADED		(1 << 26)
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CIMR_MASK_MMDC_CH0_PODF_LOADED		(1 << 23)
+#endif
+#define MXC_CCM_CIMR_MASK_PERIPH_CLK_SEL_LOADED		(1 << 22)
+#define MXC_CCM_CIMR_MASK_MMDC_CH1_PODF_LOADED		(1 << 21)
+#define MXC_CCM_CIMR_MASK_AHB_PODF_LOADED		(1 << 20)
+#define MXC_CCM_CIMR_MASK_PERIPH2_CLK_SEL_LOADED	(1 << 19)
+#define MXC_CCM_CIMR_MASK_AXI_PODF_LOADED		(1 << 17)
+#define MXC_CCM_CIMR_MASK_COSC_READY			(1 << 6)
+#define MXC_CCM_CIMR_MASK_LRF_PLL			1
+
+/* Define the bits in register CCOSR */
+#define MXC_CCM_CCOSR_CKO2_EN_OFFSET			(1 << 24)
+#define MXC_CCM_CCOSR_CKO2_DIV_MASK			(0x7 << 21)
+#define MXC_CCM_CCOSR_CKO2_DIV_OFFSET			21
+#define MXC_CCM_CCOSR_CKO2_SEL_OFFSET			16
+#define MXC_CCM_CCOSR_CKO2_SEL_MASK			(0x1F << 16)
+#define MXC_CCM_CCOSR_CLK_OUT_SEL			(0x1 << 8)
+#define MXC_CCM_CCOSR_CKOL_EN				(0x1 << 7)
+#define MXC_CCM_CCOSR_CKOL_DIV_MASK			(0x7 << 4)
+#define MXC_CCM_CCOSR_CKOL_DIV_OFFSET			4
+#define MXC_CCM_CCOSR_CKOL_SEL_MASK			0xF
+#define MXC_CCM_CCOSR_CKOL_SEL_OFFSET			0
+
+/* Define the bits in registers CGPR */
+#define MXC_CCM_CGPR_FAST_PLL_EN			(1 << 16)
+#define MXC_CCM_CGPR_EFUSE_PROG_SUPPLY_GATE		(1 << 4)
+#define MXC_CCM_CGPR_MMDC_EXT_CLK_DIS			(1 << 2)
+#define MXC_CCM_CGPR_PMIC_DELAY_SCALER			1
+
+/* Define the bits in registers CCGRx */
+#define MXC_CCM_CCGR_CG_MASK				3
+
+/* i.MX 6ULL */
+#define MXC_CCM_CCGR0_DCP_CLK_OFFSET		10
+#define MXC_CCM_CCGR0_DCP_CLK_MASK		(3 << MXC_CCM_CCGR0_DCP_CLK_OFFSET)
+#define MXC_CCM_CCGR0_ENET_CLK_ENABLE_OFFSET	12
+#define MXC_CCM_CCGR0_ENET_CLK_ENABLE_MASK	(3 << MXC_CCM_CCGR0_ENET_CLK_ENABLE_OFFSET)
+
+#define MXC_CCM_CCGR0_AIPS_TZ1_OFFSET			0
+#define MXC_CCM_CCGR0_AIPS_TZ1_MASK			(3 << MXC_CCM_CCGR0_AIPS_TZ1_OFFSET)
+#define MXC_CCM_CCGR0_AIPS_TZ2_OFFSET			2
+#define MXC_CCM_CCGR0_AIPS_TZ2_MASK			(3 << MXC_CCM_CCGR0_AIPS_TZ2_OFFSET)
+#define MXC_CCM_CCGR0_APBHDMA_OFFSET			4
+#define MXC_CCM_CCGR0_APBHDMA_MASK			(3 << MXC_CCM_CCGR0_APBHDMA_OFFSET)
+#define MXC_CCM_CCGR0_ASRC_OFFSET			6
+#define MXC_CCM_CCGR0_ASRC_MASK				(3 << MXC_CCM_CCGR0_ASRC_OFFSET)
+#define MXC_CCM_CCGR0_CAAM_SECURE_MEM_OFFSET		8
+#define MXC_CCM_CCGR0_CAAM_SECURE_MEM_MASK		(3 << MXC_CCM_CCGR0_CAAM_SECURE_MEM_OFFSET)
+#define MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_OFFSET		10
+#define MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_MASK		(3 << MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_OFFSET)
+#define MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_OFFSET		12
+#define MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_MASK		(3 << MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_OFFSET)
+#define MXC_CCM_CCGR0_CAN1_OFFSET			14
+#define MXC_CCM_CCGR0_CAN1_MASK				(3 << MXC_CCM_CCGR0_CAN1_OFFSET)
+#define MXC_CCM_CCGR0_CAN1_SERIAL_OFFSET		16
+#define MXC_CCM_CCGR0_CAN1_SERIAL_MASK			(3 << MXC_CCM_CCGR0_CAN1_SERIAL_OFFSET)
+#define MXC_CCM_CCGR0_CAN2_OFFSET			18
+#define MXC_CCM_CCGR0_CAN2_MASK				(3 << MXC_CCM_CCGR0_CAN2_OFFSET)
+#define MXC_CCM_CCGR0_CAN2_SERIAL_OFFSET		20
+#define MXC_CCM_CCGR0_CAN2_SERIAL_MASK			(3 << MXC_CCM_CCGR0_CAN2_SERIAL_OFFSET)
+#define MXC_CCM_CCGR0_CHEETAH_DBG_CLK_OFFSET		22
+#define MXC_CCM_CCGR0_CHEETAH_DBG_CLK_MASK		(3 << MXC_CCM_CCGR0_CHEETAH_DBG_CLK_OFFSET)
+#define MXC_CCM_CCGR0_DCIC1_OFFSET			24
+#define MXC_CCM_CCGR0_DCIC1_MASK			(3 << MXC_CCM_CCGR0_DCIC1_OFFSET)
+#define MXC_CCM_CCGR0_DCIC2_OFFSET			26
+#define MXC_CCM_CCGR0_DCIC2_MASK			(3 << MXC_CCM_CCGR0_DCIC2_OFFSET)
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CCGR0_AIPS_TZ3_OFFSET			30
+#define MXC_CCM_CCGR0_AIPS_TZ3_MASK			(3 << MXC_CCM_CCGR0_AIPS_TZ3_OFFSET)
+#else
+#define MXC_CCM_CCGR0_DTCP_OFFSET			28
+#define MXC_CCM_CCGR0_DTCP_MASK				(3 << MXC_CCM_CCGR0_DTCP_OFFSET)
+#endif
+
+#define MXC_CCM_CCGR1_ECSPI1S_OFFSET			0
+#define MXC_CCM_CCGR1_ECSPI1S_MASK			(3 << MXC_CCM_CCGR1_ECSPI1S_OFFSET)
+#define MXC_CCM_CCGR1_ECSPI2S_OFFSET			2
+#define MXC_CCM_CCGR1_ECSPI2S_MASK			(3 << MXC_CCM_CCGR1_ECSPI2S_OFFSET)
+#define MXC_CCM_CCGR1_ECSPI3S_OFFSET			4
+#define MXC_CCM_CCGR1_ECSPI3S_MASK			(3 << MXC_CCM_CCGR1_ECSPI3S_OFFSET)
+#define MXC_CCM_CCGR1_ECSPI4S_OFFSET			6
+#define MXC_CCM_CCGR1_ECSPI4S_MASK			(3 << MXC_CCM_CCGR1_ECSPI4S_OFFSET)
+#define MXC_CCM_CCGR1_ECSPI5S_OFFSET			8
+#define MXC_CCM_CCGR1_ECSPI5S_MASK			(3 << MXC_CCM_CCGR1_ECSPI5S_OFFSET)
+/* CCGR1_ENET does not exist on i.MX6SX/UL */
+#define MXC_CCM_CCGR1_ENET_OFFSET			10
+#define MXC_CCM_CCGR1_ENET_MASK				(3 << MXC_CCM_CCGR1_ENET_OFFSET)
+#define MXC_CCM_CCGR1_EPIT1S_OFFSET			12
+#define MXC_CCM_CCGR1_EPIT1S_MASK			(3 << MXC_CCM_CCGR1_EPIT1S_OFFSET)
+#define MXC_CCM_CCGR1_EPIT2S_OFFSET			14
+#define MXC_CCM_CCGR1_EPIT2S_MASK			(3 << MXC_CCM_CCGR1_EPIT2S_OFFSET)
+#define MXC_CCM_CCGR1_ESAIS_OFFSET			16
+#define MXC_CCM_CCGR1_ESAIS_MASK			(3 << MXC_CCM_CCGR1_ESAIS_OFFSET)
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CCGR1_WAKEUP_OFFSET			18
+#define MXC_CCM_CCGR1_WAKEUP_MASK			(3 << MXC_CCM_CCGR1_WAKEUP_OFFSET)
+#endif
+#define MXC_CCM_CCGR1_GPT_BUS_OFFSET			20
+#define MXC_CCM_CCGR1_GPT_BUS_MASK			(3 << MXC_CCM_CCGR1_GPT_BUS_OFFSET)
+#define MXC_CCM_CCGR1_GPT_SERIAL_OFFSET			22
+#define MXC_CCM_CCGR1_GPT_SERIAL_MASK			(3 << MXC_CCM_CCGR1_GPT_SERIAL_OFFSET)
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CCGR1_GPU2D_OFFSET			24
+#define MXC_CCM_CCGR1_GPU2D_MASK			(3 << MXC_CCM_CCGR1_GPU2D_OFFSET)
+#endif
+#define MXC_CCM_CCGR1_GPU3D_OFFSET			26
+#define MXC_CCM_CCGR1_GPU3D_MASK			(3 << MXC_CCM_CCGR1_GPU3D_OFFSET)
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CCGR1_OCRAM_S_OFFSET			28
+#define MXC_CCM_CCGR1_OCRAM_S_MASK			(3 << MXC_CCM_CCGR1_OCRAM_S_OFFSET)
+#define MXC_CCM_CCGR1_CANFD_OFFSET			30
+#define MXC_CCM_CCGR1_CANFD_MASK			(3 << MXC_CCM_CCGR1_CANFD_OFFSET)
+#endif
+
+#define MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_OFFSET		0
+#define MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_MASK		(3 << MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_OFFSET)
+
+/* i.MX6SX/UL */
+#define MXC_CCM_CCGR2_CSI_OFFSET			2
+#define MXC_CCM_CCGR2_CSI_MASK				(3 << MXC_CCM_CCGR2_CSI_OFFSET)
+
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_OFFSET		4
+#define MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_MASK		(3 << MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_OFFSET)
+#endif
+#define MXC_CCM_CCGR2_I2C1_SERIAL_OFFSET		6
+#define MXC_CCM_CCGR2_I2C1_SERIAL_MASK			(3 << MXC_CCM_CCGR2_I2C1_SERIAL_OFFSET)
+#define MXC_CCM_CCGR2_I2C2_SERIAL_OFFSET		8
+#define MXC_CCM_CCGR2_I2C2_SERIAL_MASK			(3 << MXC_CCM_CCGR2_I2C2_SERIAL_OFFSET)
+#define MXC_CCM_CCGR2_I2C3_SERIAL_OFFSET		10
+#define MXC_CCM_CCGR2_I2C3_SERIAL_MASK			(3 << MXC_CCM_CCGR2_I2C3_SERIAL_OFFSET)
+#define MXC_CCM_CCGR1_I2C4_SERIAL_OFFSET		8
+#define MXC_CCM_CCGR1_I2C4_SERIAL_MASK			(3 << MXC_CCM_CCGR1_I2C4_SERIAL_OFFSET)
+#define MXC_CCM_CCGR2_OCOTP_CTRL_OFFSET			12
+#define MXC_CCM_CCGR2_OCOTP_CTRL_MASK			(3 << MXC_CCM_CCGR2_OCOTP_CTRL_OFFSET)
+#define MXC_CCM_CCGR2_IOMUX_IPT_CLK_IO_OFFSET		14
+#define MXC_CCM_CCGR2_IOMUX_IPT_CLK_IO_MASK		(3 << MXC_CCM_CCGR2_IOMUX_IPT_CLK_IO_OFFSET)
+#define MXC_CCM_CCGR2_IPMUX1_OFFSET			16
+#define MXC_CCM_CCGR2_IPMUX1_MASK			(3 << MXC_CCM_CCGR2_IPMUX1_OFFSET)
+#define MXC_CCM_CCGR2_IPMUX2_OFFSET			18
+#define MXC_CCM_CCGR2_IPMUX2_MASK			(3 << MXC_CCM_CCGR2_IPMUX2_OFFSET)
+#define MXC_CCM_CCGR2_IPMUX3_OFFSET			20
+#define MXC_CCM_CCGR2_IPMUX3_MASK			(3 << MXC_CCM_CCGR2_IPMUX3_OFFSET)
+#define MXC_CCM_CCGR2_IPSYNC_IP2APB_TZASC1_IPGS_OFFSET	22
+#define MXC_CCM_CCGR2_IPSYNC_IP2APB_TZASC1_IPGS_MASK	(3 << MXC_CCM_CCGR2_IPSYNC_IP2APB_TZASC1_IPGS_OFFSET)
+/* i.MX6SX/UL/SLL LCD and PXP */
+#define MXC_CCM_CCGR2_LCD_OFFSET			28
+#define MXC_CCM_CCGR2_LCD_MASK				(3 << MXC_CCM_CCGR2_LCD_OFFSET)
+#define MXC_CCM_CCGR2_PXP_OFFSET			30
+#define MXC_CCM_CCGR2_PXP_MASK				(3 << MXC_CCM_CCGR2_PXP_OFFSET)
+
+#define MXC_CCM_CCGR2_IPSYNC_IP2APB_TZASC2_IPG_OFFSET	24
+#define MXC_CCM_CCGR2_IPSYNC_IP2APB_TZASC2_IPG_MASK	(3 << MXC_CCM_CCGR2_IPSYNC_IP2APB_TZASC2_IPG_OFFSET)
+#define MXC_CCM_CCGR2_IPSYNC_VDOA_IPG_MASTER_CLK_OFFSET	26
+#define MXC_CCM_CCGR2_IPSYNC_VDOA_IPG_MASTER_CLK_MASK	(3 << MXC_CCM_CCGR2_IPSYNC_VDOA_IPG_MASTER_CLK_OFFSET)
+
+/* i.MX6ULL */
+#define MXC_CCM_CCGR2_ESAI_CLK_OFFSET		0
+#define MXC_CCM_CCGR2_ESAI_CLK_MASK		(3 << MXC_CCM_CCGR2_ESAI_CLK_OFFSET)
+#define MXC_CCM_CCGR2_IOMUXC_SNVS_CLK_OFFSET		4
+#define MXC_CCM_CCGR2_IOMUXC_SNVS_CLK_MASK		(3 << MXC_CCM_CCGR2_IOMUXC_SNVS_CLK_OFFSET)
+
+/* Exist on i.MX6SX */
+#define MXC_CCM_CCGR3_M4_OFFSET					2
+#define MXC_CCM_CCGR3_M4_MASK					(3 << MXC_CCM_CCGR3_M4_OFFSET)
+/* i.MX6ULL */
+#define MXC_CCM_CCGR3_EPDC_CLK_ENABLE_OFFSET			4
+#define MXC_CCM_CCGR3_EPDC_CLK_ENABLE_MASK			(3 << MXC_CCM_CCGR3_EPDC_CLK_ENABLE_OFFSET)
+#define MXC_CCM_CCGR3_ENET_OFFSET				4
+#define MXC_CCM_CCGR3_ENET_MASK					(3 << MXC_CCM_CCGR3_ENET_OFFSET)
+#define MXC_CCM_CCGR3_QSPI_OFFSET				14
+#define MXC_CCM_CCGR3_QSPI_MASK					(3 << MXC_CCM_CCGR3_QSPI_OFFSET)
+
+/* i.MX6SL */
+#define MXC_CCM_CCGR3_CSI_CORE_OFFSET			0
+#define MXC_CCM_CCGR3_CSI_CORE_MASK				(3 << MXC_CCM_CCGR3_CSI_CORE_OFFSET)
+#define MXC_CCM_CCGR3_PXP_AXI_OFFSET			2
+#define MXC_CCM_CCGR3_PXP_AXI_MASK				(3 << MXC_CCM_CCGR3_PXP_AXI_OFFSET)
+#define MXC_CCM_CCGR3_EPDC_AXI_OFFSET			4
+#define MXC_CCM_CCGR3_EPDC_AXI_MASK				(3 << MXC_CCM_CCGR3_EPDC_AXI_OFFSET)
+#define MXC_CCM_CCGR3_LCDIF_AXI_OFFSET			6
+#define MXC_CCM_CCGR3_LCDIF_AXI_MASK			(3 << MXC_CCM_CCGR3_LCDIF_AXI_OFFSET)
+#define MXC_CCM_CCGR3_LCDIF_PIX_OFFSET			8
+#define MXC_CCM_CCGR3_LCDIF_PIX_MASK			(3 << MXC_CCM_CCGR3_LCDIF_PIX_OFFSET)
+#define MXC_CCM_CCGR3_EPDC_PIX_OFFSET			10
+#define MXC_CCM_CCGR3_EPDC_PIX_MASK				(3 << MXC_CCM_CCGR3_EPDC_PIX_OFFSET)
+
+#define MXC_CCM_CCGR3_IPU1_IPU_OFFSET				0
+#define MXC_CCM_CCGR3_IPU1_IPU_MASK				(3 << MXC_CCM_CCGR3_IPU1_IPU_OFFSET)
+#define MXC_CCM_CCGR3_IPU1_IPU_DI0_OFFSET			2
+#define MXC_CCM_CCGR3_IPU1_IPU_DI0_MASK				(3 << MXC_CCM_CCGR3_IPU1_IPU_DI0_OFFSET)
+#define MXC_CCM_CCGR3_IPU1_IPU_DI1_OFFSET			4
+#define MXC_CCM_CCGR3_IPU1_IPU_DI1_MASK				(3 << MXC_CCM_CCGR3_IPU1_IPU_DI1_OFFSET)
+
+#define MXC_CCM_CCGR3_IPU2_IPU_OFFSET				6
+#define MXC_CCM_CCGR3_IPU2_IPU_MASK				(3 << MXC_CCM_CCGR3_IPU2_IPU_OFFSET)
+#define MXC_CCM_CCGR3_IPU2_IPU_DI0_OFFSET			8
+#define MXC_CCM_CCGR3_IPU2_IPU_DI0_MASK				(3 << MXC_CCM_CCGR3_IPU2_IPU_DI0_OFFSET)
+#define MXC_CCM_CCGR3_IPU2_IPU_DI1_OFFSET			10
+#define MXC_CCM_CCGR3_IPU2_IPU_DI1_MASK				(3 << MXC_CCM_CCGR3_IPU2_IPU_DI1_OFFSET)
+#define MXC_CCM_CCGR3_LDB_DI0_OFFSET				12
+#define MXC_CCM_CCGR3_LDB_DI0_MASK				(3 << MXC_CCM_CCGR3_LDB_DI0_OFFSET)
+
+/* QSPI1 exists on i.MX6SX/UL */
+#define MXC_CCM_CCGR3_QSPI1_OFFSET				14
+#define MXC_CCM_CCGR3_QSPI1_MASK				(3 << MXC_CCM_CCGR3_QSPI1_OFFSET)
+
+#define MXC_CCM_CCGR3_LDB_DI1_OFFSET				14
+#define MXC_CCM_CCGR3_LDB_DI1_MASK				(3 << MXC_CCM_CCGR3_LDB_DI1_OFFSET)
+#define MXC_CCM_CCGR3_MIPI_CORE_CFG_OFFSET			16
+#define MXC_CCM_CCGR3_MIPI_CORE_CFG_MASK			(3 << MXC_CCM_CCGR3_MIPI_CORE_CFG_OFFSET)
+
+/* A7_CLKDIV/WDOG1 on i.MX6UL */
+#define MXC_CCM_CCGR3_WDOG1_CLK_ENABLE_OFFSET			16
+#define MXC_CCM_CCGR3_WDOG1_CLK_ENABLE_MASK			(3 << MXC_CCM_CCGR3_WDOG1_CLK_ENABLE_OFFSET)
+#define MXC_CCM_CCGR3_A7_CLKDIV_PATCH_OFFSET			18
+#define MXC_CCM_CCGR3_A7_CLKDIV_PATCH_MASK			(3 << MXC_CCM_CCGR3_A7_CLKDIV_PATCH_OFFSET)
+
+#define MXC_CCM_CCGR3_MLB_OFFSET				18
+#define MXC_CCM_CCGR3_MLB_MASK					(3 << MXC_CCM_CCGR3_MLB_OFFSET)
+#define MXC_CCM_CCGR3_MMDC_CORE_ACLK_FAST_CORE_P0_OFFSET	20
+#define MXC_CCM_CCGR3_MMDC_CORE_ACLK_FAST_CORE_P0_MASK		(3 << MXC_CCM_CCGR3_MMDC_CORE_ACLK_FAST_CORE_P0_OFFSET)
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CCGR3_MMDC_CORE_ACLK_FAST_CORE_P1_OFFSET	22
+#define MXC_CCM_CCGR3_MMDC_CORE_ACLK_FAST_CORE_P1_MASK		(3 << MXC_CCM_CCGR3_MMDC_CORE_ACLK_FAST_CORE_P1_OFFSET)
+#endif
+#define MXC_CCM_CCGR3_MMDC_CORE_IPG_CLK_P0_OFFSET		24
+#define MXC_CCM_CCGR3_MMDC_CORE_IPG_CLK_P0_MASK			(3 << MXC_CCM_CCGR3_MMDC_CORE_IPG_CLK_P0_OFFSET)
+#define MXC_CCM_CCGR3_MMDC_CORE_IPG_CLK_P1_OFFSET		26
+#define MXC_CCM_CCGR3_MMDC_CORE_IPG_CLK_P1_MASK			(3 << MXC_CCM_CCGR3_MMDC_CORE_IPG_CLK_P1_OFFSET)
+
+#define MXC_CCM_CCGR3_DISP_AXI_OFFSET                           6
+#define MXC_CCM_CCGR3_DISP_AXI_MASK                             (3 << MXC_CCM_CCGR3_DISP_AXI_OFFSET)
+#define MXC_CCM_CCGR3_LCDIF2_PIX_OFFSET                         8
+#define MXC_CCM_CCGR3_LCDIF2_PIX_MASK                           (3 << MXC_CCM_CCGR3_LCDIF2_PIX_OFFSET)
+#define MXC_CCM_CCGR3_LCDIF1_PIX_OFFSET                         10
+#define MXC_CCM_CCGR3_LCDIF1_PIX_MASK                           (3 << MXC_CCM_CCGR3_LCDIF1_PIX_OFFSET)
+/* AXI on i.MX6UL */
+#define MXC_CCM_CCGR3_AXI_CLK_OFFSET				28
+#define MXC_CCM_CCGR3_AXI_CLK_MASK				(3 << MXC_CCM_CCGR3_AXI_CLK_OFFSET)
+#define MXC_CCM_CCGR3_OCRAM_OFFSET				28
+#define MXC_CCM_CCGR3_OCRAM_MASK				(3 << MXC_CCM_CCGR3_OCRAM_OFFSET)
+
+/* GPIO4 on i.MX6UL/ULL */
+#define MXC_CCM_CCGR3_GPIO4_CLK_OFFSET				30
+#define MXC_CCM_CCGR3_GPIO4_CLK_MASK				(3 << MXC_CCM_CCGR3_GPIO4_CLK_OFFSET)
+
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CCGR3_OPENVGAXICLK_OFFSET			30
+#define MXC_CCM_CCGR3_OPENVGAXICLK_MASK				(3 << MXC_CCM_CCGR3_OPENVGAXICLK_OFFSET)
+#endif
+
+/* i.MX6ULL */
+#define MXC_CCM_CCGR3_IOMUXC_SNVS_GPR_CLK_OFFSET		30
+#define MXC_CCM_CCGR3_IOMUXC_SNVS_GPR_CLK_MASK			(3 << MXC_CCM_CCGR3_IOMUXC_SNVS_GPR_CLK_OFFSET)
+
+#define MXC_CCM_CCGR4_PCIE_OFFSET				0
+#define MXC_CCM_CCGR4_PCIE_MASK					(3 << MXC_CCM_CCGR4_PCIE_OFFSET)
+/* QSPI2 on i.MX6SX */
+#define MXC_CCM_CCGR4_QSPI2_ENFC_OFFSET				10
+#define MXC_CCM_CCGR4_QSPI2_ENFC_MASK				(3 << MXC_CCM_CCGR4_QSPI2_ENFC_OFFSET)
+#define MXC_CCM_CCGR4_PL301_MX6QFAST1_S133_OFFSET		8
+#define MXC_CCM_CCGR4_PL301_MX6QFAST1_S133_MASK			(3 << MXC_CCM_CCGR4_PL301_MX6QFAST1_S133_OFFSET)
+#define MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_OFFSET			12
+#define MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK			(3 << MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_OFFSET)
+#define MXC_CCM_CCGR4_PL301_MX6QPER2_MAINCLK_ENABLE_OFFSET	14
+#define MXC_CCM_CCGR4_PL301_MX6QPER2_MAINCLK_ENABLE_MASK	(3 << MXC_CCM_CCGR4_PL301_MX6QPER2_MAINCLK_ENABLE_OFFSET)
+#define MXC_CCM_CCGR4_PWM1_OFFSET				16
+#define MXC_CCM_CCGR4_PWM1_MASK					(3 << MXC_CCM_CCGR4_PWM1_OFFSET)
+#define MXC_CCM_CCGR4_PWM2_OFFSET				18
+#define MXC_CCM_CCGR4_PWM2_MASK					(3 << MXC_CCM_CCGR4_PWM2_OFFSET)
+#define MXC_CCM_CCGR4_PWM3_OFFSET				20
+#define MXC_CCM_CCGR4_PWM3_MASK					(3 << MXC_CCM_CCGR4_PWM3_OFFSET)
+#define MXC_CCM_CCGR4_PWM4_OFFSET				22
+#define MXC_CCM_CCGR4_PWM4_MASK					(3 << MXC_CCM_CCGR4_PWM4_OFFSET)
+#define MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_OFFSET		24
+#define MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK		(3 << MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_OFFSET)
+#define MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_OFFSET	26
+#define MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK		(3 << MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_OFFSET)
+#define MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_OFFSET	28
+#define MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK	(3 << MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_OFFSET)
+#define MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_OFFSET		30
+#define MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK		(3 << MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_OFFSET)
+
+#define MXC_CCM_CCGR5_ROM_OFFSET			0
+#define MXC_CCM_CCGR5_ROM_MASK				(3 << MXC_CCM_CCGR5_ROM_OFFSET)
+#ifndef CONFIG_MX6SX
+#define MXC_CCM_CCGR5_SATA_OFFSET			4
+#define MXC_CCM_CCGR5_SATA_MASK				(3 << MXC_CCM_CCGR5_SATA_OFFSET)
+#endif
+#define MXC_CCM_CCGR5_SDMA_OFFSET			6
+#define MXC_CCM_CCGR5_SDMA_MASK				(3 << MXC_CCM_CCGR5_SDMA_OFFSET)
+#define MXC_CCM_CCGR5_SPBA_OFFSET			12
+#define MXC_CCM_CCGR5_SPBA_MASK				(3 << MXC_CCM_CCGR5_SPBA_OFFSET)
+#define MXC_CCM_CCGR5_SPDIF_OFFSET			14
+#define MXC_CCM_CCGR5_SPDIF_MASK			(3 << MXC_CCM_CCGR5_SPDIF_OFFSET)
+#define MXC_CCM_CCGR5_SSI1_OFFSET			18
+#define MXC_CCM_CCGR5_SSI1_MASK				(3 << MXC_CCM_CCGR5_SSI1_OFFSET)
+#define MXC_CCM_CCGR5_SSI2_OFFSET			20
+#define MXC_CCM_CCGR5_SSI2_MASK				(3 << MXC_CCM_CCGR5_SSI2_OFFSET)
+#define MXC_CCM_CCGR5_SSI3_OFFSET			22
+#define MXC_CCM_CCGR5_SSI3_MASK				(3 << MXC_CCM_CCGR5_SSI3_OFFSET)
+#define MXC_CCM_CCGR5_UART_OFFSET			24
+#define MXC_CCM_CCGR5_UART_MASK				(3 << MXC_CCM_CCGR5_UART_OFFSET)
+#define MXC_CCM_CCGR5_UART_SERIAL_OFFSET		26
+#define MXC_CCM_CCGR5_UART_SERIAL_MASK			(3 << MXC_CCM_CCGR5_UART_SERIAL_OFFSET)
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CCGR5_SAI1_OFFSET			20
+#define MXC_CCM_CCGR5_SAI1_MASK				(3 << MXC_CCM_CCGR5_SAI1_OFFSET)
+#define MXC_CCM_CCGR5_SAI2_OFFSET			30
+#define MXC_CCM_CCGR5_SAI2_MASK				(3 << MXC_CCM_CCGR5_SAI2_OFFSET)
+#endif
+
+/* PRG_CLK0 exists on i.MX6QP */
+#define MXC_CCM_CCGR6_PRG_CLK0_MASK		(3 << 24)
+
+#define MXC_CCM_CCGR6_USBOH3_OFFSET		0
+#define MXC_CCM_CCGR6_USBOH3_MASK		(3 << MXC_CCM_CCGR6_USBOH3_OFFSET)
+#define MXC_CCM_CCGR6_USDHC1_OFFSET		2
+#define MXC_CCM_CCGR6_USDHC1_MASK		(3 << MXC_CCM_CCGR6_USDHC1_OFFSET)
+#define MXC_CCM_CCGR6_USDHC2_OFFSET		4
+#define MXC_CCM_CCGR6_USDHC2_MASK		(3 << MXC_CCM_CCGR6_USDHC2_OFFSET)
+#define MXC_CCM_CCGR6_SIM1_CLK_OFFSET		6
+#define MXC_CCM_CCGR6_SIM1_CLK_MASK		(3 << MXC_CCM_CCGR6_SIM1_CLK_OFFSET)
+#define MXC_CCM_CCGR6_SIM2_CLK_OFFSET		8
+#define MXC_CCM_CCGR6_SIM2_CLK_MASK		(3 << MXC_CCM_CCGR6_SIM2_CLK_OFFSET)
+/* i.MX6ULL */
+#define MXC_CCM_CCGR6_IPMUX4_CLK_OFFSET		8
+#define MXC_CCM_CCGR6_IPMUX4_CLK_MASK		(3 << MXC_CCM_CCGR6_IPMUX4_CLK_OFFSET)
+/* GPMI/BCH on i.MX6UL */
+#define MXC_CCM_CCGR6_BCH_OFFSET		6
+#define MXC_CCM_CCGR6_BCH_MASK			(3 << MXC_CCM_CCGR6_BCH_OFFSET)
+#define MXC_CCM_CCGR6_GPMI_OFFSET		8
+#define MXC_CCM_CCGR6_GPMI_MASK		(3 << MXC_CCM_CCGR6_GPMI_OFFSET)
+
+#define MXC_CCM_CCGR6_USDHC3_OFFSET		6
+#define MXC_CCM_CCGR6_USDHC3_MASK		(3 << MXC_CCM_CCGR6_USDHC3_OFFSET)
+#define MXC_CCM_CCGR6_USDHC4_OFFSET		8
+#define MXC_CCM_CCGR6_USDHC4_MASK		(3 << MXC_CCM_CCGR6_USDHC4_OFFSET)
+#define MXC_CCM_CCGR6_EMI_SLOW_OFFSET		10
+#define MXC_CCM_CCGR6_EMI_SLOW_MASK		(3 << MXC_CCM_CCGR6_EMI_SLOW_OFFSET)
+/* i.MX6ULL */
+#define MXC_CCM_CCGR6_AIPS_TZ3_CLK_OFFSET	18
+#define MXC_CCM_CCGR6_AIPS_TZ3_CLK_MASK		(3 << MXC_CCM_CCGR6_AIPS_TZ3_CLK_OFFSET)
+/* The following *CCGR6* exist only i.MX6SX */
+#define MXC_CCM_CCGR6_PWM8_OFFSET		16
+#define MXC_CCM_CCGR6_PWM8_MASK			(3 << MXC_CCM_CCGR6_PWM8_OFFSET)
+#define MXC_CCM_CCGR6_VADC_OFFSET		20
+#define MXC_CCM_CCGR6_VADC_MASK			(3 << MXC_CCM_CCGR6_VADC_OFFSET)
+#define MXC_CCM_CCGR6_GIS_OFFSET		22
+#define MXC_CCM_CCGR6_GIS_MASK			(3 << MXC_CCM_CCGR6_GIS_OFFSET)
+#define MXC_CCM_CCGR6_I2C4_OFFSET		24
+#define MXC_CCM_CCGR6_I2C4_MASK			(3 << MXC_CCM_CCGR6_I2C4_OFFSET)
+#define MXC_CCM_CCGR6_PWM5_OFFSET		26
+#define MXC_CCM_CCGR6_PWM5_MASK			(3 << MXC_CCM_CCGR6_PWM5_OFFSET)
+#define MXC_CCM_CCGR6_PWM6_OFFSET		28
+#define MXC_CCM_CCGR6_PWM6_MASK			(3 << MXC_CCM_CCGR6_PWM6_OFFSET)
+#define MXC_CCM_CCGR6_PWM7_OFFSET		30
+#define MXC_CCM_CCGR6_PWM7_MASK			(3 << MXC_CCM_CCGR6_PWM7_OFFSET)
+/* The two does not exist on i.MX6SX */
+#define MXC_CCM_CCGR6_VDOAXICLK_OFFSET		12
+#define MXC_CCM_CCGR6_VDOAXICLK_MASK		(3 << MXC_CCM_CCGR6_VDOAXICLK_OFFSET)
+
+#define BM_ANADIG_PLL_SYS_LOCK 0x80000000
+#define BP_ANADIG_PLL_SYS_RSVD0      20
+#define BM_ANADIG_PLL_SYS_RSVD0 0x7FF00000
+#define BF_ANADIG_PLL_SYS_RSVD0(v)  \
+	(((v) << 20) & BM_ANADIG_PLL_SYS_RSVD0)
+#define BM_ANADIG_PLL_SYS_PLL_SEL 0x00080000
+#define BM_ANADIG_PLL_SYS_LVDS_24MHZ_SEL 0x00040000
+#define BM_ANADIG_PLL_SYS_LVDS_SEL 0x00020000
+#define BM_ANADIG_PLL_SYS_BYPASS 0x00010000
+#define BP_ANADIG_PLL_SYS_BYPASS_CLK_SRC      14
+#define BM_ANADIG_PLL_SYS_BYPASS_CLK_SRC 0x0000C000
+#define BF_ANADIG_PLL_SYS_BYPASS_CLK_SRC(v)  \
+	(((v) << 14) & BM_ANADIG_PLL_SYS_BYPASS_CLK_SRC)
+#define BV_ANADIG_PLL_SYS_BYPASS_CLK_SRC__OSC_24M  0x0
+#define BV_ANADIG_PLL_SYS_BYPASS_CLK_SRC__ANACLK_1 0x1
+#define BV_ANADIG_PLL_SYS_BYPASS_CLK_SRC__ANACLK_2 0x2
+#define BV_ANADIG_PLL_SYS_BYPASS_CLK_SRC__XOR      0x3
+#define BM_ANADIG_PLL_SYS_ENABLE 0x00002000
+#define BM_ANADIG_PLL_SYS_POWERDOWN 0x00001000
+#define BM_ANADIG_PLL_SYS_HOLD_RING_OFF 0x00000800
+#define BM_ANADIG_PLL_SYS_DOUBLE_CP 0x00000400
+#define BM_ANADIG_PLL_SYS_HALF_CP 0x00000200
+#define BM_ANADIG_PLL_SYS_DOUBLE_LF 0x00000100
+#define BM_ANADIG_PLL_SYS_HALF_LF 0x00000080
+#define BP_ANADIG_PLL_SYS_DIV_SELECT      0
+#define BM_ANADIG_PLL_SYS_DIV_SELECT 0x0000007F
+#define BF_ANADIG_PLL_SYS_DIV_SELECT(v)  \
+	(((v) << 0) & BM_ANADIG_PLL_SYS_DIV_SELECT)
+
+#define BM_ANADIG_USB1_PLL_480_CTRL_LOCK 0x80000000
+#define BP_ANADIG_USB1_PLL_480_CTRL_RSVD1      17
+#define BM_ANADIG_USB1_PLL_480_CTRL_RSVD1 0x7FFE0000
+#define BF_ANADIG_USB1_PLL_480_CTRL_RSVD1(v)  \
+	(((v) << 17) & BM_ANADIG_USB1_PLL_480_CTRL_RSVD1)
+#define BM_ANADIG_USB1_PLL_480_CTRL_BYPASS 0x00010000
+#define BP_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC      14
+#define BM_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC 0x0000C000
+#define BF_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC(v)  \
+	(((v) << 14) & BM_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC)
+#define BV_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC__OSC_24M  0x0
+#define BV_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC__ANACLK_1 0x1
+#define BV_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC__ANACLK_2 0x2
+#define BV_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC__XOR      0x3
+#define BM_ANADIG_USB1_PLL_480_CTRL_ENABLE 0x00002000
+#define BM_ANADIG_USB1_PLL_480_CTRL_POWER 0x00001000
+#define BM_ANADIG_USB1_PLL_480_CTRL_HOLD_RING_OFF 0x00000800
+#define BM_ANADIG_USB1_PLL_480_CTRL_DOUBLE_CP 0x00000400
+#define BM_ANADIG_USB1_PLL_480_CTRL_HALF_CP 0x00000200
+#define BM_ANADIG_USB1_PLL_480_CTRL_DOUBLE_LF 0x00000100
+#define BM_ANADIG_USB1_PLL_480_CTRL_HALF_LF 0x00000080
+#define BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS 0x00000040
+#define BM_ANADIG_USB1_PLL_480_CTRL_RSVD0 0x00000020
+#define BP_ANADIG_USB1_PLL_480_CTRL_CONTROL0      2
+#define BM_ANADIG_USB1_PLL_480_CTRL_CONTROL0 0x0000001C
+#define BF_ANADIG_USB1_PLL_480_CTRL_CONTROL0(v)  \
+	(((v) << 2) & BM_ANADIG_USB1_PLL_480_CTRL_CONTROL0)
+#define BP_ANADIG_USB1_PLL_480_CTRL_DIV_SELECT      0
+#define BM_ANADIG_USB1_PLL_480_CTRL_DIV_SELECT 0x00000003
+#define BF_ANADIG_USB1_PLL_480_CTRL_DIV_SELECT(v)  \
+	(((v) << 0) & BM_ANADIG_USB1_PLL_480_CTRL_DIV_SELECT)
+
+#define BM_ANADIG_PLL_528_LOCK 0x80000000
+#define BP_ANADIG_PLL_528_RSVD1      19
+#define BM_ANADIG_PLL_528_RSVD1 0x7FF80000
+#define BF_ANADIG_PLL_528_RSVD1(v)  \
+	(((v) << 19) & BM_ANADIG_PLL_528_RSVD1)
+#define BM_ANADIG_PLL_528_PFD_OFFSET_EN 0x00040000
+#define BM_ANADIG_PLL_528_DITHER_ENABLE 0x00020000
+#define BM_ANADIG_PLL_528_BYPASS 0x00010000
+#define BP_ANADIG_PLL_528_BYPASS_CLK_SRC      14
+#define BM_ANADIG_PLL_528_BYPASS_CLK_SRC 0x0000C000
+#define BF_ANADIG_PLL_528_BYPASS_CLK_SRC(v)  \
+	(((v) << 14) & BM_ANADIG_PLL_528_BYPASS_CLK_SRC)
+#define BV_ANADIG_PLL_528_BYPASS_CLK_SRC__OSC_24M  0x0
+#define BV_ANADIG_PLL_528_BYPASS_CLK_SRC__ANACLK_1 0x1
+#define BV_ANADIG_PLL_528_BYPASS_CLK_SRC__ANACLK_2 0x2
+#define BV_ANADIG_PLL_528_BYPASS_CLK_SRC__XOR      0x3
+#define BM_ANADIG_PLL_528_ENABLE 0x00002000
+#define BM_ANADIG_PLL_528_POWERDOWN 0x00001000
+#define BM_ANADIG_PLL_528_HOLD_RING_OFF 0x00000800
+#define BM_ANADIG_PLL_528_DOUBLE_CP 0x00000400
+#define BM_ANADIG_PLL_528_HALF_CP 0x00000200
+#define BM_ANADIG_PLL_528_DOUBLE_LF 0x00000100
+#define BM_ANADIG_PLL_528_HALF_LF 0x00000080
+#define BP_ANADIG_PLL_528_RSVD0      1
+#define BM_ANADIG_PLL_528_RSVD0 0x0000007E
+#define BF_ANADIG_PLL_528_RSVD0(v)  \
+	(((v) << 1) & BM_ANADIG_PLL_528_RSVD0)
+#define BM_ANADIG_PLL_528_DIV_SELECT 0x00000001
+
+#define BP_ANADIG_PLL_528_SS_STOP      16
+#define BM_ANADIG_PLL_528_SS_STOP 0xFFFF0000
+#define BF_ANADIG_PLL_528_SS_STOP(v) \
+	(((v) << 16) & BM_ANADIG_PLL_528_SS_STOP)
+#define BM_ANADIG_PLL_528_SS_ENABLE 0x00008000
+#define BP_ANADIG_PLL_528_SS_STEP      0
+#define BM_ANADIG_PLL_528_SS_STEP 0x00007FFF
+#define BF_ANADIG_PLL_528_SS_STEP(v)  \
+	(((v) << 0) & BM_ANADIG_PLL_528_SS_STEP)
+
+#define BP_ANADIG_PLL_528_NUM_RSVD0      30
+#define BM_ANADIG_PLL_528_NUM_RSVD0 0xC0000000
+#define BF_ANADIG_PLL_528_NUM_RSVD0(v) \
+	(((v) << 30) & BM_ANADIG_PLL_528_NUM_RSVD0)
+#define BP_ANADIG_PLL_528_NUM_A      0
+#define BM_ANADIG_PLL_528_NUM_A 0x3FFFFFFF
+#define BF_ANADIG_PLL_528_NUM_A(v)  \
+	(((v) << 0) & BM_ANADIG_PLL_528_NUM_A)
+
+#define BP_ANADIG_PLL_528_DENOM_RSVD0      30
+#define BM_ANADIG_PLL_528_DENOM_RSVD0 0xC0000000
+#define BF_ANADIG_PLL_528_DENOM_RSVD0(v) \
+	(((v) << 30) & BM_ANADIG_PLL_528_DENOM_RSVD0)
+#define BP_ANADIG_PLL_528_DENOM_B      0
+#define BM_ANADIG_PLL_528_DENOM_B 0x3FFFFFFF
+#define BF_ANADIG_PLL_528_DENOM_B(v)  \
+	(((v) << 0) & BM_ANADIG_PLL_528_DENOM_B)
+
+#define BM_ANADIG_PLL_AUDIO_LOCK 0x80000000
+#define BP_ANADIG_PLL_AUDIO_RSVD0      22
+#define BM_ANADIG_PLL_AUDIO_RSVD0 0x7FC00000
+#define BF_ANADIG_PLL_AUDIO_RSVD0(v)  \
+	(((v) << 22) & BM_ANADIG_PLL_AUDIO_RSVD0)
+#define BM_ANADIG_PLL_AUDIO_SSC_EN 0x00200000
+#define BP_ANADIG_PLL_AUDIO_TEST_DIV_SELECT      19
+#define BM_ANADIG_PLL_AUDIO_TEST_DIV_SELECT 0x00180000
+#define BF_ANADIG_PLL_AUDIO_TEST_DIV_SELECT(v)  \
+	(((v) << 19) & BM_ANADIG_PLL_AUDIO_TEST_DIV_SELECT)
+#define BM_ANADIG_PLL_AUDIO_PFD_OFFSET_EN 0x00040000
+#define BM_ANADIG_PLL_AUDIO_DITHER_ENABLE 0x00020000
+#define BM_ANADIG_PLL_AUDIO_BYPASS 0x00010000
+#define BP_ANADIG_PLL_AUDIO_BYPASS_CLK_SRC      14
+#define BM_ANADIG_PLL_AUDIO_BYPASS_CLK_SRC 0x0000C000
+#define BF_ANADIG_PLL_AUDIO_BYPASS_CLK_SRC(v)  \
+	(((v) << 14) & BM_ANADIG_PLL_AUDIO_BYPASS_CLK_SRC)
+#define BV_ANADIG_PLL_AUDIO_BYPASS_CLK_SRC__OSC_24M  0x0
+#define BV_ANADIG_PLL_AUDIO_BYPASS_CLK_SRC__ANACLK_1 0x1
+#define BV_ANADIG_PLL_AUDIO_BYPASS_CLK_SRC__ANACLK_2 0x2
+#define BV_ANADIG_PLL_AUDIO_BYPASS_CLK_SRC__XOR      0x3
+#define BM_ANADIG_PLL_AUDIO_ENABLE 0x00002000
+#define BM_ANADIG_PLL_AUDIO_POWERDOWN 0x00001000
+#define BM_ANADIG_PLL_AUDIO_HOLD_RING_OFF 0x00000800
+#define BM_ANADIG_PLL_AUDIO_DOUBLE_CP 0x00000400
+#define BM_ANADIG_PLL_AUDIO_HALF_CP 0x00000200
+#define BM_ANADIG_PLL_AUDIO_DOUBLE_LF 0x00000100
+#define BM_ANADIG_PLL_AUDIO_HALF_LF 0x00000080
+#define BP_ANADIG_PLL_AUDIO_DIV_SELECT      0
+#define BM_ANADIG_PLL_AUDIO_DIV_SELECT 0x0000007F
+#define BF_ANADIG_PLL_AUDIO_DIV_SELECT(v)  \
+	(((v) << 0) & BM_ANADIG_PLL_AUDIO_DIV_SELECT)
+
+#define BP_ANADIG_PLL_AUDIO_NUM_RSVD0      30
+#define BM_ANADIG_PLL_AUDIO_NUM_RSVD0 0xC0000000
+#define BF_ANADIG_PLL_AUDIO_NUM_RSVD0(v) \
+	(((v) << 30) & BM_ANADIG_PLL_AUDIO_NUM_RSVD0)
+#define BP_ANADIG_PLL_AUDIO_NUM_A      0
+#define BM_ANADIG_PLL_AUDIO_NUM_A 0x3FFFFFFF
+#define BF_ANADIG_PLL_AUDIO_NUM_A(v)  \
+	(((v) << 0) & BM_ANADIG_PLL_AUDIO_NUM_A)
+
+#define BP_ANADIG_PLL_AUDIO_DENOM_RSVD0      30
+#define BM_ANADIG_PLL_AUDIO_DENOM_RSVD0 0xC0000000
+#define BF_ANADIG_PLL_AUDIO_DENOM_RSVD0(v) \
+	(((v) << 30) & BM_ANADIG_PLL_AUDIO_DENOM_RSVD0)
+#define BP_ANADIG_PLL_AUDIO_DENOM_B      0
+#define BM_ANADIG_PLL_AUDIO_DENOM_B 0x3FFFFFFF
+#define BF_ANADIG_PLL_AUDIO_DENOM_B(v)  \
+	(((v) << 0) & BM_ANADIG_PLL_AUDIO_DENOM_B)
+
+#define BM_ANADIG_PLL_VIDEO_LOCK 0x80000000
+#define BP_ANADIG_PLL_VIDEO_RSVD0      22
+#define BM_ANADIG_PLL_VIDEO_RSVD0 0x7FC00000
+#define BF_ANADIG_PLL_VIDEO_RSVD0(v)  \
+	(((v) << 22) & BM_ANADIG_PLL_VIDEO_RSVD0)
+#define BM_ANADIG_PLL_VIDEO_SSC_EN 0x00200000
+#define BP_ANADIG_PLL_VIDEO_POST_DIV_SELECT      19
+#define BM_ANADIG_PLL_VIDEO_POST_DIV_SELECT 0x00180000
+#define BF_ANADIG_PLL_VIDEO_POST_DIV_SELECT(v)  \
+	(((v) << 19) & BM_ANADIG_PLL_VIDEO_POST_DIV_SELECT)
+#define BM_ANADIG_PLL_VIDEO_PFD_OFFSET_EN 0x00040000
+#define BM_ANADIG_PLL_VIDEO_DITHER_ENABLE 0x00020000
+#define BM_ANADIG_PLL_VIDEO_BYPASS 0x00010000
+#define BP_ANADIG_PLL_VIDEO_BYPASS_CLK_SRC      14
+#define BM_ANADIG_PLL_VIDEO_BYPASS_CLK_SRC 0x0000C000
+#define BF_ANADIG_PLL_VIDEO_BYPASS_CLK_SRC(v)  \
+	(((v) << 14) & BM_ANADIG_PLL_VIDEO_BYPASS_CLK_SRC)
+#define BV_ANADIG_PLL_VIDEO_BYPASS_CLK_SRC__OSC_24M  0x0
+#define BV_ANADIG_PLL_VIDEO_BYPASS_CLK_SRC__ANACLK_1 0x1
+#define BV_ANADIG_PLL_VIDEO_BYPASS_CLK_SRC__ANACLK_2 0x2
+#define BV_ANADIG_PLL_VIDEO_BYPASS_CLK_SRC__XOR      0x3
+#define BM_ANADIG_PLL_VIDEO_ENABLE 0x00002000
+#define BM_ANADIG_PLL_VIDEO_POWERDOWN 0x00001000
+#define BM_ANADIG_PLL_VIDEO_HOLD_RING_OFF 0x00000800
+#define BM_ANADIG_PLL_VIDEO_DOUBLE_CP 0x00000400
+#define BM_ANADIG_PLL_VIDEO_HALF_CP 0x00000200
+#define BM_ANADIG_PLL_VIDEO_DOUBLE_LF 0x00000100
+#define BM_ANADIG_PLL_VIDEO_HALF_LF 0x00000080
+#define BP_ANADIG_PLL_VIDEO_DIV_SELECT      0
+#define BM_ANADIG_PLL_VIDEO_DIV_SELECT 0x0000007F
+#define BF_ANADIG_PLL_VIDEO_DIV_SELECT(v)  \
+	(((v) << 0) & BM_ANADIG_PLL_VIDEO_DIV_SELECT)
+
+#define BP_ANADIG_PLL_VIDEO_NUM_RSVD0      30
+#define BM_ANADIG_PLL_VIDEO_NUM_RSVD0 0xC0000000
+#define BF_ANADIG_PLL_VIDEO_NUM_RSVD0(v) \
+	(((v) << 30) & BM_ANADIG_PLL_VIDEO_NUM_RSVD0)
+#define BP_ANADIG_PLL_VIDEO_NUM_A      0
+#define BM_ANADIG_PLL_VIDEO_NUM_A 0x3FFFFFFF
+#define BF_ANADIG_PLL_VIDEO_NUM_A(v)  \
+	(((v) << 0) & BM_ANADIG_PLL_VIDEO_NUM_A)
+
+#define BP_ANADIG_PLL_VIDEO_DENOM_RSVD0      30
+#define BM_ANADIG_PLL_VIDEO_DENOM_RSVD0 0xC0000000
+#define BF_ANADIG_PLL_VIDEO_DENOM_RSVD0(v) \
+	(((v) << 30) & BM_ANADIG_PLL_VIDEO_DENOM_RSVD0)
+#define BP_ANADIG_PLL_VIDEO_DENOM_B      0
+#define BM_ANADIG_PLL_VIDEO_DENOM_B 0x3FFFFFFF
+#define BF_ANADIG_PLL_VIDEO_DENOM_B(v)  \
+	(((v) << 0) & BM_ANADIG_PLL_VIDEO_DENOM_B)
+
+#define BM_ANADIG_PLL_ENET_LOCK 0x80000000
+#define BP_ANADIG_PLL_ENET_RSVD1      21
+#define BM_ANADIG_PLL_ENET_RSVD1 0x7FE00000
+#define BF_ANADIG_PLL_ENET_RSVD1(v)  \
+	(((v) << 21) & BM_ANADIG_PLL_ENET_RSVD1)
+#define BM_ANADIG_PLL_ENET_REF_25M_ENABLE 0x00200000
+#define BM_ANADIG_PLL_ENET_ENABLE_SATA 0x00100000
+#define BM_ANADIG_PLL_ENET_ENABLE_PCIE 0x00080000
+#define BM_ANADIG_PLL_ENET_PFD_OFFSET_EN 0x00040000
+#define BM_ANADIG_PLL_ENET_DITHER_ENABLE 0x00020000
+#define BM_ANADIG_PLL_ENET_BYPASS 0x00010000
+#define BP_ANADIG_PLL_ENET_BYPASS_CLK_SRC      14
+#define BM_ANADIG_PLL_ENET_BYPASS_CLK_SRC 0x0000C000
+#define BF_ANADIG_PLL_ENET_BYPASS_CLK_SRC(v)  \
+	(((v) << 14) & BM_ANADIG_PLL_ENET_BYPASS_CLK_SRC)
+#define BV_ANADIG_PLL_ENET_BYPASS_CLK_SRC__OSC_24M  0x0
+#define BV_ANADIG_PLL_ENET_BYPASS_CLK_SRC__ANACLK_1 0x1
+#define BV_ANADIG_PLL_ENET_BYPASS_CLK_SRC__ANACLK_2 0x2
+#define BV_ANADIG_PLL_ENET_BYPASS_CLK_SRC__XOR      0x3
+#define BM_ANADIG_PLL_ENET_ENABLE 0x00002000
+#define BM_ANADIG_PLL_ENET_POWERDOWN 0x00001000
+#define BM_ANADIG_PLL_ENET_HOLD_RING_OFF 0x00000800
+#define BM_ANADIG_PLL_ENET_DOUBLE_CP 0x00000400
+#define BM_ANADIG_PLL_ENET_HALF_CP 0x00000200
+#define BM_ANADIG_PLL_ENET_DOUBLE_LF 0x00000100
+#define BM_ANADIG_PLL_ENET_HALF_LF 0x00000080
+#define BP_ANADIG_PLL_ENET_RSVD0      2
+#define BM_ANADIG_PLL_ENET_RSVD0 0x0000007C
+#define BF_ANADIG_PLL_ENET_RSVD0(v)  \
+	(((v) << 2) & BM_ANADIG_PLL_ENET_RSVD0)
+#define BP_ANADIG_PLL_ENET_DIV_SELECT      0
+#define BM_ANADIG_PLL_ENET_DIV_SELECT 0x00000003
+#define BF_ANADIG_PLL_ENET_DIV_SELECT(v)  \
+	(((v) << 0) & BM_ANADIG_PLL_ENET_DIV_SELECT)
+
+/* ENET2 for i.MX6SX/UL */
+#define BM_ANADIG_PLL_ENET2_ENABLE 0x00100000
+#define BM_ANADIG_PLL_ENET2_DIV_SELECT 0x0000000C
+#define BF_ANADIG_PLL_ENET2_DIV_SELECT(v)  \
+	(((v) << 2) & BM_ANADIG_PLL_ENET2_DIV_SELECT)
+
+#define BM_ANADIG_PFD_480_PFD3_CLKGATE 0x80000000
+#define BM_ANADIG_PFD_480_PFD3_STABLE 0x40000000
+#define BP_ANADIG_PFD_480_PFD3_FRAC      24
+#define BM_ANADIG_PFD_480_PFD3_FRAC 0x3F000000
+#define BF_ANADIG_PFD_480_PFD3_FRAC(v)  \
+	(((v) << 24) & BM_ANADIG_PFD_480_PFD3_FRAC)
+#define BM_ANADIG_PFD_480_PFD2_CLKGATE 0x00800000
+#define BM_ANADIG_PFD_480_PFD2_STABLE 0x00400000
+#define BP_ANADIG_PFD_480_PFD2_FRAC      16
+#define BM_ANADIG_PFD_480_PFD2_FRAC 0x003F0000
+#define BF_ANADIG_PFD_480_PFD2_FRAC(v)  \
+	(((v) << 16) & BM_ANADIG_PFD_480_PFD2_FRAC)
+#define BM_ANADIG_PFD_480_PFD1_CLKGATE 0x00008000
+#define BM_ANADIG_PFD_480_PFD1_STABLE 0x00004000
+#define BP_ANADIG_PFD_480_PFD1_FRAC      8
+#define BM_ANADIG_PFD_480_PFD1_FRAC 0x00003F00
+#define BF_ANADIG_PFD_480_PFD1_FRAC(v)  \
+	(((v) << 8) & BM_ANADIG_PFD_480_PFD1_FRAC)
+#define BM_ANADIG_PFD_480_PFD0_CLKGATE 0x00000080
+#define BM_ANADIG_PFD_480_PFD0_STABLE 0x00000040
+#define BP_ANADIG_PFD_480_PFD0_FRAC      0
+#define BM_ANADIG_PFD_480_PFD0_FRAC 0x0000003F
+#define BF_ANADIG_PFD_480_PFD0_FRAC(v)  \
+	(((v) << 0) & BM_ANADIG_PFD_480_PFD0_FRAC)
+
+#define BM_ANADIG_PFD_528_PFD3_CLKGATE 0x80000000
+#define BM_ANADIG_PFD_528_PFD3_STABLE 0x40000000
+#define BP_ANADIG_PFD_528_PFD3_FRAC      24
+#define BM_ANADIG_PFD_528_PFD3_FRAC 0x3F000000
+#define BF_ANADIG_PFD_528_PFD3_FRAC(v)  \
+	(((v) << 24) & BM_ANADIG_PFD_528_PFD3_FRAC)
+#define BM_ANADIG_PFD_528_PFD2_CLKGATE 0x00800000
+#define BM_ANADIG_PFD_528_PFD2_STABLE 0x00400000
+#define BP_ANADIG_PFD_528_PFD2_FRAC      16
+#define BM_ANADIG_PFD_528_PFD2_FRAC 0x003F0000
+#define BF_ANADIG_PFD_528_PFD2_FRAC(v)  \
+	(((v) << 16) & BM_ANADIG_PFD_528_PFD2_FRAC)
+#define BM_ANADIG_PFD_528_PFD1_CLKGATE 0x00008000
+#define BM_ANADIG_PFD_528_PFD1_STABLE 0x00004000
+#define BP_ANADIG_PFD_528_PFD1_FRAC      8
+#define BM_ANADIG_PFD_528_PFD1_FRAC 0x00003F00
+#define BF_ANADIG_PFD_528_PFD1_FRAC(v)  \
+	(((v) << 8) & BM_ANADIG_PFD_528_PFD1_FRAC)
+#define BM_ANADIG_PFD_528_PFD0_CLKGATE 0x00000080
+#define BM_ANADIG_PFD_528_PFD0_STABLE 0x00000040
+#define BP_ANADIG_PFD_528_PFD0_FRAC      0
+#define BM_ANADIG_PFD_528_PFD0_FRAC 0x0000003F
+#define BF_ANADIG_PFD_528_PFD0_FRAC(v)  \
+	(((v) << 0) & BM_ANADIG_PFD_528_PFD0_FRAC)
+
+#define BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF 0x00000008
+#define BM_ANADIG_ANA_MISC0_REFTOP_VBGADJ_SHIFT 4
+
+#define BM_PMU_MISC2_AUDIO_DIV_MSB (1 << 23)
+#define BP_PMU_MISC2_AUDIO_DIV_MSB 23
+
+#define BM_PMU_MISC2_AUDIO_DIV_LSB (1 << 15)
+#define BP_PMU_MISC2_AUDIO_DIV_LSB 15
+
+#define PMU_MISC2_AUDIO_DIV(v) \
+	(((v & BM_PMU_MISC2_AUDIO_DIV_MSB) >> \
+	(BP_PMU_MISC2_AUDIO_DIV_MSB - 1)) | \
+	((v & BM_PMU_MISC2_AUDIO_DIV_LSB) >> \
+	 BP_PMU_MISC2_AUDIO_DIV_LSB))
+
+#endif /*__ARCH_ARM_MACH_MX6_CCM_REGS_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/gpio.h ebf_6ull_uboot/arch/arm/include/asm/arch/gpio.h
--- u-boot-2016.03/arch/arm/include/asm/arch/gpio.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/gpio.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,14 @@
+/*
+ * Copyright (C) 2011
+ * Stefano Babic, DENX Software Engineering, <sbabic@denx.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+
+#ifndef __ASM_ARCH_MX6_GPIO_H
+#define __ASM_ARCH_MX6_GPIO_H
+
+#include <asm/imx-common/gpio.h>
+
+#endif	/* __ASM_ARCH_MX6_GPIO_H */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/imx-rdc.h ebf_6ull_uboot/arch/arm/include/asm/arch/imx-rdc.h
--- u-boot-2016.03/arch/arm/include/asm/arch/imx-rdc.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/imx-rdc.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,16 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:  GPL-2.0+
+ */
+
+#ifndef __IMX_RDC_H__
+#define __IMX_RDC_H__
+
+#if defined(CONFIG_MX6SX)
+#include "mx6sx_rdc.h"
+#else
+#error "Please select cpu"
+#endif /* CONFIG_MX6SX */
+
+#endif	/* __IMX_RDC_H__*/
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/imx-regs.h ebf_6ull_uboot/arch/arm/include/asm/arch/imx-regs.h
--- u-boot-2016.03/arch/arm/include/asm/arch/imx-regs.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/imx-regs.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,1102 @@
+/*
+ * Copyright (C) 2011-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_MX6_IMX_REGS_H__
+#define __ASM_ARCH_MX6_IMX_REGS_H__
+
+#define ARCH_MXC
+
+#ifdef CONFIG_MX6UL
+#define CONFIG_SYS_CACHELINE_SIZE	64
+#else
+#define CONFIG_SYS_CACHELINE_SIZE	32
+#endif
+
+#define ROMCP_ARB_BASE_ADDR             0x00000000
+#define ROMCP_ARB_END_ADDR              0x000FFFFF
+
+#ifdef CONFIG_MX6SL
+#define GPU_2D_ARB_BASE_ADDR            0x02200000
+#define GPU_2D_ARB_END_ADDR             0x02203FFF
+#define OPENVG_ARB_BASE_ADDR            0x02204000
+#define OPENVG_ARB_END_ADDR             0x02207FFF
+#elif (defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL))
+#define CAAM_ARB_BASE_ADDR              0x00100000
+#define CAAM_ARB_END_ADDR               0x00107FFF
+#define GPU_ARB_BASE_ADDR               0x01800000
+#define GPU_ARB_END_ADDR                0x01803FFF
+#define APBH_DMA_ARB_BASE_ADDR          0x01804000
+#define APBH_DMA_ARB_END_ADDR           0x0180BFFF
+#define M4_BOOTROM_BASE_ADDR			0x007F8000
+
+#elif !defined(CONFIG_MX6SLL)
+#define CAAM_ARB_BASE_ADDR              0x00100000
+#define CAAM_ARB_END_ADDR               0x00103FFF
+#define APBH_DMA_ARB_BASE_ADDR          0x00110000
+#define APBH_DMA_ARB_END_ADDR           0x00117FFF
+#define HDMI_ARB_BASE_ADDR              0x00120000
+#define HDMI_ARB_END_ADDR               0x00128FFF
+#define GPU_3D_ARB_BASE_ADDR            0x00130000
+#define GPU_3D_ARB_END_ADDR             0x00133FFF
+#define GPU_2D_ARB_BASE_ADDR            0x00134000
+#define GPU_2D_ARB_END_ADDR             0x00137FFF
+#define DTCP_ARB_BASE_ADDR              0x00138000
+#define DTCP_ARB_END_ADDR               0x0013BFFF
+#endif	/* CONFIG_MX6SL */
+
+#define MXS_APBH_BASE			APBH_DMA_ARB_BASE_ADDR
+#define MXS_GPMI_BASE			(APBH_DMA_ARB_BASE_ADDR + 0x02000)
+#define MXS_BCH_BASE			(APBH_DMA_ARB_BASE_ADDR + 0x04000)
+
+/* GPV - PL301 configuration ports */
+#if (defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || defined(CONFIG_MX6SL) || defined(CONFIG_MX6SLL))
+#define GPV2_BASE_ADDR          0x00D00000
+#define GPV3_BASE_ADDR			0x00E00000
+#define GPV4_BASE_ADDR			0x00F00000
+#define GPV5_BASE_ADDR			0x01000000
+#define GPV6_BASE_ADDR			0x01100000
+#define PCIE_ARB_BASE_ADDR              0x08000000
+#define PCIE_ARB_END_ADDR               0x08FFFFFF
+#else
+#define GPV2_BASE_ADDR			0x00200000
+#define GPV3_BASE_ADDR			0x00300000
+#define GPV4_BASE_ADDR			0x00800000
+#define PCIE_ARB_BASE_ADDR              0x01000000
+#define PCIE_ARB_END_ADDR               0x01FFFFFF
+#endif
+
+#define IRAM_BASE_ADDR			0x00900000
+#define SCU_BASE_ADDR                   0x00A00000
+#define IC_INTERFACES_BASE_ADDR         0x00A00100
+#define GLOBAL_TIMER_BASE_ADDR          0x00A00200
+#define PRIVATE_TIMERS_WD_BASE_ADDR     0x00A00600
+#define IC_DISTRIBUTOR_BASE_ADDR        0x00A01000
+#define L2_PL310_BASE			0x00A02000
+#define GPV0_BASE_ADDR                  0x00B00000
+#define GPV1_BASE_ADDR                  0x00C00000
+
+#define AIPS1_ARB_BASE_ADDR             0x02000000
+#define AIPS1_ARB_END_ADDR              0x020FFFFF
+#define AIPS2_ARB_BASE_ADDR             0x02100000
+#define AIPS2_ARB_END_ADDR              0x021FFFFF
+/* AIPS3 only on i.MX6SX */
+#define AIPS3_ARB_BASE_ADDR             0x02200000
+#define AIPS3_ARB_END_ADDR              0x022FFFFF
+#ifdef CONFIG_MX6SX
+#define WEIM_ARB_BASE_ADDR              0x50000000
+#define WEIM_ARB_END_ADDR               0x57FFFFFF
+#define QSPI0_AMBA_BASE                0x60000000
+#define QSPI0_AMBA_END                 0x6FFFFFFF
+#define QSPI1_AMBA_BASE                0x70000000
+#define QSPI1_AMBA_END                 0x7FFFFFFF
+#elif defined(CONFIG_MX6UL)
+#define WEIM_ARB_BASE_ADDR              0x50000000
+#define WEIM_ARB_END_ADDR               0x57FFFFFF
+#define QSPI0_AMBA_BASE                 0x60000000
+#define QSPI0_AMBA_END                  0x6FFFFFFF
+#elif !defined(CONFIG_MX6SLL)
+#define SATA_ARB_BASE_ADDR              0x02200000
+#define SATA_ARB_END_ADDR               0x02203FFF
+#define OPENVG_ARB_BASE_ADDR            0x02204000
+#define OPENVG_ARB_END_ADDR             0x02207FFF
+#define HSI_ARB_BASE_ADDR               0x02208000
+#define HSI_ARB_END_ADDR                0x0220BFFF
+#define IPU1_ARB_BASE_ADDR              0x02400000
+#define IPU1_ARB_END_ADDR               0x027FFFFF
+#define IPU2_ARB_BASE_ADDR              0x02800000
+#define IPU2_ARB_END_ADDR               0x02BFFFFF
+#define WEIM_ARB_BASE_ADDR              0x08000000
+#define WEIM_ARB_END_ADDR               0x0FFFFFFF
+#endif
+
+#if (defined(CONFIG_MX6SLL) || defined(CONFIG_MX6SL) || defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL))
+#define MMDC0_ARB_BASE_ADDR             0x80000000
+#define MMDC0_ARB_END_ADDR              0xFFFFFFFF
+#define MMDC1_ARB_BASE_ADDR             0xC0000000
+#define MMDC1_ARB_END_ADDR              0xFFFFFFFF
+#else
+#define MMDC0_ARB_BASE_ADDR             0x10000000
+#define MMDC0_ARB_END_ADDR              0x7FFFFFFF
+#define MMDC1_ARB_BASE_ADDR             0x80000000
+#define MMDC1_ARB_END_ADDR              0xFFFFFFFF
+#endif
+
+#define QSPI1_ARB_BASE_ADDR             0x60000000
+#define QSPI1_ARB_END_ADDR              0x6FFFFFFF
+#define QSPI2_ARB_BASE_ADDR             0x70000000
+#define QSPI2_ARB_END_ADDR              0x7FFFFFFF
+
+#if (!(defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || defined(CONFIG_MX6SLL)))
+#define IPU_SOC_BASE_ADDR		IPU1_ARB_BASE_ADDR
+#define IPU_SOC_OFFSET			0x00200000
+#endif
+
+/* Defines for Blocks connected via AIPS (SkyBlue) */
+#define ATZ1_BASE_ADDR              AIPS1_ARB_BASE_ADDR
+#define ATZ2_BASE_ADDR              AIPS2_ARB_BASE_ADDR
+#define ATZ3_BASE_ADDR              AIPS3_ARB_BASE_ADDR
+#define AIPS1_BASE_ADDR             AIPS1_ON_BASE_ADDR
+#define AIPS2_BASE_ADDR             AIPS2_ON_BASE_ADDR
+#define AIPS3_BASE_ADDR             AIPS3_ON_BASE_ADDR
+
+#define SPDIF_BASE_ADDR             (ATZ1_BASE_ADDR + 0x04000)
+#define ECSPI1_BASE_ADDR            (ATZ1_BASE_ADDR + 0x08000)
+#define ECSPI2_BASE_ADDR            (ATZ1_BASE_ADDR + 0x0C000)
+#define ECSPI3_BASE_ADDR            (ATZ1_BASE_ADDR + 0x10000)
+#define ECSPI4_BASE_ADDR            (ATZ1_BASE_ADDR + 0x14000)
+
+#define MX6SL_UART5_BASE_ADDR       (ATZ1_BASE_ADDR + 0x18000)
+#define MX6SLL_UART4_BASE_ADDR      (ATZ1_BASE_ADDR + 0x18000)
+#define MX6UL_UART7_BASE_ADDR       (ATZ1_BASE_ADDR + 0x18000)
+#define ECSPI5_BASE_ADDR            (ATZ1_BASE_ADDR + 0x18000)
+
+#define UART1_BASE                  (ATZ1_BASE_ADDR + 0x20000)
+
+#define MX6SL_UART2_BASE_ADDR       (ATZ1_BASE_ADDR + 0x24000)
+#define MX6SLL_UART2_BASE_ADDR      (ATZ1_BASE_ADDR + 0x24000)
+#define MX6UL_UART8_BASE_ADDR       (ATZ1_BASE_ADDR + 0x24000)
+#define ESAI1_BASE_ADDR             (ATZ1_BASE_ADDR + 0x24000)
+
+#if defined(CONFIG_MX6UL)
+#define SAI1_BASE_ADDR              (ATZ1_BASE_ADDR + 0x28000)
+#define SAI2_BASE_ADDR              (ATZ1_BASE_ADDR + 0x2C000)
+#define SAI3_BASE_ADDR              (ATZ1_BASE_ADDR + 0x30000)
+#else
+#define SSI1_BASE_ADDR              (ATZ1_BASE_ADDR + 0x28000)
+#define SSI2_BASE_ADDR              (ATZ1_BASE_ADDR + 0x2C000)
+#define SSI3_BASE_ADDR              (ATZ1_BASE_ADDR + 0x30000)
+#endif
+
+#define MX6SL_UART3_BASE_ADDR       (ATZ1_BASE_ADDR + 0x34000)
+#define MX6SLL_UART3_BASE_ADDR      (ATZ1_BASE_ADDR + 0x34000)
+#define ASRC_BASE_ADDR              (ATZ1_BASE_ADDR + 0x34000)
+
+#define MX6SL_UART4_BASE_ADDR       (ATZ1_BASE_ADDR + 0x38000)
+
+
+#if defined(CONFIG_MX6UL)
+#define TOUCH_CTRL_BASE_ADDR        (ATZ1_BASE_ADDR + 0x40000)
+#define BEE_BASE_ADDR               (ATZ1_BASE_ADDR + 0x44000)
+#elif !defined(CONFIG_MX6SX)
+#define SPBA_BASE_ADDR              (ATZ1_BASE_ADDR + 0x3C000)
+#define VPU_BASE_ADDR               (ATZ1_BASE_ADDR + 0x40000)
+#endif
+#define AIPS1_ON_BASE_ADDR          (ATZ1_BASE_ADDR + 0x7C000)
+
+#define AIPS1_OFF_BASE_ADDR         (ATZ1_BASE_ADDR + 0x80000)
+#define PWM1_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x0000)
+#define PWM2_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x4000)
+#define PWM3_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x8000)
+#define PWM4_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0xC000)
+/* No CAN on i.MX6SLL */
+#define CAN1_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x10000)
+#define CAN2_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x14000)
+/* QOSC on i.MX6SLL */
+#define QOSC_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x14000)
+#define GPT1_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x18000)
+#define GPIO1_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x1C000)
+#define GPIO2_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x20000)
+#define GPIO3_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x24000)
+#define GPIO4_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x28000)
+#define GPIO5_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x2C000)
+#define MX6UL_SNVS_LP_BASE_ADDR     (AIPS1_OFF_BASE_ADDR + 0x30000)
+#if defined(CONFIG_MX6UL)
+#define SNVS_LP_BASE_ADDR           (AIPS1_OFF_BASE_ADDR + 0x30000)
+#define ENET2_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x34000)
+#else
+#define GPIO6_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x30000)
+#define GPIO7_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x34000)
+#endif
+#define KPP_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x38000)
+#define WDOG1_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x3C000)
+#define WDOG2_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x40000)
+#define ANATOP_BASE_ADDR            (AIPS1_OFF_BASE_ADDR + 0x48000)
+#define USB_PHY0_BASE_ADDR          (AIPS1_OFF_BASE_ADDR + 0x49000)
+#define USB_PHY1_BASE_ADDR          (AIPS1_OFF_BASE_ADDR + 0x4a000)
+#define CCM_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x44000)
+#define SNVS_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x4C000)
+#define EPIT1_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x50000)
+#define EPIT2_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x54000)
+#define SRC_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x58000)
+#define GPC_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x5C000)
+#define IOMUXC_BASE_ADDR            (AIPS1_OFF_BASE_ADDR + 0x60000)
+#define IOMUXC_GPR_BASE_ADDR        (AIPS1_OFF_BASE_ADDR + 0x64000)
+#ifdef CONFIG_MX6SLL
+#define CSI_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x68000)
+#define SDMA_PORT_HOST_BASE_ADDR    (AIPS1_OFF_BASE_ADDR + 0x6C000)
+#define PXP_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x70000)
+#define EPDC_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x74000)
+#define DCP_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x7C000)
+#elif defined(CONFIG_MX6SL)
+#define CSI_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x64000)
+#define SIPIX_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x68000)
+#define SDMA_PORT_HOST_BASE_ADDR    (AIPS1_OFF_BASE_ADDR + 0x6C000)
+#define EPDC_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x74000)
+#elif defined(CONFIG_MX6SX)
+#define CANFD1_BASE_ADDR            (AIPS1_OFF_BASE_ADDR + 0x68000)
+#define SDMA_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x6C000)
+#define CANFD2_BASE_ADDR            (AIPS1_OFF_BASE_ADDR + 0x70000)
+#define SEMAPHORE1_BASE_ADDR        (AIPS1_OFF_BASE_ADDR + 0x74000)
+#define SEMAPHORE2_BASE_ADDR        (AIPS1_OFF_BASE_ADDR + 0x78000)
+#define RDC_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x7C000)
+
+#elif defined(CONFIG_MX6UL)
+#define GPT2_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x68000)
+#define SDMA_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x6C000)
+#define PWM5_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x70000)
+#define PWM6_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x74000)
+#define PWM7_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x78000)
+#define PWM8_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x7C000)
+#else
+#define DCIC1_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x64000)
+#define DCIC2_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x68000)
+#define DMA_REQ_PORT_HOST_BASE_ADDR (AIPS1_OFF_BASE_ADDR + 0x6C000)
+#define EPDC_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x74000)
+#endif
+#define MX6SL_LCDIF_BASE_ADDR      (AIPS1_OFF_BASE_ADDR + 0x78000)
+#define MX6SLL_LCDIF_BASE_ADDR      (AIPS1_OFF_BASE_ADDR + 0x78000)
+
+#define AIPS2_ON_BASE_ADDR          (ATZ2_BASE_ADDR + 0x7C000)
+#define AIPS2_OFF_BASE_ADDR         (ATZ2_BASE_ADDR + 0x80000)
+#define AIPS3_ON_BASE_ADDR          (ATZ3_BASE_ADDR + 0x7C000)
+#define AIPS3_OFF_BASE_ADDR         (ATZ3_BASE_ADDR + 0x80000)
+
+#if defined(CONFIG_MX6UL)
+#define CAAM_BASE_ADDR              (ATZ2_BASE_ADDR + 0x40000)
+#define ARM_BASE_ADDR               (ATZ2_BASE_ADDR)
+#else
+#define CAAM_BASE_ADDR              (ATZ2_BASE_ADDR)
+#define ARM_BASE_ADDR               (ATZ2_BASE_ADDR + 0x40000)
+#endif
+
+#define CONFIG_SYS_FSL_SEC_ADDR     CAAM_BASE_ADDR
+#define CONFIG_SYS_FSL_JR0_ADDR     (CAAM_BASE_ADDR + 0x1000)
+
+#define USB_PL301_BASE_ADDR         (AIPS2_OFF_BASE_ADDR + 0x0000)
+#define USB_BASE_ADDR               (AIPS2_OFF_BASE_ADDR + 0x4000)
+
+#define ENET_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x8000)
+#ifdef CONFIG_MX6SL
+#define MSHC_IPS_BASE_ADDR          (AIPS2_OFF_BASE_ADDR + 0xC000)
+#elif defined(CONFIG_MX6UL)
+#define SIM1_IPS_BASE_ADDR          (AIPS2_OFF_BASE_ADDR + 0xC000)
+#else
+#define MLB_BASE_ADDR               (AIPS2_OFF_BASE_ADDR + 0xC000)
+#endif
+
+#define USDHC1_BASE_ADDR            (AIPS2_OFF_BASE_ADDR + 0x10000)
+#define USDHC2_BASE_ADDR            (AIPS2_OFF_BASE_ADDR + 0x14000)
+#define USDHC3_BASE_ADDR            (AIPS2_OFF_BASE_ADDR + 0x18000)
+#define USDHC4_BASE_ADDR            (AIPS2_OFF_BASE_ADDR + 0x1C000)
+
+#define MX6UL_ADC1_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x18000)
+#define MX6UL_ADC2_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x1C000)
+#define I2C1_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x20000)
+#define I2C2_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x24000)
+#define I2C3_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x28000)
+#define ROMCP_BASE_ADDR             (AIPS2_OFF_BASE_ADDR + 0x2C000)
+#define MMDC_P0_BASE_ADDR           (AIPS2_OFF_BASE_ADDR + 0x30000)
+/* i.MX6SL/SLL */
+#define RNGB_IPS_BASE_ADDR          (AIPS2_OFF_BASE_ADDR + 0x34000)
+#ifdef CONFIG_MX6UL
+#define ENET2_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x34000)
+#else
+/* i.MX6SX */
+#define ENET2_BASE_ADDR             (AIPS2_OFF_BASE_ADDR + 0x34000)
+#endif
+/* i.MX6DQ/SDL */
+#define MMDC_P1_BASE_ADDR           (AIPS2_OFF_BASE_ADDR + 0x34000)
+
+#define WEIM_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x38000)
+#define OCOTP_BASE_ADDR             (AIPS2_OFF_BASE_ADDR + 0x3C000)
+#define CSU_BASE_ADDR               (AIPS2_OFF_BASE_ADDR + 0x40000)
+#if defined(CONFIG_MX6UL)
+#define CSI_BASE_ADDR               (AIPS2_OFF_BASE_ADDR + 0x44000)
+#define PXP_BASE_ADDR               (AIPS2_OFF_BASE_ADDR + 0x4C000)
+#elif defined(CONFIG_MX6SLL)
+#define IOMUXC_GPR_SNVS_BASE_ADDR    (AIPS2_OFF_BASE_ADDR + 0x44000)
+#define IOMUXC_SNVS_BASE_ADDR        (AIPS2_OFF_BASE_ADDR + 0x48000)
+#else
+#define IP2APB_PERFMON1_BASE_ADDR   (AIPS2_OFF_BASE_ADDR + 0x44000)
+#define IP2APB_PERFMON2_BASE_ADDR   (AIPS2_OFF_BASE_ADDR + 0x48000)
+#endif
+#define MX6UL_LCDIF1_BASE_ADDR      (AIPS2_OFF_BASE_ADDR + 0x48000)
+#define MX6ULL_LCDIF1_BASE_ADDR      (AIPS2_OFF_BASE_ADDR + 0x48000)
+#ifdef CONFIG_MX6SX
+#define DEBUG_MONITOR_BASE_ADDR     (AIPS2_OFF_BASE_ADDR + 0x4C000)
+#else
+#define IP2APB_PERFMON3_BASE_ADDR   (AIPS2_OFF_BASE_ADDR + 0x4C000)
+#endif
+#define IP2APB_TZASC1_BASE_ADDR     (AIPS2_OFF_BASE_ADDR + 0x50000)
+#ifdef CONFIG_MX6UL
+#define QSPI0_BASE_ADDR             (AIPS2_OFF_BASE_ADDR + 0x60000)
+#define SYSCNT_RD_IPS_BASE_ADDR     (AIPS2_OFF_BASE_ADDR + 0x54000)
+#define SYSCNT_CMP_IPS_BASE_ADDR    (AIPS2_OFF_BASE_ADDR + 0x58000)
+#define SYSCNT_CTRL_IPS_BASE_ADDR   (AIPS2_OFF_BASE_ADDR + 0x5C000)
+#elif defined(CONFIG_MX6SX)
+#define SAI1_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x54000)
+#define AUDMUX_BASE_ADDR            (AIPS2_OFF_BASE_ADDR + 0x58000)
+#define SAI2_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x5C000)
+#define QSPI0_BASE_ADDR             (AIPS2_OFF_BASE_ADDR + 0x60000)
+#define QSPI1_BASE_ADDR             (AIPS2_OFF_BASE_ADDR + 0x64000)
+#else
+#define IP2APB_TZASC2_BASE_ADDR     (AIPS2_OFF_BASE_ADDR + 0x54000)
+#define MIPI_CSI2_BASE_ADDR         (AIPS2_OFF_BASE_ADDR + 0x5C000)
+#define MIPI_DSI_BASE_ADDR          (AIPS2_OFF_BASE_ADDR + 0x60000)
+#define VDOA_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x64000)
+#endif
+#define MX6UL_WDOG3_BASE_ADDR       (AIPS2_OFF_BASE_ADDR + 0x64000)
+#define UART2_BASE                  (AIPS2_OFF_BASE_ADDR + 0x68000)
+#define UART3_BASE                  (AIPS2_OFF_BASE_ADDR + 0x6C000)
+#define UART4_BASE                  (AIPS2_OFF_BASE_ADDR + 0x70000)
+#define UART5_BASE                  (AIPS2_OFF_BASE_ADDR + 0x74000)
+/* i.MX6SLL */
+#define MTR_MASTER_BASE_ADDR        (AIPS2_OFF_BASE_ADDR + 0x7C000)
+/* i.MX6SX/UL */
+#define I2C4_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x78000)
+/* i.MX6UL */
+#define MX6UL_UART6_BASE_ADDR             (AIPS2_OFF_BASE_ADDR + 0x7C000)
+#define IP2APB_USBPHY1_BASE_ADDR    (AIPS2_OFF_BASE_ADDR + 0x78000)
+#define IP2APB_USBPHY2_BASE_ADDR    (AIPS2_OFF_BASE_ADDR + 0x7C000)
+
+#define OTG_BASE_ADDR               USB_BASE_ADDR
+
+#if defined(CONFIG_MX6UL)
+#define SCTR_BASE_ADDR              SYSCNT_CTRL_IPS_BASE_ADDR
+#endif
+
+#ifdef CONFIG_MX6SX
+#define GIS_BASE_ADDR               (AIPS3_ARB_BASE_ADDR + 0x04000)
+#define DCIC1_BASE_ADDR             (AIPS3_ARB_BASE_ADDR + 0x0C000)
+#define DCIC2_BASE_ADDR             (AIPS3_ARB_BASE_ADDR + 0x10000)
+#define CSI1_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x14000)
+#define PXP_BASE_ADDR               (AIPS3_ARB_BASE_ADDR + 0x18000)
+#define CSI2_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x1C000)
+#define VADC_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x28000)
+#define VDEC_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x2C000)
+#define SPBA_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x3C000)
+#define AIPS3_CONFIG_BASE_ADDR      (AIPS3_ARB_BASE_ADDR + 0x7C000)
+#define MX6SX_ADC1_BASE_ADDR        (AIPS3_ARB_BASE_ADDR + 0x80000)
+#define MX6SX_ADC2_BASE_ADDR        (AIPS3_ARB_BASE_ADDR + 0x84000)
+#define ECSPI5_BASE_ADDR            (AIPS3_ARB_BASE_ADDR + 0x8C000)
+#define HS_BASE_ADDR                (AIPS3_ARB_BASE_ADDR + 0x90000)
+#define MU_MCU_BASE_ADDR            (AIPS3_ARB_BASE_ADDR + 0x94000)
+#define CANFD_BASE_ADDR             (AIPS3_ARB_BASE_ADDR + 0x98000)
+#define MU_DSP_BASE_ADDR            (AIPS3_ARB_BASE_ADDR + 0x9C000)
+#define PWM5_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xA4000)
+#define PWM6_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xA8000)
+#define PWM7_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xAC000)
+#define PWM8_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xB0000)
+#elif defined(CONFIG_MX6ULL)
+#define AIPS3_CONFIG_BASE_ADDR      (AIPS3_ARB_BASE_ADDR + 0x7C000)
+#define DCP_BASE_ADDR               (AIPS3_ARB_BASE_ADDR + 0x80000)
+#define RNGB_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x84000)
+#define UART8_IPS_BASE_ADDR         (AIPS3_ARB_BASE_ADDR + 0x88000)
+#define EPDC_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x8C000)
+#define IOMUXC_SNVS_BASE_ADDR       (AIPS3_ARB_BASE_ADDR + 0x90000)
+#define SNVS_GPR_BASE_ADDR          (AIPS3_ARB_BASE_ADDR + 0x94000)
+#endif
+/* Only for i.MX6SX */
+#define LCDIF2_BASE_ADDR            (AIPS3_ARB_BASE_ADDR + 0x24000)
+#define MX6SX_LCDIF1_BASE_ADDR      (AIPS3_ARB_BASE_ADDR + 0x20000)
+#define MX6SX_WDOG3_BASE_ADDR       (AIPS3_ARB_BASE_ADDR + 0x88000)
+#define MX6SX_UART6_BASE_ADDR             (AIPS3_ARB_BASE_ADDR + 0xA0000)
+
+#if !(defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || \
+	defined(CONFIG_MX6SLL) || defined(CONFIG_MX6SL))
+#define IRAM_SIZE                    0x00040000
+#else
+#define IRAM_SIZE                    0x00020000
+#endif
+#define FEC_QUIRK_ENET_MAC
+#define SNVS_LPGPR                   0x68
+
+#include <asm/imx-common/regs-lcdif.h>
+#if !(defined(__KERNEL_STRICT_NAMES) || defined(__ASSEMBLY__))
+#include <asm/types.h>
+
+/* only for i.MX6SX/UL */
+#define WDOG3_BASE_ADDR (((is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL)) ?	\
+			 MX6UL_WDOG3_BASE_ADDR :  MX6SX_WDOG3_BASE_ADDR))
+#define LCDIF1_BASE_ADDR ((is_cpu_type(MXC_CPU_MX6SLL)) ?	\
+			  MX6SLL_LCDIF_BASE_ADDR :		\
+			  (is_cpu_type(MXC_CPU_MX6SL)) ?	\
+			  MX6SL_LCDIF_BASE_ADDR :		\
+			  ((is_cpu_type(MXC_CPU_MX6UL)) ?	\
+			  MX6UL_LCDIF1_BASE_ADDR :		\
+			  ((is_cpu_type(MXC_CPU_MX6ULL)) ?	\
+			  MX6ULL_LCDIF1_BASE_ADDR : MX6SX_LCDIF1_BASE_ADDR)))
+#define UART6_BASE_ADDR (((is_cpu_type(MXC_CPU_MX6UL)) || is_cpu_type(MXC_CPU_MX6ULL)) ? \
+			  MX6UL_UART6_BASE_ADDR : MX6SX_UART6_BASE_ADDR)
+
+#define MXS_LCDIF_BASE LCDIF1_BASE_ADDR
+
+
+extern void imx_get_mac_from_fuse(int dev_id, unsigned char *mac);
+
+#define SRC_SCR_CORE_1_RESET_OFFSET     14
+#define SRC_SCR_CORE_1_RESET_MASK       (1<<SRC_SCR_CORE_1_RESET_OFFSET)
+#define SRC_SCR_CORE_2_RESET_OFFSET     15
+#define SRC_SCR_CORE_2_RESET_MASK       (1<<SRC_SCR_CORE_2_RESET_OFFSET)
+#define SRC_SCR_CORE_3_RESET_OFFSET     16
+#define SRC_SCR_CORE_3_RESET_MASK       (1<<SRC_SCR_CORE_3_RESET_OFFSET)
+#define SRC_SCR_CORE_1_ENABLE_OFFSET    22
+#define SRC_SCR_CORE_1_ENABLE_MASK      (1<<SRC_SCR_CORE_1_ENABLE_OFFSET)
+#define SRC_SCR_CORE_2_ENABLE_OFFSET    23
+#define SRC_SCR_CORE_2_ENABLE_MASK      (1<<SRC_SCR_CORE_2_ENABLE_OFFSET)
+#define SRC_SCR_CORE_3_ENABLE_OFFSET    24
+#define SRC_SCR_CORE_3_ENABLE_MASK      (1<<SRC_SCR_CORE_3_ENABLE_OFFSET)
+
+struct rdc_regs {
+	u32	vir;		/* Version information */
+	u32	reserved1[8];
+	u32	stat;		/* Status */
+	u32	intctrl;	/* Interrupt and Control */
+	u32	intstat;	/* Interrupt Status */
+	u32	reserved2[116];
+	u32	mda[32];	/* Master Domain Assignment */
+	u32	reserved3[96];
+	u32	pdap[104];	/* Peripheral Domain Access Permissions */
+	u32	reserved4[88];
+	struct {
+		u32 mrsa;	/* Memory Region Start Address */
+		u32 mrea;	/* Memory Region End Address */
+		u32 mrc;	/* Memory Region Control */
+		u32 mrvs;	/* Memory Region Violation Status */
+	} mem_region[55];
+};
+
+struct rdc_sema_regs {
+	u8	gate[64];	/* Gate */
+	u16	rstgt;		/* Reset Gate */
+};
+
+/* WEIM registers */
+struct weim {
+	u32 cs0gcr1;
+	u32 cs0gcr2;
+	u32 cs0rcr1;
+	u32 cs0rcr2;
+	u32 cs0wcr1;
+	u32 cs0wcr2;
+
+	u32 cs1gcr1;
+	u32 cs1gcr2;
+	u32 cs1rcr1;
+	u32 cs1rcr2;
+	u32 cs1wcr1;
+	u32 cs1wcr2;
+
+	u32 cs2gcr1;
+	u32 cs2gcr2;
+	u32 cs2rcr1;
+	u32 cs2rcr2;
+	u32 cs2wcr1;
+	u32 cs2wcr2;
+
+	u32 cs3gcr1;
+	u32 cs3gcr2;
+	u32 cs3rcr1;
+	u32 cs3rcr2;
+	u32 cs3wcr1;
+	u32 cs3wcr2;
+
+	u32 unused[12];
+
+	u32 wcr;
+	u32 wiar;
+	u32 ear;
+};
+
+/* System Reset Controller (SRC) */
+struct src {
+	u32	scr;
+	u32	sbmr1;
+	u32	srsr;
+	u32	reserved1[2];
+	u32	sisr;
+	u32	simr;
+	u32     sbmr2;
+	u32     gpr1;
+	u32     gpr2;
+	u32     gpr3;
+	u32     gpr4;
+	u32     gpr5;
+	u32     gpr6;
+	u32     gpr7;
+	u32     gpr8;
+	u32     gpr9;
+	u32     gpr10;
+};
+
+#define SRC_SCR_M4_ENABLE_OFFSET                22
+#define SRC_SCR_M4_ENABLE_MASK                  (1 << 22)
+#define SRC_SCR_M4C_NON_SCLR_RST_OFFSET         4
+#define SRC_SCR_M4C_NON_SCLR_RST_MASK           (1 << 4)
+
+/* GPR1 bitfields */
+#define IOMUXC_GPR1_APP_CLK_REQ_N		BIT(30)
+#define IOMUXC_GPR1_PCIE_EXIT_L1		BIT(28)
+#define IOMUXC_GPR1_PCIE_RDY_L23		BIT(27)
+#define IOMUXC_GPR1_PCIE_ENTER_L1		BIT(26)
+#define IOMUXC_GPR1_MIPI_COLOR_SW		BIT(25)
+#define IOMUXC_GPR1_DPI_OFF			BIT(24)
+#define IOMUXC_GPR1_EXC_MON_SLVE		BIT(22)
+#define IOMUXC_GPR1_ENET_CLK_SEL_OFFSET		21
+#define IOMUXC_GPR1_ENET_CLK_SEL_MASK		(1 << IOMUXC_GPR1_ENET_CLK_SEL_OFFSET)
+#define IOMUXC_GPR1_MIPI_IPU2_MUX_IOMUX		BIT(20)
+#define IOMUXC_GPR1_MIPI_IPU1_MUX_IOMUX		BIT(19)
+#define IOMUXC_GPR1_PCIE_TEST_PD			BIT(18)
+#define IOMUXC_GPR1_IPU_VPU_MUX_IPU2		BIT(17)
+#define IOMUXC_GPR1_PCIE_REF_CLK_EN		BIT(16)
+#define IOMUXC_GPR1_USB_EXP_MODE			BIT(15)
+#define IOMUXC_GPR1_PCIE_INT			BIT(14)
+#define IOMUXC_GPR1_USB_OTG_ID_OFFSET		13
+#define IOMUXC_GPR1_USB_OTG_ID_SEL_MASK		(1 << IOMUXC_GPR1_USB_OTG_ID_OFFSET)
+#define IOMUXC_GPR1_GINT				BIT(12)
+#define IOMUXC_GPR1_ADDRS3_MASK			(0x3 << 10)
+#define IOMUXC_GPR1_ADDRS3_32MB			(0x0 << 10)
+#define IOMUXC_GPR1_ADDRS3_64MB			(0x1 << 10)
+#define IOMUXC_GPR1_ADDRS3_128MB			(0x2 << 10)
+#define IOMUXC_GPR1_ACT_CS3			BIT(9)
+#define IOMUXC_GPR1_ADDRS2_MASK			(0x3 << 7)
+#define IOMUXC_GPR1_ACT_CS2			BIT(6)
+#define IOMUXC_GPR1_ADDRS1_MASK			(0x3 << 4)
+#define IOMUXC_GPR1_ACT_CS1			BIT(3)
+#define IOMUXC_GPR1_ADDRS0_OFFSET		(1)
+#define IOMUXC_GPR1_ADDRS0_MASK			(0x3 << 1)
+#define IOMUXC_GPR1_ACT_CS0			BIT(0)
+
+/* GPR3 bitfields */
+#define IOMUXC_GPR3_GPU_DBG_OFFSET		29
+#define IOMUXC_GPR3_GPU_DBG_MASK		(3<<IOMUXC_GPR3_GPU_DBG_OFFSET)
+#define IOMUXC_GPR3_BCH_WR_CACHE_CTL_OFFSET	28
+#define IOMUXC_GPR3_BCH_WR_CACHE_CTL_MASK	(1<<IOMUXC_GPR3_BCH_WR_CACHE_CTL_OFFSET)
+#define IOMUXC_GPR3_BCH_RD_CACHE_CTL_OFFSET	27
+#define IOMUXC_GPR3_BCH_RD_CACHE_CTL_MASK	(1<<IOMUXC_GPR3_BCH_RD_CACHE_CTL_OFFSET)
+#define IOMUXC_GPR3_uSDHCx_WR_CACHE_CTL_OFFSET	26
+#define IOMUXC_GPR3_uSDHCx_WR_CACHE_CTL_MASK	(1<<IOMUXC_GPR3_uSDHCx_WR_CACHE_CTL_OFFSET)
+#define IOMUXC_GPR3_uSDHCx_RD_CACHE_CTL_OFFSET	25
+#define IOMUXC_GPR3_uSDHCx_RD_CACHE_CTL_MASK	(1<<IOMUXC_GPR3_uSDHCx_RD_CACHE_CTL_OFFSET)
+#define IOMUXC_GPR3_OCRAM_CTL_OFFSET		21
+#define IOMUXC_GPR3_OCRAM_CTL_MASK		(0xf<<IOMUXC_GPR3_OCRAM_CTL_OFFSET)
+#define IOMUXC_GPR3_OCRAM_STATUS_OFFSET		17
+#define IOMUXC_GPR3_OCRAM_STATUS_MASK		(0xf<<IOMUXC_GPR3_OCRAM_STATUS_OFFSET)
+#define IOMUXC_GPR3_CORE3_DBG_ACK_EN_OFFSET	16
+#define IOMUXC_GPR3_CORE3_DBG_ACK_EN_MASK	(1<<IOMUXC_GPR3_CORE3_DBG_ACK_EN_OFFSET)
+#define IOMUXC_GPR3_CORE2_DBG_ACK_EN_OFFSET	15
+#define IOMUXC_GPR3_CORE2_DBG_ACK_EN_MASK	(1<<IOMUXC_GPR3_CORE2_DBG_ACK_EN_OFFSET)
+#define IOMUXC_GPR3_CORE1_DBG_ACK_EN_OFFSET	14
+#define IOMUXC_GPR3_CORE1_DBG_ACK_EN_MASK	(1<<IOMUXC_GPR3_CORE1_DBG_ACK_EN_OFFSET)
+#define IOMUXC_GPR3_CORE0_DBG_ACK_EN_OFFSET	13
+#define IOMUXC_GPR3_CORE0_DBG_ACK_EN_MASK	(1<<IOMUXC_GPR3_CORE0_DBG_ACK_EN_OFFSET)
+#define IOMUXC_GPR3_TZASC2_BOOT_LOCK_OFFSET	12
+#define IOMUXC_GPR3_TZASC2_BOOT_LOCK_MASK	(1<<IOMUXC_GPR3_TZASC2_BOOT_LOCK_OFFSET)
+#define IOMUXC_GPR3_TZASC1_BOOT_LOCK_OFFSET	11
+#define IOMUXC_GPR3_TZASC1_BOOT_LOCK_MASK	(1<<IOMUXC_GPR3_TZASC1_BOOT_LOCK_OFFSET)
+#define IOMUXC_GPR3_IPU_DIAG_OFFSET		10
+#define IOMUXC_GPR3_IPU_DIAG_MASK		(1<<IOMUXC_GPR3_IPU_DIAG_OFFSET)
+
+#define IOMUXC_GPR3_MUX_SRC_IPU1_DI0	0
+#define IOMUXC_GPR3_MUX_SRC_IPU1_DI1	1
+#define IOMUXC_GPR3_MUX_SRC_IPU2_DI0	2
+#define IOMUXC_GPR3_MUX_SRC_IPU2_DI1	3
+
+#define IOMUXC_GPR3_LVDS1_MUX_CTL_OFFSET	8
+#define IOMUXC_GPR3_LVDS1_MUX_CTL_MASK		(3<<IOMUXC_GPR3_LVDS1_MUX_CTL_OFFSET)
+
+#define IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET	6
+#define IOMUXC_GPR3_LVDS0_MUX_CTL_MASK		(3<<IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET)
+
+#define IOMUXC_GPR3_MIPI_MUX_CTL_OFFSET		4
+#define IOMUXC_GPR3_MIPI_MUX_CTL_MASK		(3<<IOMUXC_GPR3_MIPI_MUX_CTL_OFFSET)
+
+#define IOMUXC_GPR3_HDMI_MUX_CTL_OFFSET		2
+#define IOMUXC_GPR3_HDMI_MUX_CTL_MASK		(3<<IOMUXC_GPR3_HDMI_MUX_CTL_OFFSET)
+
+/* gpr12 bitfields */
+#define IOMUXC_GPR12_ARMP_IPG_CLK_EN		BIT(27)
+#define IOMUXC_GPR12_ARMP_AHB_CLK_EN		BIT(26)
+#define IOMUXC_GPR12_ARMP_ATB_CLK_EN		BIT(25)
+#define IOMUXC_GPR12_ARMP_APB_CLK_EN		BIT(24)
+#define IOMUXC_GPR12_DEVICE_TYPE		(0xf << 12)
+#define IOMUXC_GPR12_PCIE_CTL_2			BIT(10)
+#define IOMUXC_GPR12_LOS_LEVEL			(0x1f << 4)
+
+struct iomuxc {
+#if (defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL))
+	u8 reserved[0x4000];
+#endif
+
+#ifdef CONFIG_MX6UL
+	u32 gpr[15];
+#else
+	u32 gpr[14];
+#endif
+};
+
+struct gpc {
+	u32	cntr;
+	u32	pgr;
+	u32	imr1;
+	u32	imr2;
+	u32	imr3;
+	u32	imr4;
+	u32	isr1;
+	u32	isr2;
+	u32	isr3;
+	u32	isr4;
+};
+
+#define IOMUXC_GPR2_COUNTER_RESET_VAL_OFFSET		20
+#define IOMUXC_GPR2_COUNTER_RESET_VAL_MASK		(3<<IOMUXC_GPR2_COUNTER_RESET_VAL_OFFSET)
+#define IOMUXC_GPR2_LVDS_CLK_SHIFT_OFFSET		16
+#define IOMUXC_GPR2_LVDS_CLK_SHIFT_MASK			(7<<IOMUXC_GPR2_LVDS_CLK_SHIFT_OFFSET)
+
+#define IOMUXC_GPR2_BGREF_RRMODE_OFFSET			15
+#define IOMUXC_GPR2_BGREF_RRMODE_MASK			(1<<IOMUXC_GPR2_BGREF_RRMODE_OFFSET)
+#define IOMUXC_GPR2_BGREF_RRMODE_INTERNAL_RES		(1<<IOMUXC_GPR2_BGREF_RRMODE_OFFSET)
+#define IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES		(0<<IOMUXC_GPR2_BGREF_RRMODE_OFFSET)
+#define IOMUXC_GPR2_VSYNC_ACTIVE_HIGH	0
+#define IOMUXC_GPR2_VSYNC_ACTIVE_LOW	1
+
+#define IOMUXC_GPR2_DI1_VS_POLARITY_OFFSET		10
+#define IOMUXC_GPR2_DI1_VS_POLARITY_MASK		(1<<IOMUXC_GPR2_DI1_VS_POLARITY_OFFSET)
+#define IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_HIGH		(IOMUXC_GPR2_VSYNC_ACTIVE_HIGH<<IOMUXC_GPR2_DI1_VS_POLARITY_OFFSET)
+#define IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW		(IOMUXC_GPR2_VSYNC_ACTIVE_LOW<<IOMUXC_GPR2_DI1_VS_POLARITY_OFFSET)
+
+#define IOMUXC_GPR2_DI0_VS_POLARITY_OFFSET		9
+#define IOMUXC_GPR2_DI0_VS_POLARITY_MASK		(1<<IOMUXC_GPR2_DI0_VS_POLARITY_OFFSET)
+#define IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_HIGH		(IOMUXC_GPR2_VSYNC_ACTIVE_HIGH<<IOMUXC_GPR2_DI0_VS_POLARITY_OFFSET)
+#define IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW		(IOMUXC_GPR2_VSYNC_ACTIVE_LOW<<IOMUXC_GPR2_DI0_VS_POLARITY_OFFSET)
+
+#define IOMUXC_GPR2_BITMAP_SPWG	0
+#define IOMUXC_GPR2_BITMAP_JEIDA	1
+
+#define IOMUXC_GPR2_BIT_MAPPING_CH1_OFFSET		8
+#define IOMUXC_GPR2_BIT_MAPPING_CH1_MASK		(1<<IOMUXC_GPR2_BIT_MAPPING_CH1_OFFSET)
+#define IOMUXC_GPR2_BIT_MAPPING_CH1_JEIDA		(IOMUXC_GPR2_BITMAP_JEIDA<<IOMUXC_GPR2_BIT_MAPPING_CH1_OFFSET)
+#define IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG		(IOMUXC_GPR2_BITMAP_SPWG<<IOMUXC_GPR2_BIT_MAPPING_CH1_OFFSET)
+
+#define IOMUXC_GPR2_DATA_WIDTH_18	0
+#define IOMUXC_GPR2_DATA_WIDTH_24	1
+
+#define IOMUXC_GPR2_DATA_WIDTH_CH1_OFFSET		7
+#define IOMUXC_GPR2_DATA_WIDTH_CH1_MASK			(1<<IOMUXC_GPR2_DATA_WIDTH_CH1_OFFSET)
+#define IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT		(IOMUXC_GPR2_DATA_WIDTH_18<<IOMUXC_GPR2_DATA_WIDTH_CH1_OFFSET)
+#define IOMUXC_GPR2_DATA_WIDTH_CH1_24BIT		(IOMUXC_GPR2_DATA_WIDTH_24<<IOMUXC_GPR2_DATA_WIDTH_CH1_OFFSET)
+
+#define IOMUXC_GPR2_BIT_MAPPING_CH0_OFFSET		6
+#define IOMUXC_GPR2_BIT_MAPPING_CH0_MASK		(1<<IOMUXC_GPR2_BIT_MAPPING_CH0_OFFSET)
+#define IOMUXC_GPR2_BIT_MAPPING_CH0_JEIDA		(IOMUXC_GPR2_BITMAP_JEIDA<<IOMUXC_GPR2_BIT_MAPPING_CH0_OFFSET)
+#define IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG		(IOMUXC_GPR2_BITMAP_SPWG<<IOMUXC_GPR2_BIT_MAPPING_CH0_OFFSET)
+
+#define IOMUXC_GPR2_DATA_WIDTH_CH0_OFFSET		5
+#define IOMUXC_GPR2_DATA_WIDTH_CH0_MASK			(1<<IOMUXC_GPR2_DATA_WIDTH_CH0_OFFSET)
+#define IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT		(IOMUXC_GPR2_DATA_WIDTH_18<<IOMUXC_GPR2_DATA_WIDTH_CH0_OFFSET)
+#define IOMUXC_GPR2_DATA_WIDTH_CH0_24BIT		(IOMUXC_GPR2_DATA_WIDTH_24<<IOMUXC_GPR2_DATA_WIDTH_CH0_OFFSET)
+
+#define IOMUXC_GPR2_SPLIT_MODE_EN_OFFSET		4
+#define IOMUXC_GPR2_SPLIT_MODE_EN_MASK			(1<<IOMUXC_GPR2_SPLIT_MODE_EN_OFFSET)
+
+#define IOMUXC_GPR2_MODE_DISABLED	0
+#define IOMUXC_GPR2_MODE_ENABLED_DI0	1
+#define IOMUXC_GPR2_MODE_ENABLED_DI1	3
+
+#define IOMUXC_GPR2_LVDS_CH1_MODE_OFFSET		2
+#define IOMUXC_GPR2_LVDS_CH1_MODE_MASK			(3<<IOMUXC_GPR2_LVDS_CH1_MODE_OFFSET)
+#define IOMUXC_GPR2_LVDS_CH1_MODE_DISABLED		(IOMUXC_GPR2_MODE_DISABLED<<IOMUXC_GPR2_LVDS_CH1_MODE_OFFSET)
+#define IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI0		(IOMUXC_GPR2_MODE_ENABLED_DI0<<IOMUXC_GPR2_LVDS_CH1_MODE_OFFSET)
+#define IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI1		(IOMUXC_GPR2_MODE_ENABLED_DI1<<IOMUXC_GPR2_LVDS_CH1_MODE_OFFSET)
+
+#define IOMUXC_GPR2_LVDS_CH0_MODE_OFFSET		0
+#define IOMUXC_GPR2_LVDS_CH0_MODE_MASK			(3<<IOMUXC_GPR2_LVDS_CH0_MODE_OFFSET)
+#define IOMUXC_GPR2_LVDS_CH0_MODE_DISABLED		(IOMUXC_GPR2_MODE_DISABLED<<IOMUXC_GPR2_LVDS_CH0_MODE_OFFSET)
+#define IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0		(IOMUXC_GPR2_MODE_ENABLED_DI0<<IOMUXC_GPR2_LVDS_CH0_MODE_OFFSET)
+#define IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI1		(IOMUXC_GPR2_MODE_ENABLED_DI1<<IOMUXC_GPR2_LVDS_CH0_MODE_OFFSET)
+
+#define IMX6SX_GPR5_CSI1_MUX_CTRL_MASK			(0x3 << 4)
+#define IMX6SX_GPR5_CSI1_MUX_CTRL_EXT_PIN		(0x0 << 4)
+#define IMX6SX_GPR5_CSI1_MUX_CTRL_CVD			(0x1 << 4)
+#define IMX6SX_GPR5_CSI1_MUX_CTRL_VDAC_TO_CSI	(0x2 << 4)
+#define IMX6SX_GPR5_CSI1_MUX_CTRL_GND			(0x3 << 4)
+
+/* ECSPI registers */
+struct cspi_regs {
+	u32 rxdata;
+	u32 txdata;
+	u32 ctrl;
+	u32 cfg;
+	u32 intr;
+	u32 dma;
+	u32 stat;
+	u32 period;
+};
+
+/*
+ * CSPI register definitions
+ */
+#define MXC_ECSPI
+#define MXC_CSPICTRL_EN		(1 << 0)
+#define MXC_CSPICTRL_MODE	(1 << 1)
+#define MXC_CSPICTRL_XCH	(1 << 2)
+#define MXC_CSPICTRL_MODE_MASK (0xf << 4)
+#define MXC_CSPICTRL_CHIPSELECT(x)	(((x) & 0x3) << 12)
+#define MXC_CSPICTRL_BITCOUNT(x)	(((x) & 0xfff) << 20)
+#define MXC_CSPICTRL_PREDIV(x)	(((x) & 0xF) << 12)
+#define MXC_CSPICTRL_POSTDIV(x)	(((x) & 0xF) << 8)
+#define MXC_CSPICTRL_SELCHAN(x)	(((x) & 0x3) << 18)
+#define MXC_CSPICTRL_MAXBITS	0xfff
+#define MXC_CSPICTRL_TC		(1 << 7)
+#define MXC_CSPICTRL_RXOVF	(1 << 6)
+#define MXC_CSPIPERIOD_32KHZ	(1 << 15)
+#define MAX_SPI_BYTES	32
+#if defined(CONFIG_MX6DL) || defined(CONFIG_MX6UL) || defined(CONFIG_MX6SLL) || defined(CONFIG_MX6SL)
+#define SPI_MAX_NUM	3
+#else
+#define SPI_MAX_NUM	4
+#endif
+
+/* Bit position inside CTRL register to be associated with SS */
+#define MXC_CSPICTRL_CHAN	18
+
+/* Bit position inside CON register to be associated with SS */
+#define MXC_CSPICON_PHA		0  /* SCLK phase control */
+#define MXC_CSPICON_POL		4  /* SCLK polarity */
+#define MXC_CSPICON_SSPOL	12 /* SS polarity */
+#define MXC_CSPICON_CTL		20 /* inactive state of SCLK */
+#if defined(CONFIG_MX6SLL) || defined(CONFIG_MX6SL) || defined(CONFIG_MX6DL) || defined(CONFIG_MX6UL)
+#define MXC_SPI_BASE_ADDRESSES \
+	ECSPI1_BASE_ADDR, \
+	ECSPI2_BASE_ADDR, \
+	ECSPI3_BASE_ADDR, \
+	ECSPI4_BASE_ADDR
+#else
+#define MXC_SPI_BASE_ADDRESSES \
+	ECSPI1_BASE_ADDR, \
+	ECSPI2_BASE_ADDR, \
+	ECSPI3_BASE_ADDR, \
+	ECSPI4_BASE_ADDR, \
+	ECSPI5_BASE_ADDR
+#endif
+
+#define ANATOP_PLL_VIDEO        0xA0
+
+struct ocotp_regs {
+	u32	ctrl;
+	u32	ctrl_set;
+	u32     ctrl_clr;
+	u32	ctrl_tog;
+	u32	timing;
+	u32     rsvd0[3];
+	u32     data;
+	u32     rsvd1[3];
+	u32     read_ctrl;
+	u32     rsvd2[3];
+	u32	read_fuse_data;
+	u32     rsvd3[3];
+	u32	sw_sticky;
+	u32     rsvd4[3];
+	u32     scs;
+	u32     scs_set;
+	u32     scs_clr;
+	u32     scs_tog;
+	u32     crc_addr;
+	u32     rsvd5[3];
+	u32     crc_value;
+	u32     rsvd6[3];
+	u32     version;
+	u32     rsvd7[0xdb];
+
+	/* fuse banks */
+	struct fuse_bank {
+		u32	fuse_regs[0x20];
+	} bank[0];
+};
+
+struct fuse_bank0_regs {
+	u32	lock;
+	u32	rsvd0[3];
+	u32	uid_low;
+	u32	rsvd1[3];
+	u32	uid_high;
+	u32	rsvd2[3];
+	u32	cfg2;
+	u32	rsvd3[3];
+	u32	cfg3;
+	u32	rsvd4[3];
+	u32	cfg4;
+	u32	rsvd5[3];
+	u32	cfg5;
+	u32	rsvd6[3];
+	u32	cfg6;
+	u32	rsvd7[3];
+};
+
+struct fuse_bank1_regs {
+	u32	mem0;
+	u32	rsvd0[3];
+	u32	mem1;
+	u32	rsvd1[3];
+	u32	mem2;
+	u32	rsvd2[3];
+	u32	mem3;
+	u32	rsvd3[3];
+	u32	mem4;
+	u32	rsvd4[3];
+	u32	ana0;
+	u32	rsvd5[3];
+	u32	ana1;
+	u32	rsvd6[3];
+	u32	ana2;
+	u32	rsvd7[3];
+};
+
+struct fuse_bank4_regs {
+	u32 sjc_resp_low;
+	u32 rsvd0[3];
+	u32 sjc_resp_high;
+	u32 rsvd1[3];
+	u32 mac_addr0;
+	u32 rsvd2[3];
+	u32 mac_addr1;
+	u32 rsvd3[3];
+	u32 mac_addr2; /*For i.MX6SX and i.MX6UL*/
+	u32 rsvd4[7];
+	u32 gp1;
+	u32 rsvd5[3];
+	u32 gp2;
+	u32 rsvd6[3];
+};
+
+struct aipstz_regs {
+	u32	mprot0;
+	u32	mprot1;
+	u32	rsvd[0xe];
+	u32	opacr0;
+	u32	opacr1;
+	u32	opacr2;
+	u32	opacr3;
+	u32	opacr4;
+};
+
+struct anatop_regs {
+	u32	pll_sys;		/* 0x000 */
+	u32	pll_sys_set;		/* 0x004 */
+	u32	pll_sys_clr;		/* 0x008 */
+	u32	pll_sys_tog;		/* 0x00c */
+	u32	usb1_pll_480_ctrl;	/* 0x010 */
+	u32	usb1_pll_480_ctrl_set;	/* 0x014 */
+	u32	usb1_pll_480_ctrl_clr;	/* 0x018 */
+	u32	usb1_pll_480_ctrl_tog;	/* 0x01c */
+	u32	usb2_pll_480_ctrl;	/* 0x020 */
+	u32	usb2_pll_480_ctrl_set;	/* 0x024 */
+	u32	usb2_pll_480_ctrl_clr;	/* 0x028 */
+	u32	usb2_pll_480_ctrl_tog;	/* 0x02c */
+	u32	pll_528;		/* 0x030 */
+	u32	pll_528_set;		/* 0x034 */
+	u32	pll_528_clr;		/* 0x038 */
+	u32	pll_528_tog;		/* 0x03c */
+	u32	pll_528_ss;		/* 0x040 */
+	u32	rsvd0[3];
+	u32	pll_528_num;		/* 0x050 */
+	u32	rsvd1[3];
+	u32	pll_528_denom;		/* 0x060 */
+	u32	rsvd2[3];
+	u32	pll_audio;		/* 0x070 */
+	u32	pll_audio_set;		/* 0x074 */
+	u32	pll_audio_clr;		/* 0x078 */
+	u32	pll_audio_tog;		/* 0x07c */
+	u32	pll_audio_num;		/* 0x080 */
+	u32	rsvd3[3];
+	u32	pll_audio_denom;	/* 0x090 */
+	u32	rsvd4[3];
+	u32	pll_video;		/* 0x0a0 */
+	u32	pll_video_set;		/* 0x0a4 */
+	u32	pll_video_clr;		/* 0x0a8 */
+	u32	pll_video_tog;		/* 0x0ac */
+	u32	pll_video_num;		/* 0x0b0 */
+	u32	rsvd5[3];
+	u32	pll_video_denom;	/* 0x0c0 */
+	u32	rsvd6[3];
+	u32	pll_mlb;		/* 0x0d0 */
+	u32	pll_mlb_set;		/* 0x0d4 */
+	u32	pll_mlb_clr;		/* 0x0d8 */
+	u32	pll_mlb_tog;		/* 0x0dc */
+	u32	pll_enet;		/* 0x0e0 */
+	u32	pll_enet_set;		/* 0x0e4 */
+	u32	pll_enet_clr;		/* 0x0e8 */
+	u32	pll_enet_tog;		/* 0x0ec */
+	u32	pfd_480;		/* 0x0f0 */
+	u32	pfd_480_set;		/* 0x0f4 */
+	u32	pfd_480_clr;		/* 0x0f8 */
+	u32	pfd_480_tog;		/* 0x0fc */
+	u32	pfd_528;		/* 0x100 */
+	u32	pfd_528_set;		/* 0x104 */
+	u32	pfd_528_clr;		/* 0x108 */
+	u32	pfd_528_tog;		/* 0x10c */
+	u32	reg_1p1;		/* 0x110 */
+	u32	reg_1p1_set;		/* 0x114 */
+	u32	reg_1p1_clr;		/* 0x118 */
+	u32	reg_1p1_tog;		/* 0x11c */
+	u32	reg_3p0;		/* 0x120 */
+	u32	reg_3p0_set;		/* 0x124 */
+	u32	reg_3p0_clr;		/* 0x128 */
+	u32	reg_3p0_tog;		/* 0x12c */
+	u32	reg_2p5;		/* 0x130 */
+	u32	reg_2p5_set;		/* 0x134 */
+	u32	reg_2p5_clr;		/* 0x138 */
+	u32	reg_2p5_tog;		/* 0x13c */
+	u32	reg_core;		/* 0x140 */
+	u32	reg_core_set;		/* 0x144 */
+	u32	reg_core_clr;		/* 0x148 */
+	u32	reg_core_tog;		/* 0x14c */
+	u32	ana_misc0;		/* 0x150 */
+	u32	ana_misc0_set;		/* 0x154 */
+	u32	ana_misc0_clr;		/* 0x158 */
+	u32	ana_misc0_tog;		/* 0x15c */
+	u32	ana_misc1;		/* 0x160 */
+	u32	ana_misc1_set;		/* 0x164 */
+	u32	ana_misc1_clr;		/* 0x168 */
+	u32	ana_misc1_tog;		/* 0x16c */
+	u32	ana_misc2;		/* 0x170 */
+	u32	ana_misc2_set;		/* 0x174 */
+	u32	ana_misc2_clr;		/* 0x178 */
+	u32	ana_misc2_tog;		/* 0x17c */
+	u32	tempsense0;		/* 0x180 */
+	u32	tempsense0_set;		/* 0x184 */
+	u32	tempsense0_clr;		/* 0x188 */
+	u32	tempsense0_tog;		/* 0x18c */
+	u32	tempsense1;		/* 0x190 */
+	u32	tempsense1_set;		/* 0x194 */
+	u32	tempsense1_clr;		/* 0x198 */
+	u32	tempsense1_tog;		/* 0x19c */
+	u32	usb1_vbus_detect;	/* 0x1a0 */
+	u32	usb1_vbus_detect_set;	/* 0x1a4 */
+	u32	usb1_vbus_detect_clr;	/* 0x1a8 */
+	u32	usb1_vbus_detect_tog;	/* 0x1ac */
+	u32	usb1_chrg_detect;	/* 0x1b0 */
+	u32	usb1_chrg_detect_set;	/* 0x1b4 */
+	u32	usb1_chrg_detect_clr;	/* 0x1b8 */
+	u32	usb1_chrg_detect_tog;	/* 0x1bc */
+	u32	usb1_vbus_det_stat;	/* 0x1c0 */
+	u32	usb1_vbus_det_stat_set;	/* 0x1c4 */
+	u32	usb1_vbus_det_stat_clr;	/* 0x1c8 */
+	u32	usb1_vbus_det_stat_tog;	/* 0x1cc */
+	u32	usb1_chrg_det_stat;	/* 0x1d0 */
+	u32	usb1_chrg_det_stat_set;	/* 0x1d4 */
+	u32	usb1_chrg_det_stat_clr;	/* 0x1d8 */
+	u32	usb1_chrg_det_stat_tog;	/* 0x1dc */
+	u32	usb1_loopback;		/* 0x1e0 */
+	u32	usb1_loopback_set;	/* 0x1e4 */
+	u32	usb1_loopback_clr;	/* 0x1e8 */
+	u32	usb1_loopback_tog;	/* 0x1ec */
+	u32	usb1_misc;		/* 0x1f0 */
+	u32	usb1_misc_set;		/* 0x1f4 */
+	u32	usb1_misc_clr;		/* 0x1f8 */
+	u32	usb1_misc_tog;		/* 0x1fc */
+	u32	usb2_vbus_detect;	/* 0x200 */
+	u32	usb2_vbus_detect_set;	/* 0x204 */
+	u32	usb2_vbus_detect_clr;	/* 0x208 */
+	u32	usb2_vbus_detect_tog;	/* 0x20c */
+	u32	usb2_chrg_detect;	/* 0x210 */
+	u32	usb2_chrg_detect_set;	/* 0x214 */
+	u32	usb2_chrg_detect_clr;	/* 0x218 */
+	u32	usb2_chrg_detect_tog;	/* 0x21c */
+	u32	usb2_vbus_det_stat;	/* 0x220 */
+	u32	usb2_vbus_det_stat_set;	/* 0x224 */
+	u32	usb2_vbus_det_stat_clr;	/* 0x228 */
+	u32	usb2_vbus_det_stat_tog;	/* 0x22c */
+	u32	usb2_chrg_det_stat;	/* 0x230 */
+	u32	usb2_chrg_det_stat_set;	/* 0x234 */
+	u32	usb2_chrg_det_stat_clr;	/* 0x238 */
+	u32	usb2_chrg_det_stat_tog;	/* 0x23c */
+	u32	usb2_loopback;		/* 0x240 */
+	u32	usb2_loopback_set;	/* 0x244 */
+	u32	usb2_loopback_clr;	/* 0x248 */
+	u32	usb2_loopback_tog;	/* 0x24c */
+	u32	usb2_misc;		/* 0x250 */
+	u32	usb2_misc_set;		/* 0x254 */
+	u32	usb2_misc_clr;		/* 0x258 */
+	u32	usb2_misc_tog;		/* 0x25c */
+	u32	digprog;		/* 0x260 */
+	u32	reserved1[7];
+	u32	digprog_sololite;	/* 0x280 */
+};
+
+#define ANATOP_PFD_FRAC_SHIFT(n)	((n)*8)
+#define ANATOP_PFD_FRAC_MASK(n)	(0x3f<<ANATOP_PFD_FRAC_SHIFT(n))
+#define ANATOP_PFD_STABLE_SHIFT(n)	(6+((n)*8))
+#define ANATOP_PFD_STABLE_MASK(n)	(1<<ANATOP_PFD_STABLE_SHIFT(n))
+#define ANATOP_PFD_CLKGATE_SHIFT(n)	(7+((n)*8))
+#define ANATOP_PFD_CLKGATE_MASK(n)	(1<<ANATOP_PFD_CLKGATE_SHIFT(n))
+
+struct iomuxc_gpr_base_regs {
+#if defined(CONFIG_MX6UL)
+	u32     gpr[15];        /* 0x000 */
+#else
+	u32     gpr[14];        /* 0x000 */
+#endif
+};
+
+struct iomuxc_base_regs {
+#if !(defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL))
+	u32     gpr[14];        /* 0x000 */
+#endif
+	u32     obsrv[5];       /* 0x038 */
+	u32     swmux_ctl[197]; /* 0x04c */
+	u32     swpad_ctl[250]; /* 0x360 */
+	u32     swgrp[26];      /* 0x748 */
+	u32     daisy[104];     /* 0x7b0..94c */
+};
+
+struct wdog_regs {
+	u16	wcr;	/* Control */
+	u16	wsr;	/* Service */
+	u16	wrsr;	/* Reset Status */
+	u16	wicr;	/* Interrupt Control */
+	u16	wmcr;	/* Miscellaneous Control */
+};
+
+#define PWMCR_PRESCALER(x)	(((x - 1) & 0xFFF) << 4)
+#define PWMCR_DOZEEN		(1 << 24)
+#define PWMCR_WAITEN		(1 << 23)
+#define PWMCR_DBGEN		(1 << 22)
+#define PWMCR_CLKSRC_IPG_HIGH	(2 << 16)
+#define PWMCR_CLKSRC_IPG	(1 << 16)
+#define PWMCR_EN		(1 << 0)
+
+struct pwm_regs {
+	u32	cr;
+	u32	sr;
+	u32	ir;
+	u32	sar;
+	u32	pr;
+	u32	cnr;
+};
+
+struct dbg_monitor_regs {
+	u32	ctrl[4];		/* Control */
+	u32	master_en[4];		/* Master enable */
+	u32	irq[4];			/* IRQ */
+	u32	trap_addr_low[4];	/* Trap address low */
+	u32	trap_addr_high[4];	/* Trap address high */
+	u32	trap_id[4];		/* Trap ID */
+	u32	snvs_addr[4];		/* SNVS address */
+	u32	snvs_data[4];		/* SNVS data */
+	u32	snvs_info[4];		/* SNVS info */
+	u32	version[4];		/* Version */
+};
+
+/*
+ * If ROM fail back to USB recover mode, USBPH0_PWD will be clear to use USB
+ * If boot from the other mode, USB0_PWD will keep reset value
+ */
+#define	is_boot_from_usb(void) (!(readl(USB_PHY0_BASE_ADDR) & (1<<20)))
+#define	disconnect_from_pc(void) writel(0x0, OTG_BASE_ADDR + 0x140)
+
+#endif /* __ASSEMBLER__*/
+#endif /* __ASM_ARCH_MX6_IMX_REGS_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/iomux.h ebf_6ull_uboot/arch/arm/include/asm/arch/iomux.h
--- u-boot-2016.03/arch/arm/include/asm/arch/iomux.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/iomux.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,181 @@
+/*
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_IOMUX_H__
+#define __ASM_ARCH_IOMUX_H__
+
+#define MX6_IOMUXC_GPR4		0x020e0010
+#define MX6_IOMUXC_GPR6		0x020e0018
+#define MX6_IOMUXC_GPR7		0x020e001c
+
+/*
+ * IOMUXC_GPR1 bit fields
+ */
+#define IOMUXC_GPR1_OTG_ID_ENET_RX_ERR	(0<<13)
+#define IOMUXC_GPR1_OTG_ID_GPIO1	(1<<13)
+#define IOMUXC_GPR1_OTG_ID_MASK		(1<<13)
+#define IOMUXC_GPR1_REF_SSP_EN			(1 << 16)
+#define IOMUXC_GPR1_TEST_POWERDOWN		(1 << 18)
+
+#define IOMUXC_GPR1_PCIE_SW_RST		(1 << 29)
+
+/*
+ * IOMUXC_GPR5 bit fields
+ */
+#define IOMUXC_GPR5_PCIE_BTNRST			(1 << 19)
+#define IOMUXC_GPR5_PCIE_PERST			(1 << 18)
+
+/*
+ * IOMUXC_GPR8 bit fields
+ */
+#define IOMUXC_GPR8_PCS_TX_DEEMPH_GEN1_MASK		(0x3f << 0)
+#define IOMUXC_GPR8_PCS_TX_DEEMPH_GEN1_OFFSET		0
+#define IOMUXC_GPR8_PCS_TX_DEEMPH_GEN2_3P5DB_MASK	(0x3f << 6)
+#define IOMUXC_GPR8_PCS_TX_DEEMPH_GEN2_3P5DB_OFFSET	6
+#define IOMUXC_GPR8_PCS_TX_DEEMPH_GEN2_6DB_MASK		(0x3f << 12)
+#define IOMUXC_GPR8_PCS_TX_DEEMPH_GEN2_6DB_OFFSET	12
+#define IOMUXC_GPR8_PCS_TX_SWING_FULL_MASK		(0x7f << 18)
+#define IOMUXC_GPR8_PCS_TX_SWING_FULL_OFFSET		18
+#define IOMUXC_GPR8_PCS_TX_SWING_LOW_MASK		(0x7f << 25)
+#define IOMUXC_GPR8_PCS_TX_SWING_LOW_OFFSET		25
+
+/*
+ * IOMUXC_GPR12 bit fields
+ */
+#define IOMUXC_GPR12_RX_EQ_2			(0x2 << 0)
+#define IOMUXC_GPR12_RX_EQ_MASK			(0x7 << 0)
+#define IOMUXC_GPR12_LOS_LEVEL_9		(0x9 << 4)
+#define IOMUXC_GPR12_LOS_LEVEL_MASK		(0x1f << 4)
+#define IOMUXC_GPR12_APPS_LTSSM_ENABLE		(1 << 10)
+#define IOMUXC_GPR12_DEVICE_TYPE_EP		(0x0 << 12)
+#define IOMUXC_GPR12_DEVICE_TYPE_RC		(0x4 << 12)
+#define IOMUXC_GPR12_DEVICE_TYPE_MASK		(0xf << 12)
+#define IOMUXC_GPR12_TEST_POWERDOWN		(1 << 30)
+
+/*
+ * IOMUXC_GPR13 bit fields
+ */
+#define IOMUXC_GPR13_SDMA_STOP_REQ	(1<<30)
+#define IOMUXC_GPR13_CAN2_STOP_REQ	(1<<29)
+#define IOMUXC_GPR13_CAN1_STOP_REQ	(1<<28)
+#define IOMUXC_GPR13_ENET_STOP_REQ	(1<<27)
+#define IOMUXC_GPR13_SATA_PHY_8_MASK	(7<<24)
+#define IOMUXC_GPR13_SATA_PHY_7_MASK	(0x1f<<19)
+#define IOMUXC_GPR13_SATA_PHY_6_SHIFT	16
+#define IOMUXC_GPR13_SATA_PHY_6_MASK	(7<<IOMUXC_GPR13_SATA_PHY_6_SHIFT)
+#define IOMUXC_GPR13_SATA_SPEED_MASK	(1<<15)
+#define IOMUXC_GPR13_SATA_PHY_5_MASK	(1<<14)
+#define IOMUXC_GPR13_SATA_PHY_4_MASK	(7<<11)
+#define IOMUXC_GPR13_SATA_PHY_3_MASK	(0x1f<<7)
+#define IOMUXC_GPR13_SATA_PHY_2_MASK	(0x1f<<2)
+#define IOMUXC_GPR13_SATA_PHY_1_MASK	(3<<0)
+
+#define IOMUX_GPR1_FEC_CLOCK_MUX1_SEL_MASK (0x3 << 17)
+#define IOMUX_GPR1_FEC_CLOCK_MUX2_SEL_MASK (0x1 << 14)
+#define IOMUX_GPR1_FEC_MASK    (IOMUX_GPR1_FEC_CLOCK_MUX1_SEL_MASK \
+				| IOMUX_GPR1_FEC_CLOCK_MUX2_SEL_MASK)
+
+#define IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK (0x1 << 17)
+#define IOMUX_GPR1_FEC1_CLOCK_MUX2_SEL_MASK (0x1 << 13)
+#define IOMUX_GPR1_FEC1_MASK	(IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK \
+				| IOMUX_GPR1_FEC1_CLOCK_MUX2_SEL_MASK)
+
+#define IOMUX_GPR1_FEC2_CLOCK_MUX1_SEL_MASK (0x1 << 18)
+#define IOMUX_GPR1_FEC2_CLOCK_MUX2_SEL_MASK (0x1 << 14)
+#define IOMUX_GPR1_FEC2_MASK	(IOMUX_GPR1_FEC2_CLOCK_MUX1_SEL_MASK \
+				| IOMUX_GPR1_FEC2_CLOCK_MUX2_SEL_MASK)
+
+#define IOMUXC_GPR13_SATA_PHY_8_RXEQ_0P5DB	(0<<24)
+#define IOMUXC_GPR13_SATA_PHY_8_RXEQ_1P0DB	(1<<24)
+#define IOMUXC_GPR13_SATA_PHY_8_RXEQ_1P5DB	(2<<24)
+#define IOMUXC_GPR13_SATA_PHY_8_RXEQ_2P0DB	(3<<24)
+#define IOMUXC_GPR13_SATA_PHY_8_RXEQ_2P5DB	(4<<24)
+#define IOMUXC_GPR13_SATA_PHY_8_RXEQ_3P0DB	(5<<24)
+#define IOMUXC_GPR13_SATA_PHY_8_RXEQ_3P5DB	(6<<24)
+#define IOMUXC_GPR13_SATA_PHY_8_RXEQ_4P0DB	(7<<24)
+
+#define IOMUXC_GPR13_SATA_PHY_7_SATA1I	(0x10<<19)
+#define IOMUXC_GPR13_SATA_PHY_7_SATA1M	(0x10<<19)
+#define IOMUXC_GPR13_SATA_PHY_7_SATA1X	(0x1A<<19)
+#define IOMUXC_GPR13_SATA_PHY_7_SATA2I	(0x12<<19)
+#define IOMUXC_GPR13_SATA_PHY_7_SATA2M	(0x12<<19)
+#define IOMUXC_GPR13_SATA_PHY_7_SATA2X	(0x1A<<19)
+
+#define IOMUXC_GPR13_SATA_SPEED_1P5G	(0<<15)
+#define IOMUXC_GPR13_SATA_SPEED_3G	(1<<15)
+
+#define IOMUXC_GPR13_SATA_SATA_PHY_5_SS_DISABLED	(0<<14)
+#define IOMUXC_GPR13_SATA_SATA_PHY_5_SS_ENABLED		(1<<14)
+
+#define IOMUXC_GPR13_SATA_SATA_PHY_4_ATTEN_16_16	(0<<11)
+#define IOMUXC_GPR13_SATA_SATA_PHY_4_ATTEN_14_16	(1<<11)
+#define IOMUXC_GPR13_SATA_SATA_PHY_4_ATTEN_12_16	(2<<11)
+#define IOMUXC_GPR13_SATA_SATA_PHY_4_ATTEN_10_16	(3<<11)
+#define IOMUXC_GPR13_SATA_SATA_PHY_4_ATTEN_9_16		(4<<11)
+#define IOMUXC_GPR13_SATA_SATA_PHY_4_ATTEN_8_16		(5<<11)
+
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_0P00_DB	(0<<7)
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_0P37_DB	(1<<7)
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_0P74_DB	(2<<7)
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_1P11_DB	(3<<7)
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_1P48_DB	(4<<7)
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_1P85_DB	(5<<7)
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_2P22_DB	(6<<7)
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_2P59_DB	(7<<7)
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_2P96_DB	(8<<7)
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_3P33_DB	(9<<7)
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_3P70_DB	(0xA<<7)
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_4P07_DB	(0xB<<7)
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_4P44_DB	(0xC<<7)
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_4P81_DB	(0xD<<7)
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_5P28_DB	(0xE<<7)
+#define IOMUXC_GPR13_SATA_PHY_3_TXBOOST_5P75_DB	(0xF<<7)
+
+#define IOMUXC_GPR13_SATA_PHY_2_TX_0P937V	(0<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_0P947V	(1<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_0P957V	(2<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_0P966V	(3<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_0P976V	(4<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_0P986V	(5<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_0P996V	(6<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P005V	(7<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P015V	(8<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P025V	(9<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P035V	(0xA<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P045V	(0xB<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P054V	(0xC<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P064V	(0xD<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P074V	(0xE<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P084V	(0xF<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P094V	(0x10<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P104V	(0x11<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P113V	(0x12<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P123V	(0x13<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P133V	(0x14<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P143V	(0x15<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P152V	(0x16<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P162V	(0x17<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P172V	(0x18<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P182V	(0x19<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P191V	(0x1A<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P201V	(0x1B<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P211V	(0x1C<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P221V	(0x1D<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P230V	(0x1E<<2)
+#define IOMUXC_GPR13_SATA_PHY_2_TX_1P240V	(0x1F<<2)
+
+#define IOMUXC_GPR13_SATA_PHY_1_FAST	0
+#define IOMUXC_GPR13_SATA_PHY_1_MEDIUM	1
+#define IOMUXC_GPR13_SATA_PHY_1_SLOW	2
+
+#define IOMUXC_GPR13_SATA_MASK (IOMUXC_GPR13_SATA_PHY_8_MASK \
+				|IOMUXC_GPR13_SATA_PHY_7_MASK \
+				|IOMUXC_GPR13_SATA_PHY_6_MASK \
+				|IOMUXC_GPR13_SATA_SPEED_MASK \
+				|IOMUXC_GPR13_SATA_PHY_5_MASK \
+				|IOMUXC_GPR13_SATA_PHY_4_MASK \
+				|IOMUXC_GPR13_SATA_PHY_3_MASK \
+				|IOMUXC_GPR13_SATA_PHY_2_MASK \
+				|IOMUXC_GPR13_SATA_PHY_1_MASK)
+#endif	/* __ASM_ARCH_IOMUX_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/module_fuse.h ebf_6ull_uboot/arch/arm/include/asm/arch/module_fuse.h
--- u-boot-2016.03/arch/arm/include/asm/arch/module_fuse.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/module_fuse.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MODULE_FUSE_H__
+#define __MODULE_FUSE_H__
+
+enum fuse_module_type{
+	MX6_MODULE_TSC,
+	MX6_MODULE_ADC1,
+	MX6_MODULE_ADC2,
+	MX6_MODULE_SIM1,
+	MX6_MODULE_SIM2,
+	MX6_MODULE_FLEXCAN1,
+	MX6_MODULE_FLEXCAN2,
+	MX6_MODULE_SPDIF,
+	MX6_MODULE_EIM,
+	MX6_MODULE_SD1,
+	MX6_MODULE_SD2,
+	MX6_MODULE_SD3,
+	MX6_MODULE_SD4,
+	MX6_MODULE_QSPI1,
+	MX6_MODULE_QSPI2,
+	MX6_MODULE_GPMI,
+	MX6_MODULE_APBHDMA,
+	MX6_MODULE_LCDIF,
+	MX6_MODULE_PXP,
+	MX6_MODULE_CSI,
+	MX6_MODULE_ENET1,
+	MX6_MODULE_ENET2,
+	MX6_MODULE_CAAM,
+	MX6_MODULE_USB_OTG1,
+	MX6_MODULE_USB_OTG2,
+	MX6_MODULE_SAI2,
+	MX6_MODULE_SAI3,
+	MX6_MODULE_BEE,
+	MX6_MODULE_UART1,
+	MX6_MODULE_UART2,
+	MX6_MODULE_UART3,
+	MX6_MODULE_UART4,
+	MX6_MODULE_UART5,
+	MX6_MODULE_UART6,
+	MX6_MODULE_UART7,
+	MX6_MODULE_UART8,
+	MX6_MODULE_PWM5,
+	MX6_MODULE_PWM6,
+	MX6_MODULE_PWM7,
+	MX6_MODULE_PWM8,
+	MX6_MODULE_ECSPI1,
+	MX6_MODULE_ECSPI2,
+	MX6_MODULE_ECSPI3,
+	MX6_MODULE_ECSPI4,
+	MX6_MODULE_ECSPI5,
+	MX6_MODULE_I2C1,
+	MX6_MODULE_I2C2,
+	MX6_MODULE_I2C3,
+	MX6_MODULE_I2C4,
+	MX6_MODULE_GPT1,
+	MX6_MODULE_GPT2,
+	MX6_MODULE_EPIT1,
+	MX6_MODULE_EPIT2,
+};
+
+#if !defined(CONFIG_MODULE_FUSE)
+static inline u32 check_module_fused(enum fuse_module_type module)
+{
+	return 0;
+};
+
+static inline u32 mx6_esdhc_fused(u32 base_addr)
+{
+	return 0;
+};
+
+static inline u32 mx6_ecspi_fused(u32 base_addr)
+{
+	return 0;
+};
+static inline u32 mx6_uart_fused(u32 base_addr)
+{
+	return 0;
+};
+static inline u32 mx6_usb_fused(u32 base_addr)
+{
+	return 0;
+};
+static inline u32 mx6_qspi_fused(u32 base_addr)
+{
+	return 0;
+};
+static inline u32 mx6_i2c_fused(u32 base_addr)
+{
+	return 0;
+};
+static inline u32 mx6_enet_fused(u32 base_addr)
+{
+	return 0;
+};
+
+#else
+u32 check_module_fused(enum fuse_module_type module);
+u32 mx6_esdhc_fused(u32 base_addr);
+u32 mx6_ecspi_fused(u32 base_addr);
+u32 mx6_uart_fused(u32 base_addr);
+u32 mx6_usb_fused(u32 base_addr);
+u32 mx6_qspi_fused(u32 base_addr);
+u32 mx6_i2c_fused(u32 base_addr);
+u32 mx6_enet_fused(u32 base_addr);
+#endif
+
+#ifdef DEBUG
+void print_fuse_status();
+void simulate_fuse();
+#endif
+
+#endif /* __MODULE_FUSE_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6_bee.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6_bee.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6_bee.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6_bee.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+
+#define GPR0           0x0
+#define GPR1           0x4
+#define GPR2           0x8
+#define GPR3           0xC
+#define GPR4           0x10
+#define GPR5           0x14
+#define GPR6           0x18
+#define GPR7           0x1C
+#define GPR8           0x20
+#define GPR9           0x24
+#define GPR10          0x28
+#define GPR11          0x2C
+
+#define GPR0_CTRL_CLK_EN_LOCK	(1 << 31)
+#define GPR0_CTRL_CLK_EN	(1 << 15)
+#define GPR0_CTRL_SFTRST_N_LOCK	(1 << 30)
+#define GPR0_CTRL_SFTRST	(0 << 14)
+#define GPR0_CTRL_SFTRST_N	(1 << 14)
+#define GPR0_CTRL_AES_MODE_LOCK	(1 << 29)
+#define GPR0_CTRL_AES_MODE_ECB	(0 << 13)
+#define GPR0_CTRL_AES_MODE_CTR	(1 << 13)
+#define GPR0_SEC_LEVEL_LOCK	(3 << 24)
+#define GPR0_SEC_LEVEL		(3 << 8)
+#define GPR0_AES_KEY_SEL_LOCK	(1 << 20)
+#define GPR0_AES_KEY_SEL_SNVS	(0 << 4)
+#define GPR0_AES_KEY_SEL_SOFT	(1 << 4)
+#define GPR0_BEE_ENABLE_LOCK	(1 << 16)
+#define GPR0_BEE_ENABLE		(1 << 0)
+
+/*
+ * SECURITY LEVEL
+ *        Non-Secure User |  Non-Secure Spvr | Secure User | Secure Spvr
+ * Level
+ * (0)00      RD + WR           RD + WR          RD + WR       RD + WR
+ * (1)01      None              RD + WR          RD + WR       RD + WR
+ * (2)10      None              None             RD + WR       RD + WR
+ * (3)11      None              None             None          RD + WR
+ */
+#define GPR0_SEC_LEVEL_0	(0 << 8)
+#define GPR0_SEC_LEVEL_1	(1 << 8)
+#define GPR0_SEC_LEVEL_2	(2 << 8)
+#define GPR0_SEC_LEVEL_3	(3 << 8)
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6-ddr.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6-ddr.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6-ddr.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6-ddr.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,525 @@
+/*
+ * Copyright (C) 2013 Boundary Devices Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __ASM_ARCH_MX6_DDR_H__
+#define __ASM_ARCH_MX6_DDR_H__
+
+#ifndef CONFIG_SPL_BUILD
+#ifdef CONFIG_MX6Q
+#include "mx6q-ddr.h"
+#else
+#if defined(CONFIG_MX6DL) || defined(CONFIG_MX6S)
+#include "mx6dl-ddr.h"
+#else
+#ifdef CONFIG_MX6SX
+#include "mx6sx-ddr.h"
+#else
+#ifdef CONFIG_MX6UL
+#include "mx6ul-ddr.h"
+#else
+#ifdef CONFIG_MX6SL
+#include "mx6sl-ddr.h"
+#else
+#error "Please select cpu"
+#endif	/* CONFIG_MX6SL */
+#endif	/* CONFIG_MX6UL */
+#endif	/* CONFIG_MX6SX */
+#endif	/* CONFIG_MX6DL or CONFIG_MX6S */
+#endif	/* CONFIG_MX6Q */
+#else
+
+enum {
+	DDR_TYPE_DDR3,
+	DDR_TYPE_LPDDR2,
+};
+
+/* MMDC P0/P1 Registers */
+struct mmdc_p_regs {
+	u32 mdctl;
+	u32 mdpdc;
+	u32 mdotc;
+	u32 mdcfg0;
+	u32 mdcfg1;
+	u32 mdcfg2;
+	u32 mdmisc;
+	u32 mdscr;
+	u32 mdref;
+	u32 res1[2];
+	u32 mdrwd;
+	u32 mdor;
+	u32 mdmrr;
+	u32 mdcfg3lp;
+	u32 mdmr4;
+	u32 mdasp;
+	u32 res2[239];
+	u32 maarcr;
+	u32 mapsr;
+	u32 maexidr0;
+	u32 maexidr1;
+	u32 madpcr0;
+	u32 madpcr1;
+	u32 madpsr0;
+	u32 madpsr1;
+	u32 madpsr2;
+	u32 madpsr3;
+	u32 madpsr4;
+	u32 madpsr5;
+	u32 masbs0;
+	u32 masbs1;
+	u32 res3[2];
+	u32 magenp;
+	u32 res4[239];
+	u32 mpzqhwctrl;
+	u32 mpzqswctrl;
+	u32 mpwlgcr;
+	u32 mpwldectrl0;
+	u32 mpwldectrl1;
+	u32 mpwldlst;
+	u32 mpodtctrl;
+	u32 mprddqby0dl;
+	u32 mprddqby1dl;
+	u32 mprddqby2dl;
+	u32 mprddqby3dl;
+	u32 mpwrdqby0dl;
+	u32 mpwrdqby1dl;
+	u32 mpwrdqby2dl;
+	u32 mpwrdqby3dl;
+	u32 mpdgctrl0;
+	u32 mpdgctrl1;
+	u32 mpdgdlst0;
+	u32 mprddlctl;
+	u32 mprddlst;
+	u32 mpwrdlctl;
+	u32 mpwrdlst;
+	u32 mpsdctrl;
+	u32 mpzqlp2ctl;
+	u32 mprddlhwctl;
+	u32 mpwrdlhwctl;
+	u32 mprddlhwst0;
+	u32 mprddlhwst1;
+	u32 mpwrdlhwst0;
+	u32 mpwrdlhwst1;
+	u32 mpwlhwerr;
+	u32 mpdghwst0;
+	u32 mpdghwst1;
+	u32 mpdghwst2;
+	u32 mpdghwst3;
+	u32 mppdcmpr1;
+	u32 mppdcmpr2;
+	u32 mpswdar0;
+	u32 mpswdrdr0;
+	u32 mpswdrdr1;
+	u32 mpswdrdr2;
+	u32 mpswdrdr3;
+	u32 mpswdrdr4;
+	u32 mpswdrdr5;
+	u32 mpswdrdr6;
+	u32 mpswdrdr7;
+	u32 mpmur0;
+	u32 mpwrcadl;
+	u32 mpdccr;
+};
+
+#define MX6SL_IOM_DDR_BASE     0x020e0300
+struct mx6sl_iomux_ddr_regs {
+	u32 dram_cas;
+	u32 dram_cs0_b;
+	u32 dram_cs1_b;
+	u32 dram_dqm0;
+	u32 dram_dqm1;
+	u32 dram_dqm2;
+	u32 dram_dqm3;
+	u32 dram_ras;
+	u32 dram_reset;
+	u32 dram_sdba0;
+	u32 dram_sdba1;
+	u32 dram_sdba2;
+	u32 dram_sdcke0;
+	u32 dram_sdcke1;
+	u32 dram_sdclk_0;
+	u32 dram_odt0;
+	u32 dram_odt1;
+	u32 dram_sdqs0;
+	u32 dram_sdqs1;
+	u32 dram_sdqs2;
+	u32 dram_sdqs3;
+	u32 dram_sdwe_b;
+};
+
+#define MX6SL_IOM_GRP_BASE     0x020e0500
+struct mx6sl_iomux_grp_regs {
+	u32 res1[43];
+	u32 grp_addds;
+	u32 grp_ddrmode_ctl;
+	u32 grp_ddrpke;
+	u32 grp_ddrpk;
+	u32 grp_ddrhys;
+	u32 grp_ddrmode;
+	u32 grp_b0ds;
+	u32 grp_ctlds;
+	u32 grp_b1ds;
+	u32 grp_ddr_type;
+	u32 grp_b2ds;
+	u32 grp_b3ds;
+};
+
+#define MX6UL_IOM_DDR_BASE	0x020e0200
+struct mx6ul_iomux_ddr_regs {
+	u32 res1[17];
+	u32 dram_dqm0;
+	u32 dram_dqm1;
+	u32 dram_ras;
+	u32 dram_cas;
+	u32 dram_cs0;
+	u32 dram_cs1;
+	u32 dram_sdwe_b;
+	u32 dram_odt0;
+	u32 dram_odt1;
+	u32 dram_sdba0;
+	u32 dram_sdba1;
+	u32 dram_sdba2;
+	u32 dram_sdcke0;
+	u32 dram_sdcke1;
+	u32 dram_sdclk_0;
+	u32 dram_sdqs0;
+	u32 dram_sdqs1;
+	u32 dram_reset;
+};
+
+#define MX6UL_IOM_GRP_BASE	0x020e0400
+struct mx6ul_iomux_grp_regs {
+	u32 res1[36];
+	u32 grp_addds;
+	u32 grp_ddrmode_ctl;
+	u32 grp_b0ds;
+	u32 grp_ddrpk;
+	u32 grp_ctlds;
+	u32 grp_b1ds;
+	u32 grp_ddrhys;
+	u32 grp_ddrpke;
+	u32 grp_ddrmode;
+	u32 grp_ddr_type;
+};
+
+#define MX6SX_IOM_DDR_BASE	0x020e0200
+struct mx6sx_iomux_ddr_regs {
+	u32 res1[59];
+	u32 dram_dqm0;
+	u32 dram_dqm1;
+	u32 dram_dqm2;
+	u32 dram_dqm3;
+	u32 dram_ras;
+	u32 dram_cas;
+	u32 res2[2];
+	u32 dram_sdwe_b;
+	u32 dram_odt0;
+	u32 dram_odt1;
+	u32 dram_sdba0;
+	u32 dram_sdba1;
+	u32 dram_sdba2;
+	u32 dram_sdcke0;
+	u32 dram_sdcke1;
+	u32 dram_sdclk_0;
+	u32 dram_sdqs0;
+	u32 dram_sdqs1;
+	u32 dram_sdqs2;
+	u32 dram_sdqs3;
+	u32 dram_reset;
+};
+
+#define MX6SX_IOM_GRP_BASE	0x020e0500
+struct mx6sx_iomux_grp_regs {
+	u32 res1[61];
+	u32 grp_addds;
+	u32 grp_ddrmode_ctl;
+	u32 grp_ddrpke;
+	u32 grp_ddrpk;
+	u32 grp_ddrhys;
+	u32 grp_ddrmode;
+	u32 grp_b0ds;
+	u32 grp_b1ds;
+	u32 grp_ctlds;
+	u32 grp_ddr_type;
+	u32 grp_b2ds;
+	u32 grp_b3ds;
+};
+
+/*
+ * MMDC iomux registers (pinctl/padctl) - (different for IMX6DQ vs IMX6SDL)
+ */
+#define MX6DQ_IOM_DDR_BASE      0x020e0500
+struct mx6dq_iomux_ddr_regs {
+	u32 res1[3];
+	u32 dram_sdqs5;
+	u32 dram_dqm5;
+	u32 dram_dqm4;
+	u32 dram_sdqs4;
+	u32 dram_sdqs3;
+	u32 dram_dqm3;
+	u32 dram_sdqs2;
+	u32 dram_dqm2;
+	u32 res2[16];
+	u32 dram_cas;
+	u32 res3[2];
+	u32 dram_ras;
+	u32 dram_reset;
+	u32 res4[2];
+	u32 dram_sdclk_0;
+	u32 dram_sdba2;
+	u32 dram_sdcke0;
+	u32 dram_sdclk_1;
+	u32 dram_sdcke1;
+	u32 dram_sdodt0;
+	u32 dram_sdodt1;
+	u32 res5;
+	u32 dram_sdqs0;
+	u32 dram_dqm0;
+	u32 dram_sdqs1;
+	u32 dram_dqm1;
+	u32 dram_sdqs6;
+	u32 dram_dqm6;
+	u32 dram_sdqs7;
+	u32 dram_dqm7;
+};
+
+#define MX6DQ_IOM_GRP_BASE      0x020e0700
+struct mx6dq_iomux_grp_regs {
+	u32 res1[18];
+	u32 grp_b7ds;
+	u32 grp_addds;
+	u32 grp_ddrmode_ctl;
+	u32 res2;
+	u32 grp_ddrpke;
+	u32 res3[6];
+	u32 grp_ddrmode;
+	u32 res4[3];
+	u32 grp_b0ds;
+	u32 grp_b1ds;
+	u32 grp_ctlds;
+	u32 res5;
+	u32 grp_b2ds;
+	u32 grp_ddr_type;
+	u32 grp_b3ds;
+	u32 grp_b4ds;
+	u32 grp_b5ds;
+	u32 grp_b6ds;
+};
+
+#define MX6SDL_IOM_DDR_BASE     0x020e0400
+struct mx6sdl_iomux_ddr_regs {
+	u32 res1[25];
+	u32 dram_cas;
+	u32 res2[2];
+	u32 dram_dqm0;
+	u32 dram_dqm1;
+	u32 dram_dqm2;
+	u32 dram_dqm3;
+	u32 dram_dqm4;
+	u32 dram_dqm5;
+	u32 dram_dqm6;
+	u32 dram_dqm7;
+	u32 dram_ras;
+	u32 dram_reset;
+	u32 res3[2];
+	u32 dram_sdba2;
+	u32 dram_sdcke0;
+	u32 dram_sdcke1;
+	u32 dram_sdclk_0;
+	u32 dram_sdclk_1;
+	u32 dram_sdodt0;
+	u32 dram_sdodt1;
+	u32 dram_sdqs0;
+	u32 dram_sdqs1;
+	u32 dram_sdqs2;
+	u32 dram_sdqs3;
+	u32 dram_sdqs4;
+	u32 dram_sdqs5;
+	u32 dram_sdqs6;
+	u32 dram_sdqs7;
+};
+
+#define MX6SDL_IOM_GRP_BASE     0x020e0700
+struct mx6sdl_iomux_grp_regs {
+	u32 res1[18];
+	u32 grp_b7ds;
+	u32 grp_addds;
+	u32 grp_ddrmode_ctl;
+	u32 grp_ddrpke;
+	u32 res2[2];
+	u32 grp_ddrmode;
+	u32 grp_b0ds;
+	u32 res3;
+	u32 grp_ctlds;
+	u32 grp_b1ds;
+	u32 grp_ddr_type;
+	u32 grp_b2ds;
+	u32 grp_b3ds;
+	u32 grp_b4ds;
+	u32 grp_b5ds;
+	u32 res4;
+	u32 grp_b6ds;
+};
+
+/* Device Information: Varies per DDR3 part number and speed grade */
+struct mx6_ddr3_cfg {
+	u16 mem_speed;	/* ie 1600 for DDR3-1600 (800,1066,1333,1600) */
+	u8 density;	/* chip density (Gb) (1,2,4,8) */
+	u8 width;	/* bus width (bits) (4,8,16) */
+	u8 banks;	/* number of banks */
+	u8 rowaddr;	/* row address bits (11-16)*/
+	u8 coladdr;	/* col address bits (9-12) */
+	u8 pagesz;	/* page size (K) (1-2) */
+	u16 trcd;	/* tRCD=tRP=CL (ns*100) */
+	u16 trcmin;	/* tRC min (ns*100) */
+	u16 trasmin;	/* tRAS min (ns*100) */
+	u8 SRT;		/* self-refresh temperature: 0=normal, 1=extended */
+};
+
+/* Device Information: Varies per LPDDR2 part number and speed grade */
+struct mx6_lpddr2_cfg {
+	u16 mem_speed;	/* ie 800 for LPDDR2-800 */
+	u8 density;	/* chip density (Gb) (1,2,4,8) */
+	u8 width;	/* bus width (bits) (4,8,16) */
+	u8 banks;	/* number of banks */
+	u8 rowaddr;	/* row address bits (11-16)*/
+	u8 coladdr;	/* col address bits (9-12) */
+	u16 trcd_lp;
+	u16 trppb_lp;
+	u16 trpab_lp;
+	u16 trcmin;	/* tRC min (ns*100) */
+	u16 trasmin;	/* tRAS min (ns*100) */
+};
+
+/* System Information: Varies per board design, layout, and term choices */
+struct mx6_ddr_sysinfo {
+	u8 dsize;	/* size of bus (in dwords: 0=16bit,1=32bit,2=64bit) */
+	u8 cs_density;	/* density per chip select (Gb) */
+	u8 ncs;		/* number chip selects used (1|2) */
+	char cs1_mirror;/* enable address mirror (0|1) */
+	char bi_on;	/* Bank interleaving enable */
+	u8 rtt_nom;	/* Rtt_Nom (DDR3_RTT_*) */
+	u8 rtt_wr;	/* Rtt_Wr (DDR3_RTT_*) */
+	u8 ralat;	/* Read Additional Latency (0-7) */
+	u8 walat;	/* Write Additional Latency (0-3) */
+	u8 mif3_mode;	/* Command prediction working mode */
+	u8 rst_to_cke;	/* Time from SDE enable to CKE rise */
+	u8 sde_to_rst;	/* Time from SDE enable until DDR reset# is high */
+	u8 pd_fast_exit;/* enable precharge powerdown fast-exit */
+	u8 ddr_type;	/* DDR type: DDR3(0) or LPDDR2(1) */
+};
+
+/*
+ * Board specific calibration:
+ *   This includes write leveling calibration values as well as DQS gating
+ *   and read/write delays. These values are board/layout/device specific.
+ *   Freescale recommends using the i.MX6 DDR Stress Test Tool V1.0.2
+ *   (DOC-96412) to determine these values over a range of boards and
+ *   temperatures.
+ */
+struct mx6_mmdc_calibration {
+	/* write leveling calibration */
+	u32 p0_mpwldectrl0;
+	u32 p0_mpwldectrl1;
+	u32 p1_mpwldectrl0;
+	u32 p1_mpwldectrl1;
+	/* read DQS gating */
+	u32 p0_mpdgctrl0;
+	u32 p0_mpdgctrl1;
+	u32 p1_mpdgctrl0;
+	u32 p1_mpdgctrl1;
+	/* read delay */
+	u32 p0_mprddlctl;
+	u32 p1_mprddlctl;
+	/* write delay */
+	u32 p0_mpwrdlctl;
+	u32 p1_mpwrdlctl;
+	/* lpddr2 zq hw calibration */
+	u32 mpzqlp2ctl;
+};
+
+/* configure iomux (pinctl/padctl) */
+void mx6dq_dram_iocfg(unsigned width,
+		      const struct mx6dq_iomux_ddr_regs *,
+		      const struct mx6dq_iomux_grp_regs *);
+void mx6sdl_dram_iocfg(unsigned width,
+		       const struct mx6sdl_iomux_ddr_regs *,
+		       const struct mx6sdl_iomux_grp_regs *);
+void mx6sx_dram_iocfg(unsigned width,
+		      const struct mx6sx_iomux_ddr_regs *,
+		      const struct mx6sx_iomux_grp_regs *);
+void mx6ul_dram_iocfg(unsigned width,
+		      const struct mx6ul_iomux_ddr_regs *,
+		      const struct mx6ul_iomux_grp_regs *);
+void mx6sl_dram_iocfg(unsigned width,
+		      const struct mx6sl_iomux_ddr_regs *,
+		      const struct mx6sl_iomux_grp_regs *);
+
+#if defined(CONFIG_MX6QDL) || defined(CONFIG_MX6Q) || defined(CONFIG_MX6D)
+int mmdc_do_write_level_calibration(void);
+int mmdc_do_dqs_calibration(void);
+#endif
+
+/* configure mx6 mmdc registers */
+void mx6_dram_cfg(const struct mx6_ddr_sysinfo *,
+		  const struct mx6_mmdc_calibration *,
+		  const void *);
+
+#endif /* CONFIG_SPL_BUILD */
+
+#define MX6_MMDC_P0_MDCTL	0x021b0000
+#define MX6_MMDC_P0_MDPDC	0x021b0004
+#define MX6_MMDC_P0_MDOTC	0x021b0008
+#define MX6_MMDC_P0_MDCFG0	0x021b000c
+#define MX6_MMDC_P0_MDCFG1	0x021b0010
+#define MX6_MMDC_P0_MDCFG2	0x021b0014
+#define MX6_MMDC_P0_MDMISC	0x021b0018
+#define MX6_MMDC_P0_MDSCR	0x021b001c
+#define MX6_MMDC_P0_MDREF	0x021b0020
+#define MX6_MMDC_P0_MDRWD	0x021b002c
+#define MX6_MMDC_P0_MDOR	0x021b0030
+#define MX6_MMDC_P0_MDASP	0x021b0040
+#define MX6_MMDC_P0_MAPSR	0x021b0404
+#define MX6_MMDC_P0_MPZQHWCTRL	0x021b0800
+#define MX6_MMDC_P0_MPWLDECTRL0	0x021b080c
+#define MX6_MMDC_P0_MPWLDECTRL1	0x021b0810
+#define MX6_MMDC_P0_MPODTCTRL	0x021b0818
+#define MX6_MMDC_P0_MPRDDQBY0DL	0x021b081c
+#define MX6_MMDC_P0_MPRDDQBY1DL	0x021b0820
+#define MX6_MMDC_P0_MPRDDQBY2DL	0x021b0824
+#define MX6_MMDC_P0_MPRDDQBY3DL	0x021b0828
+#define MX6_MMDC_P0_MPDGCTRL0	0x021b083c
+#define MX6_MMDC_P0_MPDGCTRL1	0x021b0840
+#define MX6_MMDC_P0_MPRDDLCTL	0x021b0848
+#define MX6_MMDC_P0_MPWRDLCTL	0x021b0850
+#define MX6_MMDC_P0_MPMUR0	0x021b08b8
+
+#define MX6_MMDC_P1_MDCTL	0x021b4000
+#define MX6_MMDC_P1_MDPDC	0x021b4004
+#define MX6_MMDC_P1_MDOTC	0x021b4008
+#define MX6_MMDC_P1_MDCFG0	0x021b400c
+#define MX6_MMDC_P1_MDCFG1	0x021b4010
+#define MX6_MMDC_P1_MDCFG2	0x021b4014
+#define MX6_MMDC_P1_MDMISC	0x021b4018
+#define MX6_MMDC_P1_MDSCR	0x021b401c
+#define MX6_MMDC_P1_MDREF	0x021b4020
+#define MX6_MMDC_P1_MDRWD	0x021b402c
+#define MX6_MMDC_P1_MDOR	0x021b4030
+#define MX6_MMDC_P1_MDASP	0x021b4040
+#define MX6_MMDC_P1_MAPSR	0x021b4404
+#define MX6_MMDC_P1_MPZQHWCTRL	0x021b4800
+#define MX6_MMDC_P1_MPWLDECTRL0	0x021b480c
+#define MX6_MMDC_P1_MPWLDECTRL1	0x021b4810
+#define MX6_MMDC_P1_MPODTCTRL	0x021b4818
+#define MX6_MMDC_P1_MPRDDQBY0DL	0x021b481c
+#define MX6_MMDC_P1_MPRDDQBY1DL	0x021b4820
+#define MX6_MMDC_P1_MPRDDQBY2DL	0x021b4824
+#define MX6_MMDC_P1_MPRDDQBY3DL	0x021b4828
+#define MX6_MMDC_P1_MPDGCTRL0	0x021b483c
+#define MX6_MMDC_P1_MPDGCTRL1	0x021b4840
+#define MX6_MMDC_P1_MPRDDLCTL	0x021b4848
+#define MX6_MMDC_P1_MPWRDLCTL	0x021b4850
+#define MX6_MMDC_P1_MPMUR0	0x021b48b8
+
+#endif	/*__ASM_ARCH_MX6_DDR_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6dl-ddr.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6dl-ddr.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6dl-ddr.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6dl-ddr.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2013 Boundary Devices Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __ASM_ARCH_MX6DLS_DDR_H__
+#define __ASM_ARCH_MX6DLS_DDR_H__
+
+#ifndef CONFIG_MX6DL
+#ifndef CONFIG_MX6S
+#error "wrong CPU"
+#endif
+#endif
+
+#define MX6_IOM_DRAM_DQM0	0x020e0470
+#define MX6_IOM_DRAM_DQM1	0x020e0474
+#define MX6_IOM_DRAM_DQM2	0x020e0478
+#define MX6_IOM_DRAM_DQM3	0x020e047c
+#define MX6_IOM_DRAM_DQM4	0x020e0480
+#define MX6_IOM_DRAM_DQM5	0x020e0484
+#define MX6_IOM_DRAM_DQM6	0x020e0488
+#define MX6_IOM_DRAM_DQM7	0x020e048c
+
+#define MX6_IOM_DRAM_CAS	0x020e0464
+#define MX6_IOM_DRAM_RAS	0x020e0490
+#define MX6_IOM_DRAM_RESET	0x020e0494
+#define MX6_IOM_DRAM_SDCLK_0	0x020e04ac
+#define MX6_IOM_DRAM_SDCLK_1	0x020e04b0
+#define MX6_IOM_DRAM_SDBA2	0x020e04a0
+#define MX6_IOM_DRAM_SDCKE0	0x020e04a4
+#define MX6_IOM_DRAM_SDCKE1	0x020e04a8
+#define MX6_IOM_DRAM_SDODT0	0x020e04b4
+#define MX6_IOM_DRAM_SDODT1	0x020e04b8
+
+#define MX6_IOM_DRAM_SDQS0	0x020e04bc
+#define MX6_IOM_DRAM_SDQS1	0x020e04c0
+#define MX6_IOM_DRAM_SDQS2	0x020e04c4
+#define MX6_IOM_DRAM_SDQS3	0x020e04c8
+#define MX6_IOM_DRAM_SDQS4	0x020e04cc
+#define MX6_IOM_DRAM_SDQS5	0x020e04d0
+#define MX6_IOM_DRAM_SDQS6	0x020e04d4
+#define MX6_IOM_DRAM_SDQS7	0x020e04d8
+
+#define MX6_IOM_GRP_B0DS	0x020e0764
+#define MX6_IOM_GRP_B1DS	0x020e0770
+#define MX6_IOM_GRP_B2DS	0x020e0778
+#define MX6_IOM_GRP_B3DS	0x020e077c
+#define MX6_IOM_GRP_B4DS	0x020e0780
+#define MX6_IOM_GRP_B5DS	0x020e0784
+#define MX6_IOM_GRP_B6DS	0x020e078c
+#define MX6_IOM_GRP_B7DS	0x020e0748
+#define MX6_IOM_GRP_ADDDS	0x020e074c
+#define MX6_IOM_DDRMODE_CTL	0x020e0750
+#define MX6_IOM_GRP_DDRPKE	0x020e0754
+#define MX6_IOM_GRP_DDRMODE	0x020e0760
+#define MX6_IOM_GRP_CTLDS	0x020e076c
+#define MX6_IOM_GRP_DDR_TYPE	0x020e0774
+
+#endif	/*__ASM_ARCH_MX6S_DDR_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6dl_pins.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6dl_pins.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6dl_pins.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6dl_pins.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,1080 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_MX6_MX6DL_PINS_H__
+#define __ASM_ARCH_MX6_MX6DL_PINS_H__
+
+MX6_PAD_DECL(CSI0_DAT10__IPU1_CSI0_DATA10,	0x0360, 0x004C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT10__AUD3_RXC,	0x0360, 0x004C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT10__ECSPI2_MISO,	0x0360, 0x004C, 2, 0x07F8, 0, 0)
+MX6_PAD_DECL(CSI0_DAT10__UART1_TX_DATA,	0x0360, 0x004C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT10__UART1_RX_DATA,	0x0360, 0x004C, 3, 0x08FC, 0, 0)
+MX6_PAD_DECL(CSI0_DAT10__GPIO5_IO28,	0x0360, 0x004C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT10__ARM_TRACE07,	0x0360, 0x004C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT11__IPU1_CSI0_DATA11,	0x0364, 0x0050, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT11__AUD3_RXFS,	0x0364, 0x0050, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT11__ECSPI2_SS0,	0x0364, 0x0050, 2, 0x0800, 0, 0)
+MX6_PAD_DECL(CSI0_DAT11__UART1_TX_DATA,	0x0364, 0x0050, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT11__UART1_RX_DATA,	0x0364, 0x0050, 3, 0x08FC, 1, 0)
+MX6_PAD_DECL(CSI0_DAT11__GPIO5_IO29,	0x0364, 0x0050, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT11__ARM_TRACE08,	0x0364, 0x0050, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT12__IPU1_CSI0_DATA12,	0x0368, 0x0054, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT12__EIM_DATA08,	0x0368, 0x0054, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT12__UART4_TX_DATA,	0x0368, 0x0054, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT12__UART4_RX_DATA,	0x0368, 0x0054, 3, 0x0914, 0, 0)
+MX6_PAD_DECL(CSI0_DAT12__GPIO5_IO30,	0x0368, 0x0054, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT12__ARM_TRACE09,	0x0368, 0x0054, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT13__IPU1_CSI0_DATA13,	0x036C, 0x0058, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT13__EIM_DATA09,	0x036C, 0x0058, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT13__UART4_TX_DATA,	0x036C, 0x0058, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT13__UART4_RX_DATA,	0x036C, 0x0058, 3, 0x0914, 1, 0)
+MX6_PAD_DECL(CSI0_DAT13__GPIO5_IO31,	0x036C, 0x0058, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT13__ARM_TRACE10,	0x036C, 0x0058, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT14__IPU1_CSI0_DATA14,	0x0370, 0x005C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT14__EIM_DATA10,	0x0370, 0x005C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT14__UART5_TX_DATA,	0x0370, 0x005C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT14__UART5_RX_DATA,	0x0370, 0x005C, 3, 0x091C, 0, 0)
+MX6_PAD_DECL(CSI0_DAT14__GPIO6_IO00,	0x0370, 0x005C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT14__ARM_TRACE11,	0x0370, 0x005C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT15__IPU1_CSI0_DATA15,	0x0374, 0x0060, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT15__EIM_DATA11,	0x0374, 0x0060, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT15__UART5_TX_DATA,	0x0374, 0x0060, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT15__UART5_RX_DATA,	0x0374, 0x0060, 3, 0x091C, 1, 0)
+MX6_PAD_DECL(CSI0_DAT15__GPIO6_IO01,	0x0374, 0x0060, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT15__ARM_TRACE12,	0x0374, 0x0060, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT16__IPU1_CSI0_DATA16,	0x0378, 0x0064, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT16__EIM_DATA12,	0x0378, 0x0064, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT16__UART4_CTS_B,	0x0378, 0x0064, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT16__UART4_RTS_B,	0x0378, 0x0064, 3, 0x0910, 0, 0)
+MX6_PAD_DECL(CSI0_DAT16__GPIO6_IO02,	0x0378, 0x0064, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT16__ARM_TRACE13,	0x0378, 0x0064, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT17__IPU1_CSI0_DATA17,	0x037C, 0x0068, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT17__EIM_DATA13,	0x037C, 0x0068, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT17__UART4_CTS_B,	0x037C, 0x0068, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT17__UART4_RTS_B,	0x037C, 0x0068, 3, 0x0910, 1, 0)
+MX6_PAD_DECL(CSI0_DAT17__GPIO6_IO03,	0x037C, 0x0068, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT17__ARM_TRACE14,	0x037C, 0x0068, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT18__IPU1_CSI0_DATA18,	0x0380, 0x006C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT18__EIM_DATA14,	0x0380, 0x006C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT18__UART5_CTS_B,	0x0380, 0x006C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT18__UART5_RTS_B,	0x0380, 0x006C, 3, 0x0918, 0, 0)
+MX6_PAD_DECL(CSI0_DAT18__GPIO6_IO04,	0x0380, 0x006C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT18__ARM_TRACE15,	0x0380, 0x006C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT19__IPU1_CSI0_DATA19,	0x0384, 0x0070, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT19__EIM_DATA15,	0x0384, 0x0070, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT19__UART5_CTS_B,	0x0384, 0x0070, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT19__UART5_RTS_B,	0x0384, 0x0070, 3, 0x0918, 1, 0)
+MX6_PAD_DECL(CSI0_DAT19__GPIO6_IO05,	0x0384, 0x0070, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT4__IPU1_CSI0_DATA04,	0x0388, 0x0074, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT4__EIM_DATA02,	0x0388, 0x0074, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT4__ECSPI1_SCLK,	0x0388, 0x0074, 2, 0x07D8, 0, 0)
+MX6_PAD_DECL(CSI0_DAT4__KEY_COL5,	0x0388, 0x0074, 3, 0x08C0, 0, 0)
+MX6_PAD_DECL(CSI0_DAT4__AUD3_TXC,	0x0388, 0x0074, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT4__GPIO5_IO22,	0x0388, 0x0074, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT4__ARM_TRACE01,	0x0388, 0x0074, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT5__IPU1_CSI0_DATA05,	0x038C, 0x0078, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT5__EIM_DATA03,	0x038C, 0x0078, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT5__ECSPI1_MOSI,	0x038C, 0x0078, 2, 0x07E0, 0, 0)
+MX6_PAD_DECL(CSI0_DAT5__KEY_ROW5,	0x038C, 0x0078, 3, 0x08CC, 0, 0)
+MX6_PAD_DECL(CSI0_DAT5__AUD3_TXD,	0x038C, 0x0078, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT5__GPIO5_IO23,	0x038C, 0x0078, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT5__ARM_TRACE02,	0x038C, 0x0078, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT6__IPU1_CSI0_DATA06,	0x0390, 0x007C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT6__EIM_DATA04,	0x0390, 0x007C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT6__ECSPI1_MISO,	0x0390, 0x007C, 2, 0x07DC, 0, 0)
+MX6_PAD_DECL(CSI0_DAT6__KEY_COL6,	0x0390, 0x007C, 3, 0x08C4, 0, 0)
+MX6_PAD_DECL(CSI0_DAT6__AUD3_TXFS,	0x0390, 0x007C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT6__GPIO5_IO24,	0x0390, 0x007C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT6__ARM_TRACE03,	0x0390, 0x007C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT7__IPU1_CSI0_DATA07,	0x0394, 0x0080, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT7__EIM_DATA05,	0x0394, 0x0080, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT7__ECSPI1_SS0,	0x0394, 0x0080, 2, 0x07E4, 0, 0)
+MX6_PAD_DECL(CSI0_DAT7__KEY_ROW6,	0x0394, 0x0080, 3, 0x08D0, 0, 0)
+MX6_PAD_DECL(CSI0_DAT7__AUD3_RXD,	0x0394, 0x0080, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT7__GPIO5_IO25,	0x0394, 0x0080, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT7__ARM_TRACE04,	0x0394, 0x0080, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT8__IPU1_CSI0_DATA08,	0x0398, 0x0084, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT8__EIM_DATA06,	0x0398, 0x0084, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT8__ECSPI2_SCLK,	0x0398, 0x0084, 2, 0x07F4, 0, 0)
+MX6_PAD_DECL(CSI0_DAT8__KEY_COL7,	0x0398, 0x0084, 3, 0x08C8, 0, 0)
+MX6_PAD_DECL(CSI0_DAT8__I2C1_SDA,	0x0398, 0x0084, 4 | IOMUX_CONFIG_SION, 0x086C, 0, 0)
+MX6_PAD_DECL(CSI0_DAT8__GPIO5_IO26,	0x0398, 0x0084, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT8__ARM_TRACE05,	0x0398, 0x0084, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT9__IPU1_CSI0_DATA09,	0x039C, 0x0088, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT9__EIM_DATA07,	0x039C, 0x0088, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT9__ECSPI2_MOSI,	0x039C, 0x0088, 2, 0x07FC, 0, 0)
+MX6_PAD_DECL(CSI0_DAT9__KEY_ROW7,	0x039C, 0x0088, 3, 0x08D4, 0, 0)
+MX6_PAD_DECL(CSI0_DAT9__I2C1_SCL,	0x039C, 0x0088, 4 | IOMUX_CONFIG_SION, 0x0868, 0, 0)
+MX6_PAD_DECL(CSI0_DAT9__GPIO5_IO27,	0x039C, 0x0088, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT9__ARM_TRACE06,	0x039C, 0x0088, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DATA_EN__IPU1_CSI0_DATA_EN,	0x03A0, 0x008C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DATA_EN__EIM_DATA00,	0x03A0, 0x008C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DATA_EN__GPIO5_IO20,	0x03A0, 0x008C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DATA_EN__ARM_TRACE_CLK,	0x03A0, 0x008C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_MCLK__IPU1_CSI0_HSYNC,	0x03A4, 0x0090, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_MCLK__CCM_CLKO1,	0x03A4, 0x0090, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_MCLK__GPIO5_IO19,	0x03A4, 0x0090, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_MCLK__ARM_TRACE_CTL,	0x03A4, 0x0090, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_PIXCLK__IPU1_CSI0_PIXCLK,	0x03A8, 0x0094, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_PIXCLK__GPIO5_IO18,	0x03A8, 0x0094, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_PIXCLK__ARM_EVENTO,	0x03A8, 0x0094, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_VSYNC__IPU1_CSI0_VSYNC,	0x03AC, 0x0098, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_VSYNC__EIM_DATA01,	0x03AC, 0x0098, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_VSYNC__GPIO5_IO21,	0x03AC, 0x0098, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_VSYNC__ARM_TRACE00,	0x03AC, 0x0098, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK,	0x03B0, 0x009C, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DI0_DISP_CLK__LCD_CLK,	0x03B0, 0x009C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_DISP_CLK__GPIO4_IO16,	0x03B0, 0x009C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_DISP_CLK__LCD_WR_RWN,	0x03B0, 0x009C, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN15__IPU1_DI0_PIN15,	0x03B4, 0x00A0, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DI0_PIN15__LCD_ENABLE,	0x03B4, 0x00A0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN15__AUD6_TXC,	0x03B4, 0x00A0, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN15__GPIO4_IO17,	0x03B4, 0x00A0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN15__LCD_RD_E,	0x03B4, 0x00A0, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN2__IPU1_DI0_PIN02,	0x03B8, 0x00A4, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DI0_PIN2__LCD_HSYNC,	0x03B8, 0x00A4, 1, 0x08D8, 0, 0)
+MX6_PAD_DECL(DI0_PIN2__AUD6_TXD,	0x03B8, 0x00A4, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN2__GPIO4_IO18,	0x03B8, 0x00A4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN2__LCD_RS,	0x03B8, 0x00A4, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN3__IPU1_DI0_PIN03,	0x03BC, 0x00A8, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DI0_PIN3__LCD_VSYNC,	0x03BC, 0x00A8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN3__AUD6_TXFS,	0x03BC, 0x00A8, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN3__GPIO4_IO19,	0x03BC, 0x00A8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN3__LCD_CS,	0x03BC, 0x00A8, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN4__IPU1_DI0_PIN04,	0x03C0, 0x00AC, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DI0_PIN4__LCD_BUSY,	0x03C0, 0x00AC, 1, 0x08D8, 1, 0)
+MX6_PAD_DECL(DI0_PIN4__AUD6_RXD,	0x03C0, 0x00AC, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN4__SD1_WP,	0x03C0, 0x00AC, 3, 0x092C, 0, 0)
+MX6_PAD_DECL(DI0_PIN4__GPIO4_IO20,	0x03C0, 0x00AC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN4__LCD_RESET,	0x03C0, 0x00AC, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT0__IPU1_DISP0_DATA00,	0x03C4, 0x00B0, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT0__LCD_DATA00,	0x03C4, 0x00B0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT0__ECSPI3_SCLK,	0x03C4, 0x00B0, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT0__GPIO4_IO21,	0x03C4, 0x00B0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT1__IPU1_DISP0_DATA01,	0x03C8, 0x00B4, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT1__LCD_DATA01,	0x03C8, 0x00B4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT1__ECSPI3_MOSI,	0x03C8, 0x00B4, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT1__GPIO4_IO22,	0x03C8, 0x00B4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT10__IPU1_DISP0_DATA10,	0x03CC, 0x00B8, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT10__LCD_DATA10,	0x03CC, 0x00B8, 1, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT10__GPIO4_IO31,	0x03CC, 0x00B8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT11__IPU1_DISP0_DATA11,	0x03D0, 0x00BC, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT11__LCD_DATA11,	0x03D0, 0x00BC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT11__GPIO5_IO05,	0x03D0, 0x00BC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT12__IPU1_DISP0_DATA12,	0x03D4, 0x00C0, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT12__LCD_DATA12,	0x03D4, 0x00C0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT12__GPIO5_IO06,	0x03D4, 0x00C0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT13__IPU1_DISP0_DATA13,	0x03D8, 0x00C4, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT13__LCD_DATA13,	0x03D8, 0x00C4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT13__AUD5_RXFS,	0x03D8, 0x00C4, 3, 0x07BC, 0, 0)
+MX6_PAD_DECL(DISP0_DAT13__GPIO5_IO07,	0x03D8, 0x00C4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT14__IPU1_DISP0_DATA14,	0x03DC, 0x00C8, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT14__LCD_DATA14,	0x03DC, 0x00C8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT14__AUD5_RXC,	0x03DC, 0x00C8, 3, 0x07B8, 0, 0)
+MX6_PAD_DECL(DISP0_DAT14__GPIO5_IO08,	0x03DC, 0x00C8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT15__IPU1_DISP0_DATA15,	0x03E0, 0x00CC, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT15__LCD_DATA15,	0x03E0, 0x00CC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT15__ECSPI1_SS1,	0x03E0, 0x00CC, 2, 0x07E8, 0, 0)
+MX6_PAD_DECL(DISP0_DAT15__ECSPI2_SS1,	0x03E0, 0x00CC, 3, 0x0804, 0, 0)
+MX6_PAD_DECL(DISP0_DAT15__GPIO5_IO09,	0x03E0, 0x00CC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT16__IPU1_DISP0_DATA16,	0x03E4, 0x00D0, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT16__LCD_DATA16,	0x03E4, 0x00D0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT16__ECSPI2_MOSI,	0x03E4, 0x00D0, 2, 0x07FC, 1, 0)
+MX6_PAD_DECL(DISP0_DAT16__AUD5_TXC,	0x03E4, 0x00D0, 3, 0x07C0, 0, 0)
+MX6_PAD_DECL(DISP0_DAT16__SDMA_EXT_EVENT0,	0x03E4, 0x00D0, 4, 0x08E8, 0, 0)
+MX6_PAD_DECL(DISP0_DAT16__GPIO5_IO10,	0x03E4, 0x00D0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT17__IPU1_DISP0_DATA17,	0x03E8, 0x00D4, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT17__LCD_DATA17,	0x03E8, 0x00D4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT17__ECSPI2_MISO,	0x03E8, 0x00D4, 2, 0x07F8, 1, 0)
+MX6_PAD_DECL(DISP0_DAT17__AUD5_TXD,	0x03E8, 0x00D4, 3, 0x07B4, 0, 0)
+MX6_PAD_DECL(DISP0_DAT17__SDMA_EXT_EVENT1,	0x03E8, 0x00D4, 4, 0x08EC, 0, 0)
+MX6_PAD_DECL(DISP0_DAT17__GPIO5_IO11,	0x03E8, 0x00D4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT18__IPU1_DISP0_DATA18,	0x03EC, 0x00D8, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT18__LCD_DATA18,	0x03EC, 0x00D8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT18__ECSPI2_SS0,	0x03EC, 0x00D8, 2, 0x0800, 1, 0)
+MX6_PAD_DECL(DISP0_DAT18__AUD5_TXFS,	0x03EC, 0x00D8, 3, 0x07C4, 0, 0)
+MX6_PAD_DECL(DISP0_DAT18__AUD4_RXFS,	0x03EC, 0x00D8, 4, 0x07A4, 0, 0)
+MX6_PAD_DECL(DISP0_DAT18__GPIO5_IO12,	0x03EC, 0x00D8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT18__EIM_CS2_B,	0x03EC, 0x00D8, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT19__IPU1_DISP0_DATA19,	0x03F0, 0x00DC, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT19__LCD_DATA19,	0x03F0, 0x00DC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT19__ECSPI2_SCLK,	0x03F0, 0x00DC, 2, 0x07F4, 1, 0)
+MX6_PAD_DECL(DISP0_DAT19__AUD5_RXD,	0x03F0, 0x00DC, 3, 0x07B0, 0, 0)
+MX6_PAD_DECL(DISP0_DAT19__AUD4_RXC,	0x03F0, 0x00DC, 4, 0x07A0, 0, 0)
+MX6_PAD_DECL(DISP0_DAT19__GPIO5_IO13,	0x03F0, 0x00DC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT19__EIM_CS3_B,	0x03F0, 0x00DC, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT2__IPU1_DISP0_DATA02,	0x03F4, 0x00E0, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT2__LCD_DATA02,	0x03F4, 0x00E0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT2__ECSPI3_MISO,	0x03F4, 0x00E0, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT2__GPIO4_IO23,	0x03F4, 0x00E0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT20__IPU1_DISP0_DATA20,	0x03F8, 0x00E4, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT20__LCD_DATA20,	0x03F8, 0x00E4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT20__ECSPI1_SCLK,	0x03F8, 0x00E4, 2, 0x07D8, 1, 0)
+MX6_PAD_DECL(DISP0_DAT20__AUD4_TXC,	0x03F8, 0x00E4, 3, 0x07A8, 0, 0)
+MX6_PAD_DECL(DISP0_DAT20__GPIO5_IO14,	0x03F8, 0x00E4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT21__IPU1_DISP0_DATA21,	0x03FC, 0x00E8, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT21__LCD_DATA21,	0x03FC, 0x00E8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT21__ECSPI1_MOSI,	0x03FC, 0x00E8, 2, 0x07E0, 1, 0)
+MX6_PAD_DECL(DISP0_DAT21__AUD4_TXD,	0x03FC, 0x00E8, 3, 0x079C, 0, 0)
+MX6_PAD_DECL(DISP0_DAT21__GPIO5_IO15,	0x03FC, 0x00E8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT22__IPU1_DISP0_DATA22,	0x0400, 0x00EC, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT22__LCD_DATA22,	0x0400, 0x00EC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT22__ECSPI1_MISO,	0x0400, 0x00EC, 2, 0x07DC, 1, 0)
+MX6_PAD_DECL(DISP0_DAT22__AUD4_TXFS,	0x0400, 0x00EC, 3, 0x07AC, 0, 0)
+MX6_PAD_DECL(DISP0_DAT22__GPIO5_IO16,	0x0400, 0x00EC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT23__IPU1_DISP0_DATA23,	0x0404, 0x00F0, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT23__LCD_DATA23,	0x0404, 0x00F0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT23__ECSPI1_SS0,	0x0404, 0x00F0, 2, 0x07E4, 1, 0)
+MX6_PAD_DECL(DISP0_DAT23__AUD4_RXD,	0x0404, 0x00F0, 3, 0x0798, 0, 0)
+MX6_PAD_DECL(DISP0_DAT23__GPIO5_IO17,	0x0404, 0x00F0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT3__IPU1_DISP0_DATA03,	0x0408, 0x00F4, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT3__LCD_DATA03,	0x0408, 0x00F4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT3__ECSPI3_SS0,	0x0408, 0x00F4, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT3__GPIO4_IO24,	0x0408, 0x00F4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT4__IPU1_DISP0_DATA04,	0x040C, 0x00F8, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT4__LCD_DATA04,	0x040C, 0x00F8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT4__ECSPI3_SS1,	0x040C, 0x00F8, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT4__GPIO4_IO25,	0x040C, 0x00F8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT5__IPU1_DISP0_DATA05,	0x0410, 0x00FC, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT5__LCD_DATA05,	0x0410, 0x00FC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT5__ECSPI3_SS2,	0x0410, 0x00FC, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT5__AUD6_RXFS,	0x0410, 0x00FC, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT5__GPIO4_IO26,	0x0410, 0x00FC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT6__IPU1_DISP0_DATA06,	0x0414, 0x0100, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT6__LCD_DATA06,	0x0414, 0x0100, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT6__ECSPI3_SS3,	0x0414, 0x0100, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT6__AUD6_RXC,	0x0414, 0x0100, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT6__GPIO4_IO27,	0x0414, 0x0100, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT7__IPU1_DISP0_DATA07,	0x0418, 0x0104, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT7__LCD_DATA07,	0x0418, 0x0104, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT7__ECSPI3_RDY,	0x0418, 0x0104, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT7__GPIO4_IO28,	0x0418, 0x0104, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT8__IPU1_DISP0_DATA08,	0x041C, 0x0108, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT8__LCD_DATA08,	0x041C, 0x0108, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT8__PWM1_OUT,	0x041C, 0x0108, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT8__WDOG1_B,	0x041C, 0x0108, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT8__GPIO4_IO29,	0x041C, 0x0108, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT9__IPU1_DISP0_DATA09,	0x0420, 0x010C, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT9__LCD_DATA09,	0x0420, 0x010C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT9__PWM2_OUT,	0x0420, 0x010C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT9__WDOG2_B,	0x0420, 0x010C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT9__GPIO4_IO30,	0x0420, 0x010C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A16__EIM_ADDR16,	0x04E0, 0x0110, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A16__IPU1_DI1_DISP_CLK,	0x04E0, 0x0110, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A16__IPU1_CSI1_PIXCLK,	0x04E0, 0x0110, 2, 0x08B8, 0, 0)
+MX6_PAD_DECL(EIM_A16__GPIO2_IO22,	0x04E0, 0x0110, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A16__SRC_BOOT_CFG16,	0x04E0, 0x0110, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A16__EPDC_DATA00,	0x04E0, 0x0110, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A17__EIM_ADDR17,	0x04E4, 0x0114, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A17__IPU1_DISP1_DATA12,	0x04E4, 0x0114, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A17__IPU1_CSI1_DATA12,	0x04E4, 0x0114, 2, 0x0890, 0, 0)
+MX6_PAD_DECL(EIM_A17__GPIO2_IO21,	0x04E4, 0x0114, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A17__SRC_BOOT_CFG17,	0x04E4, 0x0114, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A17__EPDC_PWR_STAT,	0x04E4, 0x0114, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A18__EIM_ADDR18,	0x04E8, 0x0118, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A18__IPU1_DISP1_DATA13,	0x04E8, 0x0118, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A18__IPU1_CSI1_DATA13,	0x04E8, 0x0118, 2, 0x0894, 0, 0)
+MX6_PAD_DECL(EIM_A18__GPIO2_IO20,	0x04E8, 0x0118, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A18__SRC_BOOT_CFG18,	0x04E8, 0x0118, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A18__EPDC_PWR_CTRL0,	0x04E8, 0x0118, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A19__EIM_ADDR19,	0x04EC, 0x011C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A19__IPU1_DISP1_DATA14,	0x04EC, 0x011C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A19__IPU1_CSI1_DATA14,	0x04EC, 0x011C, 2, 0x0898, 0, 0)
+MX6_PAD_DECL(EIM_A19__GPIO2_IO19,	0x04EC, 0x011C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A19__SRC_BOOT_CFG19,	0x04EC, 0x011C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A19__EPDC_PWR_CTRL1,	0x04EC, 0x011C, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A20__EIM_ADDR20,	0x04F0, 0x0120, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A20__IPU1_DISP1_DATA15,	0x04F0, 0x0120, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A20__IPU1_CSI1_DATA15,	0x04F0, 0x0120, 2, 0x089C, 0, 0)
+MX6_PAD_DECL(EIM_A20__GPIO2_IO18,	0x04F0, 0x0120, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A20__SRC_BOOT_CFG20,	0x04F0, 0x0120, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A20__EPDC_PWR_CTRL2,	0x04F0, 0x0120, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A21__EIM_ADDR21,	0x04F4, 0x0124, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A21__IPU1_DISP1_DATA16,	0x04F4, 0x0124, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A21__IPU1_CSI1_DATA16,	0x04F4, 0x0124, 2, 0x08A0, 0, 0)
+MX6_PAD_DECL(EIM_A21__GPIO2_IO17,	0x04F4, 0x0124, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A21__SRC_BOOT_CFG21,	0x04F4, 0x0124, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A21__EPDC_GDCLK,	0x04F4, 0x0124, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A22__EIM_ADDR22,	0x04F8, 0x0128, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A22__IPU1_DISP1_DATA17,	0x04F8, 0x0128, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A22__IPU1_CSI1_DATA17,	0x04F8, 0x0128, 2, 0x08A4, 0, 0)
+MX6_PAD_DECL(EIM_A22__GPIO2_IO16,	0x04F8, 0x0128, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A22__SRC_BOOT_CFG22,	0x04F8, 0x0128, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A22__EPDC_GDSP,	0x04F8, 0x0128, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A23__EIM_ADDR23,	0x04FC, 0x012C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A23__IPU1_DISP1_DATA18,	0x04FC, 0x012C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A23__IPU1_CSI1_DATA18,	0x04FC, 0x012C, 2, 0x08A8, 0, 0)
+MX6_PAD_DECL(EIM_A23__IPU1_SISG3,	0x04FC, 0x012C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A23__GPIO6_IO06,	0x04FC, 0x012C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A23__SRC_BOOT_CFG23,	0x04FC, 0x012C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A23__EPDC_GDOE,	0x04FC, 0x012C, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A24__EIM_ADDR24,	0x0500, 0x0130, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A24__IPU1_DISP1_DATA19,	0x0500, 0x0130, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A24__IPU1_CSI1_DATA19,	0x0500, 0x0130, 2, 0x08AC, 0, 0)
+MX6_PAD_DECL(EIM_A24__IPU1_SISG2,	0x0500, 0x0130, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A24__GPIO5_IO04,	0x0500, 0x0130, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A24__SRC_BOOT_CFG24,	0x0500, 0x0130, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A24__EPDC_GDRL,	0x0500, 0x0130, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A25__EIM_ADDR25,	0x0504, 0x0134, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A25__ECSPI4_SS1,	0x0504, 0x0134, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A25__ECSPI2_RDY,	0x0504, 0x0134, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A25__IPU1_DI1_PIN12,	0x0504, 0x0134, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A25__IPU1_DI0_D1_CS,	0x0504, 0x0134, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A25__GPIO5_IO02,	0x0504, 0x0134, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A25__HDMI_TX_CEC_LINE,	0x0504, 0x0134, 6, 0x085C, 0, 0)
+MX6_PAD_DECL(EIM_A25__EPDC_DATA15,	0x0504, 0x0134, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A25__EIM_ACLK_FREERUN,	0x0504, 0x0134, 9, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_BCLK__EIM_BCLK,	0x0508, 0x0138, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_BCLK__IPU1_DI1_PIN16,	0x0508, 0x0138, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_BCLK__GPIO6_IO31,	0x0508, 0x0138, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_BCLK__EPDC_SDCE9,	0x0508, 0x0138, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_CS0__EIM_CS0_B,	0x050C, 0x013C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_CS0__IPU1_DI1_PIN05,	0x050C, 0x013C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_CS0__ECSPI2_SCLK,	0x050C, 0x013C, 2, 0x07F4, 2, 0)
+MX6_PAD_DECL(EIM_CS0__GPIO2_IO23,	0x050C, 0x013C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_CS0__EPDC_DATA06,	0x050C, 0x013C, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_CS1__EIM_CS1_B,	0x0510, 0x0140, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_CS1__IPU1_DI1_PIN06,	0x0510, 0x0140, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_CS1__ECSPI2_MOSI,	0x0510, 0x0140, 2, 0x07FC, 2, 0)
+MX6_PAD_DECL(EIM_CS1__GPIO2_IO24,	0x0510, 0x0140, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_CS1__EPDC_DATA08,	0x0510, 0x0140, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D16__EIM_DATA16,	0x0514, 0x0144, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D16__ECSPI1_SCLK,	0x0514, 0x0144, 1, 0x07D8, 2, 0)
+MX6_PAD_DECL(EIM_D16__IPU1_DI0_PIN05,	0x0514, 0x0144, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D16__IPU1_CSI1_DATA18,	0x0514, 0x0144, 3, 0x08A8, 1, 0)
+MX6_PAD_DECL(EIM_D16__HDMI_TX_DDC_SDA,	0x0514, 0x0144, 4, 0x0864, 0, 0)
+MX6_PAD_DECL(EIM_D16__GPIO3_IO16,	0x0514, 0x0144, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D16__I2C2_SDA,	0x0514, 0x0144, 6 | IOMUX_CONFIG_SION, 0x0874, 0, 0)
+MX6_PAD_DECL(EIM_D16__EPDC_DATA10,	0x0514, 0x0144, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D17__EIM_DATA17,	0x0518, 0x0148, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D17__ECSPI1_MISO,	0x0518, 0x0148, 1, 0x07DC, 2, 0)
+MX6_PAD_DECL(EIM_D17__IPU1_DI0_PIN06,	0x0518, 0x0148, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D17__IPU1_CSI1_PIXCLK,	0x0518, 0x0148, 3, 0x08B8, 1, 0)
+MX6_PAD_DECL(EIM_D17__DCIC1_OUT,	0x0518, 0x0148, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D17__GPIO3_IO17,	0x0518, 0x0148, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D17__I2C3_SCL,	0x0518, 0x0148, 6 | IOMUX_CONFIG_SION, 0x0878, 0, 0)
+MX6_PAD_DECL(EIM_D17__EPDC_VCOM0,	0x0518, 0x0148, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D18__EIM_DATA18,	0x051C, 0x014C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D18__ECSPI1_MOSI,	0x051C, 0x014C, 1, 0x07E0, 2, 0)
+MX6_PAD_DECL(EIM_D18__IPU1_DI0_PIN07,	0x051C, 0x014C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D18__IPU1_CSI1_DATA17,	0x051C, 0x014C, 3, 0x08A4, 1, 0)
+MX6_PAD_DECL(EIM_D18__IPU1_DI1_D0_CS,	0x051C, 0x014C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D18__GPIO3_IO18,	0x051C, 0x014C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D18__I2C3_SDA,	0x051C, 0x014C, 6 | IOMUX_CONFIG_SION, 0x087C, 0, 0)
+MX6_PAD_DECL(EIM_D18__EPDC_VCOM1,	0x051C, 0x014C, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D19__EIM_DATA19,	0x0520, 0x0150, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D19__ECSPI1_SS1,	0x0520, 0x0150, 1, 0x07E8, 1, 0)
+MX6_PAD_DECL(EIM_D19__IPU1_DI0_PIN08,	0x0520, 0x0150, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D19__IPU1_CSI1_DATA16,	0x0520, 0x0150, 3, 0x08A0, 1, 0)
+MX6_PAD_DECL(EIM_D19__UART1_CTS_B,	0x0520, 0x0150, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D19__UART1_RTS_B,	0x0520, 0x0150, 4, 0x08F8, 0, 0)
+MX6_PAD_DECL(EIM_D19__GPIO3_IO19,	0x0520, 0x0150, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D19__EPIT1_OUT,	0x0520, 0x0150, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D19__EPDC_DATA12,	0x0520, 0x0150, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D20__EIM_DATA20,	0x0524, 0x0154, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D20__ECSPI4_SS0,	0x0524, 0x0154, 1, 0x0808, 0, 0)
+MX6_PAD_DECL(EIM_D20__IPU1_DI0_PIN16,	0x0524, 0x0154, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D20__IPU1_CSI1_DATA15,	0x0524, 0x0154, 3, 0x089C, 1, 0)
+MX6_PAD_DECL(EIM_D20__UART1_CTS_B,	0x0524, 0x0154, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D20__UART1_RTS_B,	0x0524, 0x0154, 4, 0x08F8, 1, 0)
+MX6_PAD_DECL(EIM_D20__GPIO3_IO20,	0x0524, 0x0154, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D20__EPIT2_OUT,	0x0524, 0x0154, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D21__EIM_DATA21,	0x0528, 0x0158, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D21__ECSPI4_SCLK,	0x0528, 0x0158, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D21__IPU1_DI0_PIN17,	0x0528, 0x0158, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D21__IPU1_CSI1_DATA11,	0x0528, 0x0158, 3, 0x088C, 0, 0)
+MX6_PAD_DECL(EIM_D21__USB_OTG_OC,	0x0528, 0x0158, 4, 0x0920, 0, 0)
+MX6_PAD_DECL(EIM_D21__GPIO3_IO21,	0x0528, 0x0158, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D21__I2C1_SCL,	0x0528, 0x0158, 6 | IOMUX_CONFIG_SION, 0x0868, 1, 0)
+MX6_PAD_DECL(EIM_D21__SPDIF_IN,	0x0528, 0x0158, 7, 0x08F0, 0, 0)
+MX6_PAD_DECL(EIM_D22__EIM_DATA22,	0x052C, 0x015C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D22__ECSPI4_MISO,	0x052C, 0x015C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D22__IPU1_DI0_PIN01,	0x052C, 0x015C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D22__IPU1_CSI1_DATA10,	0x052C, 0x015C, 3, 0x0888, 0, 0)
+MX6_PAD_DECL(EIM_D22__USB_OTG_PWR,	0x052C, 0x015C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D22__GPIO3_IO22,	0x052C, 0x015C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D22__SPDIF_OUT,	0x052C, 0x015C, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D22__EPDC_SDCE6,	0x052C, 0x015C, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D23__EIM_DATA23,	0x0530, 0x0160, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D23__IPU1_DI0_D0_CS,	0x0530, 0x0160, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D23__UART3_CTS_B,	0x0530, 0x0160, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D23__UART3_RTS_B,	0x0530, 0x0160, 2, 0x0908, 0, 0)
+MX6_PAD_DECL(EIM_D23__UART1_DCD_B,	0x0530, 0x0160, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D23__IPU1_CSI1_DATA_EN,	0x0530, 0x0160, 4, 0x08B0, 0, 0)
+MX6_PAD_DECL(EIM_D23__GPIO3_IO23,	0x0530, 0x0160, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D23__IPU1_DI1_PIN02,	0x0530, 0x0160, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D23__IPU1_DI1_PIN14,	0x0530, 0x0160, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D23__EPDC_DATA11,	0x0530, 0x0160, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D24__EIM_DATA24,	0x0534, 0x0164, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D24__ECSPI4_SS2,	0x0534, 0x0164, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D24__UART3_TX_DATA,	0x0534, 0x0164, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D24__UART3_RX_DATA,	0x0534, 0x0164, 2, 0x090C, 0, 0)
+MX6_PAD_DECL(EIM_D24__ECSPI1_SS2,	0x0534, 0x0164, 3, 0x07EC, 0, 0)
+MX6_PAD_DECL(EIM_D24__ECSPI2_SS2,	0x0534, 0x0164, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D24__GPIO3_IO24,	0x0534, 0x0164, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D24__AUD5_RXFS,	0x0534, 0x0164, 6, 0x07BC, 1, 0)
+MX6_PAD_DECL(EIM_D24__UART1_DTR_B,	0x0534, 0x0164, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D24__EPDC_SDCE7,	0x0534, 0x0164, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D25__EIM_DATA25,	0x0538, 0x0168, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D25__ECSPI4_SS3,	0x0538, 0x0168, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D25__UART3_TX_DATA,	0x0538, 0x0168, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D25__UART3_RX_DATA,	0x0538, 0x0168, 2, 0x090C, 1, 0)
+MX6_PAD_DECL(EIM_D25__ECSPI1_SS3,	0x0538, 0x0168, 3, 0x07F0, 0, 0)
+MX6_PAD_DECL(EIM_D25__ECSPI2_SS3,	0x0538, 0x0168, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D25__GPIO3_IO25,	0x0538, 0x0168, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D25__AUD5_RXC,	0x0538, 0x0168, 6, 0x07B8, 1, 0)
+MX6_PAD_DECL(EIM_D25__UART1_DSR_B,	0x0538, 0x0168, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D25__EPDC_SDCE8,	0x0538, 0x0168, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D26__EIM_DATA26,	0x053C, 0x016C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D26__IPU1_DI1_PIN11,	0x053C, 0x016C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D26__IPU1_CSI0_DATA01,	0x053C, 0x016C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D26__IPU1_CSI1_DATA14,	0x053C, 0x016C, 3, 0x0898, 1, 0)
+MX6_PAD_DECL(EIM_D26__UART2_TX_DATA,	0x053C, 0x016C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D26__UART2_RX_DATA,	0x053C, 0x016C, 4, 0x0904, 0, 0)
+MX6_PAD_DECL(EIM_D26__GPIO3_IO26,	0x053C, 0x016C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D26__IPU1_SISG2,	0x053C, 0x016C, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D26__IPU1_DISP1_DATA22,	0x053C, 0x016C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D26__EPDC_SDOED,	0x053C, 0x016C, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D27__EIM_DATA27,	0x0540, 0x0170, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D27__IPU1_DI1_PIN13,	0x0540, 0x0170, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D27__IPU1_CSI0_DATA00,	0x0540, 0x0170, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D27__IPU1_CSI1_DATA13,	0x0540, 0x0170, 3, 0x0894, 1, 0)
+MX6_PAD_DECL(EIM_D27__UART2_TX_DATA,	0x0540, 0x0170, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D27__UART2_RX_DATA,	0x0540, 0x0170, 4, 0x0904, 1, 0)
+MX6_PAD_DECL(EIM_D27__GPIO3_IO27,	0x0540, 0x0170, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D27__IPU1_SISG3,	0x0540, 0x0170, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D27__IPU1_DISP1_DATA23,	0x0540, 0x0170, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D27__EPDC_SDOE,	0x0540, 0x0170, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D28__EIM_DATA28,	0x0544, 0x0174, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D28__I2C1_SDA,	0x0544, 0x0174, 1 | IOMUX_CONFIG_SION, 0x086C, 1, 0)
+MX6_PAD_DECL(EIM_D28__ECSPI4_MOSI,	0x0544, 0x0174, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D28__IPU1_CSI1_DATA12,	0x0544, 0x0174, 3, 0x0890, 1, 0)
+MX6_PAD_DECL(EIM_D28__UART2_DTE_RTS_B,	0x0544, 0x0174, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D28__UART2_DTE_CTS_B,	0x0544, 0x0174, 4, 0x0900, 0, 0)
+MX6_PAD_DECL(EIM_D28__GPIO3_IO28,	0x0544, 0x0174, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D28__IPU1_EXT_TRIG,	0x0544, 0x0174, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D28__IPU1_DI0_PIN13,	0x0544, 0x0174, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D28__EPDC_PWR_CTRL3,	0x0544, 0x0174, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D29__EIM_DATA29,	0x0548, 0x0178, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D29__IPU1_DI1_PIN15,	0x0548, 0x0178, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D29__ECSPI4_SS0,	0x0548, 0x0178, 2, 0x0808, 1, 0)
+MX6_PAD_DECL(EIM_D29__UART2_CTS_B,	0x0548, 0x0178, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D29__UART2_RTS_B,	0x0548, 0x0178, 4, 0x0900, 1, 0)
+MX6_PAD_DECL(EIM_D29__GPIO3_IO29,	0x0548, 0x0178, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D29__IPU1_CSI1_VSYNC,	0x0548, 0x0178, 6, 0x08BC, 0, 0)
+MX6_PAD_DECL(EIM_D29__IPU1_DI0_PIN14,	0x0548, 0x0178, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D29__EPDC_PWR_WAKE,	0x0548, 0x0178, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D30__EIM_DATA30,	0x054C, 0x017C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D30__IPU1_DISP1_DATA21,	0x054C, 0x017C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D30__IPU1_DI0_PIN11,	0x054C, 0x017C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D30__IPU1_CSI0_DATA03,	0x054C, 0x017C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D30__UART3_CTS_B,	0x054C, 0x017C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D30__UART3_RTS_B,	0x054C, 0x017C, 4, 0x0908, 1, 0)
+MX6_PAD_DECL(EIM_D30__GPIO3_IO30,	0x054C, 0x017C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D30__USB_H1_OC,	0x054C, 0x017C, 6, 0x0924, 0, 0)
+MX6_PAD_DECL(EIM_D30__EPDC_SDOEZ,	0x054C, 0x017C, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D31__EIM_DATA31,	0x0550, 0x0180, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D31__IPU1_DISP1_DATA20,	0x0550, 0x0180, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D31__IPU1_DI0_PIN12,	0x0550, 0x0180, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D31__IPU1_CSI0_DATA02,	0x0550, 0x0180, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D31__UART3_CTS_B,	0x0550, 0x0180, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D31__UART3_RTS_B,	0x0550, 0x0180, 4, 0x0908, 2, 0)
+MX6_PAD_DECL(EIM_D31__GPIO3_IO31,	0x0550, 0x0180, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D31__USB_H1_PWR,	0x0550, 0x0180, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D31__EPDC_SDCLK_P,	0x0550, 0x0180, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D31__EIM_ACLK_FREERUN,	0x0550, 0x0180, 9, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA0__EIM_AD00,	0x0554, 0x0184, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA0__IPU1_DISP1_DATA09,	0x0554, 0x0184, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA0__IPU1_CSI1_DATA09,	0x0554, 0x0184, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA0__GPIO3_IO00,	0x0554, 0x0184, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA0__SRC_BOOT_CFG00,	0x0554, 0x0184, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA0__EPDC_SDCLK_N,	0x0554, 0x0184, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA1__EIM_AD01,	0x0558, 0x0188, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA1__IPU1_DISP1_DATA08,	0x0558, 0x0188, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA1__IPU1_CSI1_DATA08,	0x0558, 0x0188, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA1__GPIO3_IO01,	0x0558, 0x0188, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA1__SRC_BOOT_CFG01,	0x0558, 0x0188, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA1__EPDC_SDLE,	0x0558, 0x0188, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA10__EIM_AD10,	0x055C, 0x018C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA10__IPU1_DI1_PIN15,	0x055C, 0x018C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA10__IPU1_CSI1_DATA_EN,	0x055C, 0x018C, 2, 0x08B0, 1, 0)
+MX6_PAD_DECL(EIM_DA10__GPIO3_IO10,	0x055C, 0x018C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA10__SRC_BOOT_CFG10,	0x055C, 0x018C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA10__EPDC_DATA01,	0x055C, 0x018C, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA11__EIM_AD11,	0x0560, 0x0190, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA11__IPU1_DI1_PIN02,	0x0560, 0x0190, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA11__IPU1_CSI1_HSYNC,	0x0560, 0x0190, 2, 0x08B4, 0, 0)
+MX6_PAD_DECL(EIM_DA11__GPIO3_IO11,	0x0560, 0x0190, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA11__SRC_BOOT_CFG11,	0x0560, 0x0190, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA11__EPDC_DATA03,	0x0560, 0x0190, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA12__EIM_AD12,	0x0564, 0x0194, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA12__IPU1_DI1_PIN03,	0x0564, 0x0194, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA12__IPU1_CSI1_VSYNC,	0x0564, 0x0194, 2, 0x08BC, 1, 0)
+MX6_PAD_DECL(EIM_DA12__GPIO3_IO12,	0x0564, 0x0194, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA12__SRC_BOOT_CFG12,	0x0564, 0x0194, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA12__EPDC_DATA02,	0x0564, 0x0194, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA13__EIM_AD13,	0x0568, 0x0198, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA13__IPU1_DI1_D0_CS,	0x0568, 0x0198, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA13__GPIO3_IO13,	0x0568, 0x0198, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA13__SRC_BOOT_CFG13,	0x0568, 0x0198, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA13__EPDC_DATA13,	0x0568, 0x0198, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA14__EIM_AD14,	0x056C, 0x019C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA14__IPU1_DI1_D1_CS,	0x056C, 0x019C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA14__GPIO3_IO14,	0x056C, 0x019C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA14__SRC_BOOT_CFG14,	0x056C, 0x019C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA14__EPDC_DATA14,	0x056C, 0x019C, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA15__EIM_AD15,	0x0570, 0x01A0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA15__IPU1_DI1_PIN01,	0x0570, 0x01A0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA15__IPU1_DI1_PIN04,	0x0570, 0x01A0, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA15__GPIO3_IO15,	0x0570, 0x01A0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA15__SRC_BOOT_CFG15,	0x0570, 0x01A0, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA15__EPDC_DATA09,	0x0570, 0x01A0, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA2__EIM_AD02,	0x0574, 0x01A4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA2__IPU1_DISP1_DATA07,	0x0574, 0x01A4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA2__IPU1_CSI1_DATA07,	0x0574, 0x01A4, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA2__GPIO3_IO02,	0x0574, 0x01A4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA2__SRC_BOOT_CFG02,	0x0574, 0x01A4, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA2__EPDC_BDR0,	0x0574, 0x01A4, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA3__EIM_AD03,	0x0578, 0x01A8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA3__IPU1_DISP1_DATA06,	0x0578, 0x01A8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA3__IPU1_CSI1_DATA06,	0x0578, 0x01A8, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA3__GPIO3_IO03,	0x0578, 0x01A8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA3__SRC_BOOT_CFG03,	0x0578, 0x01A8, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA3__EPDC_BDR1,	0x0578, 0x01A8, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA4__EIM_AD04,	0x057C, 0x01AC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA4__IPU1_DISP1_DATA05,	0x057C, 0x01AC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA4__IPU1_CSI1_DATA05,	0x057C, 0x01AC, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA4__GPIO3_IO04,	0x057C, 0x01AC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA4__SRC_BOOT_CFG04,	0x057C, 0x01AC, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA4__EPDC_SDCE0,	0x057C, 0x01AC, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA5__EIM_AD05,	0x0580, 0x01B0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA5__IPU1_DISP1_DATA04,	0x0580, 0x01B0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA5__IPU1_CSI1_DATA04,	0x0580, 0x01B0, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA5__GPIO3_IO05,	0x0580, 0x01B0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA5__SRC_BOOT_CFG05,	0x0580, 0x01B0, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA5__EPDC_SDCE1,	0x0580, 0x01B0, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA6__EIM_AD06,	0x0584, 0x01B4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA6__IPU1_DISP1_DATA03,	0x0584, 0x01B4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA6__IPU1_CSI1_DATA03,	0x0584, 0x01B4, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA6__GPIO3_IO06,	0x0584, 0x01B4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA6__SRC_BOOT_CFG06,	0x0584, 0x01B4, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA6__EPDC_SDCE2,	0x0584, 0x01B4, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA7__EIM_AD07,	0x0588, 0x01B8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA7__IPU1_DISP1_DATA02,	0x0588, 0x01B8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA7__IPU1_CSI1_DATA02,	0x0588, 0x01B8, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA7__GPIO3_IO07,	0x0588, 0x01B8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA7__SRC_BOOT_CFG07,	0x0588, 0x01B8, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA7__EPDC_SDCE3,	0x0588, 0x01B8, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA8__EIM_AD08,	0x058C, 0x01BC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA8__IPU1_DISP1_DATA01,	0x058C, 0x01BC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA8__IPU1_CSI1_DATA01,	0x058C, 0x01BC, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA8__GPIO3_IO08,	0x058C, 0x01BC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA8__SRC_BOOT_CFG08,	0x058C, 0x01BC, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA8__EPDC_SDCE4,	0x058C, 0x01BC, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA9__EIM_AD09,	0x0590, 0x01C0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA9__IPU1_DISP1_DATA00,	0x0590, 0x01C0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA9__IPU1_CSI1_DATA00,	0x0590, 0x01C0, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA9__GPIO3_IO09,	0x0590, 0x01C0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA9__SRC_BOOT_CFG09,	0x0590, 0x01C0, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA9__EPDC_SDCE5,	0x0590, 0x01C0, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB0__EIM_EB0_B,	0x0594, 0x01C4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB0__IPU1_DISP1_DATA11,	0x0594, 0x01C4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB0__IPU1_CSI1_DATA11,	0x0594, 0x01C4, 2, 0x088C, 1, 0)
+MX6_PAD_DECL(EIM_EB0__CCM_PMIC_READY,	0x0594, 0x01C4, 4, 0x07D4, 0, 0)
+MX6_PAD_DECL(EIM_EB0__GPIO2_IO28,	0x0594, 0x01C4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB0__SRC_BOOT_CFG27,	0x0594, 0x01C4, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB0__EPDC_PWR_COM,	0x0594, 0x01C4, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB1__EIM_EB1_B,	0x0598, 0x01C8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB1__IPU1_DISP1_DATA10,	0x0598, 0x01C8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB1__IPU1_CSI1_DATA10,	0x0598, 0x01C8, 2, 0x0888, 1, 0)
+MX6_PAD_DECL(EIM_EB1__GPIO2_IO29,	0x0598, 0x01C8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB1__SRC_BOOT_CFG28,	0x0598, 0x01C8, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB1__EPDC_SDSHR,	0x0598, 0x01C8, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB2__EIM_EB2_B,	0x059C, 0x01CC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB2__ECSPI1_SS0,	0x059C, 0x01CC, 1, 0x07E4, 2, 0)
+MX6_PAD_DECL(EIM_EB2__IPU1_CSI1_DATA19,	0x059C, 0x01CC, 3, 0x08AC, 1, 0)
+MX6_PAD_DECL(EIM_EB2__HDMI_TX_DDC_SCL,	0x059C, 0x01CC, 4, 0x0860, 0, 0)
+MX6_PAD_DECL(EIM_EB2__GPIO2_IO30,	0x059C, 0x01CC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB2__I2C2_SCL,	0x059C, 0x01CC, 6 | IOMUX_CONFIG_SION, 0x0870, 0, 0)
+MX6_PAD_DECL(EIM_EB2__SRC_BOOT_CFG30,	0x059C, 0x01CC, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB2__EPDC_DATA05,	0x059C, 0x01CC, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__EIM_EB3_B,	0x05A0, 0x01D0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__ECSPI4_RDY,	0x05A0, 0x01D0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__UART3_CTS_B,	0x05A0, 0x01D0, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__UART3_RTS_B,	0x05A0, 0x01D0, 2, 0x0908, 3, 0)
+MX6_PAD_DECL(EIM_EB3__UART1_RI_B,	0x05A0, 0x01D0, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__IPU1_CSI1_HSYNC,	0x05A0, 0x01D0, 4, 0x08B4, 1, 0)
+MX6_PAD_DECL(EIM_EB3__GPIO2_IO31,	0x05A0, 0x01D0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__IPU1_DI1_PIN03,	0x05A0, 0x01D0, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__SRC_BOOT_CFG31,	0x05A0, 0x01D0, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__EPDC_SDCE0,	0x05A0, 0x01D0, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__EIM_ACLK_FREERUN,	0x05A0, 0x01D0, 9, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_LBA__EIM_LBA_B,	0x05A4, 0x01D4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_LBA__IPU1_DI1_PIN17,	0x05A4, 0x01D4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_LBA__ECSPI2_SS1,	0x05A4, 0x01D4, 2, 0x0804, 1, 0)
+MX6_PAD_DECL(EIM_LBA__GPIO2_IO27,	0x05A4, 0x01D4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_LBA__SRC_BOOT_CFG26,	0x05A4, 0x01D4, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_LBA__EPDC_DATA04,	0x05A4, 0x01D4, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_OE__EIM_OE_B,	0x05A8, 0x01D8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_OE__IPU1_DI1_PIN07,	0x05A8, 0x01D8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_OE__ECSPI2_MISO,	0x05A8, 0x01D8, 2, 0x07F8, 2, 0)
+MX6_PAD_DECL(EIM_OE__GPIO2_IO25,	0x05A8, 0x01D8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_OE__EPDC_PWR_IRQ,	0x05A8, 0x01D8, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_RW__EIM_RW,	0x05AC, 0x01DC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_RW__IPU1_DI1_PIN08,	0x05AC, 0x01DC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_RW__ECSPI2_SS0,	0x05AC, 0x01DC, 2, 0x0800, 2, 0)
+MX6_PAD_DECL(EIM_RW__GPIO2_IO26,	0x05AC, 0x01DC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_RW__SRC_BOOT_CFG29,	0x05AC, 0x01DC, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_RW__EPDC_DATA07,	0x05AC, 0x01DC, 8, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_WAIT__EIM_WAIT_B,	0x05B0, 0x01E0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_WAIT__EIM_DTACK_B,	0x05B0, 0x01E0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_WAIT__GPIO5_IO00,	0x05B0, 0x01E0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_WAIT__SRC_BOOT_CFG25,	0x05B0, 0x01E0, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_CRS_DV__ENET_RX_EN,	0x05B4, 0x01E4, 1, 0x0828, 0, 0)
+MX6_PAD_DECL(ENET_CRS_DV__ESAI_TX_CLK,	0x05B4, 0x01E4, 2, 0x0840, 0, 0)
+MX6_PAD_DECL(ENET_CRS_DV__SPDIF_EXT_CLK,	0x05B4, 0x01E4, 3, 0x08F4, 0, 0)
+MX6_PAD_DECL(ENET_CRS_DV__GPIO1_IO25,	0x05B4, 0x01E4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_MDC__MLB_DATA,	0x05B8, 0x01E8, 0, 0x08E0, 0, 0)
+MX6_PAD_DECL(ENET_MDC__ENET_MDC,	0x05B8, 0x01E8, 1, 0x0000, 0,  0)
+MX6_PAD_DECL(ENET_MDC__ESAI_TX5_RX0,	0x05B8, 0x01E8, 2, 0x0858, 0, 0)
+MX6_PAD_DECL(ENET_MDC__ENET_1588_EVENT1_IN,	0x05B8, 0x01E8, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_MDC__GPIO1_IO31,	0x05B8, 0x01E8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_MDIO__ENET_MDIO,	0x05BC, 0x01EC, 1, 0x0810, 0, 0)
+MX6_PAD_DECL(ENET_MDIO__ESAI_RX_CLK,	0x05BC, 0x01EC, 2, 0x083C, 0, 0)
+MX6_PAD_DECL(ENET_MDIO__ENET_1588_EVENT1_OUT,	0x05BC, 0x01EC, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_MDIO__GPIO1_IO22,	0x05BC, 0x01EC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_MDIO__SPDIF_LOCK,	0x05BC, 0x01EC, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_REF_CLK__ENET_TX_CLK,	0x05C0, 0x01F0, 1 | IOMUX_CONFIG_SION, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_REF_CLK__ESAI_RX_FS,	0x05C0, 0x01F0, 2, 0x082C, 0, 0)
+MX6_PAD_DECL(ENET_REF_CLK__GPIO1_IO23,	0x05C0, 0x01F0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_REF_CLK__SPDIF_SR_CLK,	0x05C0, 0x01F0, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_RX_ER__USB_OTG_ID,	0x05C4, 0x01F4, 0, 0x0790, 0, 0)
+MX6_PAD_DECL(ENET_RX_ER__ENET_RX_ER,	0x05C4, 0x01F4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_RX_ER__ESAI_RX_HF_CLK,	0x05C4, 0x01F4, 2, 0x0834, 0, 0)
+MX6_PAD_DECL(ENET_RX_ER__SPDIF_IN,	0x05C4, 0x01F4, 3, 0x08F0, 1, 0)
+MX6_PAD_DECL(ENET_RX_ER__ENET_1588_EVENT2_OUT,	0x05C4, 0x01F4, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_RX_ER__GPIO1_IO24,	0x05C4, 0x01F4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_RXD0__ENET_RX_DATA0,	0x05C8, 0x01F8, 1, 0x0818, 0, 0)
+MX6_PAD_DECL(ENET_RXD0__ESAI_TX_HF_CLK,	0x05C8, 0x01F8, 2, 0x0838, 0, 0)
+MX6_PAD_DECL(ENET_RXD0__SPDIF_OUT,	0x05C8, 0x01F8, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_RXD0__GPIO1_IO27,	0x05C8, 0x01F8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_RXD1__MLB_SIG,	0x05CC, 0x01FC, 0, 0x08E4, 0, 0)
+MX6_PAD_DECL(ENET_RXD1__ENET_RX_DATA1,	0x05CC, 0x01FC, 1, 0x081C, 0, 0)
+MX6_PAD_DECL(ENET_RXD1__ESAI_TX_FS,	0x05CC, 0x01FC, 2, 0x0830, 0, 0)
+MX6_PAD_DECL(ENET_RXD1__ENET_1588_EVENT3_OUT,	0x05CC, 0x01FC, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_RXD1__GPIO1_IO26,	0x05CC, 0x01FC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_TX_EN__ENET_TX_EN,	0x05D0, 0x0200, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_TX_EN__ESAI_TX3_RX2,	0x05D0, 0x0200, 2, 0x0850, 0, 0)
+MX6_PAD_DECL(ENET_TX_EN__GPIO1_IO28,	0x05D0, 0x0200, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_TX_EN__I2C4_SCL,	0x05D0, 0x0200, 9 | IOMUX_CONFIG_SION, 0x0880, 0, 0)
+MX6_PAD_DECL(ENET_TXD0__ENET_TX_DATA0,	0x05D4, 0x0204, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_TXD0__ESAI_TX4_RX1,	0x05D4, 0x0204, 2, 0x0854, 0, 0)
+MX6_PAD_DECL(ENET_TXD0__GPIO1_IO30,	0x05D4, 0x0204, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_TXD1__MLB_CLK,	0x05D8, 0x0208, 0, 0x08DC, 0, 0)
+MX6_PAD_DECL(ENET_TXD1__ENET_TX_DATA1,	0x05D8, 0x0208, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_TXD1__ESAI_TX2_RX3,	0x05D8, 0x0208, 2, 0x084C, 0, 0)
+MX6_PAD_DECL(ENET_TXD1__ENET_1588_EVENT0_IN,	0x05D8, 0x0208, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_TXD1__GPIO1_IO29,	0x05D8, 0x0208, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_TXD1__I2C4_SDA,	0x05D8, 0x0208, 9 | IOMUX_CONFIG_SION, 0x0884, 0, 0)
+MX6_PAD_DECL(GPIO_0__CCM_CLKO1,	0x05DC, 0x020C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_0__KEY_COL5,	0x05DC, 0x020C, 2, 0x08C0, 1, 0)
+MX6_PAD_DECL(GPIO_0__ASRC_EXT_CLK,	0x05DC, 0x020C, 3, 0x0794, 0, 0)
+MX6_PAD_DECL(GPIO_0__EPIT1_OUT,	0x05DC, 0x020C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_0__GPIO1_IO00,	0x05DC, 0x020C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_0__USB_H1_PWR,	0x05DC, 0x020C, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_0__SNVS_VIO_5,	0x05DC, 0x020C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_1__ESAI_RX_CLK,	0x05E0, 0x0210, 0, 0x083C, 1, 0)
+MX6_PAD_DECL(GPIO_1__WDOG2_B,	0x05E0, 0x0210, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_1__KEY_ROW5,	0x05E0, 0x0210, 2, 0x08CC, 1, 0)
+MX6_PAD_DECL(GPIO_1__USB_OTG_ID,	0x05E0, 0x0210, 3, 0x0790, 1, 0)
+MX6_PAD_DECL(GPIO_1__PWM2_OUT,	0x05E0, 0x0210, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_1__GPIO1_IO01,	0x05E0, 0x0210, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_1__SD1_CD_B,	0x05E0, 0x0210, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_16__ESAI_TX3_RX2,	0x05E4, 0x0214, 0, 0x0850, 1, 0)
+MX6_PAD_DECL(GPIO_16__ENET_1588_EVENT2_IN,	0x05E4, 0x0214, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_16__ENET_REF_CLK,	0x05E4, 0x0214, 2 | IOMUX_CONFIG_SION, 0x080C, 0, 0)
+MX6_PAD_DECL(GPIO_16__SD1_LCTL,	0x05E4, 0x0214, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_16__SPDIF_IN,	0x05E4, 0x0214, 4, 0x08F0, 2, 0)
+MX6_PAD_DECL(GPIO_16__GPIO7_IO11,	0x05E4, 0x0214, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_16__I2C3_SDA,	0x05E4, 0x0214, 6 | IOMUX_CONFIG_SION, 0x087C, 1, 0)
+MX6_PAD_DECL(GPIO_16__JTAG_DE_B,	0x05E4, 0x0214, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_17__ESAI_TX0,	0x05E8, 0x0218, 0, 0x0844, 0, 0)
+MX6_PAD_DECL(GPIO_17__ENET_1588_EVENT3_IN,	0x05E8, 0x0218, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_17__CCM_PMIC_READY,	0x05E8, 0x0218, 2, 0x07D4, 1, 0)
+MX6_PAD_DECL(GPIO_17__SDMA_EXT_EVENT0,	0x05E8, 0x0218, 3, 0x08E8, 1, 0)
+MX6_PAD_DECL(GPIO_17__SPDIF_OUT,	0x05E8, 0x0218, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_17__GPIO7_IO12,	0x05E8, 0x0218, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_18__ESAI_TX1,	0x05EC, 0x021C, 0, 0x0848, 0, 0)
+MX6_PAD_DECL(GPIO_18__ENET_RX_CLK,	0x05EC, 0x021C, 1, 0x0814, 0, 0)
+MX6_PAD_DECL(GPIO_18__SD3_VSELECT,	0x05EC, 0x021C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_18__SDMA_EXT_EVENT1,	0x05EC, 0x021C, 3, 0x08EC, 1, 0)
+MX6_PAD_DECL(GPIO_18__ASRC_EXT_CLK,	0x05EC, 0x021C, 4, 0x0794, 1, 0)
+MX6_PAD_DECL(GPIO_18__GPIO7_IO13,	0x05EC, 0x021C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_18__SNVS_VIO_5_CTL,	0x05EC, 0x021C, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_19__KEY_COL5,	0x05F0, 0x0220, 0, 0x08C0, 2, 0)
+MX6_PAD_DECL(GPIO_19__ENET_1588_EVENT0_OUT,	0x05F0, 0x0220, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_19__SPDIF_OUT,	0x05F0, 0x0220, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_19__CCM_CLKO1,	0x05F0, 0x0220, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_19__ECSPI1_RDY,	0x05F0, 0x0220, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_19__GPIO4_IO05,	0x05F0, 0x0220, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_19__ENET_TX_ER,	0x05F0, 0x0220, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_2__ESAI_TX_FS,	0x05F4, 0x0224, 0, 0x0830, 1, 0)
+MX6_PAD_DECL(GPIO_2__KEY_ROW6,	0x05F4, 0x0224, 2, 0x08D0, 1, 0)
+MX6_PAD_DECL(GPIO_2__GPIO1_IO02,	0x05F4, 0x0224, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_2__SD2_WP,	0x05F4, 0x0224, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_2__MLB_DATA,	0x05F4, 0x0224, 7, 0x08E0, 1, 0)
+MX6_PAD_DECL(GPIO_3__ESAI_RX_HF_CLK,	0x05F8, 0x0228, 0, 0x0834, 1, 0)
+MX6_PAD_DECL(GPIO_3__I2C3_SCL,	0x05F8, 0x0228, 2 | IOMUX_CONFIG_SION, 0x0878, 1, 0)
+MX6_PAD_DECL(GPIO_3__XTALOSC_REF_CLK_24M,	0x05F8, 0x0228, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_3__CCM_CLKO2,	0x05F8, 0x0228, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_3__GPIO1_IO03,	0x05F8, 0x0228, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_3__USB_H1_OC,	0x05F8, 0x0228, 6, 0x0924, 1, 0)
+MX6_PAD_DECL(GPIO_3__MLB_CLK,	0x05F8, 0x0228, 7, 0x08DC, 1, 0)
+MX6_PAD_DECL(GPIO_4__ESAI_TX_HF_CLK,	0x05FC, 0x022C, 0, 0x0838, 1, 0)
+MX6_PAD_DECL(GPIO_4__KEY_COL7,	0x05FC, 0x022C, 2, 0x08C8, 1, 0)
+MX6_PAD_DECL(GPIO_4__GPIO1_IO04,	0x05FC, 0x022C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_4__SD2_CD_B,	0x05FC, 0x022C, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_5__ESAI_TX2_RX3,	0x0600, 0x0230, 0, 0x084C, 1, 0)
+MX6_PAD_DECL(GPIO_5__KEY_ROW7,	0x0600, 0x0230, 2, 0x08D4, 1, 0)
+MX6_PAD_DECL(GPIO_5__CCM_CLKO1,	0x0600, 0x0230, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_5__GPIO1_IO05,	0x0600, 0x0230, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_5__I2C3_SCL,	0x0600, 0x0230, 6 | IOMUX_CONFIG_SION, 0x0878, 2, 0)
+MX6_PAD_DECL(GPIO_5__ARM_EVENTI,	0x0600, 0x0230, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_6__ESAI_TX_CLK,	0x0604, 0x0234, 0, 0x0840, 1, 0)
+MX6_PAD_DECL(GPIO_6__I2C3_SDA,	0x0604, 0x0234, 2 | IOMUX_CONFIG_SION, 0x087C, 2, 0)
+MX6_PAD_DECL(GPIO_6__GPIO1_IO06,	0x0604, 0x0234, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_6__SD2_LCTL,	0x0604, 0x0234, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_6__MLB_SIG,	0x0604, 0x0234, 7, 0x08E4, 1, 0)
+MX6_PAD_DECL(GPIO_7__ESAI_TX4_RX1,	0x0608, 0x0238, 0, 0x0854, 1, 0)
+MX6_PAD_DECL(GPIO_7__EPIT1_OUT,	0x0608, 0x0238, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_7__FLEXCAN1_TX,	0x0608, 0x0238, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_7__UART2_TX_DATA,	0x0608, 0x0238, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_7__UART2_RX_DATA,	0x0608, 0x0238, 4, 0x0904, 2, 0)
+MX6_PAD_DECL(GPIO_7__GPIO1_IO07,	0x0608, 0x0238, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_7__SPDIF_LOCK,	0x0608, 0x0238, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_7__USB_OTG_HOST_MODE,	0x0608, 0x0238, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_7__I2C4_SCL,	0x0608, 0x0238, 8 | IOMUX_CONFIG_SION, 0x0880, 1, 0)
+MX6_PAD_DECL(GPIO_8__ESAI_TX5_RX0,	0x060C, 0x023C, 0, 0x0858, 1, 0)
+MX6_PAD_DECL(GPIO_8__XTALOSC_REF_CLK_32K,	0x060C, 0x023C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_8__EPIT2_OUT,	0x060C, 0x023C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_8__FLEXCAN1_RX,	0x060C, 0x023C, 3, 0x07C8, 0, 0)
+MX6_PAD_DECL(GPIO_8__UART2_TX_DATA,	0x060C, 0x023C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_8__UART2_RX_DATA,	0x060C, 0x023C, 4, 0x0904, 3, 0)
+MX6_PAD_DECL(GPIO_8__GPIO1_IO08,	0x060C, 0x023C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_8__SPDIF_SR_CLK,	0x060C, 0x023C, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_8__USB_OTG_PWR_CTL_WAKE,	0x060C, 0x023C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_8__I2C4_SDA,	0x060C, 0x023C, 8 | IOMUX_CONFIG_SION, 0x0884, 1, 0)
+MX6_PAD_DECL(GPIO_9__ESAI_RX_FS,	0x0610, 0x0240, 0, 0x082C, 1, 0)
+MX6_PAD_DECL(GPIO_9__WDOG1_B,	0x0610, 0x0240, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_9__KEY_COL6,	0x0610, 0x0240, 2, 0x08C4, 1, 0)
+MX6_PAD_DECL(GPIO_9__CCM_REF_EN_B,	0x0610, 0x0240, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_9__PWM1_OUT,	0x0610, 0x0240, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_9__GPIO1_IO09,	0x0610, 0x0240, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_9__SD1_WP,	0x0610, 0x0240, 6, 0x092C, 1, 0)
+MX6_PAD_DECL(KEY_COL0__ECSPI1_SCLK,	0x062C, 0x0244, 0, 0x07D8, 3, 0)
+MX6_PAD_DECL(KEY_COL0__ENET_RX_DATA3,	0x062C, 0x0244, 1, 0x0824, 0, 0)
+MX6_PAD_DECL(KEY_COL0__AUD5_TXC,	0x062C, 0x0244, 2, 0x07C0, 1, 0)
+MX6_PAD_DECL(KEY_COL0__KEY_COL0,	0x062C, 0x0244, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL0__UART4_TX_DATA,	0x062C, 0x0244, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL0__UART4_RX_DATA,	0x062C, 0x0244, 4, 0x0914, 2, 0)
+MX6_PAD_DECL(KEY_COL0__GPIO4_IO06,	0x062C, 0x0244, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL0__DCIC1_OUT,	0x062C, 0x0244, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL1__ECSPI1_MISO,	0x0630, 0x0248, 0, 0x07DC, 3, 0)
+MX6_PAD_DECL(KEY_COL1__ENET_MDIO,	0x0630, 0x0248, 1, 0x0810, 1, 0)
+MX6_PAD_DECL(KEY_COL1__AUD5_TXFS,	0x0630, 0x0248, 2, 0x07C4, 1, 0)
+MX6_PAD_DECL(KEY_COL1__KEY_COL1,	0x0630, 0x0248, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL1__UART5_TX_DATA,	0x0630, 0x0248, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL1__UART5_RX_DATA,	0x0630, 0x0248, 4, 0x091C, 2, 0)
+MX6_PAD_DECL(KEY_COL1__GPIO4_IO08,	0x0630, 0x0248, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL1__SD1_VSELECT,	0x0630, 0x0248, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL2__ECSPI1_SS1,	0x0634, 0x024C, 0, 0x07E8, 2, 0)
+MX6_PAD_DECL(KEY_COL2__ENET_RX_DATA2,	0x0634, 0x024C, 1, 0x0820, 0, 0)
+MX6_PAD_DECL(KEY_COL2__FLEXCAN1_TX,	0x0634, 0x024C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL2__KEY_COL2,	0x0634, 0x024C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL2__ENET_MDC,	0x0634, 0x024C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL2__GPIO4_IO10,	0x0634, 0x024C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL2__USB_H1_PWR_CTL_WAKE,	0x0634, 0x024C, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL3__ECSPI1_SS3,	0x0638, 0x0250, 0, 0x07F0, 1, 0)
+MX6_PAD_DECL(KEY_COL3__ENET_CRS,	0x0638, 0x0250, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL3__HDMI_TX_DDC_SCL,	0x0638, 0x0250, 2, 0x0860, 1, 0)
+MX6_PAD_DECL(KEY_COL3__KEY_COL3,	0x0638, 0x0250, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL3__I2C2_SCL,	0x0638, 0x0250, 4 | IOMUX_CONFIG_SION, 0x0870, 1, 0)
+MX6_PAD_DECL(KEY_COL3__GPIO4_IO12,	0x0638, 0x0250, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL3__SPDIF_IN,	0x0638, 0x0250, 6, 0x08F0, 3, 0)
+MX6_PAD_DECL(KEY_COL4__FLEXCAN2_TX,	0x063C, 0x0254, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL4__IPU1_SISG4,	0x063C, 0x0254, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL4__USB_OTG_OC,	0x063C, 0x0254, 2, 0x0920, 1, 0)
+MX6_PAD_DECL(KEY_COL4__KEY_COL4,	0x063C, 0x0254, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL4__UART5_CTS_B,	0x063C, 0x0254, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL4__UART5_RTS_B,	0x063C, 0x0254, 4, 0x0918, 2, 0)
+MX6_PAD_DECL(KEY_COL4__GPIO4_IO14,	0x063C, 0x0254, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW0__ECSPI1_MOSI,	0x0640, 0x0258, 0, 0x07E0, 3, 0)
+MX6_PAD_DECL(KEY_ROW0__ENET_TX_DATA3,	0x0640, 0x0258, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW0__AUD5_TXD,	0x0640, 0x0258, 2, 0x07B4, 1, 0)
+MX6_PAD_DECL(KEY_ROW0__KEY_ROW0,	0x0640, 0x0258, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW0__UART4_TX_DATA,	0x0640, 0x0258, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW0__UART4_RX_DATA,	0x0640, 0x0258, 4, 0x0914, 3, 0)
+MX6_PAD_DECL(KEY_ROW0__GPIO4_IO07,	0x0640, 0x0258, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW0__DCIC2_OUT,	0x0640, 0x0258, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW1__ECSPI1_SS0,	0x0644, 0x025C, 0, 0x07E4, 3, 0)
+MX6_PAD_DECL(KEY_ROW1__ENET_COL,	0x0644, 0x025C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW1__AUD5_RXD,	0x0644, 0x025C, 2, 0x07B0, 1, 0)
+MX6_PAD_DECL(KEY_ROW1__KEY_ROW1,	0x0644, 0x025C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW1__UART5_TX_DATA,	0x0644, 0x025C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW1__UART5_RX_DATA,	0x0644, 0x025C, 4, 0x091C, 3, 0)
+MX6_PAD_DECL(KEY_ROW1__GPIO4_IO09,	0x0644, 0x025C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW1__SD2_VSELECT,	0x0644, 0x025C, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW2__ECSPI1_SS2,	0x0648, 0x0260, 0, 0x07EC, 1, 0)
+MX6_PAD_DECL(KEY_ROW2__ENET_TX_DATA2,	0x0648, 0x0260, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW2__FLEXCAN1_RX,	0x0648, 0x0260, 2, 0x07C8, 1, 0)
+MX6_PAD_DECL(KEY_ROW2__KEY_ROW2,	0x0648, 0x0260, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW2__SD2_VSELECT,	0x0648, 0x0260, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW2__GPIO4_IO11,	0x0648, 0x0260, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW2__HDMI_TX_CEC_LINE,	0x0648, 0x0260, 6, 0x085C, 1, 0)
+MX6_PAD_DECL(KEY_ROW3__ASRC_EXT_CLK,	0x064C, 0x0264, 1, 0x0794, 2, 0)
+MX6_PAD_DECL(KEY_ROW3__HDMI_TX_DDC_SDA,	0x064C, 0x0264, 2, 0x0864, 1, 0)
+MX6_PAD_DECL(KEY_ROW3__KEY_ROW3,	0x064C, 0x0264, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW3__I2C2_SDA,	0x064C, 0x0264, 4 | IOMUX_CONFIG_SION, 0x0874, 1, 0)
+MX6_PAD_DECL(KEY_ROW3__GPIO4_IO13,	0x064C, 0x0264, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW3__SD1_VSELECT,	0x064C, 0x0264, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW4__FLEXCAN2_RX,	0x0650, 0x0268, 0, 0x07CC, 0, 0)
+MX6_PAD_DECL(KEY_ROW4__IPU1_SISG5,	0x0650, 0x0268, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW4__USB_OTG_PWR,	0x0650, 0x0268, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW4__KEY_ROW4,	0x0650, 0x0268, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW4__UART5_CTS_B,	0x0650, 0x0268, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW4__UART5_RTS_B,	0x0650, 0x0268, 4, 0x0918, 3, 0)
+MX6_PAD_DECL(KEY_ROW4__GPIO4_IO15,	0x0650, 0x0268, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_ALE__NAND_ALE,	0x0654, 0x026C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_ALE__SD4_RESET,	0x0654, 0x026C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_ALE__GPIO6_IO08,	0x0654, 0x026C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CLE__NAND_CLE,	0x0658, 0x0270, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CLE__GPIO6_IO07,	0x0658, 0x0270, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS0__NAND_CE0_B,	0x065C, 0x0274, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS0__GPIO6_IO11,	0x065C, 0x0274, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS1__NAND_CE1_B,	0x0660, 0x0278, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS1__SD4_VSELECT,	0x0660, 0x0278, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS1__SD3_VSELECT,	0x0660, 0x0278, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS1__GPIO6_IO14,	0x0660, 0x0278, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS2__NAND_CE2_B,	0x0664, 0x027C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS2__IPU1_SISG0,	0x0664, 0x027C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS2__ESAI_TX0,	0x0664, 0x027C, 2, 0x0844, 1, 0)
+MX6_PAD_DECL(NANDF_CS2__EIM_CRE,	0x0664, 0x027C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS2__CCM_CLKO2,	0x0664, 0x027C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS2__GPIO6_IO15,	0x0664, 0x027C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS3__NAND_CE3_B,	0x0668, 0x0280, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS3__IPU1_SISG1,	0x0668, 0x0280, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS3__ESAI_TX1,	0x0668, 0x0280, 2, 0x0848, 1, 0)
+MX6_PAD_DECL(NANDF_CS3__EIM_ADDR26,	0x0668, 0x0280, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS3__GPIO6_IO16,	0x0668, 0x0280, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS3__I2C4_SDA,	0x0668, 0x0280, 9 | IOMUX_CONFIG_SION, 0x0884, 2, 0)
+MX6_PAD_DECL(NANDF_D0__NAND_DATA00,	0x066C, 0x0284, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D0__SD1_DATA4,	0x066C, 0x0284, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D0__GPIO2_IO00,	0x066C, 0x0284, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D1__NAND_DATA01,	0x0670, 0x0288, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D1__SD1_DATA5,	0x0670, 0x0288, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D1__GPIO2_IO01,	0x0670, 0x0288, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D2__NAND_DATA02,	0x0674, 0x028C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D2__SD1_DATA6,	0x0674, 0x028C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D2__GPIO2_IO02,	0x0674, 0x028C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D3__NAND_DATA03,	0x0678, 0x0290, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D3__SD1_DATA7,	0x0678, 0x0290, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D3__GPIO2_IO03,	0x0678, 0x0290, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D4__NAND_DATA04,	0x067C, 0x0294, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D4__SD2_DATA4,	0x067C, 0x0294, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D4__GPIO2_IO04,	0x067C, 0x0294, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D5__NAND_DATA05,	0x0680, 0x0298, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D5__SD2_DATA5,	0x0680, 0x0298, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D5__GPIO2_IO05,	0x0680, 0x0298, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D6__NAND_DATA06,	0x0684, 0x029C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D6__SD2_DATA6,	0x0684, 0x029C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D6__GPIO2_IO06,	0x0684, 0x029C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D7__NAND_DATA07,	0x0688, 0x02A0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D7__SD2_DATA7,	0x0688, 0x02A0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D7__GPIO2_IO07,	0x0688, 0x02A0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_RB0__NAND_READY_B,	0x068C, 0x02A4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_RB0__GPIO6_IO10,	0x068C, 0x02A4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_WP_B__NAND_WP_B,	0x0690, 0x02A8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_WP_B__GPIO6_IO09,	0x0690, 0x02A8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_WP_B__I2C4_SCL,	0x0690, 0x02A8, 9 | IOMUX_CONFIG_SION, 0x0880, 2, 0)
+MX6_PAD_DECL(RGMII_RD0__HSI_RX_READY,	0x0694, 0x02AC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RD0__RGMII_RD0,	0x0694, 0x02AC, 1, 0x0818, 1, 0)
+MX6_PAD_DECL(RGMII_RD0__GPIO6_IO25,	0x0694, 0x02AC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RD1__HSI_TX_FLAG,	0x0698, 0x02B0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RD1__RGMII_RD1,	0x0698, 0x02B0, 1, 0x081C, 1, 0)
+MX6_PAD_DECL(RGMII_RD1__GPIO6_IO27,	0x0698, 0x02B0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RD2__HSI_TX_DATA,	0x069C, 0x02B4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RD2__RGMII_RD2,	0x069C, 0x02B4, 1, 0x0820, 1, 0)
+MX6_PAD_DECL(RGMII_RD2__GPIO6_IO28,	0x069C, 0x02B4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RD3__HSI_TX_WAKE,	0x06A0, 0x02B8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RD3__RGMII_RD3,	0x06A0, 0x02B8, 1, 0x0824, 1, 0)
+MX6_PAD_DECL(RGMII_RD3__GPIO6_IO29,	0x06A0, 0x02B8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RX_CTL__USB_H3_DATA,	0x06A4, 0x02BC, 0 | IOMUX_CONFIG_SION, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RX_CTL__RGMII_RX_CTL,	0x06A4, 0x02BC, 1, 0x0828, 1, 0)
+MX6_PAD_DECL(RGMII_RX_CTL__GPIO6_IO24,	0x06A4, 0x02BC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RXC__USBOH3_H3_STROBE,	0x06A8, 0x02C0, 0 | IOMUX_CONFIG_SION, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RXC__USB_H3_STROBE,	0x06A8, 0x02C0, 0 | IOMUX_CONFIG_SION, 0x0000, 0, PAD_CTL_PUS_47K_UP)
+MX6_PAD_DECL(RGMII_RXC__RGMII_RXC,	0x06A8, 0x02C0, 1, 0x0814, 1, 0)
+MX6_PAD_DECL(RGMII_RXC__GPIO6_IO30,	0x06A8, 0x02C0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD0__HSI_TX_READY,	0x06AC, 0x02C4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD0__RGMII_TD0,	0x06AC, 0x02C4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD0__GPIO6_IO20,	0x06AC, 0x02C4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD1__HSI_RX_FLAG,	0x06B0, 0x02C8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD1__RGMII_TD1,	0x06B0, 0x02C8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD1__GPIO6_IO21,	0x06B0, 0x02C8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD2__HSI_RX_DATA,	0x06B4, 0x02CC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD2__RGMII_TD2,	0x06B4, 0x02CC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD2__GPIO6_IO22,	0x06B4, 0x02CC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD3__HSI_RX_WAKE,	0x06B8, 0x02D0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD3__RGMII_TD3,	0x06B8, 0x02D0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD3__GPIO6_IO23,	0x06B8, 0x02D0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TX_CTL__USBOH3_H2_STROBE,	0x06BC, 0x02D4, 0 | IOMUX_CONFIG_SION, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TX_CTL__USB_H2_STROBE,	0x06BC, 0x02D4, 0 | IOMUX_CONFIG_SION, 0x0000, 0, PAD_CTL_PUS_47K_UP)
+MX6_PAD_DECL(RGMII_TX_CTL__RGMII_TX_CTL,	0x06BC, 0x02D4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TX_CTL__GPIO6_IO26,	0x06BC, 0x02D4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TX_CTL__ENET_REF_CLK,	0x06BC, 0x02D4, 7 | IOMUX_CONFIG_SION, 0x080C, 1, 0)
+MX6_PAD_DECL(RGMII_TXC__USB_H2_DATA,	0x06C0, 0x02D8, 0 | IOMUX_CONFIG_SION, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TXC__RGMII_TXC,	0x06C0, 0x02D8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TXC__SPDIF_EXT_CLK,	0x06C0, 0x02D8, 2, 0x08F4, 1, 0)
+MX6_PAD_DECL(RGMII_TXC__GPIO6_IO19,	0x06C0, 0x02D8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TXC__XTALOSC_REF_CLK_24M,	0x06C0, 0x02D8, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_CLK__SD1_CLK,	0x06C4, 0x02DC, 0, 0x0928, 1, 0)
+MX6_PAD_DECL(SD1_CLK__GPT_CLKIN,	0x06C4, 0x02DC, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_CLK__GPIO1_IO20,	0x06C4, 0x02DC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_CMD__SD1_CMD,	0x06C8, 0x02E0, 0 | IOMUX_CONFIG_SION, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_CMD__PWM4_OUT,	0x06C8, 0x02E0, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_CMD__GPT_COMPARE1,	0x06C8, 0x02E0, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_CMD__GPIO1_IO18,	0x06C8, 0x02E0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT0__SD1_DATA0,	0x06CC, 0x02E4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT0__GPT_CAPTURE1,	0x06CC, 0x02E4, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT0__GPIO1_IO16,	0x06CC, 0x02E4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT1__SD1_DATA1,	0x06D0, 0x02E8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT1__PWM3_OUT,	0x06D0, 0x02E8, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT1__GPT_CAPTURE2,	0x06D0, 0x02E8, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT1__GPIO1_IO17,	0x06D0, 0x02E8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT2__SD1_DATA2,	0x06D4, 0x02EC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT2__GPT_COMPARE2,	0x06D4, 0x02EC, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT2__PWM2_OUT,	0x06D4, 0x02EC, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT2__WDOG1_B,	0x06D4, 0x02EC, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT2__GPIO1_IO19,	0x06D4, 0x02EC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT2__WDOG1_RESET_B_DEB,	0x06D4, 0x02EC, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT3__SD1_DATA3,	0x06D8, 0x02F0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT3__GPT_COMPARE3,	0x06D8, 0x02F0, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT3__PWM1_OUT,	0x06D8, 0x02F0, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT3__WDOG2_B,	0x06D8, 0x02F0, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT3__GPIO1_IO21,	0x06D8, 0x02F0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT3__WDOG2_RESET_B_DEB,	0x06D8, 0x02F0, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_CLK__SD2_CLK,	0x06DC, 0x02F4, 0, 0x0930, 1, 0)
+MX6_PAD_DECL(SD2_CLK__KEY_COL5,	0x06DC, 0x02F4, 2, 0x08C0, 3, 0)
+MX6_PAD_DECL(SD2_CLK__AUD4_RXFS,	0x06DC, 0x02F4, 3, 0x07A4, 1, 0)
+MX6_PAD_DECL(SD2_CLK__GPIO1_IO10,	0x06DC, 0x02F4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_CMD__SD2_CMD,	0x06E0, 0x02F8, 0 | IOMUX_CONFIG_SION, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_CMD__KEY_ROW5,	0x06E0, 0x02F8, 2, 0x08CC, 2, 0)
+MX6_PAD_DECL(SD2_CMD__AUD4_RXC,	0x06E0, 0x02F8, 3, 0x07A0, 1, 0)
+MX6_PAD_DECL(SD2_CMD__GPIO1_IO11,	0x06E0, 0x02F8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT0__SD2_DATA0,	0x06E4, 0x02FC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT0__AUD4_RXD,	0x06E4, 0x02FC, 3, 0x0798, 1, 0)
+MX6_PAD_DECL(SD2_DAT0__KEY_ROW7,	0x06E4, 0x02FC, 4, 0x08D4, 2, 0)
+MX6_PAD_DECL(SD2_DAT0__GPIO1_IO15,	0x06E4, 0x02FC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT0__DCIC2_OUT,	0x06E4, 0x02FC, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT1__SD2_DATA1,	0x06E8, 0x0300, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT1__EIM_CS2_B,	0x06E8, 0x0300, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT1__AUD4_TXFS,	0x06E8, 0x0300, 3, 0x07AC, 1, 0)
+MX6_PAD_DECL(SD2_DAT1__KEY_COL7,	0x06E8, 0x0300, 4, 0x08C8, 2, 0)
+MX6_PAD_DECL(SD2_DAT1__GPIO1_IO14,	0x06E8, 0x0300, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT2__SD2_DATA2,	0x06EC, 0x0304, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT2__EIM_CS3_B,	0x06EC, 0x0304, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT2__AUD4_TXD,	0x06EC, 0x0304, 3, 0x079C, 1, 0)
+MX6_PAD_DECL(SD2_DAT2__KEY_ROW6,	0x06EC, 0x0304, 4, 0x08D0, 2, 0)
+MX6_PAD_DECL(SD2_DAT2__GPIO1_IO13,	0x06EC, 0x0304, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT3__SD2_DATA3,	0x06F0, 0x0308, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT3__KEY_COL6,	0x06F0, 0x0308, 2, 0x08C4, 2, 0)
+MX6_PAD_DECL(SD2_DAT3__AUD4_TXC,	0x06F0, 0x0308, 3, 0x07A8, 1, 0)
+MX6_PAD_DECL(SD2_DAT3__GPIO1_IO12,	0x06F0, 0x0308, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_CLK__SD3_CLK,	0x06F4, 0x030C, 0, 0x0934, 1, 0)
+MX6_PAD_DECL(SD3_CLK__UART2_CTS_B,	0x06F4, 0x030C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_CLK__UART2_RTS_B,	0x06F4, 0x030C, 1, 0x0900, 2, 0)
+MX6_PAD_DECL(SD3_CLK__FLEXCAN1_RX,	0x06F4, 0x030C, 2, 0x07C8, 2, 0)
+MX6_PAD_DECL(SD3_CLK__GPIO7_IO03,	0x06F4, 0x030C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_CMD__SD3_CMD,	0x06F8, 0x0310, 0 | IOMUX_CONFIG_SION, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_CMD__UART2_CTS_B,	0x06F8, 0x0310, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_CMD__UART2_RTS_B,	0x06F8, 0x0310, 1, 0x0900, 3, 0)
+MX6_PAD_DECL(SD3_CMD__FLEXCAN1_TX,	0x06F8, 0x0310, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_CMD__GPIO7_IO02,	0x06F8, 0x0310, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT0__SD3_DATA0,	0x06FC, 0x0314, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT0__UART1_CTS_B,	0x06FC, 0x0314, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT0__UART1_RTS_B,	0x06FC, 0x0314, 1, 0x08F8, 2, 0)
+MX6_PAD_DECL(SD3_DAT0__FLEXCAN2_TX,	0x06FC, 0x0314, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT0__GPIO7_IO04,	0x06FC, 0x0314, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT1__SD3_DATA1,	0x0700, 0x0318, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT1__UART1_CTS_B,	0x0700, 0x0318, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT1__UART1_RTS_B,	0x0700, 0x0318, 1, 0x08F8, 3, 0)
+MX6_PAD_DECL(SD3_DAT1__FLEXCAN2_RX,	0x0700, 0x0318, 2, 0x07CC, 1, 0)
+MX6_PAD_DECL(SD3_DAT1__GPIO7_IO05,	0x0700, 0x0318, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT2__SD3_DATA2,	0x0704, 0x031C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT2__GPIO7_IO06,	0x0704, 0x031C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT3__SD3_DATA3,	0x0708, 0x0320, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT3__UART3_CTS_B,	0x0708, 0x0320, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT3__UART3_RTS_B,	0x0708, 0x0320, 1, 0x0908, 4, 0)
+MX6_PAD_DECL(SD3_DAT3__GPIO7_IO07,	0x0708, 0x0320, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT4__SD3_DATA4,	0x070C, 0x0324, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT4__UART2_TX_DATA,	0x070C, 0x0324, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT4__UART2_RX_DATA,	0x070C, 0x0324, 1, 0x0904, 4, 0)
+MX6_PAD_DECL(SD3_DAT4__GPIO7_IO01,	0x070C, 0x0324, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT5__SD3_DATA5,	0x0710, 0x0328, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT5__UART2_TX_DATA,	0x0710, 0x0328, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT5__UART2_RX_DATA,	0x0710, 0x0328, 1, 0x0904, 5, 0)
+MX6_PAD_DECL(SD3_DAT5__GPIO7_IO00,	0x0710, 0x0328, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT6__SD3_DATA6,	0x0714, 0x032C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT6__UART1_TX_DATA,	0x0714, 0x032C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT6__UART1_RX_DATA,	0x0714, 0x032C, 1, 0x08FC, 2, 0)
+MX6_PAD_DECL(SD3_DAT6__GPIO6_IO18,	0x0714, 0x032C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT7__SD3_DATA7,	0x0718, 0x0330, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT7__UART1_TX_DATA,	0x0718, 0x0330, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT7__UART1_RX_DATA,	0x0718, 0x0330, 1, 0x08FC, 3, 0)
+MX6_PAD_DECL(SD3_DAT7__GPIO6_IO17,	0x0718, 0x0330, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_RST__SD3_RESET,	0x071C, 0x0334, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_RST__UART3_CTS_B,	0x071C, 0x0334, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_RST__UART3_RTS_B,	0x071C, 0x0334, 1, 0x0908, 5, 0)
+MX6_PAD_DECL(SD3_RST__GPIO7_IO08,	0x071C, 0x0334, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_CLK__SD4_CLK,	0x0720, 0x0338, 0, 0x0938, 1, 0)
+MX6_PAD_DECL(SD4_CLK__NAND_WE_B,	0x0720, 0x0338, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_CLK__UART3_TX_DATA,	0x0720, 0x0338, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_CLK__UART3_RX_DATA,	0x0720, 0x0338, 2, 0x090C, 2, 0)
+MX6_PAD_DECL(SD4_CLK__GPIO7_IO10,	0x0720, 0x0338, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_CMD__SD4_CMD,	0x0724, 0x033C, 0 | IOMUX_CONFIG_SION, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_CMD__NAND_RE_B,	0x0724, 0x033C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_CMD__UART3_TX_DATA,	0x0724, 0x033C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_CMD__UART3_RX_DATA,	0x0724, 0x033C, 2, 0x090C, 3, 0)
+MX6_PAD_DECL(SD4_CMD__GPIO7_IO09,	0x0724, 0x033C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT0__SD4_DATA0,	0x0728, 0x0340, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT0__NAND_DQS,	0x0728, 0x0340, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT0__GPIO2_IO08,	0x0728, 0x0340, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT1__SD4_DATA1,	0x072C, 0x0344, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT1__PWM3_OUT,	0x072C, 0x0344, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT1__GPIO2_IO09,	0x072C, 0x0344, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT2__SD4_DATA2,	0x0730, 0x0348, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT2__PWM4_OUT,	0x0730, 0x0348, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT2__GPIO2_IO10,	0x0730, 0x0348, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT3__SD4_DATA3,	0x0734, 0x034C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT3__GPIO2_IO11,	0x0734, 0x034C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT4__SD4_DATA4,	0x0738, 0x0350, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT4__UART2_TX_DATA,	0x0738, 0x0350, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT4__UART2_RX_DATA,	0x0738, 0x0350, 2, 0x0904, 6, 0)
+MX6_PAD_DECL(SD4_DAT4__GPIO2_IO12,	0x0738, 0x0350, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT5__SD4_DATA5,	0x073C, 0x0354, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT5__UART2_CTS_B,	0x073C, 0x0354, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT5__UART2_RTS_B,	0x073C, 0x0354, 2, 0x0900, 4, 0)
+MX6_PAD_DECL(SD4_DAT5__GPIO2_IO13,	0x073C, 0x0354, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT6__SD4_DATA6,	0x0740, 0x0358, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT6__UART2_CTS_B,	0x0740, 0x0358, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT6__UART2_RTS_B,	0x0740, 0x0358, 2, 0x0900, 5, 0)
+MX6_PAD_DECL(SD4_DAT6__GPIO2_IO14,	0x0740, 0x0358, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT7__SD4_DATA7,	0x0744, 0x035C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT7__UART2_TX_DATA,	0x0744, 0x035C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT7__UART2_RX_DATA,	0x0744, 0x035C, 2, 0x0904, 7, 0)
+MX6_PAD_DECL(SD4_DAT7__GPIO2_IO15,	0x0744, 0x035C, 5, 0x0000, 0, 0)
+
+#endif	/* __ASM_ARCH_MX6_MX6DL_PINS_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6-pins.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6-pins.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6-pins.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6-pins.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Boundary Devices Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __ASM_ARCH_MX6_PINS_H__
+#define __ASM_ARCH_MX6_PINS_H__
+
+#include <asm/imx-common/iomux-v3.h>
+
+#define MX6_PAD_DECLARE(prefix, name, pco, mc, mm, sio, si, pc) \
+	prefix##name = IOMUX_PAD(pco, mc, mm, sio, si, pc)
+
+#ifdef CONFIG_MX6QDL
+enum {
+#define MX6_PAD_DECL(name, pco, mc, mm, sio, si, pc) \
+	MX6_PAD_DECLARE(MX6Q_PAD_,name, pco, mc, mm, sio, si, pc),
+#include "mx6q_pins.h"
+#undef MX6_PAD_DECL
+#define MX6_PAD_DECL(name, pco, mc, mm, sio, si, pc) \
+	MX6_PAD_DECLARE(MX6DL_PAD_,name, pco, mc, mm, sio, si, pc),
+#include "mx6dl_pins.h"
+};
+#elif defined(CONFIG_MX6Q)
+enum {
+#define MX6_PAD_DECL(name, pco, mc, mm, sio, si, pc) \
+	MX6_PAD_DECLARE(MX6_PAD_,name, pco, mc, mm, sio, si, pc),
+#include "mx6q_pins.h"
+};
+#elif defined(CONFIG_MX6DL) || defined(CONFIG_MX6S)
+enum {
+#define MX6_PAD_DECL(name, pco, mc, mm, sio, si, pc) \
+	MX6_PAD_DECLARE(MX6_PAD_,name, pco, mc, mm, sio, si, pc),
+#include "mx6dl_pins.h"
+};
+#elif defined(CONFIG_MX6SLL)
+#include "mx6sll_pins.h"
+#elif defined(CONFIG_MX6SL)
+#include "mx6sl_pins.h"
+#elif defined(CONFIG_MX6SX)
+#include "mx6sx_pins.h"
+#elif defined(CONFIG_MX6ULL)
+#include "mx6ull_pins.h"
+#elif defined(CONFIG_MX6UL)
+#include "mx6ul_pins.h"
+#else
+#error "Please select cpu"
+#endif	/* CONFIG_MX6Q */
+
+#endif	/*__ASM_ARCH_MX6_PINS_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6_plugin.S ebf_6ull_uboot/arch/arm/include/asm/arch/mx6_plugin.S
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6_plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6_plugin.S	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <config.h>
+
+#ifdef CONFIG_ROM_UNIFIED_SECTIONS
+#define ROM_API_TABLE_BASE_ADDR_LEGACY		0x180
+#define ROM_VERSION_OFFSET               	0x80
+#else
+#define ROM_API_TABLE_BASE_ADDR_LEGACY		0xC0
+#define ROM_VERSION_OFFSET               	0x48
+#endif
+#define ROM_API_TABLE_BASE_ADDR_MX6DQ_TO15	0xC4
+#define ROM_API_TABLE_BASE_ADDR_MX6DL_TO12	0xC4
+#define ROM_API_HWCNFG_SETUP_OFFSET		0x08
+#define ROM_VERSION_TO10			0x10
+#define ROM_VERSION_TO12			0x12
+#define ROM_VERSION_TO15			0x15
+
+plugin_start:
+
+	push    {r0-r4, lr}
+
+	imx6_ddr_setting
+	imx6_clock_gating
+	imx6_qos_setting
+
+/*
+ * The following is to fill in those arguments for this ROM function
+ * pu_irom_hwcnfg_setup(void **start, size_t *bytes, const void *boot_data)
+ * This function is used to copy data from the storage media into DDR.
+ * start - Initial (possibly partial) image load address on entry.
+ *         Final image load address on exit.
+ * bytes - Initial (possibly partial) image size on entry.
+ *         Final image size on exit.
+ * boot_data - Initial @ref ivt Boot Data load address.
+ */
+	adr r0, boot_data2
+	adr r1, image_len2
+	adr r2, boot_data2
+
+#ifdef CONFIG_SYS_BOOT_EIMNOR
+#ifdef CONFIG_MX6SX
+	ldr r3, =ROM_VERSION_OFFSET
+	ldr r4, [r3]
+	cmp r4, #ROM_VERSION_TO10
+	bgt before_calling_rom___pu_irom_hwcnfg_setup
+	ldr r3, =0x00900b00
+	ldr r4, =0x50000000
+	str r4, [r3, #0x5c]
+#else
+	ldr r3, =0x00900800
+	ldr r4, =0x08000000
+	str r4, [r3, #0xc0]
+#endif
+#endif
+
+/*
+ * check the _pu_irom_api_table for the address
+ */
+before_calling_rom___pu_irom_hwcnfg_setup:
+	ldr r3, =ROM_VERSION_OFFSET
+	ldr r4, [r3]
+#if defined(CONFIG_MX6SOLO) || defined(CONFIG_MX6DL)
+	ldr r3, =ROM_VERSION_TO12
+	cmp r4, r3
+	ldrge r3, =ROM_API_TABLE_BASE_ADDR_MX6DL_TO12
+	ldrlt r3, =ROM_API_TABLE_BASE_ADDR_LEGACY
+#elif defined(CONFIG_MX6Q)
+	ldr r3, =ROM_VERSION_TO15
+	cmp r4, r3
+	ldrge r3, =ROM_API_TABLE_BASE_ADDR_MX6DQ_TO15
+	ldrlt r3, =ROM_API_TABLE_BASE_ADDR_LEGACY
+#else
+	ldr r3, =ROM_API_TABLE_BASE_ADDR_LEGACY
+#endif
+	ldr r4, [r3, #ROM_API_HWCNFG_SETUP_OFFSET]
+	blx r4
+after_calling_rom___pu_irom_hwcnfg_setup:
+
+/*
+ * ROM_API_HWCNFG_SETUP function enables MMU & Caches.
+ * Thus disable MMU & Caches.
+ */
+
+#define ENABLE_CACHE 0x01
+
+    MRC     p15, 0, r0, c1, c0, 0   /* read CP15 register 1 into r0 */
+    ANDS    r0, r0, #0x1            /* check if MMU is enabled         */
+    BEQ     mmu_disable_notreq      /* exit if MMU is already disabled */
+
+/* Disable caches, MMU    */
+    MRC     p15, 0, r0, c1, c0, 0           /* read CP15 register 1 into r0 */
+    BIC     r0, r0, #(ENABLE_CACHE << 2)    /* disable D Cache */
+    BIC     r0, r0, #0x1                    /* clear bit 0 ; MMU off */
+
+    BIC     r0, r0, #(0x1 << 11)            /* disable Z, branch prediction */
+    BIC     r0, r0, #(0x1 << 1)             /* disable A, Strict alignment */
+					    /*		check enabled. */
+
+    MCR     p15, 0, r0, c1, c0, 0           /* write CP15 register 1 */
+    MOV     r0, r0
+    MOV     r0, r0
+    MOV     r0, r0
+    MOV     r0, r0
+
+mmu_disable_notreq:
+    NOP
+
+/* To return to ROM from plugin, we need to fill in these argument.
+ * Here is what need to do:
+ * Need to construct the paramters for this function before return to ROM:
+ * plugin_download(void **start, size_t *bytes, UINT32 *ivt_offset)
+ */
+	pop {r0-r4, lr}
+	push {r5}
+	ldr r5, boot_data2
+	str r5, [r0]
+	ldr r5, image_len2
+	str r5, [r1]
+	ldr r5, second_ivt_offset
+	str r5, [r2]
+	mov r0, #1
+	pop {r5}
+
+	/* return back to ROM code */
+	bx lr
+
+/* make the following data right in the end of the output*/
+.ltorg
+
+#if (defined(CONFIG_SYS_BOOT_EIMNOR) || defined(CONFIG_SYS_BOOT_QSPI))
+#define FLASH_OFFSET 0x1000
+#else
+#define FLASH_OFFSET 0x400
+#endif
+
+/*
+ * second_ivt_offset is the offset from the "second_ivt_header" to
+ * "image_copy_start", which involves FLASH_OFFSET, plus the first
+ * ivt_header, the plugin code size itself recorded by "ivt2_header"
+ */
+
+second_ivt_offset:      .long (ivt2_header + 0x2C + FLASH_OFFSET)
+
+/*
+ * The following is the second IVT header plus the second boot data
+ */
+ivt2_header:            .long 0x0
+app2_code_jump_v:       .long 0x0
+reserv3:                .long 0x0
+dcd2_ptr:               .long 0x0
+boot_data2_ptr:         .long 0x0
+self_ptr2:              .long 0x0
+app_code_csf2:          .long 0x0
+reserv4:                .long 0x0
+boot_data2:             .long 0x0
+image_len2:             .long 0x0
+plugin2:                .long 0x0
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6q-ddr.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6q-ddr.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6q-ddr.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6q-ddr.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2013 Boundary Devices Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __ASM_ARCH_MX6Q_DDR_H__
+#define __ASM_ARCH_MX6Q_DDR_H__
+
+#ifndef CONFIG_MX6Q
+#error "wrong CPU"
+#endif
+
+#define MX6_IOM_DRAM_DQM0	0x020e05ac
+#define MX6_IOM_DRAM_DQM1	0x020e05b4
+#define MX6_IOM_DRAM_DQM2	0x020e0528
+#define MX6_IOM_DRAM_DQM3	0x020e0520
+#define MX6_IOM_DRAM_DQM4	0x020e0514
+#define MX6_IOM_DRAM_DQM5	0x020e0510
+#define MX6_IOM_DRAM_DQM6	0x020e05bc
+#define MX6_IOM_DRAM_DQM7	0x020e05c4
+
+#define MX6_IOM_DRAM_CAS	0x020e056c
+#define MX6_IOM_DRAM_RAS	0x020e0578
+#define MX6_IOM_DRAM_RESET	0x020e057c
+#define MX6_IOM_DRAM_SDCLK_0	0x020e0588
+#define MX6_IOM_DRAM_SDCLK_1	0x020e0594
+#define MX6_IOM_DRAM_SDBA2	0x020e058c
+#define MX6_IOM_DRAM_SDCKE0	0x020e0590
+#define MX6_IOM_DRAM_SDCKE1	0x020e0598
+#define MX6_IOM_DRAM_SDODT0	0x020e059c
+#define MX6_IOM_DRAM_SDODT1	0x020e05a0
+
+#define MX6_IOM_DRAM_SDQS0	0x020e05a8
+#define MX6_IOM_DRAM_SDQS1	0x020e05b0
+#define MX6_IOM_DRAM_SDQS2	0x020e0524
+#define MX6_IOM_DRAM_SDQS3	0x020e051c
+#define MX6_IOM_DRAM_SDQS4	0x020e0518
+#define MX6_IOM_DRAM_SDQS5	0x020e050c
+#define MX6_IOM_DRAM_SDQS6	0x020e05b8
+#define MX6_IOM_DRAM_SDQS7	0x020e05c0
+
+#define MX6_IOM_GRP_B0DS	0x020e0784
+#define MX6_IOM_GRP_B1DS	0x020e0788
+#define MX6_IOM_GRP_B2DS	0x020e0794
+#define MX6_IOM_GRP_B3DS	0x020e079c
+#define MX6_IOM_GRP_B4DS	0x020e07a0
+#define MX6_IOM_GRP_B5DS	0x020e07a4
+#define MX6_IOM_GRP_B6DS	0x020e07a8
+#define MX6_IOM_GRP_B7DS	0x020e0748
+#define MX6_IOM_GRP_ADDDS	0x020e074c
+#define MX6_IOM_DDRMODE_CTL	0x020e0750
+#define MX6_IOM_GRP_DDRPKE	0x020e0758
+#define MX6_IOM_GRP_DDRMODE	0x020e0774
+#define MX6_IOM_GRP_CTLDS	0x020e078c
+#define MX6_IOM_GRP_DDR_TYPE	0x020e0798
+
+#endif	/*__ASM_ARCH_MX6Q_DDR_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6q_pins.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6q_pins.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6q_pins.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6q_pins.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,1036 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Auto Generate file, please don't edit it
+ */
+
+#ifndef __ASM_ARCH_MX6_MX6Q_PINS_H__
+#define __ASM_ARCH_MX6_MX6Q_PINS_H__
+
+MX6_PAD_DECL(SD2_DAT1__SD2_DATA1,	0x0360, 0x004C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT1__ECSPI5_SS0,	0x0360, 0x004C, 1, 0x0834, 0, 0)
+MX6_PAD_DECL(SD2_DAT1__EIM_CS2_B,	0x0360, 0x004C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT1__AUD4_TXFS,	0x0360, 0x004C, 3, 0x07C8, 0, 0)
+MX6_PAD_DECL(SD2_DAT1__KEY_COL7,	0x0360, 0x004C, 4, 0x08F0, 0, 0)
+MX6_PAD_DECL(SD2_DAT1__GPIO1_IO14,	0x0360, 0x004C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT2__SD2_DATA2,	0x0364, 0x0050, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT2__ECSPI5_SS1,	0x0364, 0x0050, 1, 0x0838, 0, 0)
+MX6_PAD_DECL(SD2_DAT2__EIM_CS3_B,	0x0364, 0x0050, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT2__AUD4_TXD,	0x0364, 0x0050, 3, 0x07B8, 0, 0)
+MX6_PAD_DECL(SD2_DAT2__KEY_ROW6,	0x0364, 0x0050, 4, 0x08F8, 0, 0)
+MX6_PAD_DECL(SD2_DAT2__GPIO1_IO13,	0x0364, 0x0050, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT0__SD2_DATA0,	0x0368, 0x0054, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT0__ECSPI5_MISO,	0x0368, 0x0054, 1, 0x082C, 0, 0)
+MX6_PAD_DECL(SD2_DAT0__AUD4_RXD,	0x0368, 0x0054, 3, 0x07B4, 0, 0)
+MX6_PAD_DECL(SD2_DAT0__KEY_ROW7,	0x0368, 0x0054, 4, 0x08FC, 0, 0)
+MX6_PAD_DECL(SD2_DAT0__GPIO1_IO15,	0x0368, 0x0054, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT0__DCIC2_OUT,	0x0368, 0x0054, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TXC__USB_H2_DATA,	0x036C, 0x0058, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TXC__RGMII_TXC,	0x036C, 0x0058, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TXC__SPDIF_EXT_CLK,	0x036C, 0x0058, 2, 0x0918, 0, 0)
+MX6_PAD_DECL(RGMII_TXC__GPIO6_IO19,	0x036C, 0x0058, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TXC__XTALOSC_REF_CLK_24M,	0x036C, 0x0058, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD0__HSI_TX_READY,	0x0370, 0x005C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD0__RGMII_TD0,	0x0370, 0x005C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD0__GPIO6_IO20,	0x0370, 0x005C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD1__HSI_RX_FLAG,	0x0374, 0x0060, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD1__RGMII_TD1,	0x0374, 0x0060, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD1__GPIO6_IO21,	0x0374, 0x0060, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD2__HSI_RX_DATA,	0x0378, 0x0064, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD2__RGMII_TD2,	0x0378, 0x0064, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD2__GPIO6_IO22,	0x0378, 0x0064, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD3__HSI_RX_WAKE,	0x037C, 0x0068, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD3__RGMII_TD3,	0x037C, 0x0068, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TD3__GPIO6_IO23,	0x037C, 0x0068, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RX_CTL__USB_H3_DATA,	0x0380, 0x006C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RX_CTL__RGMII_RX_CTL,	0x0380, 0x006C, 1, 0x0858, 0, 0)
+MX6_PAD_DECL(RGMII_RX_CTL__GPIO6_IO24,	0x0380, 0x006C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RD0__HSI_RX_READY,	0x0384, 0x0070, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RD0__RGMII_RD0,	0x0384, 0x0070, 1, 0x0848, 0, 0)
+MX6_PAD_DECL(RGMII_RD0__GPIO6_IO25,	0x0384, 0x0070, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TX_CTL__USB_H2_STROBE,	0x0388, 0x0074, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TX_CTL__RGMII_TX_CTL,	0x0388, 0x0074, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TX_CTL__GPIO6_IO26,	0x0388, 0x0074, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_TX_CTL__ENET_REF_CLK,	0x0388, 0x0074, 7 | IOMUX_CONFIG_SION, 0x083C, 0, 0)
+MX6_PAD_DECL(RGMII_RD1__HSI_TX_FLAG,	0x038C, 0x0078, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RD1__RGMII_RD1,	0x038C, 0x0078, 1, 0x084C, 0, 0)
+MX6_PAD_DECL(RGMII_RD1__GPIO6_IO27,	0x038C, 0x0078, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RD2__HSI_TX_DATA,	0x0390, 0x007C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RD2__RGMII_RD2,	0x0390, 0x007C, 1, 0x0850, 0, 0)
+MX6_PAD_DECL(RGMII_RD2__GPIO6_IO28,	0x0390, 0x007C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RD3__HSI_TX_WAKE,	0x0394, 0x0080, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RD3__RGMII_RD3,	0x0394, 0x0080, 1, 0x0854, 0, 0)
+MX6_PAD_DECL(RGMII_RD3__GPIO6_IO29,	0x0394, 0x0080, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RXC__USB_H3_STROBE,	0x0398, 0x0084, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(RGMII_RXC__RGMII_RXC,	0x0398, 0x0084, 1, 0x0844, 0, 0)
+MX6_PAD_DECL(RGMII_RXC__GPIO6_IO30,	0x0398, 0x0084, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A25__EIM_ADDR25,	0x039C, 0x0088, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A25__ECSPI4_SS1,	0x039C, 0x0088, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A25__ECSPI2_RDY,	0x039C, 0x0088, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A25__IPU1_DI1_PIN12,	0x039C, 0x0088, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A25__IPU1_DI0_D1_CS,	0x039C, 0x0088, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A25__GPIO5_IO02,	0x039C, 0x0088, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A25__HDMI_TX_CEC_LINE,	0x039C, 0x0088, 6, 0x088C, 0, 0)
+MX6_PAD_DECL(EIM_EB2__EIM_EB2_B,	0x03A0, 0x008C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB2__ECSPI1_SS0,	0x03A0, 0x008C, 1, 0x0800, 0, 0)
+MX6_PAD_DECL(EIM_EB2__IPU2_CSI1_DATA19,	0x03A0, 0x008C, 3, 0x08D4, 0, 0)
+MX6_PAD_DECL(EIM_EB2__HDMI_TX_DDC_SCL,	0x03A0, 0x008C, 4, 0x0890, 0, 0)
+MX6_PAD_DECL(EIM_EB2__GPIO2_IO30,	0x03A0, 0x008C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB2__I2C2_SCL,	0x03A0, 0x008C, 22, 0x08A0, 0, 0)
+MX6_PAD_DECL(EIM_EB2__SRC_BOOT_CFG30,	0x03A0, 0x008C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D16__EIM_DATA16,	0x03A4, 0x0090, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D16__ECSPI1_SCLK,	0x03A4, 0x0090, 1, 0x07F4, 0, 0)
+MX6_PAD_DECL(EIM_D16__IPU1_DI0_PIN05,	0x03A4, 0x0090, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D16__IPU2_CSI1_DATA18,	0x03A4, 0x0090, 3, 0x08D0, 0, 0)
+MX6_PAD_DECL(EIM_D16__HDMI_TX_DDC_SDA,	0x03A4, 0x0090, 4, 0x0894, 0, 0)
+MX6_PAD_DECL(EIM_D16__GPIO3_IO16,	0x03A4, 0x0090, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D16__I2C2_SDA,	0x03A4, 0x0090, 22, 0x08A4, 0, 0)
+MX6_PAD_DECL(EIM_D17__EIM_DATA17,	0x03A8, 0x0094, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D17__ECSPI1_MISO,	0x03A8, 0x0094, 1, 0x07F8, 0, 0)
+MX6_PAD_DECL(EIM_D17__IPU1_DI0_PIN06,	0x03A8, 0x0094, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D17__IPU2_CSI1_PIXCLK,	0x03A8, 0x0094, 3, 0x08E0, 0, 0)
+MX6_PAD_DECL(EIM_D17__DCIC1_OUT,	0x03A8, 0x0094, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D17__GPIO3_IO17,	0x03A8, 0x0094, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D17__I2C3_SCL,	0x03A8, 0x0094, 22, 0x08A8, 0, 0)
+MX6_PAD_DECL(EIM_D18__EIM_DATA18,	0x03AC, 0x0098, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D18__ECSPI1_MOSI,	0x03AC, 0x0098, 1, 0x07FC, 0, 0)
+MX6_PAD_DECL(EIM_D18__IPU1_DI0_PIN07,	0x03AC, 0x0098, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D18__IPU2_CSI1_DATA17,	0x03AC, 0x0098, 3, 0x08CC, 0, 0)
+MX6_PAD_DECL(EIM_D18__IPU1_DI1_D0_CS,	0x03AC, 0x0098, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D18__GPIO3_IO18,	0x03AC, 0x0098, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D18__I2C3_SDA,	0x03AC, 0x0098, 22, 0x08AC, 0, 0)
+MX6_PAD_DECL(EIM_D19__EIM_DATA19,	0x03B0, 0x009C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D19__ECSPI1_SS1,	0x03B0, 0x009C, 1, 0x0804, 0, 0)
+MX6_PAD_DECL(EIM_D19__IPU1_DI0_PIN08,	0x03B0, 0x009C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D19__IPU2_CSI1_DATA16,	0x03B0, 0x009C, 3, 0x08C8, 0, 0)
+MX6_PAD_DECL(EIM_D19__UART1_CTS_B,	0x03B0, 0x009C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D19__UART1_RTS_B,	0x03B0, 0x009C, 4, 0x091C, 0, 0)
+MX6_PAD_DECL(EIM_D19__GPIO3_IO19,	0x03B0, 0x009C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D19__EPIT1_OUT,	0x03B0, 0x009C, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D20__EIM_DATA20,	0x03B4, 0x00A0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D20__ECSPI4_SS0,	0x03B4, 0x00A0, 1, 0x0824, 0, 0)
+MX6_PAD_DECL(EIM_D20__IPU1_DI0_PIN16,	0x03B4, 0x00A0, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D20__IPU2_CSI1_DATA15,	0x03B4, 0x00A0, 3, 0x08C4, 0, 0)
+MX6_PAD_DECL(EIM_D20__UART1_CTS_B,	0x03B4, 0x00A0, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D20__UART1_RTS_B,	0x03B4, 0x00A0, 4, 0x091C, 1, 0)
+MX6_PAD_DECL(EIM_D20__GPIO3_IO20,	0x03B4, 0x00A0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D20__EPIT2_OUT,	0x03B4, 0x00A0, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D21__EIM_DATA21,	0x03B8, 0x00A4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D21__ECSPI4_SCLK,	0x03B8, 0x00A4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D21__IPU1_DI0_PIN17,	0x03B8, 0x00A4, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D21__IPU2_CSI1_DATA11,	0x03B8, 0x00A4, 3, 0x08B4, 0, 0)
+MX6_PAD_DECL(EIM_D21__USB_OTG_OC,	0x03B8, 0x00A4, 4, 0x0944, 0, 0)
+MX6_PAD_DECL(EIM_D21__GPIO3_IO21,	0x03B8, 0x00A4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D21__I2C1_SCL,	0x03B8, 0x00A4, 22, 0x0898, 0, 0)
+MX6_PAD_DECL(EIM_D21__SPDIF_IN,	0x03B8, 0x00A4, 7, 0x0914, 0, 0)
+MX6_PAD_DECL(EIM_D22__EIM_DATA22,	0x03BC, 0x00A8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D22__ECSPI4_MISO,	0x03BC, 0x00A8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D22__IPU1_DI0_PIN01,	0x03BC, 0x00A8, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D22__IPU2_CSI1_DATA10,	0x03BC, 0x00A8, 3, 0x08B0, 0, 0)
+MX6_PAD_DECL(EIM_D22__USB_OTG_PWR,	0x03BC, 0x00A8, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D22__GPIO3_IO22,	0x03BC, 0x00A8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D22__SPDIF_OUT,	0x03BC, 0x00A8, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D23__EIM_DATA23,	0x03C0, 0x00AC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D23__IPU1_DI0_D0_CS,	0x03C0, 0x00AC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D23__UART3_CTS_B,	0x03C0, 0x00AC, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D23__UART3_RTS_B,	0x03C0, 0x00AC, 2, 0x092C, 0, 0)
+MX6_PAD_DECL(EIM_D23__UART1_DCD_B,	0x03C0, 0x00AC, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D23__IPU2_CSI1_DATA_EN,	0x03C0, 0x00AC, 4, 0x08D8, 0, 0)
+MX6_PAD_DECL(EIM_D23__GPIO3_IO23,	0x03C0, 0x00AC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D23__IPU1_DI1_PIN02,	0x03C0, 0x00AC, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D23__IPU1_DI1_PIN14,	0x03C0, 0x00AC, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__EIM_EB3_B,	0x03C4, 0x00B0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__ECSPI4_RDY,	0x03C4, 0x00B0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__UART3_CTS_B,	0x03C4, 0x00B0, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__UART3_RTS_B,	0x03C4, 0x00B0, 2, 0x092C, 1, 0)
+MX6_PAD_DECL(EIM_EB3__UART1_RI_B,	0x03C4, 0x00B0, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__IPU2_CSI1_HSYNC,	0x03C4, 0x00B0, 4, 0x08DC, 0, 0)
+MX6_PAD_DECL(EIM_EB3__GPIO2_IO31,	0x03C4, 0x00B0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__IPU1_DI1_PIN03,	0x03C4, 0x00B0, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB3__SRC_BOOT_CFG31,	0x03C4, 0x00B0, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D24__EIM_DATA24,	0x03C8, 0x00B4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D24__ECSPI4_SS2,	0x03C8, 0x00B4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D24__UART3_TX_DATA,	0x03C8, 0x00B4, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D24__UART3_RX_DATA,	0x03C8, 0x00B4, 2, 0x0930, 0, 0)
+MX6_PAD_DECL(EIM_D24__ECSPI1_SS2,	0x03C8, 0x00B4, 3, 0x0808, 0, 0)
+MX6_PAD_DECL(EIM_D24__ECSPI2_SS2,	0x03C8, 0x00B4, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D24__GPIO3_IO24,	0x03C8, 0x00B4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D24__AUD5_RXFS,	0x03C8, 0x00B4, 6, 0x07D8, 0, 0)
+MX6_PAD_DECL(EIM_D24__UART1_DTR_B,	0x03C8, 0x00B4, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D25__EIM_DATA25,	0x03CC, 0x00B8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D25__ECSPI4_SS3,	0x03CC, 0x00B8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D25__UART3_TX_DATA,	0x03CC, 0x00B8, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D25__UART3_RX_DATA,	0x03CC, 0x00B8, 2, 0x0930, 1, 0)
+MX6_PAD_DECL(EIM_D25__ECSPI1_SS3,	0x03CC, 0x00B8, 3, 0x080C, 0, 0)
+MX6_PAD_DECL(EIM_D25__ECSPI2_SS3,	0x03CC, 0x00B8, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D25__GPIO3_IO25,	0x03CC, 0x00B8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D25__AUD5_RXC,	0x03CC, 0x00B8, 6, 0x07D4, 0, 0)
+MX6_PAD_DECL(EIM_D25__UART1_DSR_B,	0x03CC, 0x00B8, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D26__EIM_DATA26,	0x03D0, 0x00BC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D26__IPU1_DI1_PIN11,	0x03D0, 0x00BC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D26__IPU1_CSI0_DATA01,	0x03D0, 0x00BC, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D26__IPU2_CSI1_DATA14,	0x03D0, 0x00BC, 3, 0x08C0, 0, 0)
+MX6_PAD_DECL(EIM_D26__UART2_TX_DATA,	0x03D0, 0x00BC, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D26__UART2_RX_DATA,	0x03D0, 0x00BC, 4, 0x0928, 0, 0)
+MX6_PAD_DECL(EIM_D26__GPIO3_IO26,	0x03D0, 0x00BC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D26__IPU1_SISG2,	0x03D0, 0x00BC, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D26__IPU1_DISP1_DATA22,	0x03D0, 0x00BC, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D27__EIM_DATA27,	0x03D4, 0x00C0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D27__IPU1_DI1_PIN13,	0x03D4, 0x00C0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D27__IPU1_CSI0_DATA00,	0x03D4, 0x00C0, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D27__IPU2_CSI1_DATA13,	0x03D4, 0x00C0, 3, 0x08BC, 0, 0)
+MX6_PAD_DECL(EIM_D27__UART2_TX_DATA,	0x03D4, 0x00C0, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D27__UART2_RX_DATA,	0x03D4, 0x00C0, 4, 0x0928, 1, 0)
+MX6_PAD_DECL(EIM_D27__GPIO3_IO27,	0x03D4, 0x00C0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D27__IPU1_SISG3,	0x03D4, 0x00C0, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D27__IPU1_DISP1_DATA23,	0x03D4, 0x00C0, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D28__EIM_DATA28,	0x03D8, 0x00C4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D28__I2C1_SDA,	0x03D8, 0x00C4, 17, 0x089C, 0, 0)
+MX6_PAD_DECL(EIM_D28__ECSPI4_MOSI,	0x03D8, 0x00C4, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D28__IPU2_CSI1_DATA12,	0x03D8, 0x00C4, 3, 0x08B8, 0, 0)
+MX6_PAD_DECL(EIM_D28__UART2_DTE_CTS_B,	0x03D8, 0x00C4, 4, 0x0924, 0, 0)
+MX6_PAD_DECL(EIM_D28__UART2_DTE_RTS_B,	0x03D8, 0x00C4, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D28__GPIO3_IO28,	0x03D8, 0x00C4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D28__IPU1_EXT_TRIG,	0x03D8, 0x00C4, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D28__IPU1_DI0_PIN13,	0x03D8, 0x00C4, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D29__EIM_DATA29,	0x03DC, 0x00C8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D29__IPU1_DI1_PIN15,	0x03DC, 0x00C8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D29__ECSPI4_SS0,	0x03DC, 0x00C8, 2, 0x0824, 1, 0)
+MX6_PAD_DECL(EIM_D29__UART2_CTS_B,	0x03DC, 0x00C8, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D29__UART2_RTS_B,	0x03DC, 0x00C8, 4, 0x0924, 1, 0)
+MX6_PAD_DECL(EIM_D29__GPIO3_IO29,	0x03DC, 0x00C8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D29__IPU2_CSI1_VSYNC,	0x03DC, 0x00C8, 6, 0x08E4, 0, 0)
+MX6_PAD_DECL(EIM_D29__IPU1_DI0_PIN14,	0x03DC, 0x00C8, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D30__EIM_DATA30,	0x03E0, 0x00CC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D30__IPU1_DISP1_DATA21,	0x03E0, 0x00CC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D30__IPU1_DI0_PIN11,	0x03E0, 0x00CC, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D30__IPU1_CSI0_DATA03,	0x03E0, 0x00CC, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D30__UART3_CTS_B,	0x03E0, 0x00CC, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D30__UART3_RTS_B,	0x03E0, 0x00CC, 4, 0x092C, 2, 0)
+MX6_PAD_DECL(EIM_D30__GPIO3_IO30,	0x03E0, 0x00CC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D30__USB_H1_OC,	0x03E0, 0x00CC, 6, 0x0948, 0, 0)
+MX6_PAD_DECL(EIM_D31__EIM_DATA31,	0x03E4, 0x00D0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D31__IPU1_DISP1_DATA20,	0x03E4, 0x00D0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D31__IPU1_DI0_PIN12,	0x03E4, 0x00D0, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D31__IPU1_CSI0_DATA02,	0x03E4, 0x00D0, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D31__UART3_CTS_B,	0x03E4, 0x00D0, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D31__UART3_RTS_B,	0x03E4, 0x00D0, 4, 0x092C, 3, 0)
+MX6_PAD_DECL(EIM_D31__GPIO3_IO31,	0x03E4, 0x00D0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_D31__USB_H1_PWR,	0x03E4, 0x00D0, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A24__EIM_ADDR24,	0x03E8, 0x00D4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A24__IPU1_DISP1_DATA19,	0x03E8, 0x00D4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A24__IPU2_CSI1_DATA19,	0x03E8, 0x00D4, 2, 0x08D4, 1, 0)
+MX6_PAD_DECL(EIM_A24__IPU2_SISG2,	0x03E8, 0x00D4, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A24__IPU1_SISG2,	0x03E8, 0x00D4, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A24__GPIO5_IO04,	0x03E8, 0x00D4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A24__SRC_BOOT_CFG24,	0x03E8, 0x00D4, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A23__EIM_ADDR23,	0x03EC, 0x00D8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A23__IPU1_DISP1_DATA18,	0x03EC, 0x00D8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A23__IPU2_CSI1_DATA18,	0x03EC, 0x00D8, 2, 0x08D0, 1, 0)
+MX6_PAD_DECL(EIM_A23__IPU2_SISG3,	0x03EC, 0x00D8, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A23__IPU1_SISG3,	0x03EC, 0x00D8, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A23__GPIO6_IO06,	0x03EC, 0x00D8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A23__SRC_BOOT_CFG23,	0x03EC, 0x00D8, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A22__EIM_ADDR22,	0x03F0, 0x00DC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A22__IPU1_DISP1_DATA17,	0x03F0, 0x00DC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A22__IPU2_CSI1_DATA17,	0x03F0, 0x00DC, 2, 0x08CC, 1, 0)
+MX6_PAD_DECL(EIM_A22__GPIO2_IO16,	0x03F0, 0x00DC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A22__SRC_BOOT_CFG22,	0x03F0, 0x00DC, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A21__EIM_ADDR21,	0x03F4, 0x00E0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A21__IPU1_DISP1_DATA16,	0x03F4, 0x00E0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A21__IPU2_CSI1_DATA16,	0x03F4, 0x00E0, 2, 0x08C8, 1, 0)
+MX6_PAD_DECL(EIM_A21__GPIO2_IO17,	0x03F4, 0x00E0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A21__SRC_BOOT_CFG21,	0x03F4, 0x00E0, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A20__EIM_ADDR20,	0x03F8, 0x00E4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A20__IPU1_DISP1_DATA15,	0x03F8, 0x00E4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A20__IPU2_CSI1_DATA15,	0x03F8, 0x00E4, 2, 0x08C4, 1, 0)
+MX6_PAD_DECL(EIM_A20__GPIO2_IO18,	0x03F8, 0x00E4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A20__SRC_BOOT_CFG20,	0x03F8, 0x00E4, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A19__EIM_ADDR19,	0x03FC, 0x00E8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A19__IPU1_DISP1_DATA14,	0x03FC, 0x00E8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A19__IPU2_CSI1_DATA14,	0x03FC, 0x00E8, 2, 0x08C0, 1, 0)
+MX6_PAD_DECL(EIM_A19__GPIO2_IO19,	0x03FC, 0x00E8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A19__SRC_BOOT_CFG19,	0x03FC, 0x00E8, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A18__EIM_ADDR18,	0x0400, 0x00EC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A18__IPU1_DISP1_DATA13,	0x0400, 0x00EC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A18__IPU2_CSI1_DATA13,	0x0400, 0x00EC, 2, 0x08BC, 1, 0)
+MX6_PAD_DECL(EIM_A18__GPIO2_IO20,	0x0400, 0x00EC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A18__SRC_BOOT_CFG18,	0x0400, 0x00EC, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A17__EIM_ADDR17,	0x0404, 0x00F0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A17__IPU1_DISP1_DATA12,	0x0404, 0x00F0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A17__IPU2_CSI1_DATA12,	0x0404, 0x00F0, 2, 0x08B8, 1, 0)
+MX6_PAD_DECL(EIM_A17__GPIO2_IO21,	0x0404, 0x00F0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A17__SRC_BOOT_CFG17,	0x0404, 0x00F0, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A16__EIM_ADDR16,	0x0408, 0x00F4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A16__IPU1_DI1_DISP_CLK,	0x0408, 0x00F4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A16__IPU2_CSI1_PIXCLK,	0x0408, 0x00F4, 2, 0x08E0, 1, 0)
+MX6_PAD_DECL(EIM_A16__GPIO2_IO22,	0x0408, 0x00F4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_A16__SRC_BOOT_CFG16,	0x0408, 0x00F4, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_CS0__EIM_CS0_B,	0x040C, 0x00F8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_CS0__IPU1_DI1_PIN05,	0x040C, 0x00F8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_CS0__ECSPI2_SCLK,	0x040C, 0x00F8, 2, 0x0810, 0, 0)
+MX6_PAD_DECL(EIM_CS0__GPIO2_IO23,	0x040C, 0x00F8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_CS1__EIM_CS1_B,	0x0410, 0x00FC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_CS1__IPU1_DI1_PIN06,	0x0410, 0x00FC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_CS1__ECSPI2_MOSI,	0x0410, 0x00FC, 2, 0x0818, 0, 0)
+MX6_PAD_DECL(EIM_CS1__GPIO2_IO24,	0x0410, 0x00FC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_OE__EIM_OE_B,	0x0414, 0x0100, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_OE__IPU1_DI1_PIN07,	0x0414, 0x0100, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_OE__ECSPI2_MISO,	0x0414, 0x0100, 2, 0x0814, 0, 0)
+MX6_PAD_DECL(EIM_OE__GPIO2_IO25,	0x0414, 0x0100, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_RW__EIM_RW,	0x0418, 0x0104, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_RW__IPU1_DI1_PIN08,	0x0418, 0x0104, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_RW__ECSPI2_SS0,	0x0418, 0x0104, 2, 0x081C, 0, 0)
+MX6_PAD_DECL(EIM_RW__GPIO2_IO26,	0x0418, 0x0104, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_RW__SRC_BOOT_CFG29,	0x0418, 0x0104, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_LBA__EIM_LBA_B,	0x041C, 0x0108, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_LBA__IPU1_DI1_PIN17,	0x041C, 0x0108, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_LBA__ECSPI2_SS1,	0x041C, 0x0108, 2, 0x0820, 0, 0)
+MX6_PAD_DECL(EIM_LBA__GPIO2_IO27,	0x041C, 0x0108, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_LBA__SRC_BOOT_CFG26,	0x041C, 0x0108, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB0__EIM_EB0_B,	0x0420, 0x010C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB0__IPU1_DISP1_DATA11,	0x0420, 0x010C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB0__IPU2_CSI1_DATA11,	0x0420, 0x010C, 2, 0x08B4, 1, 0)
+MX6_PAD_DECL(EIM_EB0__CCM_PMIC_READY,	0x0420, 0x010C, 4, 0x07F0, 0, 0)
+MX6_PAD_DECL(EIM_EB0__GPIO2_IO28,	0x0420, 0x010C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB0__SRC_BOOT_CFG27,	0x0420, 0x010C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB1__EIM_EB1_B,	0x0424, 0x0110, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB1__IPU1_DISP1_DATA10,	0x0424, 0x0110, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB1__IPU2_CSI1_DATA10,	0x0424, 0x0110, 2, 0x08B0, 1, 0)
+MX6_PAD_DECL(EIM_EB1__GPIO2_IO29,	0x0424, 0x0110, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_EB1__SRC_BOOT_CFG28,	0x0424, 0x0110, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA0__EIM_AD00,	0x0428, 0x0114, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA0__IPU1_DISP1_DATA09,	0x0428, 0x0114, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA0__IPU2_CSI1_DATA09,	0x0428, 0x0114, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA0__GPIO3_IO00,	0x0428, 0x0114, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA0__SRC_BOOT_CFG00,	0x0428, 0x0114, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA1__EIM_AD01,	0x042C, 0x0118, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA1__IPU1_DISP1_DATA08,	0x042C, 0x0118, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA1__IPU2_CSI1_DATA08,	0x042C, 0x0118, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA1__GPIO3_IO01,	0x042C, 0x0118, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA1__SRC_BOOT_CFG01,	0x042C, 0x0118, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA2__EIM_AD02,	0x0430, 0x011C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA2__IPU1_DISP1_DATA07,	0x0430, 0x011C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA2__IPU2_CSI1_DATA07,	0x0430, 0x011C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA2__GPIO3_IO02,	0x0430, 0x011C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA2__SRC_BOOT_CFG02,	0x0430, 0x011C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA3__EIM_AD03,	0x0434, 0x0120, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA3__IPU1_DISP1_DATA06,	0x0434, 0x0120, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA3__IPU2_CSI1_DATA06,	0x0434, 0x0120, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA3__GPIO3_IO03,	0x0434, 0x0120, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA3__SRC_BOOT_CFG03,	0x0434, 0x0120, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA4__EIM_AD04,	0x0438, 0x0124, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA4__IPU1_DISP1_DATA05,	0x0438, 0x0124, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA4__IPU2_CSI1_DATA05,	0x0438, 0x0124, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA4__GPIO3_IO04,	0x0438, 0x0124, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA4__SRC_BOOT_CFG04,	0x0438, 0x0124, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA5__EIM_AD05,	0x043C, 0x0128, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA5__IPU1_DISP1_DATA04,	0x043C, 0x0128, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA5__IPU2_CSI1_DATA04,	0x043C, 0x0128, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA5__GPIO3_IO05,	0x043C, 0x0128, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA5__SRC_BOOT_CFG05,	0x043C, 0x0128, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA6__EIM_AD06,	0x0440, 0x012C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA6__IPU1_DISP1_DATA03,	0x0440, 0x012C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA6__IPU2_CSI1_DATA03,	0x0440, 0x012C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA6__GPIO3_IO06,	0x0440, 0x012C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA6__SRC_BOOT_CFG06,	0x0440, 0x012C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA7__EIM_AD07,	0x0444, 0x0130, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA7__IPU1_DISP1_DATA02,	0x0444, 0x0130, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA7__IPU2_CSI1_DATA02,	0x0444, 0x0130, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA7__GPIO3_IO07,	0x0444, 0x0130, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA7__SRC_BOOT_CFG07,	0x0444, 0x0130, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA8__EIM_AD08,	0x0448, 0x0134, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA8__IPU1_DISP1_DATA01,	0x0448, 0x0134, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA8__IPU2_CSI1_DATA01,	0x0448, 0x0134, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA8__GPIO3_IO08,	0x0448, 0x0134, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA8__SRC_BOOT_CFG08,	0x0448, 0x0134, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA9__EIM_AD09,	0x044C, 0x0138, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA9__IPU1_DISP1_DATA00,	0x044C, 0x0138, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA9__IPU2_CSI1_DATA00,	0x044C, 0x0138, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA9__GPIO3_IO09,	0x044C, 0x0138, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA9__SRC_BOOT_CFG09,	0x044C, 0x0138, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA10__EIM_AD10,	0x0450, 0x013C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA10__IPU1_DI1_PIN15,	0x0450, 0x013C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA10__IPU2_CSI1_DATA_EN,	0x0450, 0x013C, 2, 0x08D8, 1, 0)
+MX6_PAD_DECL(EIM_DA10__GPIO3_IO10,	0x0450, 0x013C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA10__SRC_BOOT_CFG10,	0x0450, 0x013C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA11__EIM_AD11,	0x0454, 0x0140, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA11__IPU1_DI1_PIN02,	0x0454, 0x0140, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA11__IPU2_CSI1_HSYNC,	0x0454, 0x0140, 2, 0x08DC, 1, 0)
+MX6_PAD_DECL(EIM_DA11__GPIO3_IO11,	0x0454, 0x0140, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA11__SRC_BOOT_CFG11,	0x0454, 0x0140, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA12__EIM_AD12,	0x0458, 0x0144, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA12__IPU1_DI1_PIN03,	0x0458, 0x0144, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA12__IPU2_CSI1_VSYNC,	0x0458, 0x0144, 2, 0x08E4, 1, 0)
+MX6_PAD_DECL(EIM_DA12__GPIO3_IO12,	0x0458, 0x0144, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA12__SRC_BOOT_CFG12,	0x0458, 0x0144, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA13__EIM_AD13,	0x045C, 0x0148, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA13__IPU1_DI1_D0_CS,	0x045C, 0x0148, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA13__GPIO3_IO13,	0x045C, 0x0148, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA13__SRC_BOOT_CFG13,	0x045C, 0x0148, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA14__EIM_AD14,	0x0460, 0x014C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA14__IPU1_DI1_D1_CS,	0x0460, 0x014C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA14__GPIO3_IO14,	0x0460, 0x014C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA14__SRC_BOOT_CFG14,	0x0460, 0x014C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA15__EIM_AD15,	0x0464, 0x0150, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA15__IPU1_DI1_PIN01,	0x0464, 0x0150, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA15__IPU1_DI1_PIN04,	0x0464, 0x0150, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA15__GPIO3_IO15,	0x0464, 0x0150, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_DA15__SRC_BOOT_CFG15,	0x0464, 0x0150, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_WAIT__EIM_WAIT_B,	0x0468, 0x0154, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_WAIT__EIM_DTACK_B,	0x0468, 0x0154, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_WAIT__GPIO5_IO00,	0x0468, 0x0154, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_WAIT__SRC_BOOT_CFG25,	0x0468, 0x0154, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_BCLK__EIM_BCLK,	0x046C, 0x0158, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_BCLK__IPU1_DI1_PIN16,	0x046C, 0x0158, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(EIM_BCLK__GPIO6_IO31,	0x046C, 0x0158, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK,	0x0470, 0x015C, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DI0_DISP_CLK__IPU2_DI0_DISP_CLK,	0x0470, 0x015C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_DISP_CLK__GPIO4_IO16,	0x0470, 0x015C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN15__IPU1_DI0_PIN15,	0x0474, 0x0160, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DI0_PIN15__IPU2_DI0_PIN15,	0x0474, 0x0160, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN15__AUD6_TXC,	0x0474, 0x0160, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN15__GPIO4_IO17,	0x0474, 0x0160, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN2__IPU1_DI0_PIN02,	0x0478, 0x0164, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DI0_PIN2__IPU2_DI0_PIN02,	0x0478, 0x0164, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN2__AUD6_TXD,	0x0478, 0x0164, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN2__GPIO4_IO18,	0x0478, 0x0164, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN3__IPU1_DI0_PIN03,	0x047C, 0x0168, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DI0_PIN3__IPU2_DI0_PIN03,	0x047C, 0x0168, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN3__AUD6_TXFS,	0x047C, 0x0168, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN3__GPIO4_IO19,	0x047C, 0x0168, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN4__IPU1_DI0_PIN04,	0x0480, 0x016C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN4__IPU2_DI0_PIN04,	0x0480, 0x016C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN4__AUD6_RXD,	0x0480, 0x016C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DI0_PIN4__SD1_WP,	0x0480, 0x016C, 3, 0x094C, 0, 0)
+MX6_PAD_DECL(DI0_PIN4__GPIO4_IO20,	0x0480, 0x016C, 5, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT0__IPU1_DISP0_DATA00,	0x0484, 0x0170, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT0__IPU2_DISP0_DATA00,	0x0484, 0x0170, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT0__ECSPI3_SCLK,	0x0484, 0x0170, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT0__GPIO4_IO21,	0x0484, 0x0170, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT1__IPU1_DISP0_DATA01,	0x0488, 0x0174, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT1__IPU2_DISP0_DATA01,	0x0488, 0x0174, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT1__ECSPI3_MOSI,	0x0488, 0x0174, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT1__GPIO4_IO22,	0x0488, 0x0174, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT2__IPU1_DISP0_DATA02,	0x048C, 0x0178, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT2__IPU2_DISP0_DATA02,	0x048C, 0x0178, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT2__ECSPI3_MISO,	0x048C, 0x0178, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT2__GPIO4_IO23,	0x048C, 0x0178, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT3__IPU1_DISP0_DATA03,	0x0490, 0x017C, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT3__IPU2_DISP0_DATA03,	0x0490, 0x017C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT3__ECSPI3_SS0,	0x0490, 0x017C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT3__GPIO4_IO24,	0x0490, 0x017C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT4__IPU1_DISP0_DATA04,	0x0494, 0x0180, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT4__IPU2_DISP0_DATA04,	0x0494, 0x0180, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT4__ECSPI3_SS1,	0x0494, 0x0180, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT4__GPIO4_IO25,	0x0494, 0x0180, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT5__IPU1_DISP0_DATA05,	0x0498, 0x0184, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT5__IPU2_DISP0_DATA05,	0x0498, 0x0184, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT5__ECSPI3_SS2,	0x0498, 0x0184, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT5__AUD6_RXFS,	0x0498, 0x0184, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT5__GPIO4_IO26,	0x0498, 0x0184, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT6__IPU1_DISP0_DATA06,	0x049C, 0x0188, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT6__IPU2_DISP0_DATA06,	0x049C, 0x0188, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT6__ECSPI3_SS3,	0x049C, 0x0188, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT6__AUD6_RXC,	0x049C, 0x0188, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT6__GPIO4_IO27,	0x049C, 0x0188, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT7__IPU1_DISP0_DATA07,	0x04A0, 0x018C, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT7__IPU2_DISP0_DATA07,	0x04A0, 0x018C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT7__ECSPI3_RDY,	0x04A0, 0x018C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT7__GPIO4_IO28,	0x04A0, 0x018C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT8__IPU1_DISP0_DATA08,	0x04A4, 0x0190, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT8__IPU2_DISP0_DATA08,	0x04A4, 0x0190, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT8__PWM1_OUT,	0x04A4, 0x0190, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT8__WDOG1_B,	0x04A4, 0x0190, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT8__GPIO4_IO29,	0x04A4, 0x0190, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT9__IPU1_DISP0_DATA09,	0x04A8, 0x0194, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT9__IPU2_DISP0_DATA09,	0x04A8, 0x0194, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT9__PWM2_OUT,	0x04A8, 0x0194, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT9__WDOG2_B,	0x04A8, 0x0194, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT9__GPIO4_IO30,	0x04A8, 0x0194, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT10__IPU1_DISP0_DATA10,	0x04AC, 0x0198, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT10__IPU2_DISP0_DATA10,	0x04AC, 0x0198, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT10__GPIO4_IO31,	0x04AC, 0x0198, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT11__IPU1_DISP0_DATA11,	0x04B0, 0x019C, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT11__IPU2_DISP0_DATA11,	0x04B0, 0x019C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT11__GPIO5_IO05,	0x04B0, 0x019C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT12__IPU1_DISP0_DATA12,	0x04B4, 0x01A0, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT12__IPU2_DISP0_DATA12,	0x04B4, 0x01A0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT12__GPIO5_IO06,	0x04B4, 0x01A0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT13__IPU1_DISP0_DATA13,	0x04B8, 0x01A4, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT13__IPU2_DISP0_DATA13,	0x04B8, 0x01A4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT13__AUD5_RXFS,	0x04B8, 0x01A4, 3, 0x07D8, 1, 0)
+MX6_PAD_DECL(DISP0_DAT13__GPIO5_IO07,	0x04B8, 0x01A4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT14__IPU1_DISP0_DATA14,	0x04BC, 0x01A8, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT14__IPU2_DISP0_DATA14,	0x04BC, 0x01A8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT14__AUD5_RXC,	0x04BC, 0x01A8, 3, 0x07D4, 1, 0)
+MX6_PAD_DECL(DISP0_DAT14__GPIO5_IO08,	0x04BC, 0x01A8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT15__IPU1_DISP0_DATA15,	0x04C0, 0x01AC, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT15__IPU2_DISP0_DATA15,	0x04C0, 0x01AC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT15__ECSPI1_SS1,	0x04C0, 0x01AC, 2, 0x0804, 1, 0)
+MX6_PAD_DECL(DISP0_DAT15__ECSPI2_SS1,	0x04C0, 0x01AC, 3, 0x0820, 1, 0)
+MX6_PAD_DECL(DISP0_DAT15__GPIO5_IO09,	0x04C0, 0x01AC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT16__IPU1_DISP0_DATA16,	0x04C4, 0x01B0, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT16__IPU2_DISP0_DATA16,	0x04C4, 0x01B0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT16__ECSPI2_MOSI,	0x04C4, 0x01B0, 2, 0x0818, 1, 0)
+MX6_PAD_DECL(DISP0_DAT16__AUD5_TXC,	0x04C4, 0x01B0, 3, 0x07DC, 0, 0)
+MX6_PAD_DECL(DISP0_DAT16__SDMA_EXT_EVENT0,	0x04C4, 0x01B0, 4, 0x090C, 0, 0)
+MX6_PAD_DECL(DISP0_DAT16__GPIO5_IO10,	0x04C4, 0x01B0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT17__IPU1_DISP0_DATA17,	0x04C8, 0x01B4, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT17__IPU2_DISP0_DATA17,	0x04C8, 0x01B4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT17__ECSPI2_MISO,	0x04C8, 0x01B4, 2, 0x0814, 1, 0)
+MX6_PAD_DECL(DISP0_DAT17__AUD5_TXD,	0x04C8, 0x01B4, 3, 0x07D0, 0, 0)
+MX6_PAD_DECL(DISP0_DAT17__SDMA_EXT_EVENT1,	0x04C8, 0x01B4, 4, 0x0910, 0, 0)
+MX6_PAD_DECL(DISP0_DAT17__GPIO5_IO11,	0x04C8, 0x01B4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT18__IPU1_DISP0_DATA18,	0x04CC, 0x01B8, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT18__IPU2_DISP0_DATA18,	0x04CC, 0x01B8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT18__ECSPI2_SS0,	0x04CC, 0x01B8, 2, 0x081C, 1, 0)
+MX6_PAD_DECL(DISP0_DAT18__AUD5_TXFS,	0x04CC, 0x01B8, 3, 0x07E0, 0, 0)
+MX6_PAD_DECL(DISP0_DAT18__AUD4_RXFS,	0x04CC, 0x01B8, 4, 0x07C0, 0, 0)
+MX6_PAD_DECL(DISP0_DAT18__GPIO5_IO12,	0x04CC, 0x01B8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT18__EIM_CS2_B,	0x04CC, 0x01B8, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT19__IPU1_DISP0_DATA19,	0x04D0, 0x01BC, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT19__IPU2_DISP0_DATA19,	0x04D0, 0x01BC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT19__ECSPI2_SCLK,	0x04D0, 0x01BC, 2, 0x0810, 1, 0)
+MX6_PAD_DECL(DISP0_DAT19__AUD5_RXD,	0x04D0, 0x01BC, 3, 0x07CC, 0, 0)
+MX6_PAD_DECL(DISP0_DAT19__AUD4_RXC,	0x04D0, 0x01BC, 4, 0x07BC, 0, 0)
+MX6_PAD_DECL(DISP0_DAT19__GPIO5_IO13,	0x04D0, 0x01BC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT19__EIM_CS3_B,	0x04D0, 0x01BC, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT20__IPU1_DISP0_DATA20,	0x04D4, 0x01C0, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT20__IPU2_DISP0_DATA20,	0x04D4, 0x01C0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT20__ECSPI1_SCLK,	0x04D4, 0x01C0, 2, 0x07F4, 1, 0)
+MX6_PAD_DECL(DISP0_DAT20__AUD4_TXC,	0x04D4, 0x01C0, 3, 0x07C4, 0, 0)
+MX6_PAD_DECL(DISP0_DAT20__GPIO5_IO14,	0x04D4, 0x01C0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT21__IPU1_DISP0_DATA21,	0x04D8, 0x01C4, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT21__IPU2_DISP0_DATA21,	0x04D8, 0x01C4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT21__ECSPI1_MOSI,	0x04D8, 0x01C4, 2, 0x07FC, 1, 0)
+MX6_PAD_DECL(DISP0_DAT21__AUD4_TXD,	0x04D8, 0x01C4, 3, 0x07B8, 1, 0)
+MX6_PAD_DECL(DISP0_DAT21__GPIO5_IO15,	0x04D8, 0x01C4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT22__IPU1_DISP0_DATA22,	0x04DC, 0x01C8, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT22__IPU2_DISP0_DATA22,	0x04DC, 0x01C8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT22__ECSPI1_MISO,	0x04DC, 0x01C8, 2, 0x07F8, 1, 0)
+MX6_PAD_DECL(DISP0_DAT22__AUD4_TXFS,	0x04DC, 0x01C8, 3, 0x07C8, 1, 0)
+MX6_PAD_DECL(DISP0_DAT22__GPIO5_IO16,	0x04DC, 0x01C8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT23__IPU1_DISP0_DATA23,	0x04E0, 0x01CC, 0, 0x0000, 0, PAD_CTL_DSE_120ohm)
+MX6_PAD_DECL(DISP0_DAT23__IPU2_DISP0_DATA23,	0x04E0, 0x01CC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(DISP0_DAT23__ECSPI1_SS0,	0x04E0, 0x01CC, 2, 0x0800, 1, 0)
+MX6_PAD_DECL(DISP0_DAT23__AUD4_RXD,	0x04E0, 0x01CC, 3, 0x07B4, 1, 0)
+MX6_PAD_DECL(DISP0_DAT23__GPIO5_IO17,	0x04E0, 0x01CC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_MDIO__ENET_MDIO,	0x04E4, 0x01D0, 1, 0x0840, 0, 0)
+MX6_PAD_DECL(ENET_MDIO__ESAI_RX_CLK,	0x04E4, 0x01D0, 2, 0x086C, 0, 0)
+MX6_PAD_DECL(ENET_MDIO__ENET_1588_EVENT1_OUT,	0x04E4, 0x01D0, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_MDIO__GPIO1_IO22,	0x04E4, 0x01D0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_MDIO__SPDIF_LOCK,	0x04E4, 0x01D0, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_REF_CLK__ENET_TX_CLK,	0x04E8, 0x01D4, 1 | IOMUX_CONFIG_SION, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_REF_CLK__ESAI_RX_FS,	0x04E8, 0x01D4, 2, 0x085C, 0, 0)
+MX6_PAD_DECL(ENET_REF_CLK__GPIO1_IO23,	0x04E8, 0x01D4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_REF_CLK__SPDIF_SR_CLK,	0x04E8, 0x01D4, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_RX_ER__USB_OTG_ID,	0x04EC, 0x01D8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_RX_ER__ENET_RX_ER,	0x04EC, 0x01D8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_RX_ER__ESAI_RX_HF_CLK,	0x04EC, 0x01D8, 2, 0x0864, 0, 0)
+MX6_PAD_DECL(ENET_RX_ER__SPDIF_IN,	0x04EC, 0x01D8, 3, 0x0914, 1, 0)
+MX6_PAD_DECL(ENET_RX_ER__ENET_1588_EVENT2_OUT,	0x04EC, 0x01D8, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_RX_ER__GPIO1_IO24,	0x04EC, 0x01D8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_CRS_DV__ENET_RX_EN,	0x04F0, 0x01DC, 1, 0x0858, 1, 0)
+MX6_PAD_DECL(ENET_CRS_DV__ESAI_TX_CLK,	0x04F0, 0x01DC, 2, 0x0870, 0, 0)
+MX6_PAD_DECL(ENET_CRS_DV__SPDIF_EXT_CLK,	0x04F0, 0x01DC, 3, 0x0918, 1, 0)
+MX6_PAD_DECL(ENET_CRS_DV__GPIO1_IO25,	0x04F0, 0x01DC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_RXD1__MLB_SIG,	0x04F4, 0x01E0, 0, 0x0908, 0, 0)
+MX6_PAD_DECL(ENET_RXD1__ENET_RX_DATA1,	0x04F4, 0x01E0, 1, 0x084C, 1, 0)
+MX6_PAD_DECL(ENET_RXD1__ESAI_TX_FS,	0x04F4, 0x01E0, 2, 0x0860, 0, 0)
+MX6_PAD_DECL(ENET_RXD1__ENET_1588_EVENT3_OUT,	0x04F4, 0x01E0, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_RXD1__GPIO1_IO26,	0x04F4, 0x01E0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_RXD0__ENET_RX_DATA0,	0x04F8, 0x01E4, 1, 0x0848, 1, 0)
+MX6_PAD_DECL(ENET_RXD0__ESAI_TX_HF_CLK,	0x04F8, 0x01E4, 2, 0x0868, 0, 0)
+MX6_PAD_DECL(ENET_RXD0__SPDIF_OUT,	0x04F8, 0x01E4, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_RXD0__GPIO1_IO27,	0x04F8, 0x01E4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_TX_EN__ENET_TX_EN,	0x04FC, 0x01E8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_TX_EN__ESAI_TX3_RX2,	0x04FC, 0x01E8, 2, 0x0880, 0, 0)
+MX6_PAD_DECL(ENET_TX_EN__GPIO1_IO28,	0x04FC, 0x01E8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_TXD1__MLB_CLK,	0x0500, 0x01EC, 0, 0x0900, 0, 0)
+MX6_PAD_DECL(ENET_TXD1__ENET_TX_DATA1,	0x0500, 0x01EC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_TXD1__ESAI_TX2_RX3,	0x0500, 0x01EC, 2, 0x087C, 0, 0)
+MX6_PAD_DECL(ENET_TXD1__ENET_1588_EVENT0_IN,	0x0500, 0x01EC, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_TXD1__GPIO1_IO29,	0x0500, 0x01EC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_TXD0__ENET_TX_DATA0,	0x0504, 0x01F0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_TXD0__ESAI_TX4_RX1,	0x0504, 0x01F0, 2, 0x0884, 0, 0)
+MX6_PAD_DECL(ENET_TXD0__GPIO1_IO30,	0x0504, 0x01F0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_MDC__MLB_DATA,	0x0508, 0x01F4, 0, 0x0904, 0, 0)
+MX6_PAD_DECL(ENET_MDC__ENET_MDC,	0x0508, 0x01F4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_MDC__ESAI_TX5_RX0,	0x0508, 0x01F4, 2, 0x0888, 0, 0)
+MX6_PAD_DECL(ENET_MDC__ENET_1588_EVENT1_IN,	0x0508, 0x01F4, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(ENET_MDC__GPIO1_IO31,	0x0508, 0x01F4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL0__ECSPI1_SCLK,	0x05C8, 0x01F8, 0, 0x07F4, 2, 0)
+MX6_PAD_DECL(KEY_COL0__ENET_RX_DATA3,	0x05C8, 0x01F8, 1, 0x0854, 1, 0)
+MX6_PAD_DECL(KEY_COL0__AUD5_TXC,	0x05C8, 0x01F8, 2, 0x07DC, 1, 0)
+MX6_PAD_DECL(KEY_COL0__KEY_COL0,	0x05C8, 0x01F8, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL0__UART4_TX_DATA,	0x05C8, 0x01F8, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL0__UART4_RX_DATA,	0x05C8, 0x01F8, 4, 0x0938, 0, 0)
+MX6_PAD_DECL(KEY_COL0__GPIO4_IO06,	0x05C8, 0x01F8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL0__DCIC1_OUT,	0x05C8, 0x01F8, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW0__ECSPI1_MOSI,	0x05CC, 0x01FC, 0, 0x07FC, 2, 0)
+MX6_PAD_DECL(KEY_ROW0__ENET_TX_DATA3,	0x05CC, 0x01FC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW0__AUD5_TXD,	0x05CC, 0x01FC, 2, 0x07D0, 1, 0)
+MX6_PAD_DECL(KEY_ROW0__KEY_ROW0,	0x05CC, 0x01FC, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW0__UART4_TX_DATA,	0x05CC, 0x01FC, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW0__UART4_RX_DATA,	0x05CC, 0x01FC, 4, 0x0938, 1, 0)
+MX6_PAD_DECL(KEY_ROW0__GPIO4_IO07,	0x05CC, 0x01FC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW0__DCIC2_OUT,	0x05CC, 0x01FC, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL1__ECSPI1_MISO,	0x05D0, 0x0200, 0, 0x07F8, 2, 0)
+MX6_PAD_DECL(KEY_COL1__ENET_MDIO,	0x05D0, 0x0200, 1, 0x0840, 1, 0)
+MX6_PAD_DECL(KEY_COL1__AUD5_TXFS,	0x05D0, 0x0200, 2, 0x07E0, 1, 0)
+MX6_PAD_DECL(KEY_COL1__KEY_COL1,	0x05D0, 0x0200, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL1__UART5_TX_DATA,	0x05D0, 0x0200, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL1__UART5_RX_DATA,	0x05D0, 0x0200, 4, 0x0940, 0, 0)
+MX6_PAD_DECL(KEY_COL1__GPIO4_IO08,	0x05D0, 0x0200, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL1__SD1_VSELECT,	0x05D0, 0x0200, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW1__ECSPI1_SS0,	0x05D4, 0x0204, 0, 0x0800, 2, 0)
+MX6_PAD_DECL(KEY_ROW1__ENET_COL,	0x05D4, 0x0204, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW1__AUD5_RXD,	0x05D4, 0x0204, 2, 0x07CC, 1, 0)
+MX6_PAD_DECL(KEY_ROW1__KEY_ROW1,	0x05D4, 0x0204, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW1__UART5_TX_DATA,	0x05D4, 0x0204, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW1__UART5_RX_DATA,	0x05D4, 0x0204, 4, 0x0940, 1, 0)
+MX6_PAD_DECL(KEY_ROW1__GPIO4_IO09,	0x05D4, 0x0204, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW1__SD2_VSELECT,	0x05D4, 0x0204, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL2__ECSPI1_SS1,	0x05D8, 0x0208, 0, 0x0804, 2, 0)
+MX6_PAD_DECL(KEY_COL2__ENET_RX_DATA2,	0x05D8, 0x0208, 1, 0x0850, 1, 0)
+MX6_PAD_DECL(KEY_COL2__FLEXCAN1_TX,	0x05D8, 0x0208, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL2__KEY_COL2,	0x05D8, 0x0208, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL2__ENET_MDC,	0x05D8, 0x0208, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL2__GPIO4_IO10,	0x05D8, 0x0208, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL2__USB_H1_PWR_CTL_WAKE,	0x05D8, 0x0208, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW2__ECSPI1_SS2,	0x05DC, 0x020C, 0, 0x0808, 1, 0)
+MX6_PAD_DECL(KEY_ROW2__ENET_TX_DATA2,	0x05DC, 0x020C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW2__FLEXCAN1_RX,	0x05DC, 0x020C, 2, 0x07E4, 0, 0)
+MX6_PAD_DECL(KEY_ROW2__KEY_ROW2,	0x05DC, 0x020C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW2__SD2_VSELECT,	0x05DC, 0x020C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW2__GPIO4_IO11,	0x05DC, 0x020C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW2__HDMI_TX_CEC_LINE,	0x05DC, 0x020C, 6, 0x088C, 1, 0)
+MX6_PAD_DECL(KEY_COL3__ECSPI1_SS3,	0x05E0, 0x0210, 0, 0x080C, 1, 0)
+MX6_PAD_DECL(KEY_COL3__ENET_CRS,	0x05E0, 0x0210, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL3__HDMI_TX_DDC_SCL,	0x05E0, 0x0210, 2, 0x0890, 1, 0)
+MX6_PAD_DECL(KEY_COL3__KEY_COL3,	0x05E0, 0x0210, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL3__I2C2_SCL,	0x05E0, 0x0210, 20, 0x08A0, 1, 0)
+MX6_PAD_DECL(KEY_COL3__GPIO4_IO12,	0x05E0, 0x0210, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL3__SPDIF_IN,	0x05E0, 0x0210, 6, 0x0914, 2, 0)
+MX6_PAD_DECL(KEY_ROW3__ASRC_EXT_CLK,	0x05E4, 0x0214, 1, 0x07B0, 0, 0)
+MX6_PAD_DECL(KEY_ROW3__HDMI_TX_DDC_SDA,	0x05E4, 0x0214, 2, 0x0894, 1, 0)
+MX6_PAD_DECL(KEY_ROW3__KEY_ROW3,	0x05E4, 0x0214, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW3__I2C2_SDA,	0x05E4, 0x0214, 20, 0x08A4, 1, 0)
+MX6_PAD_DECL(KEY_ROW3__GPIO4_IO13,	0x05E4, 0x0214, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW3__SD1_VSELECT,	0x05E4, 0x0214, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL4__FLEXCAN2_TX,	0x05E8, 0x0218, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL4__IPU1_SISG4,	0x05E8, 0x0218, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL4__USB_OTG_OC,	0x05E8, 0x0218, 2, 0x0944, 1, 0)
+MX6_PAD_DECL(KEY_COL4__KEY_COL4,	0x05E8, 0x0218, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL4__UART5_CTS_B,	0x05E8, 0x0218, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_COL4__UART5_RTS_B,	0x05E8, 0x0218, 4, 0x093C, 0, 0)
+MX6_PAD_DECL(KEY_COL4__GPIO4_IO14,	0x05E8, 0x0218, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW4__FLEXCAN2_RX,	0x05EC, 0x021C, 0, 0x07E8, 0, 0)
+MX6_PAD_DECL(KEY_ROW4__IPU1_SISG5,	0x05EC, 0x021C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW4__USB_OTG_PWR,	0x05EC, 0x021C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW4__KEY_ROW4,	0x05EC, 0x021C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW4__UART5_CTS_B,	0x05EC, 0x021C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(KEY_ROW4__UART5_RTS_B,	0x05EC, 0x021C, 4, 0x093C, 1, 0)
+MX6_PAD_DECL(KEY_ROW4__GPIO4_IO15,	0x05EC, 0x021C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_0__CCM_CLKO1,	0x05F0, 0x0220, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_0__KEY_COL5,	0x05F0, 0x0220, 2, 0x08E8, 0, 0)
+MX6_PAD_DECL(GPIO_0__ASRC_EXT_CLK,	0x05F0, 0x0220, 3, 0x07B0, 1, 0)
+MX6_PAD_DECL(GPIO_0__EPIT1_OUT,	0x05F0, 0x0220, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_0__GPIO1_IO00,	0x05F0, 0x0220, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_0__USB_H1_PWR,	0x05F0, 0x0220, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_0__SNVS_VIO_5,	0x05F0, 0x0220, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_1__ESAI_RX_CLK,	0x05F4, 0x0224, 0, 0x086C, 1, 0)
+MX6_PAD_DECL(GPIO_1__WDOG2_B,	0x05F4, 0x0224, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_1__KEY_ROW5,	0x05F4, 0x0224, 2, 0x08F4, 0, 0)
+MX6_PAD_DECL(GPIO_1__USB_OTG_ID,	0x05F4, 0x0224, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_1__PWM2_OUT,	0x05F4, 0x0224, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_1__GPIO1_IO01,	0x05F4, 0x0224, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_1__SD1_CD_B,	0x05F4, 0x0224, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_9__ESAI_RX_FS,	0x05F8, 0x0228, 0, 0x085C, 1, 0)
+MX6_PAD_DECL(GPIO_9__WDOG1_B,	0x05F8, 0x0228, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_9__KEY_COL6,	0x05F8, 0x0228, 2, 0x08EC, 0, 0)
+MX6_PAD_DECL(GPIO_9__CCM_REF_EN_B,	0x05F8, 0x0228, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_9__PWM1_OUT,	0x05F8, 0x0228, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_9__GPIO1_IO09,	0x05F8, 0x0228, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_9__SD1_WP,	0x05F8, 0x0228, 6, 0x094C, 1, 0)
+MX6_PAD_DECL(GPIO_3__ESAI_RX_HF_CLK,	0x05FC, 0x022C, 0, 0x0864, 1, 0)
+MX6_PAD_DECL(GPIO_3__I2C3_SCL,	0x05FC, 0x022C, 18, 0x08A8, 1, 0)
+MX6_PAD_DECL(GPIO_3__XTALOSC_REF_CLK_24M,	0x05FC, 0x022C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_3__CCM_CLKO2,	0x05FC, 0x022C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_3__GPIO1_IO03,	0x05FC, 0x022C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_3__USB_H1_OC,	0x05FC, 0x022C, 6, 0x0948, 1, 0)
+MX6_PAD_DECL(GPIO_3__MLB_CLK,	0x05FC, 0x022C, 7, 0x0900, 1, 0)
+MX6_PAD_DECL(GPIO_6__ESAI_TX_CLK,	0x0600, 0x0230, 0, 0x0870, 1, 0)
+MX6_PAD_DECL(GPIO_6__I2C3_SDA,	0x0600, 0x0230, 18, 0x08AC, 1, 0)
+MX6_PAD_DECL(GPIO_6__GPIO1_IO06,	0x0600, 0x0230, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_6__SD2_LCTL,	0x0600, 0x0230, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_6__MLB_SIG,	0x0600, 0x0230, 7, 0x0908, 1, 0)
+MX6_PAD_DECL(GPIO_2__ESAI_TX_FS,	0x0604, 0x0234, 0, 0x0860, 1, 0)
+MX6_PAD_DECL(GPIO_2__KEY_ROW6,	0x0604, 0x0234, 2, 0x08F8, 1, 0)
+MX6_PAD_DECL(GPIO_2__GPIO1_IO02,	0x0604, 0x0234, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_2__SD2_WP,	0x0604, 0x0234, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_2__MLB_DATA,	0x0604, 0x0234, 7, 0x0904, 1, 0)
+MX6_PAD_DECL(GPIO_4__ESAI_TX_HF_CLK,	0x0608, 0x0238, 0, 0x0868, 1, 0)
+MX6_PAD_DECL(GPIO_4__KEY_COL7,	0x0608, 0x0238, 2, 0x08F0, 1, 0)
+MX6_PAD_DECL(GPIO_4__GPIO1_IO04,	0x0608, 0x0238, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_4__SD2_CD_B,	0x0608, 0x0238, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_5__ESAI_TX2_RX3,	0x060C, 0x023C, 0, 0x087C, 1, 0)
+MX6_PAD_DECL(GPIO_5__KEY_ROW7,	0x060C, 0x023C, 2, 0x08FC, 1, 0)
+MX6_PAD_DECL(GPIO_5__CCM_CLKO1,	0x060C, 0x023C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_5__GPIO1_IO05,	0x060C, 0x023C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_5__I2C3_SCL,	0x060C, 0x023C, 22, 0x08A8, 2, 0)
+MX6_PAD_DECL(GPIO_5__ARM_EVENTI,	0x060C, 0x023C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_7__ESAI_TX4_RX1,	0x0610, 0x0240, 0, 0x0884, 1, 0)
+MX6_PAD_DECL(GPIO_7__ECSPI5_RDY,	0x0610, 0x0240, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_7__EPIT1_OUT,	0x0610, 0x0240, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_7__FLEXCAN1_TX,	0x0610, 0x0240, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_7__UART2_TX_DATA,	0x0610, 0x0240, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_7__UART2_RX_DATA,	0x0610, 0x0240, 4, 0x0928, 2, 0)
+MX6_PAD_DECL(GPIO_7__GPIO1_IO07,	0x0610, 0x0240, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_7__SPDIF_LOCK,	0x0610, 0x0240, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_7__USB_OTG_HOST_MODE,	0x0610, 0x0240, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_8__ESAI_TX5_RX0,	0x0614, 0x0244, 0, 0x0888, 1, 0)
+MX6_PAD_DECL(GPIO_8__XTALOSC_REF_CLK_32K,	0x0614, 0x0244, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_8__EPIT2_OUT,	0x0614, 0x0244, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_8__FLEXCAN1_RX,	0x0614, 0x0244, 3, 0x07E4, 1, 0)
+MX6_PAD_DECL(GPIO_8__UART2_TX_DATA,	0x0614, 0x0244, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_8__UART2_RX_DATA,	0x0614, 0x0244, 4, 0x0928, 3, 0)
+MX6_PAD_DECL(GPIO_8__GPIO1_IO08,	0x0614, 0x0244, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_8__SPDIF_SR_CLK,	0x0614, 0x0244, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_8__USB_OTG_PWR_CTL_WAKE,	0x0614, 0x0244, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_16__ESAI_TX3_RX2,	0x0618, 0x0248, 0, 0x0880, 1, 0)
+MX6_PAD_DECL(GPIO_16__ENET_1588_EVENT2_IN,	0x0618, 0x0248, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_16__ENET_REF_CLK,	0x0618, 0x0248, 2 | IOMUX_CONFIG_SION, 0x083C, 1, 0)
+MX6_PAD_DECL(GPIO_16__SD1_LCTL,	0x0618, 0x0248, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_16__SPDIF_IN,	0x0618, 0x0248, 4, 0x0914, 3, 0)
+MX6_PAD_DECL(GPIO_16__GPIO7_IO11,	0x0618, 0x0248, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_16__I2C3_SDA,	0x0618, 0x0248, 22, 0x08AC, 2, 0)
+MX6_PAD_DECL(GPIO_16__JTAG_DE_B,	0x0618, 0x0248, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_17__ESAI_TX0,	0x061C, 0x024C, 0, 0x0874, 0, 0)
+MX6_PAD_DECL(GPIO_17__ENET_1588_EVENT3_IN,	0x061C, 0x024C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_17__CCM_PMIC_READY,	0x061C, 0x024C, 2, 0x07F0, 1, 0)
+MX6_PAD_DECL(GPIO_17__SDMA_EXT_EVENT0,	0x061C, 0x024C, 3, 0x090C, 1, 0)
+MX6_PAD_DECL(GPIO_17__SPDIF_OUT,	0x061C, 0x024C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_17__GPIO7_IO12,	0x061C, 0x024C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_18__ESAI_TX1,	0x0620, 0x0250, 0, 0x0878, 0, 0)
+MX6_PAD_DECL(GPIO_18__ENET_RX_CLK,	0x0620, 0x0250, 1, 0x0844, 1, 0)
+MX6_PAD_DECL(GPIO_18__SD3_VSELECT,	0x0620, 0x0250, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_18__SDMA_EXT_EVENT1,	0x0620, 0x0250, 3, 0x0910, 1, 0)
+MX6_PAD_DECL(GPIO_18__ASRC_EXT_CLK,	0x0620, 0x0250, 4, 0x07B0, 2, 0)
+MX6_PAD_DECL(GPIO_18__GPIO7_IO13,	0x0620, 0x0250, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_18__SNVS_VIO_5_CTL,	0x0620, 0x0250, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_19__KEY_COL5,	0x0624, 0x0254, 0, 0x08E8, 1, 0)
+MX6_PAD_DECL(GPIO_19__ENET_1588_EVENT0_OUT,	0x0624, 0x0254, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_19__SPDIF_OUT,	0x0624, 0x0254, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_19__CCM_CLKO1,	0x0624, 0x0254, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_19__ECSPI1_RDY,	0x0624, 0x0254, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_19__GPIO4_IO05,	0x0624, 0x0254, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(GPIO_19__ENET_TX_ER,	0x0624, 0x0254, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_PIXCLK__IPU1_CSI0_PIXCLK,	0x0628, 0x0258, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_PIXCLK__GPIO5_IO18,	0x0628, 0x0258, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_PIXCLK__ARM_EVENTO,	0x0628, 0x0258, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_MCLK__IPU1_CSI0_HSYNC,	0x062C, 0x025C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_MCLK__CCM_CLKO1,	0x062C, 0x025C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_MCLK__GPIO5_IO19,	0x062C, 0x025C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_MCLK__ARM_TRACE_CTL,	0x062C, 0x025C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DATA_EN__IPU1_CSI0_DATA_EN,	0x0630, 0x0260, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DATA_EN__EIM_DATA00,	0x0630, 0x0260, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DATA_EN__GPIO5_IO20,	0x0630, 0x0260, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DATA_EN__ARM_TRACE_CLK,	0x0630, 0x0260, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_VSYNC__IPU1_CSI0_VSYNC,	0x0634, 0x0264, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_VSYNC__EIM_DATA01,	0x0634, 0x0264, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_VSYNC__GPIO5_IO21,	0x0634, 0x0264, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_VSYNC__ARM_TRACE00,	0x0634, 0x0264, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT4__IPU1_CSI0_DATA04,	0x0638, 0x0268, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT4__EIM_DATA02,	0x0638, 0x0268, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT4__ECSPI1_SCLK,	0x0638, 0x0268, 2, 0x07F4, 3, 0)
+MX6_PAD_DECL(CSI0_DAT4__KEY_COL5,	0x0638, 0x0268, 3, 0x08E8, 2, 0)
+MX6_PAD_DECL(CSI0_DAT4__AUD3_TXC,	0x0638, 0x0268, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT4__GPIO5_IO22,	0x0638, 0x0268, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT4__ARM_TRACE01,	0x0638, 0x0268, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT5__IPU1_CSI0_DATA05,	0x063C, 0x026C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT5__EIM_DATA03,	0x063C, 0x026C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT5__ECSPI1_MOSI,	0x063C, 0x026C, 2, 0x07FC, 3, 0)
+MX6_PAD_DECL(CSI0_DAT5__KEY_ROW5,	0x063C, 0x026C, 3, 0x08F4, 1, 0)
+MX6_PAD_DECL(CSI0_DAT5__AUD3_TXD,	0x063C, 0x026C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT5__GPIO5_IO23,	0x063C, 0x026C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT5__ARM_TRACE02,	0x063C, 0x026C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT6__IPU1_CSI0_DATA06,	0x0640, 0x0270, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT6__EIM_DATA04,	0x0640, 0x0270, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT6__ECSPI1_MISO,	0x0640, 0x0270, 2, 0x07F8, 3, 0)
+MX6_PAD_DECL(CSI0_DAT6__KEY_COL6,	0x0640, 0x0270, 3, 0x08EC, 1, 0)
+MX6_PAD_DECL(CSI0_DAT6__AUD3_TXFS,	0x0640, 0x0270, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT6__GPIO5_IO24,	0x0640, 0x0270, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT6__ARM_TRACE03,	0x0640, 0x0270, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT7__IPU1_CSI0_DATA07,	0x0644, 0x0274, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT7__EIM_DATA05,	0x0644, 0x0274, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT7__ECSPI1_SS0,	0x0644, 0x0274, 2, 0x0800, 3, 0)
+MX6_PAD_DECL(CSI0_DAT7__KEY_ROW6,	0x0644, 0x0274, 3, 0x08F8, 2, 0)
+MX6_PAD_DECL(CSI0_DAT7__AUD3_RXD,	0x0644, 0x0274, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT7__GPIO5_IO25,	0x0644, 0x0274, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT7__ARM_TRACE04,	0x0644, 0x0274, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT8__IPU1_CSI0_DATA08,	0x0648, 0x0278, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT8__EIM_DATA06,	0x0648, 0x0278, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT8__ECSPI2_SCLK,	0x0648, 0x0278, 2, 0x0810, 2, 0)
+MX6_PAD_DECL(CSI0_DAT8__KEY_COL7,	0x0648, 0x0278, 3, 0x08F0, 2, 0)
+MX6_PAD_DECL(CSI0_DAT8__I2C1_SDA,	0x0648, 0x0278, 20, 0x089C, 1, 0)
+MX6_PAD_DECL(CSI0_DAT8__GPIO5_IO26,	0x0648, 0x0278, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT8__ARM_TRACE05,	0x0648, 0x0278, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT9__IPU1_CSI0_DATA09,	0x064C, 0x027C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT9__EIM_DATA07,	0x064C, 0x027C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT9__ECSPI2_MOSI,	0x064C, 0x027C, 2, 0x0818, 2, 0)
+MX6_PAD_DECL(CSI0_DAT9__KEY_ROW7,	0x064C, 0x027C, 3, 0x08FC, 2, 0)
+MX6_PAD_DECL(CSI0_DAT9__I2C1_SCL,	0x064C, 0x027C, 20, 0x0898, 1, 0)
+MX6_PAD_DECL(CSI0_DAT9__GPIO5_IO27,	0x064C, 0x027C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT9__ARM_TRACE06,	0x064C, 0x027C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT10__IPU1_CSI0_DATA10,	0x0650, 0x0280, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT10__AUD3_RXC,	0x0650, 0x0280, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT10__ECSPI2_MISO,	0x0650, 0x0280, 2, 0x0814, 2, 0)
+MX6_PAD_DECL(CSI0_DAT10__UART1_TX_DATA,	0x0650, 0x0280, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT10__UART1_RX_DATA,	0x0650, 0x0280, 3, 0x0920, 0, 0)
+MX6_PAD_DECL(CSI0_DAT10__GPIO5_IO28,	0x0650, 0x0280, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT10__ARM_TRACE07,	0x0650, 0x0280, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT11__IPU1_CSI0_DATA11,	0x0654, 0x0284, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT11__AUD3_RXFS,	0x0654, 0x0284, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT11__ECSPI2_SS0,	0x0654, 0x0284, 2, 0x081C, 2, 0)
+MX6_PAD_DECL(CSI0_DAT11__UART1_TX_DATA,	0x0654, 0x0284, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT11__UART1_RX_DATA,	0x0654, 0x0284, 3, 0x0920, 1, 0)
+MX6_PAD_DECL(CSI0_DAT11__GPIO5_IO29,	0x0654, 0x0284, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT11__ARM_TRACE08,	0x0654, 0x0284, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT12__IPU1_CSI0_DATA12,	0x0658, 0x0288, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT12__EIM_DATA08,	0x0658, 0x0288, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT12__UART4_TX_DATA,	0x0658, 0x0288, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT12__UART4_RX_DATA,	0x0658, 0x0288, 3, 0x0938, 2, 0)
+MX6_PAD_DECL(CSI0_DAT12__GPIO5_IO30,	0x0658, 0x0288, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT12__ARM_TRACE09,	0x0658, 0x0288, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT13__IPU1_CSI0_DATA13,	0x065C, 0x028C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT13__EIM_DATA09,	0x065C, 0x028C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT13__UART4_TX_DATA,	0x065C, 0x028C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT13__UART4_RX_DATA,	0x065C, 0x028C, 3, 0x0938, 3, 0)
+MX6_PAD_DECL(CSI0_DAT13__GPIO5_IO31,	0x065C, 0x028C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT13__ARM_TRACE10,	0x065C, 0x028C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT14__IPU1_CSI0_DATA14,	0x0660, 0x0290, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT14__EIM_DATA10,	0x0660, 0x0290, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT14__UART5_TX_DATA,	0x0660, 0x0290, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT14__UART5_RX_DATA,	0x0660, 0x0290, 3, 0x0940, 2, 0)
+MX6_PAD_DECL(CSI0_DAT14__GPIO6_IO00,	0x0660, 0x0290, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT14__ARM_TRACE11,	0x0660, 0x0290, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT15__IPU1_CSI0_DATA15,	0x0664, 0x0294, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT15__EIM_DATA11,	0x0664, 0x0294, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT15__UART5_TX_DATA,	0x0664, 0x0294, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT15__UART5_RX_DATA,	0x0664, 0x0294, 3, 0x0940, 3, 0)
+MX6_PAD_DECL(CSI0_DAT15__GPIO6_IO01,	0x0664, 0x0294, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT15__ARM_TRACE12,	0x0664, 0x0294, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT16__IPU1_CSI0_DATA16,	0x0668, 0x0298, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT16__EIM_DATA12,	0x0668, 0x0298, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT16__UART4_CTS_B,	0x0668, 0x0298, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT16__UART4_RTS_B,	0x0668, 0x0298, 3, 0x0934, 0, 0)
+MX6_PAD_DECL(CSI0_DAT16__GPIO6_IO02,	0x0668, 0x0298, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT16__ARM_TRACE13,	0x0668, 0x0298, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT17__IPU1_CSI0_DATA17,	0x066C, 0x029C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT17__EIM_DATA13,	0x066C, 0x029C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT17__UART4_CTS_B,	0x066C, 0x029C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT17__UART4_RTS_B,	0x066C, 0x029C, 3, 0x0934, 1, 0)
+MX6_PAD_DECL(CSI0_DAT17__GPIO6_IO03,	0x066C, 0x029C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT17__ARM_TRACE14,	0x066C, 0x029C, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT18__IPU1_CSI0_DATA18,	0x0670, 0x02A0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT18__EIM_DATA14,	0x0670, 0x02A0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT18__UART5_CTS_B,	0x0670, 0x02A0, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT18__UART5_RTS_B,	0x0670, 0x02A0, 3, 0x093C, 2, 0)
+MX6_PAD_DECL(CSI0_DAT18__GPIO6_IO04,	0x0670, 0x02A0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT18__ARM_TRACE15,	0x0670, 0x02A0, 7, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT19__IPU1_CSI0_DATA19,	0x0674, 0x02A4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT19__EIM_DATA15,	0x0674, 0x02A4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT19__UART5_CTS_B,	0x0674, 0x02A4, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(CSI0_DAT19__UART5_RTS_B,	0x0674, 0x02A4, 3, 0x093C, 3, 0)
+MX6_PAD_DECL(CSI0_DAT19__GPIO6_IO05,	0x0674, 0x02A4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT7__SD3_DATA7,	0x0690, 0x02A8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT7__UART1_TX_DATA,	0x0690, 0x02A8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT7__UART1_RX_DATA,	0x0690, 0x02A8, 1, 0x0920, 2, 0)
+MX6_PAD_DECL(SD3_DAT7__GPIO6_IO17,	0x0690, 0x02A8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT6__SD3_DATA6,	0x0694, 0x02AC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT6__UART1_TX_DATA,	0x0694, 0x02AC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT6__UART1_RX_DATA,	0x0694, 0x02AC, 1, 0x0920, 3, 0)
+MX6_PAD_DECL(SD3_DAT6__GPIO6_IO18,	0x0694, 0x02AC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT5__SD3_DATA5,	0x0698, 0x02B0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT5__UART2_TX_DATA,	0x0698, 0x02B0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT5__UART2_RX_DATA,	0x0698, 0x02B0, 1, 0x0928, 4, 0)
+MX6_PAD_DECL(SD3_DAT5__GPIO7_IO00,	0x0698, 0x02B0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT4__SD3_DATA4,	0x069C, 0x02B4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT4__UART2_TX_DATA,	0x069C, 0x02B4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT4__UART2_RX_DATA,	0x069C, 0x02B4, 1, 0x0928, 5, 0)
+MX6_PAD_DECL(SD3_DAT4__GPIO7_IO01,	0x069C, 0x02B4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_CMD__SD3_CMD,	0x06A0, 0x02B8, 16, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_CMD__UART2_CTS_B,	0x06A0, 0x02B8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_CMD__UART2_RTS_B,	0x06A0, 0x02B8, 1, 0x0924, 2, 0)
+MX6_PAD_DECL(SD3_CMD__FLEXCAN1_TX,	0x06A0, 0x02B8, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_CMD__GPIO7_IO02,	0x06A0, 0x02B8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_CLK__SD3_CLK,	0x06A4, 0x02BC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_CLK__UART2_CTS_B,	0x06A4, 0x02BC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_CLK__UART2_RTS_B,	0x06A4, 0x02BC, 1, 0x0924, 3, 0)
+MX6_PAD_DECL(SD3_CLK__FLEXCAN1_RX,	0x06A4, 0x02BC, 2, 0x07E4, 2, 0)
+MX6_PAD_DECL(SD3_CLK__GPIO7_IO03,	0x06A4, 0x02BC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT0__SD3_DATA0,	0x06A8, 0x02C0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT0__UART1_CTS_B,	0x06A8, 0x02C0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT0__UART1_RTS_B,	0x06A8, 0x02C0, 1, 0x091C, 2, 0)
+MX6_PAD_DECL(SD3_DAT0__FLEXCAN2_TX,	0x06A8, 0x02C0, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT0__GPIO7_IO04,	0x06A8, 0x02C0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT1__SD3_DATA1,	0x06AC, 0x02C4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT1__UART1_CTS_B,	0x06AC, 0x02C4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT1__UART1_RTS_B,	0x06AC, 0x02C4, 1, 0x091C, 3, 0)
+MX6_PAD_DECL(SD3_DAT1__FLEXCAN2_RX,	0x06AC, 0x02C4, 2, 0x07E8, 1, 0)
+MX6_PAD_DECL(SD3_DAT1__GPIO7_IO05,	0x06AC, 0x02C4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT2__SD3_DATA2,	0x06B0, 0x02C8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT2__GPIO7_IO06,	0x06B0, 0x02C8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT3__SD3_DATA3,	0x06B4, 0x02CC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT3__UART3_CTS_B,	0x06B4, 0x02CC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_DAT3__UART3_RTS_B,	0x06B4, 0x02CC, 1, 0x092C, 4, 0)
+MX6_PAD_DECL(SD3_DAT3__GPIO7_IO07,	0x06B4, 0x02CC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_RST__SD3_RESET,	0x06B8, 0x02D0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_RST__UART3_CTS_B,	0x06B8, 0x02D0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD3_RST__UART3_RTS_B,	0x06B8, 0x02D0, 1, 0x092C, 5, 0)
+MX6_PAD_DECL(SD3_RST__GPIO7_IO08,	0x06B8, 0x02D0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CLE__NAND_CLE,	0x06BC, 0x02D4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CLE__IPU2_SISG4,	0x06BC, 0x02D4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CLE__GPIO6_IO07,	0x06BC, 0x02D4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_ALE__NAND_ALE,	0x06C0, 0x02D8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_ALE__SD4_RESET,	0x06C0, 0x02D8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_ALE__GPIO6_IO08,	0x06C0, 0x02D8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_WP_B__NAND_WP_B,	0x06C4, 0x02DC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_WP_B__IPU2_SISG5,	0x06C4, 0x02DC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_WP_B__GPIO6_IO09,	0x06C4, 0x02DC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_RB0__NAND_READY_B,	0x06C8, 0x02E0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_RB0__IPU2_DI0_PIN01,	0x06C8, 0x02E0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_RB0__GPIO6_IO10,	0x06C8, 0x02E0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS0__NAND_CE0_B,	0x06CC, 0x02E4, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS0__GPIO6_IO11,	0x06CC, 0x02E4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS1__NAND_CE1_B,	0x06D0, 0x02E8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS1__SD4_VSELECT,	0x06D0, 0x02E8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS1__SD3_VSELECT,	0x06D0, 0x02E8, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS1__GPIO6_IO14,	0x06D0, 0x02E8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS2__NAND_CE2_B,	0x06D4, 0x02EC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS2__IPU1_SISG0,	0x06D4, 0x02EC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS2__ESAI_TX0,	0x06D4, 0x02EC, 2, 0x0874, 1, 0)
+MX6_PAD_DECL(NANDF_CS2__EIM_CRE,	0x06D4, 0x02EC, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS2__CCM_CLKO2,	0x06D4, 0x02EC, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS2__GPIO6_IO15,	0x06D4, 0x02EC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS2__IPU2_SISG0,	0x06D4, 0x02EC, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS3__NAND_CE3_B,	0x06D8, 0x02F0, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS3__IPU1_SISG1,	0x06D8, 0x02F0, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS3__ESAI_TX1,	0x06D8, 0x02F0, 2, 0x0878, 1, 0)
+MX6_PAD_DECL(NANDF_CS3__EIM_ADDR26,	0x06D8, 0x02F0, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS3__GPIO6_IO16,	0x06D8, 0x02F0, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_CS3__IPU2_SISG1,	0x06D8, 0x02F0, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_CMD__SD4_CMD,	0x06DC, 0x02F4, 16, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_CMD__NAND_RE_B,	0x06DC, 0x02F4, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_CMD__UART3_TX_DATA,	0x06DC, 0x02F4, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_CMD__UART3_RX_DATA,	0x06DC, 0x02F4, 2, 0x0930, 2, 0)
+MX6_PAD_DECL(SD4_CMD__GPIO7_IO09,	0x06DC, 0x02F4, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_CLK__SD4_CLK,	0x06E0, 0x02F8, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_CLK__NAND_WE_B,	0x06E0, 0x02F8, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_CLK__UART3_TX_DATA,	0x06E0, 0x02F8, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_CLK__UART3_RX_DATA,	0x06E0, 0x02F8, 2, 0x0930, 3, 0)
+MX6_PAD_DECL(SD4_CLK__GPIO7_IO10,	0x06E0, 0x02F8, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D0__NAND_DATA00,	0x06E4, 0x02FC, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D0__SD1_DATA4,	0x06E4, 0x02FC, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D0__GPIO2_IO00,	0x06E4, 0x02FC, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D1__NAND_DATA01,	0x06E8, 0x0300, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D1__SD1_DATA5,	0x06E8, 0x0300, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D1__GPIO2_IO01,	0x06E8, 0x0300, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D2__NAND_DATA02,	0x06EC, 0x0304, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D2__SD1_DATA6,	0x06EC, 0x0304, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D2__GPIO2_IO02,	0x06EC, 0x0304, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D3__NAND_DATA03,	0x06F0, 0x0308, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D3__SD1_DATA7,	0x06F0, 0x0308, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D3__GPIO2_IO03,	0x06F0, 0x0308, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D4__NAND_DATA04,	0x06F4, 0x030C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D4__SD2_DATA4,	0x06F4, 0x030C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D4__GPIO2_IO04,	0x06F4, 0x030C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D5__NAND_DATA05,	0x06F8, 0x0310, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D5__SD2_DATA5,	0x06F8, 0x0310, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D5__GPIO2_IO05,	0x06F8, 0x0310, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D6__NAND_DATA06,	0x06FC, 0x0314, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D6__SD2_DATA6,	0x06FC, 0x0314, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D6__GPIO2_IO06,	0x06FC, 0x0314, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D7__NAND_DATA07,	0x0700, 0x0318, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D7__SD2_DATA7,	0x0700, 0x0318, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(NANDF_D7__GPIO2_IO07,	0x0700, 0x0318, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT0__SD4_DATA0,	0x0704, 0x031C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT0__NAND_DQS,	0x0704, 0x031C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT0__GPIO2_IO08,	0x0704, 0x031C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT1__SD4_DATA1,	0x0708, 0x0320, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT1__PWM3_OUT,	0x0708, 0x0320, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT1__GPIO2_IO09,	0x0708, 0x0320, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT2__SD4_DATA2,	0x070C, 0x0324, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT2__PWM4_OUT,	0x070C, 0x0324, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT2__GPIO2_IO10,	0x070C, 0x0324, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT3__SD4_DATA3,	0x0710, 0x0328, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT3__GPIO2_IO11,	0x0710, 0x0328, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT4__SD4_DATA4,	0x0714, 0x032C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT4__UART2_TX_DATA,	0x0714, 0x032C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT4__UART2_RX_DATA,	0x0714, 0x032C, 2, 0x0928, 6, 0)
+MX6_PAD_DECL(SD4_DAT4__GPIO2_IO12,	0x0714, 0x032C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT5__SD4_DATA5,	0x0718, 0x0330, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT5__UART2_CTS_B,	0x0718, 0x0330, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT5__UART2_RTS_B,	0x0718, 0x0330, 2, 0x0924, 4, 0)
+MX6_PAD_DECL(SD4_DAT5__GPIO2_IO13,	0x0718, 0x0330, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT6__SD4_DATA6,	0x071C, 0x0334, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT6__UART2_CTS_B,	0x071C, 0x0334, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT6__UART2_RTS_B,	0x071C, 0x0334, 2, 0x0924, 5, 0)
+MX6_PAD_DECL(SD4_DAT6__GPIO2_IO14,	0x071C, 0x0334, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT7__SD4_DATA7,	0x0720, 0x0338, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT7__UART2_TX_DATA,	0x0720, 0x0338, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD4_DAT7__UART2_RX_DATA,	0x0720, 0x0338, 2, 0x0928, 7, 0)
+MX6_PAD_DECL(SD4_DAT7__GPIO2_IO15,	0x0720, 0x0338, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT1__SD1_DATA1,	0x0724, 0x033C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT1__ECSPI5_SS0,	0x0724, 0x033C, 1, 0x0834, 1, 0)
+MX6_PAD_DECL(SD1_DAT1__PWM3_OUT,	0x0724, 0x033C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT1__GPT_CAPTURE2,	0x0724, 0x033C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT1__GPIO1_IO17,	0x0724, 0x033C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT0__SD1_DATA0,	0x0728, 0x0340, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT0__ECSPI5_MISO,	0x0728, 0x0340, 1, 0x082C, 1, 0)
+MX6_PAD_DECL(SD1_DAT0__GPT_CAPTURE1,	0x0728, 0x0340, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT0__GPIO1_IO16,	0x0728, 0x0340, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT3__SD1_DATA3,	0x072C, 0x0344, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT3__ECSPI5_SS2,	0x072C, 0x0344, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT3__GPT_COMPARE3,	0x072C, 0x0344, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT3__PWM1_OUT,	0x072C, 0x0344, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT3__WDOG2_B,	0x072C, 0x0344, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT3__GPIO1_IO21,	0x072C, 0x0344, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT3__WDOG2_RESET_B_DEB,	0x072C, 0x0344, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_CMD__SD1_CMD,	0x0730, 0x0348, 16, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_CMD__ECSPI5_MOSI,	0x0730, 0x0348, 1, 0x0830, 0, 0)
+MX6_PAD_DECL(SD1_CMD__PWM4_OUT,	0x0730, 0x0348, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_CMD__GPT_COMPARE1,	0x0730, 0x0348, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_CMD__GPIO1_IO18,	0x0730, 0x0348, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT2__SD1_DATA2,	0x0734, 0x034C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT2__ECSPI5_SS1,	0x0734, 0x034C, 1, 0x0838, 1, 0)
+MX6_PAD_DECL(SD1_DAT2__GPT_COMPARE2,	0x0734, 0x034C, 2, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT2__PWM2_OUT,	0x0734, 0x034C, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT2__WDOG1_B,	0x0734, 0x034C, 4, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT2__GPIO1_IO19,	0x0734, 0x034C, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_DAT2__WDOG1_RESET_B_DEB,	0x0734, 0x034C, 6, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_CLK__SD1_CLK,	0x0738, 0x0350, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_CLK__ECSPI5_SCLK,	0x0738, 0x0350, 1, 0x0828, 0, 0)
+MX6_PAD_DECL(SD1_CLK__GPT_CLKIN,	0x0738, 0x0350, 3, 0x0000, 0, 0)
+MX6_PAD_DECL(SD1_CLK__GPIO1_IO20,	0x0738, 0x0350, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_CLK__SD2_CLK,	0x073C, 0x0354, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_CLK__ECSPI5_SCLK,	0x073C, 0x0354, 1, 0x0828, 1, 0)
+MX6_PAD_DECL(SD2_CLK__KEY_COL5,	0x073C, 0x0354, 2, 0x08E8, 3, 0)
+MX6_PAD_DECL(SD2_CLK__AUD4_RXFS,	0x073C, 0x0354, 3, 0x07C0, 1, 0)
+MX6_PAD_DECL(SD2_CLK__GPIO1_IO10,	0x073C, 0x0354, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_CMD__SD2_CMD,	0x0740, 0x0358, 16, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_CMD__ECSPI5_MOSI,	0x0740, 0x0358, 1, 0x0830, 1, 0)
+MX6_PAD_DECL(SD2_CMD__KEY_ROW5,	0x0740, 0x0358, 2, 0x08F4, 2, 0)
+MX6_PAD_DECL(SD2_CMD__AUD4_RXC,	0x0740, 0x0358, 3, 0x07BC, 1, 0)
+MX6_PAD_DECL(SD2_CMD__GPIO1_IO11,	0x0740, 0x0358, 5, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT3__SD2_DATA3,	0x0744, 0x035C, 0, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT3__ECSPI5_SS3,	0x0744, 0x035C, 1, 0x0000, 0, 0)
+MX6_PAD_DECL(SD2_DAT3__KEY_COL6,	0x0744, 0x035C, 2, 0x08EC, 2, 0)
+MX6_PAD_DECL(SD2_DAT3__AUD4_TXC,	0x0744, 0x035C, 3, 0x07C4, 1, 0)
+MX6_PAD_DECL(SD2_DAT3__GPIO1_IO12,	0x0744, 0x035C, 5, 0x0000, 0, 0)
+
+#endif	/* __ASM_ARCH_MX6_MX6Q_PINS_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6sl-ddr.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6sl-ddr.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6sl-ddr.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6sl-ddr.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_MX6SL_DDR_H__
+#define __ASM_ARCH_MX6SL_DDR_H__
+
+#ifndef CONFIG_MX6SL
+#error "wrong CPU"
+#endif
+
+#define MX6_IOM_DRAM_CAS_B	0x020e0300
+#define MX6_IOM_DRAM_CS0_B	0x020e0304
+#define MX6_IOM_DRAM_CS1_B	0x020e0308
+
+#define MX6_IOM_DRAM_DQM0	0x020e030c
+#define MX6_IOM_DRAM_DQM1	0x020e0310
+#define MX6_IOM_DRAM_DQM2	0x020e0314
+#define MX6_IOM_DRAM_DQM3	0x020e0318
+
+#define MX6_IOM_DRAM_RAS_B	0x020e031c
+#define MX6_IOM_DRAM_RESET	0x020e0320
+
+#define MX6_IOM_DRAM_SDBA0	0x020e0324
+#define MX6_IOM_DRAM_SDBA1	0x020e0328
+#define MX6_IOM_DRAM_SDBA2	0x020e032c
+
+#define MX6_IOM_DRAM_SDCKE0	0x020e0330
+#define MX6_IOM_DRAM_SDCKE1	0x020e0334
+
+#define MX6_IOM_DRAM_SDCLK0_P	0x020e0338
+
+#define MX6_IOM_DRAM_ODT0	0x020e033c
+#define MX6_IOM_DRAM_ODT1	0x020e0340
+
+#define MX6_IOM_DRAM_SDQS0_P	0x020e0344
+#define MX6_IOM_DRAM_SDQS1_P	0x020e0348
+#define MX6_IOM_DRAM_SDQS2_P	0x020e034c
+#define MX6_IOM_DRAM_SDQS3_P	0x020e0350
+
+#define MX6_IOM_DRAM_SDWE_B	0x020e0354
+
+#endif /*__ASM_ARCH_MX6SL_DDR_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6sll_pins.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6sll_pins.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6sll_pins.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6sll_pins.h	2021-04-16 14:42:14.692580786 +0800
@@ -0,0 +1,1019 @@
+/*
+ * Copyright (C) 2014 - 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_IMX6SLL_PINS_H__
+#define __ASM_ARCH_IMX6SLL_PINS_H__
+
+#include <asm/imx-common/iomux-v3.h>
+
+enum {
+	MX6_PAD_WDOG_B__WDOG1_B                               = IOMUX_PAD(0x02DC, 0x0014, 0, 0x0000, 0, 0),
+	MX6_PAD_WDOG_B__WDOG1_RESET_B_DEB                     = IOMUX_PAD(0x02DC, 0x0014, 1, 0x0000, 0, 0),
+	MX6_PAD_WDOG_B__UART5_RI_B                            = IOMUX_PAD(0x02DC, 0x0014, 2, 0x0000, 0, 0),
+	MX6_PAD_WDOG_B__GPIO3_IO18                            = IOMUX_PAD(0x02DC, 0x0014, 5, 0x0000, 0, 0),
+
+	MX6_PAD_REF_CLK_24M__XTALOSC_REF_CLK_24M              = IOMUX_PAD(0x02E0, 0x0018, 0, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_24M__I2C3_SCL                         = IOMUX_PAD(0x02E0, 0x0018, IOMUX_CONFIG_SION | 1, 0x068C, 0, 0),
+	MX6_PAD_REF_CLK_24M__PWM3_OUT                         = IOMUX_PAD(0x02E0, 0x0018, 2, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_24M__USB_OTG2_ID                      = IOMUX_PAD(0x02E0, 0x0018, 3, 0x0560, 0, 0),
+	MX6_PAD_REF_CLK_24M__CCM_PMIC_READY                   = IOMUX_PAD(0x02E0, 0x0018, 4, 0x05AC, 0, 0),
+	MX6_PAD_REF_CLK_24M__GPIO3_IO21                       = IOMUX_PAD(0x02E0, 0x0018, 5, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_24M__SD3_WP                           = IOMUX_PAD(0x02E0, 0x0018, 6, 0x0794, 0, 0),
+
+	MX6_PAD_REF_CLK_32K__XTALOSC_REF_CLK_32K              = IOMUX_PAD(0x02E4, 0x001C, 0, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_32K__I2C3_SDA                         = IOMUX_PAD(0x02E4, 0x001C, IOMUX_CONFIG_SION | 1, 0x0690, 0, 0),
+	MX6_PAD_REF_CLK_32K__PWM4_OUT                         = IOMUX_PAD(0x02E4, 0x001C, 2, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_32K__USB_OTG1_ID                      = IOMUX_PAD(0x02E4, 0x001C, 3, 0x055C, 0, 0),
+	MX6_PAD_REF_CLK_32K__SD1_LCTL                         = IOMUX_PAD(0x02E4, 0x001C, 4, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_32K__GPIO3_IO22                       = IOMUX_PAD(0x02E4, 0x001C, 5, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_32K__SD3_CD_B                         = IOMUX_PAD(0x02E4, 0x001C, 6, 0x0780, 0, 0),
+
+	MX6_PAD_PWM1__PWM1_OUT                                = IOMUX_PAD(0x02E8, 0x0020, 0, 0x0000, 0, 0),
+	MX6_PAD_PWM1__CCM_CLKO                                = IOMUX_PAD(0x02E8, 0x0020, 1, 0x0000, 0, 0),
+	MX6_PAD_PWM1__AUDIO_CLK_OUT                           = IOMUX_PAD(0x02E8, 0x0020, 2, 0x0000, 0, 0),
+	MX6_PAD_PWM1__CSI_MCLK                                = IOMUX_PAD(0x02E8, 0x0020, 4, 0x0000, 0, 0),
+	MX6_PAD_PWM1__GPIO3_IO23                              = IOMUX_PAD(0x02E8, 0x0020, 5, 0x0000, 0, 0),
+	MX6_PAD_PWM1__EPIT1_OUT                               = IOMUX_PAD(0x02E8, 0x0020, 6, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_COL0__KEY_COL0                            = IOMUX_PAD(0x02EC, 0x0024, 0, 0x06A0, 0, 0),
+	MX6_PAD_KEY_COL0__I2C2_SCL                            = IOMUX_PAD(0x02EC, 0x0024, IOMUX_CONFIG_SION | 1, 0x0684, 0, 0),
+	MX6_PAD_KEY_COL0__LCD_DATA00                          = IOMUX_PAD(0x02EC, 0x0024, 2, 0x06D8, 0, 0),
+	MX6_PAD_KEY_COL0__SD1_CD_B                            = IOMUX_PAD(0x02EC, 0x0024, 4, 0x0770, 1, 0),
+	MX6_PAD_KEY_COL0__GPIO3_IO24                          = IOMUX_PAD(0x02EC, 0x0024, 5, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_ROW0__KEY_ROW0                            = IOMUX_PAD(0x02F0, 0x0028, 0, 0x06C0, 0, 0),
+	MX6_PAD_KEY_ROW0__I2C2_SDA                            = IOMUX_PAD(0x02F0, 0x0028, IOMUX_CONFIG_SION | 1, 0x0688, 0, 0),
+	MX6_PAD_KEY_ROW0__LCD_DATA01                          = IOMUX_PAD(0x02F0, 0x0028, 2, 0x06DC, 0, 0),
+	MX6_PAD_KEY_ROW0__SD1_WP                              = IOMUX_PAD(0x02F0, 0x0028, 4, 0x0774, 1, 0),
+	MX6_PAD_KEY_ROW0__GPIO3_IO25                          = IOMUX_PAD(0x02F0, 0x0028, 5, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_COL1__KEY_COL1                            = IOMUX_PAD(0x02F4, 0x002C, 0, 0x06A4, 0, 0),
+	MX6_PAD_KEY_COL1__ECSPI4_MOSI                         = IOMUX_PAD(0x02F4, 0x002C, 1, 0x0658, 1, 0),
+	MX6_PAD_KEY_COL1__LCD_DATA02                          = IOMUX_PAD(0x02F4, 0x002C, 2, 0x06E0, 0, 0),
+	MX6_PAD_KEY_COL1__SD3_DATA4                           = IOMUX_PAD(0x02F4, 0x002C, 4, 0x0784, 0, 0),
+	MX6_PAD_KEY_COL1__GPIO3_IO26                          = IOMUX_PAD(0x02F4, 0x002C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_ROW1__KEY_ROW1                            = IOMUX_PAD(0x02F8, 0x0030, 0, 0x06C4, 0, 0),
+	MX6_PAD_KEY_ROW1__ECSPI4_MISO                         = IOMUX_PAD(0x02F8, 0x0030, 1, 0x0654, 1, 0),
+	MX6_PAD_KEY_ROW1__LCD_DATA03                          = IOMUX_PAD(0x02F8, 0x0030, 2, 0x06E4, 0, 0),
+	MX6_PAD_KEY_ROW1__CSI_FIELD                           = IOMUX_PAD(0x02F8, 0x0030, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW1__SD3_DATA5                           = IOMUX_PAD(0x02F8, 0x0030, 4, 0x0788, 0, 0),
+	MX6_PAD_KEY_ROW1__GPIO3_IO27                          = IOMUX_PAD(0x02F8, 0x0030, 5, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_COL2__KEY_COL2                            = IOMUX_PAD(0x02FC, 0x0034, 0, 0x06A8, 0, 0),
+	MX6_PAD_KEY_COL2__ECSPI4_SS0                          = IOMUX_PAD(0x02FC, 0x0034, 1, 0x065C, 1, 0),
+	MX6_PAD_KEY_COL2__LCD_DATA04                          = IOMUX_PAD(0x02FC, 0x0034, 2, 0x06E8, 0, 0),
+	MX6_PAD_KEY_COL2__CSI_DATA12                          = IOMUX_PAD(0x02FC, 0x0034, 3, 0x05B8, 1, 0),
+	MX6_PAD_KEY_COL2__SD3_DATA6                           = IOMUX_PAD(0x02FC, 0x0034, 4, 0x078C, 0, 0),
+	MX6_PAD_KEY_COL2__GPIO3_IO28                          = IOMUX_PAD(0x02FC, 0x0034, 5, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_ROW2__KEY_ROW2                            = IOMUX_PAD(0x0300, 0x0038, 0, 0x06C8, 0, 0),
+	MX6_PAD_KEY_ROW2__ECSPI4_SCLK                         = IOMUX_PAD(0x0300, 0x0038, 1, 0x0650, 1, 0),
+	MX6_PAD_KEY_ROW2__LCD_DATA05                          = IOMUX_PAD(0x0300, 0x0038, 2, 0x06EC, 0, 0),
+	MX6_PAD_KEY_ROW2__CSI_DATA13                          = IOMUX_PAD(0x0300, 0x0038, 3, 0x05BC, 1, 0),
+	MX6_PAD_KEY_ROW2__SD3_DATA7                           = IOMUX_PAD(0x0300, 0x0038, 4, 0x0790, 0, 0),
+	MX6_PAD_KEY_ROW2__GPIO3_IO29                          = IOMUX_PAD(0x0300, 0x0038, 5, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_COL3__KEY_COL3                            = IOMUX_PAD(0x0304, 0x003C, 0, 0x06AC, 0, 0),
+	MX6_PAD_KEY_COL3__AUD6_RXFS                           = IOMUX_PAD(0x0304, 0x003C, 1, 0x05A0, 1, 0),
+	MX6_PAD_KEY_COL3__LCD_DATA06                          = IOMUX_PAD(0x0304, 0x003C, 2, 0x06F0, 0, 0),
+	MX6_PAD_KEY_COL3__CSI_DATA14                          = IOMUX_PAD(0x0304, 0x003C, 3, 0x05C0, 1, 0),
+	MX6_PAD_KEY_COL3__GPIO3_IO30                          = IOMUX_PAD(0x0304, 0x003C, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL3__SD1_RESET                           = IOMUX_PAD(0x0304, 0x003C, 6, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_ROW3__KEY_ROW3                            = IOMUX_PAD(0x0308, 0x0040, 0, 0x06CC, 1, 0),
+	MX6_PAD_KEY_ROW3__AUD6_RXC                            = IOMUX_PAD(0x0308, 0x0040, 1, 0x059C, 1, 0),
+	MX6_PAD_KEY_ROW3__LCD_DATA07                          = IOMUX_PAD(0x0308, 0x0040, 2, 0x06F4, 1, 0),
+	MX6_PAD_KEY_ROW3__CSI_DATA15                          = IOMUX_PAD(0x0308, 0x0040, 3, 0x05C4, 2, 0),
+	MX6_PAD_KEY_ROW3__GPIO3_IO31                          = IOMUX_PAD(0x0308, 0x0040, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW3__SD1_VSELECT                         = IOMUX_PAD(0x0308, 0x0040, 6, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_COL4__KEY_COL4                            = IOMUX_PAD(0x030C, 0x0044, 0, 0x06B0, 1, 0),
+	MX6_PAD_KEY_COL4__AUD6_RXD                            = IOMUX_PAD(0x030C, 0x0044, 1, 0x0594, 1, 0),
+	MX6_PAD_KEY_COL4__LCD_DATA08                          = IOMUX_PAD(0x030C, 0x0044, 2, 0x06F8, 1, 0),
+	MX6_PAD_KEY_COL4__CSI_DATA16                          = IOMUX_PAD(0x030C, 0x0044, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL4__GPIO4_IO00                          = IOMUX_PAD(0x030C, 0x0044, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL4__USB_OTG1_PWR                        = IOMUX_PAD(0x030C, 0x0044, 6, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_ROW4__KEY_ROW4                            = IOMUX_PAD(0x0310, 0x0048, 0, 0x06D0, 1, 0),
+	MX6_PAD_KEY_ROW4__AUD6_TXC                            = IOMUX_PAD(0x0310, 0x0048, 1, 0x05A4, 1, 0),
+	MX6_PAD_KEY_ROW4__LCD_DATA09                          = IOMUX_PAD(0x0310, 0x0048, 2, 0x06FC, 1, 0),
+	MX6_PAD_KEY_ROW4__CSI_DATA17                          = IOMUX_PAD(0x0310, 0x0048, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW4__GPIO4_IO01                          = IOMUX_PAD(0x0310, 0x0048, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW4__USB_OTG1_OC                         = IOMUX_PAD(0x0310, 0x0048, 6, 0x076C, 2, 0),
+
+	MX6_PAD_KEY_COL5__KEY_COL5                            = IOMUX_PAD(0x0314, 0x004C, 0, 0x0694, 1, 0),
+	MX6_PAD_KEY_COL5__AUD6_TXFS                           = IOMUX_PAD(0x0314, 0x004C, 1, 0x05A8, 1, 0),
+	MX6_PAD_KEY_COL5__LCD_DATA10                          = IOMUX_PAD(0x0314, 0x004C, 2, 0x0700, 0, 0),
+	MX6_PAD_KEY_COL5__CSI_DATA18                          = IOMUX_PAD(0x0314, 0x004C, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL5__GPIO4_IO02                          = IOMUX_PAD(0x0314, 0x004C, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL5__USB_OTG2_PWR                        = IOMUX_PAD(0x0314, 0x004C, 6, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_ROW5__KEY_ROW5                            = IOMUX_PAD(0x0318, 0x0050, 0, 0x06B4, 2, 0),
+	MX6_PAD_KEY_ROW5__AUD6_TXD                            = IOMUX_PAD(0x0318, 0x0050, 1, 0x0598, 1, 0),
+	MX6_PAD_KEY_ROW5__LCD_DATA11                          = IOMUX_PAD(0x0318, 0x0050, 2, 0x0704, 1, 0),
+	MX6_PAD_KEY_ROW5__CSI_DATA19                          = IOMUX_PAD(0x0318, 0x0050, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW5__GPIO4_IO03                          = IOMUX_PAD(0x0318, 0x0050, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW5__USB_OTG2_OC                         = IOMUX_PAD(0x0318, 0x0050, 6, 0x0768, 3, 0),
+
+	MX6_PAD_KEY_COL6__KEY_COL6                            = IOMUX_PAD(0x031C, 0x0054, 0, 0x0698, 2, 0),
+	MX6_PAD_KEY_COL6__UART4_DCE_RX                        = IOMUX_PAD(0x031C, 0x0054, 1, 0x075C, 2, 0),
+	MX6_PAD_KEY_COL6__UART4_DTE_TX                        = IOMUX_PAD(0x031C, 0x0054, 1, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL6__LCD_DATA12                          = IOMUX_PAD(0x031C, 0x0054, 2, 0x0708, 1, 0),
+	MX6_PAD_KEY_COL6__CSI_DATA20                          = IOMUX_PAD(0x031C, 0x0054, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL6__GPIO4_IO04                          = IOMUX_PAD(0x031C, 0x0054, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL6__SD3_RESET                           = IOMUX_PAD(0x031C, 0x0054, 6, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_ROW6__KEY_ROW6                            = IOMUX_PAD(0x0320, 0x0058, 0, 0x06B8, 2, 0),
+	MX6_PAD_KEY_ROW6__UART4_DCE_TX                        = IOMUX_PAD(0x0320, 0x0058, 1, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW6__UART4_DTE_RX                        = IOMUX_PAD(0x0320, 0x0058, 1, 0x075C, 3, 0),
+	MX6_PAD_KEY_ROW6__LCD_DATA13                          = IOMUX_PAD(0x0320, 0x0058, 2, 0x070C, 1, 0),
+	MX6_PAD_KEY_ROW6__CSI_DATA21                          = IOMUX_PAD(0x0320, 0x0058, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW6__GPIO4_IO05                          = IOMUX_PAD(0x0320, 0x0058, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW6__SD3_VSELECT                         = IOMUX_PAD(0x0320, 0x0058, 6, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_COL7__KEY_COL7                            = IOMUX_PAD(0x0324, 0x005C, 0, 0x069C, 2, 0),
+	MX6_PAD_KEY_COL7__UART4_DCE_RTS                       = IOMUX_PAD(0x0324, 0x005C, 1, 0x0758, 2, 0),
+	MX6_PAD_KEY_COL7__UART4_DTE_CTS                       = IOMUX_PAD(0x0324, 0x005C, 1, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL7__LCD_DATA14                          = IOMUX_PAD(0x0324, 0x005C, 2, 0x0710, 1, 0),
+	MX6_PAD_KEY_COL7__CSI_DATA22                          = IOMUX_PAD(0x0324, 0x005C, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL7__GPIO4_IO06                          = IOMUX_PAD(0x0324, 0x005C, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL7__SD1_WP                              = IOMUX_PAD(0x0324, 0x005C, 6, 0x0774, 3, 0),
+
+	MX6_PAD_KEY_ROW7__KEY_ROW7                            = IOMUX_PAD(0x0328, 0x0060, 0, 0x06BC, 2, 0),
+	MX6_PAD_KEY_ROW7__UART4_DCE_CTS                       = IOMUX_PAD(0x0328, 0x0060, 1, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW7__UART4_DTE_RTS                       = IOMUX_PAD(0x0328, 0x0060, 1, 0x0758, 3, 0),
+	MX6_PAD_KEY_ROW7__LCD_DATA15                          = IOMUX_PAD(0x0328, 0x0060, 2, 0x0714, 1, 0),
+	MX6_PAD_KEY_ROW7__CSI_DATA23                          = IOMUX_PAD(0x0328, 0x0060, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW7__GPIO4_IO07                          = IOMUX_PAD(0x0328, 0x0060, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW7__SD1_CD_B                            = IOMUX_PAD(0x0328, 0x0060, 6, 0x0770, 3, 0),
+
+	MX6_PAD_EPDC_DATA00__EPDC_DATA00                      = IOMUX_PAD(0x032C, 0x0064, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA00__ECSPI4_MOSI                      = IOMUX_PAD(0x032C, 0x0064, 1, 0x0658, 2, 0),
+	MX6_PAD_EPDC_DATA00__LCD_DATA24                       = IOMUX_PAD(0x032C, 0x0064, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA00__CSI_DATA00                       = IOMUX_PAD(0x032C, 0x0064, 3, 0x05C8, 2, 0),
+	MX6_PAD_EPDC_DATA00__GPIO1_IO07                       = IOMUX_PAD(0x032C, 0x0064, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA01__EPDC_DATA01                      = IOMUX_PAD(0x0330, 0x0068, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA01__ECSPI4_MISO                      = IOMUX_PAD(0x0330, 0x0068, 1, 0x0654, 2, 0),
+	MX6_PAD_EPDC_DATA01__LCD_DATA25                       = IOMUX_PAD(0x0330, 0x0068, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA01__CSI_DATA01                       = IOMUX_PAD(0x0330, 0x0068, 3, 0x05CC, 2, 0),
+	MX6_PAD_EPDC_DATA01__GPIO1_IO08                       = IOMUX_PAD(0x0330, 0x0068, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA02__EPDC_DATA02                      = IOMUX_PAD(0x0334, 0x006C, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA02__ECSPI4_SS0                       = IOMUX_PAD(0x0334, 0x006C, 1, 0x065C, 2, 0),
+	MX6_PAD_EPDC_DATA02__LCD_DATA26                       = IOMUX_PAD(0x0334, 0x006C, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA02__CSI_DATA02                       = IOMUX_PAD(0x0334, 0x006C, 3, 0x05D0, 2, 0),
+	MX6_PAD_EPDC_DATA02__GPIO1_IO09                       = IOMUX_PAD(0x0334, 0x006C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA03__EPDC_DATA03                      = IOMUX_PAD(0x0338, 0x0070, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA03__ECSPI4_SCLK                      = IOMUX_PAD(0x0338, 0x0070, 1, 0x0650, 2, 0),
+	MX6_PAD_EPDC_DATA03__LCD_DATA27                       = IOMUX_PAD(0x0338, 0x0070, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA03__CSI_DATA03                       = IOMUX_PAD(0x0338, 0x0070, 3, 0x05D4, 2, 0),
+	MX6_PAD_EPDC_DATA03__GPIO1_IO10                       = IOMUX_PAD(0x0338, 0x0070, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA04__EPDC_DATA04                      = IOMUX_PAD(0x033C, 0x0074, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA04__ECSPI4_SS1                       = IOMUX_PAD(0x033C, 0x0074, 1, 0x0660, 1, 0),
+	MX6_PAD_EPDC_DATA04__LCD_DATA28                       = IOMUX_PAD(0x033C, 0x0074, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA04__CSI_DATA04                       = IOMUX_PAD(0x033C, 0x0074, 3, 0x05D8, 2, 0),
+	MX6_PAD_EPDC_DATA04__GPIO1_IO11                       = IOMUX_PAD(0x033C, 0x0074, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA05__EPDC_DATA05                      = IOMUX_PAD(0x0340, 0x0078, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA05__ECSPI4_SS2                       = IOMUX_PAD(0x0340, 0x0078, 1, 0x0664, 1, 0),
+	MX6_PAD_EPDC_DATA05__LCD_DATA29                       = IOMUX_PAD(0x0340, 0x0078, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA05__CSI_DATA05                       = IOMUX_PAD(0x0340, 0x0078, 3, 0x05DC, 2, 0),
+	MX6_PAD_EPDC_DATA05__GPIO1_IO12                       = IOMUX_PAD(0x0340, 0x0078, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA06__EPDC_DATA06                      = IOMUX_PAD(0x0344, 0x007C, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA06__ECSPI4_SS3                       = IOMUX_PAD(0x0344, 0x007C, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA06__LCD_DATA30                       = IOMUX_PAD(0x0344, 0x007C, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA06__CSI_DATA06                       = IOMUX_PAD(0x0344, 0x007C, 3, 0x05E0, 2, 0),
+	MX6_PAD_EPDC_DATA06__GPIO1_IO13                       = IOMUX_PAD(0x0344, 0x007C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA07__EPDC_DATA07                      = IOMUX_PAD(0x0348, 0x0080, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA07__ECSPI4_RDY                       = IOMUX_PAD(0x0348, 0x0080, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA07__LCD_DATA31                       = IOMUX_PAD(0x0348, 0x0080, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA07__CSI_DATA07                       = IOMUX_PAD(0x0348, 0x0080, 3, 0x05E4, 2, 0),
+	MX6_PAD_EPDC_DATA07__GPIO1_IO14                       = IOMUX_PAD(0x0348, 0x0080, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA08__EPDC_DATA08                      = IOMUX_PAD(0x034C, 0x0084, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA08__ECSPI3_MOSI                      = IOMUX_PAD(0x034C, 0x0084, 1, 0x063C, 2, 0),
+	MX6_PAD_EPDC_DATA08__EPDC_PWR_CTRL0                   = IOMUX_PAD(0x034C, 0x0084, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA08__GPIO1_IO15                       = IOMUX_PAD(0x034C, 0x0084, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA09__EPDC_DATA09                      = IOMUX_PAD(0x0350, 0x0088, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA09__ECSPI3_MISO                      = IOMUX_PAD(0x0350, 0x0088, 1, 0x0638, 2, 0),
+	MX6_PAD_EPDC_DATA09__EPDC_PWR_CTRL1                   = IOMUX_PAD(0x0350, 0x0088, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA09__GPIO1_IO16                       = IOMUX_PAD(0x0350, 0x0088, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA10__EPDC_DATA10                      = IOMUX_PAD(0x0354, 0x008C, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA10__ECSPI3_SS0                       = IOMUX_PAD(0x0354, 0x008C, 1, 0x0648, 2, 0),
+	MX6_PAD_EPDC_DATA10__EPDC_PWR_CTRL2                   = IOMUX_PAD(0x0354, 0x008C, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA10__GPIO1_IO17                       = IOMUX_PAD(0x0354, 0x008C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA11__EPDC_DATA11                      = IOMUX_PAD(0x0358, 0x0090, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA11__ECSPI3_SCLK                      = IOMUX_PAD(0x0358, 0x0090, 1, 0x0630, 2, 0),
+	MX6_PAD_EPDC_DATA11__EPDC_PWR_CTRL3                   = IOMUX_PAD(0x0358, 0x0090, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA11__GPIO1_IO18                       = IOMUX_PAD(0x0358, 0x0090, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA12__EPDC_DATA12                      = IOMUX_PAD(0x035C, 0x0094, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA12__UART2_DCE_RX                     = IOMUX_PAD(0x035C, 0x0094, 1, 0x074C, 4, 0),
+	MX6_PAD_EPDC_DATA12__UART2_DTE_TX                     = IOMUX_PAD(0x035C, 0x0094, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA12__EPDC_PWR_COM                     = IOMUX_PAD(0x035C, 0x0094, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA12__GPIO1_IO19                       = IOMUX_PAD(0x035C, 0x0094, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA12__ECSPI3_SS1                       = IOMUX_PAD(0x035C, 0x0094, 6, 0x064C, 1, 0),
+
+	MX6_PAD_EPDC_DATA13__EPDC_DATA13                      = IOMUX_PAD(0x0360, 0x0098, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA13__UART2_DCE_TX                     = IOMUX_PAD(0x0360, 0x0098, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA13__UART2_DTE_RX                     = IOMUX_PAD(0x0360, 0x0098, 1, 0x074C, 5, 0),
+	MX6_PAD_EPDC_DATA13__EPDC_PWR_IRQ                     = IOMUX_PAD(0x0360, 0x0098, 2, 0x0668, 0, 0),
+	MX6_PAD_EPDC_DATA13__GPIO1_IO20                       = IOMUX_PAD(0x0360, 0x0098, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA13__ECSPI3_SS2                       = IOMUX_PAD(0x0360, 0x0098, 6, 0x0640, 1, 0),
+
+	MX6_PAD_EPDC_DATA14__EPDC_DATA14                      = IOMUX_PAD(0x0364, 0x009C, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA14__UART2_DCE_RTS                    = IOMUX_PAD(0x0364, 0x009C, 1, 0x0748, 4, 0),
+	MX6_PAD_EPDC_DATA14__UART2_DTE_CTS                    = IOMUX_PAD(0x0364, 0x009C, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA14__EPDC_PWR_STAT                    = IOMUX_PAD(0x0364, 0x009C, 2, 0x066C, 0, 0),
+	MX6_PAD_EPDC_DATA14__GPIO1_IO21                       = IOMUX_PAD(0x0364, 0x009C, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA14__ECSPI3_SS3                       = IOMUX_PAD(0x0364, 0x009C, 6, 0x0644, 1, 0),
+
+	MX6_PAD_EPDC_DATA15__EPDC_DATA15                      = IOMUX_PAD(0x0368, 0x00A0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA15__UART2_DCE_CTS                    = IOMUX_PAD(0x0368, 0x00A0, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA15__UART2_DTE_RTS                    = IOMUX_PAD(0x0368, 0x00A0, 1, 0x0748, 5, 0),
+	MX6_PAD_EPDC_DATA15__EPDC_PWR_WAKE                    = IOMUX_PAD(0x0368, 0x00A0, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA15__GPIO1_IO22                       = IOMUX_PAD(0x0368, 0x00A0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA15__ECSPI3_RDY                       = IOMUX_PAD(0x0368, 0x00A0, 6, 0x0634, 1, 0),
+
+	MX6_PAD_EPDC_SDCLK__EPDC_SDCLK_P                      = IOMUX_PAD(0x036C, 0x00A4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCLK__ECSPI2_MOSI                       = IOMUX_PAD(0x036C, 0x00A4, 1, 0x0624, 2, 0),
+	MX6_PAD_EPDC_SDCLK__I2C2_SCL                          = IOMUX_PAD(0x036C, 0x00A4, IOMUX_CONFIG_SION | 2, 0x0684, 2, 0),
+	MX6_PAD_EPDC_SDCLK__CSI_DATA08                        = IOMUX_PAD(0x036C, 0x00A4, 3, 0x05E8, 2, 0),
+	MX6_PAD_EPDC_SDCLK__GPIO1_IO23                        = IOMUX_PAD(0x036C, 0x00A4, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_SDLE__EPDC_SDLE                          = IOMUX_PAD(0x0370, 0x00A8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDLE__ECSPI2_MISO                        = IOMUX_PAD(0x0370, 0x00A8, 1, 0x0620, 2, 0),
+	MX6_PAD_EPDC_SDLE__I2C2_SDA                           = IOMUX_PAD(0x0370, 0x00A8, IOMUX_CONFIG_SION | 2, 0x0688, 2, 0),
+	MX6_PAD_EPDC_SDLE__CSI_DATA09                         = IOMUX_PAD(0x0370, 0x00A8, 3, 0x05EC, 2, 0),
+	MX6_PAD_EPDC_SDLE__GPIO1_IO24                         = IOMUX_PAD(0x0370, 0x00A8, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_SDOE__EPDC_SDOE                          = IOMUX_PAD(0x0374, 0x00AC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDOE__ECSPI2_SS0                         = IOMUX_PAD(0x0374, 0x00AC, 1, 0x0628, 1, 0),
+	MX6_PAD_EPDC_SDOE__CSI_DATA10                         = IOMUX_PAD(0x0374, 0x00AC, 3, 0x05B0, 2, 0),
+	MX6_PAD_EPDC_SDOE__GPIO1_IO25                         = IOMUX_PAD(0x0374, 0x00AC, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_SDSHR__EPDC_SDSHR                        = IOMUX_PAD(0x0378, 0x00B0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDSHR__ECSPI2_SCLK                       = IOMUX_PAD(0x0378, 0x00B0, 1, 0x061C, 2, 0),
+	MX6_PAD_EPDC_SDSHR__EPDC_SDCE4                        = IOMUX_PAD(0x0378, 0x00B0, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDSHR__CSI_DATA11                        = IOMUX_PAD(0x0378, 0x00B0, 3, 0x05B4, 2, 0),
+	MX6_PAD_EPDC_SDSHR__GPIO1_IO26                        = IOMUX_PAD(0x0378, 0x00B0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_SDCE0__EPDC_SDCE0                        = IOMUX_PAD(0x037C, 0x00B4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE0__ECSPI2_SS1                        = IOMUX_PAD(0x037C, 0x00B4, 1, 0x062C, 1, 0),
+	MX6_PAD_EPDC_SDCE0__PWM3_OUT                          = IOMUX_PAD(0x037C, 0x00B4, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE0__GPIO1_IO27                        = IOMUX_PAD(0x037C, 0x00B4, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_SDCE1__EPDC_SDCE1                        = IOMUX_PAD(0x0380, 0x00B8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE1__WDOG2_B                           = IOMUX_PAD(0x0380, 0x00B8, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE1__PWM4_OUT                          = IOMUX_PAD(0x0380, 0x00B8, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE1__GPIO1_IO28                        = IOMUX_PAD(0x0380, 0x00B8, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_SDCE2__EPDC_SDCE2                        = IOMUX_PAD(0x0384, 0x00BC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE2__I2C3_SCL                          = IOMUX_PAD(0x0384, 0x00BC, IOMUX_CONFIG_SION | 1, 0x068C, 2, 0),
+	MX6_PAD_EPDC_SDCE2__PWM1_OUT                          = IOMUX_PAD(0x0384, 0x00BC, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE2__GPIO1_IO29                        = IOMUX_PAD(0x0384, 0x00BC, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_SDCE3__EPDC_SDCE3                        = IOMUX_PAD(0x0388, 0x00C0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE3__I2C3_SDA                          = IOMUX_PAD(0x0388, 0x00C0, IOMUX_CONFIG_SION | 1, 0x0690, 2, 0),
+	MX6_PAD_EPDC_SDCE3__PWM2_OUT                          = IOMUX_PAD(0x0388, 0x00C0, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE3__GPIO1_IO30                        = IOMUX_PAD(0x0388, 0x00C0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_GDCLK__EPDC_GDCLK                        = IOMUX_PAD(0x038C, 0x00C4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDCLK__ECSPI2_SS2                        = IOMUX_PAD(0x038C, 0x00C4, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDCLK__CSI_PIXCLK                        = IOMUX_PAD(0x038C, 0x00C4, 3, 0x05F4, 2, 0),
+	MX6_PAD_EPDC_GDCLK__GPIO1_IO31                        = IOMUX_PAD(0x038C, 0x00C4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDCLK__SD2_RESET                         = IOMUX_PAD(0x038C, 0x00C4, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_GDOE__EPDC_GDOE                          = IOMUX_PAD(0x0390, 0x00C8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDOE__ECSPI2_SS3                         = IOMUX_PAD(0x0390, 0x00C8, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDOE__CSI_HSYNC                          = IOMUX_PAD(0x0390, 0x00C8, 3, 0x05F0, 2, 0),
+	MX6_PAD_EPDC_GDOE__GPIO2_IO00                         = IOMUX_PAD(0x0390, 0x00C8, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDOE__SD2_VSELECT                        = IOMUX_PAD(0x0390, 0x00C8, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_GDRL__EPDC_GDRL                          = IOMUX_PAD(0x0394, 0x00CC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDRL__ECSPI2_RDY                         = IOMUX_PAD(0x0394, 0x00CC, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDRL__CSI_MCLK                           = IOMUX_PAD(0x0394, 0x00CC, 3, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDRL__GPIO2_IO01                         = IOMUX_PAD(0x0394, 0x00CC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDRL__SD2_WP                             = IOMUX_PAD(0x0394, 0x00CC, 6, 0x077C, 2, 0),
+
+	MX6_PAD_EPDC_GDSP__EPDC_GDSP                          = IOMUX_PAD(0x0398, 0x00D0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDSP__PWM4_OUT                           = IOMUX_PAD(0x0398, 0x00D0, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDSP__CSI_VSYNC                          = IOMUX_PAD(0x0398, 0x00D0, 3, 0x05F8, 2, 0),
+	MX6_PAD_EPDC_GDSP__GPIO2_IO02                         = IOMUX_PAD(0x0398, 0x00D0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDSP__SD2_CD_B                           = IOMUX_PAD(0x0398, 0x00D0, 6, 0x0778, 2, 0),
+
+	MX6_PAD_EPDC_VCOM0__EPDC_VCOM0                        = IOMUX_PAD(0x039C, 0x00D4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_VCOM0__AUD5_RXFS                         = IOMUX_PAD(0x039C, 0x00D4, 1, 0x0588, 1, 0),
+	MX6_PAD_EPDC_VCOM0__UART3_DCE_RX                      = IOMUX_PAD(0x039C, 0x00D4, 2, 0x0754, 4, 0),
+	MX6_PAD_EPDC_VCOM0__UART3_DTE_TX                      = IOMUX_PAD(0x039C, 0x00D4, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_VCOM0__GPIO2_IO03                        = IOMUX_PAD(0x039C, 0x00D4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_VCOM0__EPDC_SDCE5                        = IOMUX_PAD(0x039C, 0x00D4, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_VCOM1__EPDC_VCOM1                        = IOMUX_PAD(0x03A0, 0x00D8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_VCOM1__AUD5_RXD                          = IOMUX_PAD(0x03A0, 0x00D8, 1, 0x057C, 1, 0),
+	MX6_PAD_EPDC_VCOM1__UART3_DCE_TX                      = IOMUX_PAD(0x03A0, 0x00D8, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_VCOM1__UART3_DTE_RX                      = IOMUX_PAD(0x03A0, 0x00D8, 2, 0x0754, 5, 0),
+	MX6_PAD_EPDC_VCOM1__GPIO2_IO04                        = IOMUX_PAD(0x03A0, 0x00D8, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_VCOM1__EPDC_SDCE6                        = IOMUX_PAD(0x03A0, 0x00D8, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_BDR0__EPDC_BDR0                          = IOMUX_PAD(0x03A4, 0x00DC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR0__UART3_DCE_RTS                      = IOMUX_PAD(0x03A4, 0x00DC, 2, 0x0750, 2, 0),
+	MX6_PAD_EPDC_BDR0__UART3_DTE_CTS                      = IOMUX_PAD(0x03A4, 0x00DC, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR0__GPIO2_IO05                         = IOMUX_PAD(0x03A4, 0x00DC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR0__EPDC_SDCE7                         = IOMUX_PAD(0x03A4, 0x00DC, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_BDR1__EPDC_BDR1                          = IOMUX_PAD(0x03A8, 0x00E0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR1__UART3_DCE_CTS                      = IOMUX_PAD(0x03A8, 0x00E0, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR1__UART3_DTE_RTS                      = IOMUX_PAD(0x03A8, 0x00E0, 2, 0x0750, 3, 0),
+	MX6_PAD_EPDC_BDR1__GPIO2_IO06                         = IOMUX_PAD(0x03A8, 0x00E0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR1__EPDC_SDCE8                         = IOMUX_PAD(0x03A8, 0x00E0, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWR_CTRL0__EPDC_PWR_CTRL0                = IOMUX_PAD(0x03AC, 0x00E4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_CTRL0__AUD5_RXC                      = IOMUX_PAD(0x03AC, 0x00E4, 1, 0x0584, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL0__LCD_DATA16                    = IOMUX_PAD(0x03AC, 0x00E4, 2, 0x0718, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL0__GPIO2_IO07                    = IOMUX_PAD(0x03AC, 0x00E4, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWR_CTRL1__EPDC_PWR_CTRL1                = IOMUX_PAD(0x03B0, 0x00E8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_CTRL1__AUD5_TXFS                     = IOMUX_PAD(0x03B0, 0x00E8, 1, 0x0590, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL1__LCD_DATA17                    = IOMUX_PAD(0x03B0, 0x00E8, 2, 0x071C, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL1__GPIO2_IO08                    = IOMUX_PAD(0x03B0, 0x00E8, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWR_CTRL2__EPDC_PWR_CTRL2                = IOMUX_PAD(0x03B4, 0x00EC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_CTRL2__AUD5_TXD                      = IOMUX_PAD(0x03B4, 0x00EC, 1, 0x0580, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL2__LCD_DATA18                    = IOMUX_PAD(0x03B4, 0x00EC, 2, 0x0720, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL2__GPIO2_IO09                    = IOMUX_PAD(0x03B4, 0x00EC, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWR_CTRL3__EPDC_PWR_CTRL3                = IOMUX_PAD(0x03B8, 0x00F0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_CTRL3__AUD5_TXC                      = IOMUX_PAD(0x03B8, 0x00F0, 1, 0x058C, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL3__LCD_DATA19                    = IOMUX_PAD(0x03B8, 0x00F0, 2, 0x0724, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL3__GPIO2_IO10                    = IOMUX_PAD(0x03B8, 0x00F0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWR_COM__EPDC_PWR_COM                    = IOMUX_PAD(0x03BC, 0x00F4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_COM__LCD_DATA20                      = IOMUX_PAD(0x03BC, 0x00F4, 2, 0x0728, 1, 0),
+	MX6_PAD_EPDC_PWR_COM__USB_OTG1_ID                     = IOMUX_PAD(0x03BC, 0x00F4, 4, 0x055C, 4, 0),
+	MX6_PAD_EPDC_PWR_COM__GPIO2_IO11                      = IOMUX_PAD(0x03BC, 0x00F4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_COM__SD3_RESET                       = IOMUX_PAD(0x03BC, 0x00F4, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWR_IRQ__EPDC_PWR_IRQ                    = IOMUX_PAD(0x03C0, 0x00F8, 0, 0x0668, 1, 0),
+	MX6_PAD_EPDC_PWR_IRQ__LCD_DATA21                      = IOMUX_PAD(0x03C0, 0x00F8, 2, 0x072C, 1, 0),
+	MX6_PAD_EPDC_PWR_IRQ__USB_OTG2_ID                     = IOMUX_PAD(0x03C0, 0x00F8, 4, 0x0560, 3, 0),
+	MX6_PAD_EPDC_PWR_IRQ__GPIO2_IO12                      = IOMUX_PAD(0x03C0, 0x00F8, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_IRQ__SD3_VSELECT                     = IOMUX_PAD(0x03C0, 0x00F8, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWR_STAT__EPDC_PWR_STAT                  = IOMUX_PAD(0x03C4, 0x00FC, 0, 0x066C, 1, 0),
+	MX6_PAD_EPDC_PWR_STAT__LCD_DATA22                     = IOMUX_PAD(0x03C4, 0x00FC, 2, 0x0730, 1, 0),
+	MX6_PAD_EPDC_PWR_STAT__ARM_EVENTI                     = IOMUX_PAD(0x03C4, 0x00FC, 4, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_STAT__GPIO2_IO13                     = IOMUX_PAD(0x03C4, 0x00FC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_STAT__SD3_WP                         = IOMUX_PAD(0x03C4, 0x00FC, 6, 0x0794, 2, 0),
+
+	MX6_PAD_EPDC_PWR_WAKE__EPDC_PWR_WAKE                  = IOMUX_PAD(0x03C8, 0x0100, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_WAKE__LCD_DATA23                     = IOMUX_PAD(0x03C8, 0x0100, 2, 0x0734, 1, 0),
+	MX6_PAD_EPDC_PWR_WAKE__ARM_EVENTO                     = IOMUX_PAD(0x03C8, 0x0100, 4, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_WAKE__GPIO2_IO14                     = IOMUX_PAD(0x03C8, 0x0100, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_WAKE__SD3_CD_B                       = IOMUX_PAD(0x03C8, 0x0100, 6, 0x0780, 2, 0),
+
+	MX6_PAD_LCD_CLK__LCD_CLK                              = IOMUX_PAD(0x03CC, 0x0104, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__LCD_WR_RWN                           = IOMUX_PAD(0x03CC, 0x0104, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__PWM4_OUT                             = IOMUX_PAD(0x03CC, 0x0104, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__GPIO2_IO15                           = IOMUX_PAD(0x03CC, 0x0104, 5, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_ENABLE__LCD_ENABLE                        = IOMUX_PAD(0x03D0, 0x0108, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__LCD_RD_E                          = IOMUX_PAD(0x03D0, 0x0108, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__UART2_DCE_RX                      = IOMUX_PAD(0x03D0, 0x0108, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__UART2_DTE_TX                      = IOMUX_PAD(0x03D0, 0x0108, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__GPIO2_IO16                        = IOMUX_PAD(0x03D0, 0x0108, 5, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_HSYNC__LCD_HSYNC                          = IOMUX_PAD(0x03D4, 0x010C, 0, 0x06D4, 0, 0),
+	MX6_PAD_LCD_HSYNC__LCD_CS                             = IOMUX_PAD(0x03D4, 0x010C, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__UART2_DCE_TX                       = IOMUX_PAD(0x03D4, 0x010C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__UART2_DTE_RX                       = IOMUX_PAD(0x03D4, 0x010C, 4, 0x074C, 1, 0),
+	MX6_PAD_LCD_HSYNC__GPIO2_IO17                         = IOMUX_PAD(0x03D4, 0x010C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__ARM_TRACE_CLK                      = IOMUX_PAD(0x03D4, 0x010C, 6, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_VSYNC__LCD_VSYNC                          = IOMUX_PAD(0x03D8, 0x0110, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__LCD_RS                             = IOMUX_PAD(0x03D8, 0x0110, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__UART2_DCE_RTS                      = IOMUX_PAD(0x03D8, 0x0110, 4, 0x0748, 0, 0),
+	MX6_PAD_LCD_VSYNC__UART2_DTE_CTS                      = IOMUX_PAD(0x03D8, 0x0110, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__GPIO2_IO18                         = IOMUX_PAD(0x03D8, 0x0110, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__ARM_TRACE_CTL                      = IOMUX_PAD(0x03D8, 0x0110, 6, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_RESET__LCD_RESET                          = IOMUX_PAD(0x03DC, 0x0114, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__LCD_BUSY                           = IOMUX_PAD(0x03DC, 0x0114, 2, 0x06D4, 1, 0),
+	MX6_PAD_LCD_RESET__UART2_DCE_CTS                      = IOMUX_PAD(0x03DC, 0x0114, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__UART2_DTE_RTS                      = IOMUX_PAD(0x03DC, 0x0114, 4, 0x0748, 1, 0),
+	MX6_PAD_LCD_RESET__GPIO2_IO19                         = IOMUX_PAD(0x03DC, 0x0114, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__CCM_PMIC_READY                     = IOMUX_PAD(0x03DC, 0x0114, 6, 0x05AC, 2, 0),
+
+	MX6_PAD_LCD_DATA00__LCD_DATA00                        = IOMUX_PAD(0x03E0, 0x0118, 0, 0x06D8, 1, 0),
+	MX6_PAD_LCD_DATA00__ECSPI1_MOSI                       = IOMUX_PAD(0x03E0, 0x0118, 1, 0x0608, 0, 0),
+	MX6_PAD_LCD_DATA00__USB_OTG2_ID                       = IOMUX_PAD(0x03E0, 0x0118, 2, 0x0560, 2, 0),
+	MX6_PAD_LCD_DATA00__PWM1_OUT                          = IOMUX_PAD(0x03E0, 0x0118, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__UART5_DTR_B                       = IOMUX_PAD(0x03E0, 0x0118, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__GPIO2_IO20                        = IOMUX_PAD(0x03E0, 0x0118, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__ARM_TRACE00                       = IOMUX_PAD(0x03E0, 0x0118, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__SRC_BOOT_CFG00                    = IOMUX_PAD(0x03E0, 0x0118, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA01__LCD_DATA01                        = IOMUX_PAD(0x03E4, 0x011C, 0, 0x06DC, 1, 0),
+	MX6_PAD_LCD_DATA01__ECSPI1_MISO                       = IOMUX_PAD(0x03E4, 0x011C, 1, 0x0604, 0, 0),
+	MX6_PAD_LCD_DATA01__USB_OTG1_ID                       = IOMUX_PAD(0x03E4, 0x011C, 2, 0x055C, 3, 0),
+	MX6_PAD_LCD_DATA01__PWM2_OUT                          = IOMUX_PAD(0x03E4, 0x011C, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__AUD4_RXFS                         = IOMUX_PAD(0x03E4, 0x011C, 4, 0x0570, 0, 0),
+	MX6_PAD_LCD_DATA01__GPIO2_IO21                        = IOMUX_PAD(0x03E4, 0x011C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__ARM_TRACE01                       = IOMUX_PAD(0x03E4, 0x011C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__SRC_BOOT_CFG01                    = IOMUX_PAD(0x03E4, 0x011C, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA02__LCD_DATA02                        = IOMUX_PAD(0x03E8, 0x0120, 0, 0x06E0, 1, 0),
+	MX6_PAD_LCD_DATA02__ECSPI1_SS0                        = IOMUX_PAD(0x03E8, 0x0120, 1, 0x0614, 0, 0),
+	MX6_PAD_LCD_DATA02__EPIT2_OUT                         = IOMUX_PAD(0x03E8, 0x0120, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__PWM3_OUT                          = IOMUX_PAD(0x03E8, 0x0120, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__AUD4_RXC                          = IOMUX_PAD(0x03E8, 0x0120, 4, 0x056C, 0, 0),
+	MX6_PAD_LCD_DATA02__GPIO2_IO22                        = IOMUX_PAD(0x03E8, 0x0120, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__ARM_TRACE02                       = IOMUX_PAD(0x03E8, 0x0120, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__SRC_BOOT_CFG02                    = IOMUX_PAD(0x03E8, 0x0120, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA03__LCD_DATA03                        = IOMUX_PAD(0x03EC, 0x0124, 0, 0x06E4, 1, 0),
+	MX6_PAD_LCD_DATA03__ECSPI1_SCLK                       = IOMUX_PAD(0x03EC, 0x0124, 1, 0x05FC, 0, 0),
+	MX6_PAD_LCD_DATA03__UART5_DSR_B                       = IOMUX_PAD(0x03EC, 0x0124, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__PWM4_OUT                          = IOMUX_PAD(0x03EC, 0x0124, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__AUD4_RXD                          = IOMUX_PAD(0x03EC, 0x0124, 4, 0x0564, 0, 0),
+	MX6_PAD_LCD_DATA03__GPIO2_IO23                        = IOMUX_PAD(0x03EC, 0x0124, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__ARM_TRACE03                       = IOMUX_PAD(0x03EC, 0x0124, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__SRC_BOOT_CFG03                    = IOMUX_PAD(0x03EC, 0x0124, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA04__LCD_DATA04                        = IOMUX_PAD(0x03F0, 0x0128, 0, 0x06E8, 1, 0),
+	MX6_PAD_LCD_DATA04__ECSPI1_SS1                        = IOMUX_PAD(0x03F0, 0x0128, 1, 0x060C, 1, 0),
+	MX6_PAD_LCD_DATA04__CSI_VSYNC                         = IOMUX_PAD(0x03F0, 0x0128, 2, 0x05F8, 0, 0),
+	MX6_PAD_LCD_DATA04__WDOG2_RESET_B_DEB                 = IOMUX_PAD(0x03F0, 0x0128, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__AUD4_TXC                          = IOMUX_PAD(0x03F0, 0x0128, 4, 0x0574, 0, 0),
+	MX6_PAD_LCD_DATA04__GPIO2_IO24                        = IOMUX_PAD(0x03F0, 0x0128, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__ARM_TRACE04                       = IOMUX_PAD(0x03F0, 0x0128, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SRC_BOOT_CFG04                    = IOMUX_PAD(0x03F0, 0x0128, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA05__LCD_DATA05                        = IOMUX_PAD(0x03F4, 0x012C, 0, 0x06EC, 1, 0),
+	MX6_PAD_LCD_DATA05__ECSPI1_SS2                        = IOMUX_PAD(0x03F4, 0x012C, 1, 0x0610, 1, 0),
+	MX6_PAD_LCD_DATA05__CSI_HSYNC                         = IOMUX_PAD(0x03F4, 0x012C, 2, 0x05F0, 0, 0),
+	MX6_PAD_LCD_DATA05__AUD4_TXFS                         = IOMUX_PAD(0x03F4, 0x012C, 4, 0x0578, 0, 0),
+	MX6_PAD_LCD_DATA05__GPIO2_IO25                        = IOMUX_PAD(0x03F4, 0x012C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__ARM_TRACE05                       = IOMUX_PAD(0x03F4, 0x012C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__SRC_BOOT_CFG05                    = IOMUX_PAD(0x03F4, 0x012C, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA06__LCD_DATA06                        = IOMUX_PAD(0x03F8, 0x0130, 0, 0x06F0, 1, 0),
+	MX6_PAD_LCD_DATA06__ECSPI1_SS3                        = IOMUX_PAD(0x03F8, 0x0130, 1, 0x0618, 0, 0),
+	MX6_PAD_LCD_DATA06__CSI_PIXCLK                        = IOMUX_PAD(0x03F8, 0x0130, 2, 0x05F4, 0, 0),
+	MX6_PAD_LCD_DATA06__AUD4_TXD                          = IOMUX_PAD(0x03F8, 0x0130, 4, 0x0568, 0, 0),
+	MX6_PAD_LCD_DATA06__GPIO2_IO26                        = IOMUX_PAD(0x03F8, 0x0130, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__ARM_TRACE06                       = IOMUX_PAD(0x03F8, 0x0130, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__SRC_BOOT_CFG06                    = IOMUX_PAD(0x03F8, 0x0130, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA07__LCD_DATA07                        = IOMUX_PAD(0x03FC, 0x0134, 0, 0x06F4, 0, 0),
+	MX6_PAD_LCD_DATA07__ECSPI1_RDY                        = IOMUX_PAD(0x03FC, 0x0134, 1, 0x0600, 0, 0),
+	MX6_PAD_LCD_DATA07__CSI_MCLK                          = IOMUX_PAD(0x03FC, 0x0134, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__AUDIO_CLK_OUT                     = IOMUX_PAD(0x03FC, 0x0134, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__GPIO2_IO27                        = IOMUX_PAD(0x03FC, 0x0134, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__ARM_TRACE07                       = IOMUX_PAD(0x03FC, 0x0134, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__SRC_BOOT_CFG07                    = IOMUX_PAD(0x03FC, 0x0134, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA08__LCD_DATA08                        = IOMUX_PAD(0x0400, 0x0138, 0, 0x06F8, 0, 0),
+	MX6_PAD_LCD_DATA08__KEY_COL0                          = IOMUX_PAD(0x0400, 0x0138, 1, 0x06A0, 1, 0),
+	MX6_PAD_LCD_DATA08__CSI_DATA09                        = IOMUX_PAD(0x0400, 0x0138, 2, 0x05EC, 0, 0),
+	MX6_PAD_LCD_DATA08__ECSPI2_SCLK                       = IOMUX_PAD(0x0400, 0x0138, 4, 0x061C, 0, 0),
+	MX6_PAD_LCD_DATA08__GPIO2_IO28                        = IOMUX_PAD(0x0400, 0x0138, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__ARM_TRACE08                       = IOMUX_PAD(0x0400, 0x0138, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__SRC_BOOT_CFG08                    = IOMUX_PAD(0x0400, 0x0138, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA09__LCD_DATA09                        = IOMUX_PAD(0x0404, 0x013C, 0, 0x06FC, 0, 0),
+	MX6_PAD_LCD_DATA09__KEY_ROW0                          = IOMUX_PAD(0x0404, 0x013C, 1, 0x06C0, 1, 0),
+	MX6_PAD_LCD_DATA09__CSI_DATA08                        = IOMUX_PAD(0x0404, 0x013C, 2, 0x05E8, 0, 0),
+	MX6_PAD_LCD_DATA09__ECSPI2_MOSI                       = IOMUX_PAD(0x0404, 0x013C, 4, 0x0624, 0, 0),
+	MX6_PAD_LCD_DATA09__GPIO2_IO29                        = IOMUX_PAD(0x0404, 0x013C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__ARM_TRACE09                       = IOMUX_PAD(0x0404, 0x013C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__SRC_BOOT_CFG09                    = IOMUX_PAD(0x0404, 0x013C, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA10__LCD_DATA10                        = IOMUX_PAD(0x0408, 0x0140, 0, 0x0700, 1, 0),
+	MX6_PAD_LCD_DATA10__KEY_COL1                          = IOMUX_PAD(0x0408, 0x0140, 1, 0x06A4, 1, 0),
+	MX6_PAD_LCD_DATA10__CSI_DATA07                        = IOMUX_PAD(0x0408, 0x0140, 2, 0x05E4, 0, 0),
+	MX6_PAD_LCD_DATA10__ECSPI2_MISO                       = IOMUX_PAD(0x0408, 0x0140, 4, 0x0620, 0, 0),
+	MX6_PAD_LCD_DATA10__GPIO2_IO30                        = IOMUX_PAD(0x0408, 0x0140, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__ARM_TRACE10                       = IOMUX_PAD(0x0408, 0x0140, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__SRC_BOOT_CFG10                    = IOMUX_PAD(0x0408, 0x0140, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA11__LCD_DATA11                        = IOMUX_PAD(0x040C, 0x0144, 0, 0x0704, 0, 0),
+	MX6_PAD_LCD_DATA11__KEY_ROW1                          = IOMUX_PAD(0x040C, 0x0144, 1, 0x06C4, 1, 0),
+	MX6_PAD_LCD_DATA11__CSI_DATA06                        = IOMUX_PAD(0x040C, 0x0144, 2, 0x05E0, 0, 0),
+	MX6_PAD_LCD_DATA11__ECSPI2_SS1                        = IOMUX_PAD(0x040C, 0x0144, 4, 0x062C, 0, 0),
+	MX6_PAD_LCD_DATA11__GPIO2_IO31                        = IOMUX_PAD(0x040C, 0x0144, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__ARM_TRACE11                       = IOMUX_PAD(0x040C, 0x0144, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__SRC_BOOT_CFG11                    = IOMUX_PAD(0x040C, 0x0144, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA12__LCD_DATA12                        = IOMUX_PAD(0x0410, 0x0148, 0, 0x0708, 0, 0),
+	MX6_PAD_LCD_DATA12__KEY_COL2                          = IOMUX_PAD(0x0410, 0x0148, 1, 0x06A8, 1, 0),
+	MX6_PAD_LCD_DATA12__CSI_DATA05                        = IOMUX_PAD(0x0410, 0x0148, 2, 0x05DC, 0, 0),
+	MX6_PAD_LCD_DATA12__UART5_DCE_RTS                     = IOMUX_PAD(0x0410, 0x0148, 4, 0x0760, 0, 0),
+	MX6_PAD_LCD_DATA12__UART5_DTE_CTS                     = IOMUX_PAD(0x0410, 0x0148, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__GPIO3_IO00                        = IOMUX_PAD(0x0410, 0x0148, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__ARM_TRACE12                       = IOMUX_PAD(0x0410, 0x0148, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__SRC_BOOT_CFG12                    = IOMUX_PAD(0x0410, 0x0148, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA13__LCD_DATA13                        = IOMUX_PAD(0x0414, 0x014C, 0, 0x070C, 0, 0),
+	MX6_PAD_LCD_DATA13__KEY_ROW2                          = IOMUX_PAD(0x0414, 0x014C, 1, 0x06C8, 1, 0),
+	MX6_PAD_LCD_DATA13__CSI_DATA04                        = IOMUX_PAD(0x0414, 0x014C, 2, 0x05D8, 0, 0),
+	MX6_PAD_LCD_DATA13__UART5_DCE_CTS                     = IOMUX_PAD(0x0414, 0x014C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__UART5_DTE_RTS                     = IOMUX_PAD(0x0414, 0x014C, 4, 0x0760, 1, 0),
+	MX6_PAD_LCD_DATA13__GPIO3_IO01                        = IOMUX_PAD(0x0414, 0x014C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__ARM_TRACE13                       = IOMUX_PAD(0x0414, 0x014C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__SRC_BOOT_CFG13                    = IOMUX_PAD(0x0414, 0x014C, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA14__LCD_DATA14                        = IOMUX_PAD(0x0418, 0x0150, 0, 0x0710, 0, 0),
+	MX6_PAD_LCD_DATA14__KEY_COL3                          = IOMUX_PAD(0x0418, 0x0150, 1, 0x06AC, 1, 0),
+	MX6_PAD_LCD_DATA14__CSI_DATA03                        = IOMUX_PAD(0x0418, 0x0150, 2, 0x05D4, 0, 0),
+	MX6_PAD_LCD_DATA14__UART5_DCE_RX                      = IOMUX_PAD(0x0418, 0x0150, 4, 0x0764, 0, 0),
+	MX6_PAD_LCD_DATA14__UART5_DTE_TX                      = IOMUX_PAD(0x0418, 0x0150, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__GPIO3_IO02                        = IOMUX_PAD(0x0418, 0x0150, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__ARM_TRACE14                       = IOMUX_PAD(0x0418, 0x0150, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__SRC_BOOT_CFG14                    = IOMUX_PAD(0x0418, 0x0150, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA15__LCD_DATA15                        = IOMUX_PAD(0x041C, 0x0154, 0, 0x0714, 0, 0),
+	MX6_PAD_LCD_DATA15__KEY_ROW3                          = IOMUX_PAD(0x041C, 0x0154, 1, 0x06CC, 0, 0),
+	MX6_PAD_LCD_DATA15__CSI_DATA02                        = IOMUX_PAD(0x041C, 0x0154, 2, 0x05D0, 0, 0),
+	MX6_PAD_LCD_DATA15__UART5_DCE_TX                      = IOMUX_PAD(0x041C, 0x0154, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__UART5_DTE_RX                      = IOMUX_PAD(0x041C, 0x0154, 4, 0x0764, 1, 0),
+	MX6_PAD_LCD_DATA15__GPIO3_IO03                        = IOMUX_PAD(0x041C, 0x0154, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__ARM_TRACE15                       = IOMUX_PAD(0x041C, 0x0154, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__SRC_BOOT_CFG15                    = IOMUX_PAD(0x041C, 0x0154, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA16__LCD_DATA16                        = IOMUX_PAD(0x0420, 0x0158, 0, 0x0718, 0, 0),
+	MX6_PAD_LCD_DATA16__KEY_COL4                          = IOMUX_PAD(0x0420, 0x0158, 1, 0x06B0, 0, 0),
+	MX6_PAD_LCD_DATA16__CSI_DATA01                        = IOMUX_PAD(0x0420, 0x0158, 2, 0x05CC, 0, 0),
+	MX6_PAD_LCD_DATA16__I2C2_SCL                          = IOMUX_PAD(0x0420, 0x0158, IOMUX_CONFIG_SION | 4, 0x0684, 1, 0),
+	MX6_PAD_LCD_DATA16__GPIO3_IO04                        = IOMUX_PAD(0x0420, 0x0158, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__SRC_BOOT_CFG24                    = IOMUX_PAD(0x0420, 0x0158, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA17__LCD_DATA17                        = IOMUX_PAD(0x0424, 0x015C, 0, 0x071C, 0, 0),
+	MX6_PAD_LCD_DATA17__KEY_ROW4                          = IOMUX_PAD(0x0424, 0x015C, 1, 0x06D0, 0, 0),
+	MX6_PAD_LCD_DATA17__CSI_DATA00                        = IOMUX_PAD(0x0424, 0x015C, 2, 0x05C8, 0, 0),
+	MX6_PAD_LCD_DATA17__I2C2_SDA                          = IOMUX_PAD(0x0424, 0x015C, IOMUX_CONFIG_SION | 4, 0x0688, 1, 0),
+	MX6_PAD_LCD_DATA17__GPIO3_IO05                        = IOMUX_PAD(0x0424, 0x015C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__SRC_BOOT_CFG25                    = IOMUX_PAD(0x0424, 0x015C, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA18__LCD_DATA18                        = IOMUX_PAD(0x0428, 0x0160, 0, 0x0720, 0, 0),
+	MX6_PAD_LCD_DATA18__KEY_COL5                          = IOMUX_PAD(0x0428, 0x0160, 1, 0x0694, 2, 0),
+	MX6_PAD_LCD_DATA18__CSI_DATA15                        = IOMUX_PAD(0x0428, 0x0160, 2, 0x05C4, 1, 0),
+	MX6_PAD_LCD_DATA18__GPT_CAPTURE1                      = IOMUX_PAD(0x0428, 0x0160, 4, 0x0670, 1, 0),
+	MX6_PAD_LCD_DATA18__GPIO3_IO06                        = IOMUX_PAD(0x0428, 0x0160, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__SRC_BOOT_CFG26                    = IOMUX_PAD(0x0428, 0x0160, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA19__LCD_DATA19                        = IOMUX_PAD(0x042C, 0x0164, 0, 0x0724, 0, 0),
+	MX6_PAD_LCD_DATA19__KEY_ROW5                          = IOMUX_PAD(0x042C, 0x0164, 1, 0x06B4, 1, 0),
+	MX6_PAD_LCD_DATA19__CSI_DATA14                        = IOMUX_PAD(0x042C, 0x0164, 2, 0x05C0, 2, 0),
+	MX6_PAD_LCD_DATA19__GPT_CAPTURE2                      = IOMUX_PAD(0x042C, 0x0164, 4, 0x0674, 1, 0),
+	MX6_PAD_LCD_DATA19__GPIO3_IO07                        = IOMUX_PAD(0x042C, 0x0164, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__SRC_BOOT_CFG27                    = IOMUX_PAD(0x042C, 0x0164, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA20__LCD_DATA20                        = IOMUX_PAD(0x0430, 0x0168, 0, 0x0728, 0, 0),
+	MX6_PAD_LCD_DATA20__KEY_COL6                          = IOMUX_PAD(0x0430, 0x0168, 1, 0x0698, 1, 0),
+	MX6_PAD_LCD_DATA20__CSI_DATA13                        = IOMUX_PAD(0x0430, 0x0168, 2, 0x05BC, 2, 0),
+	MX6_PAD_LCD_DATA20__GPT_COMPARE1                      = IOMUX_PAD(0x0430, 0x0168, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__GPIO3_IO08                        = IOMUX_PAD(0x0430, 0x0168, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__SRC_BOOT_CFG28                    = IOMUX_PAD(0x0430, 0x0168, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA21__LCD_DATA21                        = IOMUX_PAD(0x0434, 0x016C, 0, 0x072C, 0, 0),
+	MX6_PAD_LCD_DATA21__KEY_ROW6                          = IOMUX_PAD(0x0434, 0x016C, 1, 0x06B8, 1, 0),
+	MX6_PAD_LCD_DATA21__CSI_DATA12                        = IOMUX_PAD(0x0434, 0x016C, 2, 0x05B8, 2, 0),
+	MX6_PAD_LCD_DATA21__GPT_COMPARE2                      = IOMUX_PAD(0x0434, 0x016C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__GPIO3_IO09                        = IOMUX_PAD(0x0434, 0x016C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__SRC_BOOT_CFG29                    = IOMUX_PAD(0x0434, 0x016C, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA22__LCD_DATA22                        = IOMUX_PAD(0x0438, 0x0170, 0, 0x0730, 0, 0),
+	MX6_PAD_LCD_DATA22__KEY_COL7                          = IOMUX_PAD(0x0438, 0x0170, 1, 0x069C, 1, 0),
+	MX6_PAD_LCD_DATA22__CSI_DATA11                        = IOMUX_PAD(0x0438, 0x0170, 2, 0x05B4, 1, 0),
+	MX6_PAD_LCD_DATA22__GPT_COMPARE3                      = IOMUX_PAD(0x0438, 0x0170, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__GPIO3_IO10                        = IOMUX_PAD(0x0438, 0x0170, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__SRC_BOOT_CFG30                    = IOMUX_PAD(0x0438, 0x0170, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA23__LCD_DATA23                        = IOMUX_PAD(0x043C, 0x0174, 0, 0x0734, 0, 0),
+	MX6_PAD_LCD_DATA23__KEY_ROW7                          = IOMUX_PAD(0x043C, 0x0174, 1, 0x06BC, 1, 0),
+	MX6_PAD_LCD_DATA23__CSI_DATA10                        = IOMUX_PAD(0x043C, 0x0174, 2, 0x05B0, 1, 0),
+	MX6_PAD_LCD_DATA23__GPT_CLKIN                         = IOMUX_PAD(0x043C, 0x0174, 4, 0x0678, 1, 0),
+	MX6_PAD_LCD_DATA23__GPIO3_IO11                        = IOMUX_PAD(0x043C, 0x0174, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__SRC_BOOT_CFG31                    = IOMUX_PAD(0x043C, 0x0174, 7, 0x0000, 0, 0),
+
+	MX6_PAD_AUD_RXFS__AUD3_RXFS                           = IOMUX_PAD(0x0440, 0x0178, 0, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXFS__I2C1_SCL                            = IOMUX_PAD(0x0440, 0x0178, IOMUX_CONFIG_SION | 1, 0x067C, 1, 0),
+	MX6_PAD_AUD_RXFS__UART3_DCE_RX                        = IOMUX_PAD(0x0440, 0x0178, 2, 0x0754, 0, 0),
+	MX6_PAD_AUD_RXFS__UART3_DTE_TX                        = IOMUX_PAD(0x0440, 0x0178, 2, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXFS__I2C3_SCL                            = IOMUX_PAD(0x0440, 0x0178, IOMUX_CONFIG_SION | 4, 0x068C, 1, 0),
+	MX6_PAD_AUD_RXFS__GPIO1_IO00                          = IOMUX_PAD(0x0440, 0x0178, 5, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXFS__ECSPI3_SS0                          = IOMUX_PAD(0x0440, 0x0178, 6, 0x0648, 0, 0),
+	MX6_PAD_AUD_RXFS__MBIST_BEND                          = IOMUX_PAD(0x0440, 0x0178, 7, 0x0000, 0, 0),
+
+	MX6_PAD_AUD_RXC__AUD3_RXC                             = IOMUX_PAD(0x0444, 0x017C, 0, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXC__I2C1_SDA                             = IOMUX_PAD(0x0444, 0x017C, IOMUX_CONFIG_SION | 1, 0x0680, 1, 0),
+	MX6_PAD_AUD_RXC__UART3_DCE_TX                         = IOMUX_PAD(0x0444, 0x017C, 2, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXC__UART3_DTE_RX                         = IOMUX_PAD(0x0444, 0x017C, 2, 0x0754, 1, 0),
+	MX6_PAD_AUD_RXC__I2C3_SDA                             = IOMUX_PAD(0x0444, 0x017C, IOMUX_CONFIG_SION | 4, 0x0690, 1, 0),
+	MX6_PAD_AUD_RXC__GPIO1_IO01                           = IOMUX_PAD(0x0444, 0x017C, 5, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXC__ECSPI3_SS1                           = IOMUX_PAD(0x0444, 0x017C, 6, 0x064C, 0, 0),
+
+	MX6_PAD_AUD_RXD__AUD3_RXD                             = IOMUX_PAD(0x0448, 0x0180, 0, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXD__ECSPI3_MOSI                          = IOMUX_PAD(0x0448, 0x0180, 1, 0x063C, 0, 0),
+	MX6_PAD_AUD_RXD__UART4_DCE_RX                         = IOMUX_PAD(0x0448, 0x0180, 2, 0x075C, 0, 0),
+	MX6_PAD_AUD_RXD__UART4_DTE_TX                         = IOMUX_PAD(0x0448, 0x0180, 2, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXD__SD1_LCTL                             = IOMUX_PAD(0x0448, 0x0180, 4, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXD__GPIO1_IO02                           = IOMUX_PAD(0x0448, 0x0180, 5, 0x0000, 0, 0),
+
+	MX6_PAD_AUD_TXC__AUD3_TXC                             = IOMUX_PAD(0x044C, 0x0184, 0, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXC__ECSPI3_MISO                          = IOMUX_PAD(0x044C, 0x0184, 1, 0x0638, 0, 0),
+	MX6_PAD_AUD_TXC__UART4_DCE_TX                         = IOMUX_PAD(0x044C, 0x0184, 2, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXC__UART4_DTE_RX                         = IOMUX_PAD(0x044C, 0x0184, 2, 0x075C, 1, 0),
+	MX6_PAD_AUD_TXC__SD2_LCTL                             = IOMUX_PAD(0x044C, 0x0184, 4, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXC__GPIO1_IO03                           = IOMUX_PAD(0x044C, 0x0184, 5, 0x0000, 0, 0),
+
+	MX6_PAD_AUD_TXFS__AUD3_TXFS                           = IOMUX_PAD(0x0450, 0x0188, 0, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXFS__PWM3_OUT                            = IOMUX_PAD(0x0450, 0x0188, 1, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXFS__UART4_DCE_RTS                       = IOMUX_PAD(0x0450, 0x0188, 2, 0x0758, 0, 0),
+	MX6_PAD_AUD_TXFS__UART4_DTE_CTS                       = IOMUX_PAD(0x0450, 0x0188, 2, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXFS__SD3_LCTL                            = IOMUX_PAD(0x0450, 0x0188, 4, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXFS__GPIO1_IO04                          = IOMUX_PAD(0x0450, 0x0188, 5, 0x0000, 0, 0),
+
+	MX6_PAD_AUD_TXD__AUD3_TXD                             = IOMUX_PAD(0x0454, 0x018C, 0, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXD__ECSPI3_SCLK                          = IOMUX_PAD(0x0454, 0x018C, 1, 0x0630, 0, 0),
+	MX6_PAD_AUD_TXD__UART4_DCE_CTS                        = IOMUX_PAD(0x0454, 0x018C, 2, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXD__UART4_DTE_RTS                        = IOMUX_PAD(0x0454, 0x018C, 2, 0x0758, 1, 0),
+	MX6_PAD_AUD_TXD__GPIO1_IO05                           = IOMUX_PAD(0x0454, 0x018C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_AUD_MCLK__AUDIO_CLK_OUT                       = IOMUX_PAD(0x0458, 0x0190, 0, 0x0000, 0, 0),
+	MX6_PAD_AUD_MCLK__PWM4_OUT                            = IOMUX_PAD(0x0458, 0x0190, 1, 0x0000, 0, 0),
+	MX6_PAD_AUD_MCLK__ECSPI3_RDY                          = IOMUX_PAD(0x0458, 0x0190, 2, 0x0634, 0, 0),
+	MX6_PAD_AUD_MCLK__WDOG2_RESET_B_DEB                   = IOMUX_PAD(0x0458, 0x0190, 4, 0x0000, 0, 0),
+	MX6_PAD_AUD_MCLK__GPIO1_IO06                          = IOMUX_PAD(0x0458, 0x0190, 5, 0x0000, 0, 0),
+	MX6_PAD_AUD_MCLK__SPDIF_EXT_CLK                       = IOMUX_PAD(0x0458, 0x0190, 6, 0x073C, 1, 0),
+
+	MX6_PAD_UART1_RXD__UART1_DCE_RX                       = IOMUX_PAD(0x045C, 0x0194, 0, 0x0744, 0, 0),
+
+	MX6_PAD_UART1_RXD__UART1_DTE_TX                       = IOMUX_PAD(0x045C, 0x0194, 0, 0x0000, 0, 0),
+	MX6_PAD_UART1_RXD__PWM1_OUT                           = IOMUX_PAD(0x045C, 0x0194, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_RXD__UART4_DCE_RX                       = IOMUX_PAD(0x045C, 0x0194, 2, 0x075C, 4, 0),
+	MX6_PAD_UART1_RXD__UART4_DTE_TX                       = IOMUX_PAD(0x045C, 0x0194, 2, 0x0000, 0, 0),
+	MX6_PAD_UART1_RXD__UART5_DCE_RX                       = IOMUX_PAD(0x045C, 0x0194, 4, 0x0764, 6, 0),
+	MX6_PAD_UART1_RXD__UART5_DTE_TX                       = IOMUX_PAD(0x045C, 0x0194, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_RXD__GPIO3_IO16                         = IOMUX_PAD(0x045C, 0x0194, 5, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_TXD__UART1_DCE_TX                       = IOMUX_PAD(0x0460, 0x0198, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_TXD__UART1_DTE_RX                       = IOMUX_PAD(0x0460, 0x0198, 0, 0x0744, 1, 0),
+	MX6_PAD_UART1_TXD__PWM2_OUT                           = IOMUX_PAD(0x0460, 0x0198, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_TXD__UART4_DCE_TX                       = IOMUX_PAD(0x0460, 0x0198, 2, 0x0000, 0, 0),
+	MX6_PAD_UART1_TXD__UART4_DTE_RX                       = IOMUX_PAD(0x0460, 0x0198, 2, 0x075C, 5, 0),
+	MX6_PAD_UART1_TXD__UART5_DCE_TX                       = IOMUX_PAD(0x0460, 0x0198, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_TXD__UART5_DTE_RX                       = IOMUX_PAD(0x0460, 0x0198, 4, 0x0764, 7, 0),
+	MX6_PAD_UART1_TXD__GPIO3_IO17                         = IOMUX_PAD(0x0460, 0x0198, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_TXD__UART5_DCD_B                        = IOMUX_PAD(0x0460, 0x0198, 7, 0x0000, 0, 0),
+
+	MX6_PAD_I2C1_SCL__I2C1_SCL                            = IOMUX_PAD(0x0464, 0x019C, IOMUX_CONFIG_SION | 0, 0x067C, 0, 0),
+	MX6_PAD_I2C1_SCL__UART1_DCE_RTS                       = IOMUX_PAD(0x0464, 0x019C, 1, 0x0740, 0, 0),
+	MX6_PAD_I2C1_SCL__UART1_DTE_CTS                       = IOMUX_PAD(0x0464, 0x019C, 1, 0x0000, 0, 0),
+	MX6_PAD_I2C1_SCL__ECSPI3_SS2                          = IOMUX_PAD(0x0464, 0x019C, 2, 0x0640, 0, 0),
+	MX6_PAD_I2C1_SCL__SD3_RESET                           = IOMUX_PAD(0x0464, 0x019C, 4, 0x0000, 0, 0),
+	MX6_PAD_I2C1_SCL__GPIO3_IO12                          = IOMUX_PAD(0x0464, 0x019C, 5, 0x0000, 0, 0),
+	MX6_PAD_I2C1_SCL__ECSPI1_SS1                          = IOMUX_PAD(0x0464, 0x019C, 6, 0x060C, 0, 0),
+
+	MX6_PAD_I2C1_SDA__I2C1_SDA                            = IOMUX_PAD(0x0468, 0x01A0, IOMUX_CONFIG_SION | 0, 0x0680, 0, 0),
+	MX6_PAD_I2C1_SDA__UART1_DCE_CTS                       = IOMUX_PAD(0x0468, 0x01A0, 1, 0x0000, 0, 0),
+	MX6_PAD_I2C1_SDA__UART1_DTE_RTS                       = IOMUX_PAD(0x0468, 0x01A0, 1, 0x0740, 1, 0),
+	MX6_PAD_I2C1_SDA__ECSPI3_SS3                          = IOMUX_PAD(0x0468, 0x01A0, 2, 0x0644, 0, 0),
+	MX6_PAD_I2C1_SDA__SD3_VSELECT                         = IOMUX_PAD(0x0468, 0x01A0, 4, 0x0000, 0, 0),
+	MX6_PAD_I2C1_SDA__GPIO3_IO13                          = IOMUX_PAD(0x0468, 0x01A0, 5, 0x0000, 0, 0),
+	MX6_PAD_I2C1_SDA__ECSPI1_SS2                          = IOMUX_PAD(0x0468, 0x01A0, 6, 0x0610, 0, 0),
+
+	MX6_PAD_I2C2_SCL__I2C2_SCL                            = IOMUX_PAD(0x046C, 0x01A4, IOMUX_CONFIG_SION | 0, 0x0684, 3, 0),
+	MX6_PAD_I2C2_SCL__AUD4_RXFS                           = IOMUX_PAD(0x046C, 0x01A4, 1, 0x0570, 2, 0),
+	MX6_PAD_I2C2_SCL__SPDIF_IN                            = IOMUX_PAD(0x046C, 0x01A4, 2, 0x0738, 2, 0),
+	MX6_PAD_I2C2_SCL__SD3_WP                              = IOMUX_PAD(0x046C, 0x01A4, 4, 0x0794, 3, 0),
+	MX6_PAD_I2C2_SCL__GPIO3_IO14                          = IOMUX_PAD(0x046C, 0x01A4, 5, 0x0000, 0, 0),
+	MX6_PAD_I2C2_SCL__ECSPI1_RDY                          = IOMUX_PAD(0x046C, 0x01A4, 6, 0x0600, 1, 0),
+
+	MX6_PAD_I2C2_SDA__I2C2_SDA                            = IOMUX_PAD(0x0470, 0x01A8, IOMUX_CONFIG_SION | 0, 0x0688, 3, 0),
+	MX6_PAD_I2C2_SDA__AUD4_RXC                            = IOMUX_PAD(0x0470, 0x01A8, 1, 0x056C, 2, 0),
+	MX6_PAD_I2C2_SDA__SPDIF_OUT                           = IOMUX_PAD(0x0470, 0x01A8, 2, 0x0000, 0, 0),
+	MX6_PAD_I2C2_SDA__SD3_CD_B                            = IOMUX_PAD(0x0470, 0x01A8, 4, 0x0780, 3, 0),
+	MX6_PAD_I2C2_SDA__GPIO3_IO15                          = IOMUX_PAD(0x0470, 0x01A8, 5, 0x0000, 0, 0),
+
+	MX6_PAD_ECSPI1_SCLK__ECSPI1_SCLK                      = IOMUX_PAD(0x0474, 0x01AC, 0, 0x05FC, 1, 0),
+	MX6_PAD_ECSPI1_SCLK__AUD4_TXD                         = IOMUX_PAD(0x0474, 0x01AC, 1, 0x0568, 1, 0),
+	MX6_PAD_ECSPI1_SCLK__UART5_DCE_RX                     = IOMUX_PAD(0x0474, 0x01AC, 2, 0x0764, 2, 0),
+	MX6_PAD_ECSPI1_SCLK__UART5_DTE_TX                     = IOMUX_PAD(0x0474, 0x01AC, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_SCLK__EPDC_VCOM0                       = IOMUX_PAD(0x0474, 0x01AC, 3, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_SCLK__SD2_RESET                        = IOMUX_PAD(0x0474, 0x01AC, 4, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_SCLK__GPIO4_IO08                       = IOMUX_PAD(0x0474, 0x01AC, 5, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_SCLK__USB_OTG2_OC                      = IOMUX_PAD(0x0474, 0x01AC, 6, 0x0768, 1, 0),
+
+	MX6_PAD_ECSPI1_MOSI__ECSPI1_MOSI                      = IOMUX_PAD(0x0478, 0x01B0, 0, 0x0608, 1, 0),
+	MX6_PAD_ECSPI1_MOSI__AUD4_TXC                         = IOMUX_PAD(0x0478, 0x01B0, 1, 0x0574, 1, 0),
+	MX6_PAD_ECSPI1_MOSI__UART5_DCE_TX                     = IOMUX_PAD(0x0478, 0x01B0, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_MOSI__UART5_DTE_RX                     = IOMUX_PAD(0x0478, 0x01B0, 2, 0x0764, 3, 0),
+	MX6_PAD_ECSPI1_MOSI__EPDC_VCOM1                       = IOMUX_PAD(0x0478, 0x01B0, 3, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_MOSI__SD2_VSELECT                      = IOMUX_PAD(0x0478, 0x01B0, 4, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_MOSI__GPIO4_IO09                       = IOMUX_PAD(0x0478, 0x01B0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_ECSPI1_MISO__ECSPI1_MISO                      = IOMUX_PAD(0x047C, 0x01B4, 0, 0x0604, 1, 0),
+	MX6_PAD_ECSPI1_MISO__AUD4_TXFS                        = IOMUX_PAD(0x047C, 0x01B4, 1, 0x0578, 1, 0),
+	MX6_PAD_ECSPI1_MISO__UART5_DCE_RTS                    = IOMUX_PAD(0x047C, 0x01B4, 2, 0x0760, 2, 0),
+	MX6_PAD_ECSPI1_MISO__UART5_DTE_CTS                    = IOMUX_PAD(0x047C, 0x01B4, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_MISO__EPDC_BDR0                        = IOMUX_PAD(0x047C, 0x01B4, 3, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_MISO__SD2_WP                           = IOMUX_PAD(0x047C, 0x01B4, 4, 0x077C, 0, 0),
+	MX6_PAD_ECSPI1_MISO__GPIO4_IO10                       = IOMUX_PAD(0x047C, 0x01B4, 5, 0x0000, 0, 0),
+
+	MX6_PAD_ECSPI1_SS0__ECSPI1_SS0                        = IOMUX_PAD(0x0480, 0x01B8, 0, 0x0614, 1, 0),
+	MX6_PAD_ECSPI1_SS0__AUD4_RXD                          = IOMUX_PAD(0x0480, 0x01B8, 1, 0x0564, 1, 0),
+	MX6_PAD_ECSPI1_SS0__UART5_DCE_CTS                     = IOMUX_PAD(0x0480, 0x01B8, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_SS0__UART5_DTE_RTS                     = IOMUX_PAD(0x0480, 0x01B8, 2, 0x0760, 3, 0),
+	MX6_PAD_ECSPI1_SS0__EPDC_BDR1                         = IOMUX_PAD(0x0480, 0x01B8, 3, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_SS0__SD2_CD_B                          = IOMUX_PAD(0x0480, 0x01B8, 4, 0x0778, 0, 0),
+	MX6_PAD_ECSPI1_SS0__GPIO4_IO11                        = IOMUX_PAD(0x0480, 0x01B8, 5, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_SS0__USB_OTG2_PWR                      = IOMUX_PAD(0x0480, 0x01B8, 6, 0x0000, 0, 0),
+
+	MX6_PAD_ECSPI2_SCLK__ECSPI2_SCLK                      = IOMUX_PAD(0x0484, 0x01BC, 0, 0x061C, 1, 0),
+	MX6_PAD_ECSPI2_SCLK__SPDIF_EXT_CLK                    = IOMUX_PAD(0x0484, 0x01BC, 1, 0x073C, 2, 0),
+	MX6_PAD_ECSPI2_SCLK__UART3_DCE_RX                     = IOMUX_PAD(0x0484, 0x01BC, 2, 0x0754, 2, 0),
+	MX6_PAD_ECSPI2_SCLK__UART3_DTE_TX                     = IOMUX_PAD(0x0484, 0x01BC, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_SCLK__CSI_PIXCLK                       = IOMUX_PAD(0x0484, 0x01BC, 3, 0x05F4, 1, 0),
+	MX6_PAD_ECSPI2_SCLK__SD1_RESET                        = IOMUX_PAD(0x0484, 0x01BC, 4, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_SCLK__GPIO4_IO12                       = IOMUX_PAD(0x0484, 0x01BC, 5, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_SCLK__USB_OTG2_OC                      = IOMUX_PAD(0x0484, 0x01BC, 6, 0x0768, 2, 0),
+
+	MX6_PAD_ECSPI2_MOSI__ECSPI2_MOSI                      = IOMUX_PAD(0x0488, 0x01C0, 0, 0x0624, 1, 0),
+	MX6_PAD_ECSPI2_MOSI__SDMA_EXT_EVENT1                  = IOMUX_PAD(0x0488, 0x01C0, 1, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_MOSI__UART3_DCE_TX                     = IOMUX_PAD(0x0488, 0x01C0, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_MOSI__UART3_DTE_RX                     = IOMUX_PAD(0x0488, 0x01C0, 2, 0x0754, 3, 0),
+	MX6_PAD_ECSPI2_MOSI__CSI_HSYNC                        = IOMUX_PAD(0x0488, 0x01C0, 3, 0x05F0, 1, 0),
+	MX6_PAD_ECSPI2_MOSI__SD1_VSELECT                      = IOMUX_PAD(0x0488, 0x01C0, 4, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_MOSI__GPIO4_IO13                       = IOMUX_PAD(0x0488, 0x01C0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_ECSPI2_MISO__ECSPI2_MISO                      = IOMUX_PAD(0x048C, 0x01C4, 0, 0x0620, 1, 0),
+	MX6_PAD_ECSPI2_MISO__SDMA_EXT_EVENT0                  = IOMUX_PAD(0x048C, 0x01C4, 1, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_MISO__UART3_DCE_RTS                    = IOMUX_PAD(0x048C, 0x01C4, 2, 0x0750, 0, 0),
+	MX6_PAD_ECSPI2_MISO__UART3_DTE_CTS                    = IOMUX_PAD(0x048C, 0x01C4, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_MISO__CSI_MCLK                         = IOMUX_PAD(0x048C, 0x01C4, 3, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_MISO__SD1_WP                           = IOMUX_PAD(0x048C, 0x01C4, 4, 0x0774, 2, 0),
+	MX6_PAD_ECSPI2_MISO__GPIO4_IO14                       = IOMUX_PAD(0x048C, 0x01C4, 5, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_MISO__USB_OTG1_OC                      = IOMUX_PAD(0x048C, 0x01C4, 6, 0x076C, 1, 0),
+
+	MX6_PAD_ECSPI2_SS0__ECSPI2_SS0                        = IOMUX_PAD(0x0490, 0x01C8, 0, 0x0628, 0, 0),
+	MX6_PAD_ECSPI2_SS0__ECSPI1_SS3                        = IOMUX_PAD(0x0490, 0x01C8, 1, 0x0618, 1, 0),
+	MX6_PAD_ECSPI2_SS0__UART3_DCE_CTS                     = IOMUX_PAD(0x0490, 0x01C8, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_SS0__UART3_DTE_RTS                     = IOMUX_PAD(0x0490, 0x01C8, 2, 0x0750, 1, 0),
+	MX6_PAD_ECSPI2_SS0__CSI_VSYNC                         = IOMUX_PAD(0x0490, 0x01C8, 3, 0x05F8, 1, 0),
+	MX6_PAD_ECSPI2_SS0__SD1_CD_B                          = IOMUX_PAD(0x0490, 0x01C8, 4, 0x0770, 2, 0),
+	MX6_PAD_ECSPI2_SS0__GPIO4_IO15                        = IOMUX_PAD(0x0490, 0x01C8, 5, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_SS0__USB_OTG1_PWR                      = IOMUX_PAD(0x0490, 0x01C8, 6, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_CLK__SD1_CLK                              = IOMUX_PAD(0x0494, 0x01CC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__KEY_COL0                             = IOMUX_PAD(0x0494, 0x01CC, 2, 0x06A0, 2, 0),
+	MX6_PAD_SD1_CLK__EPDC_SDCE4                           = IOMUX_PAD(0x0494, 0x01CC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__GPIO5_IO15                           = IOMUX_PAD(0x0494, 0x01CC, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_CMD__SD1_CMD                              = IOMUX_PAD(0x0498, 0x01D0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__KEY_ROW0                             = IOMUX_PAD(0x0498, 0x01D0, 2, 0x06C0, 2, 0),
+	MX6_PAD_SD1_CMD__EPDC_SDCE5                           = IOMUX_PAD(0x0498, 0x01D0, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__GPIO5_IO14                           = IOMUX_PAD(0x0498, 0x01D0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA0__SD1_DATA0                          = IOMUX_PAD(0x049C, 0x01D4, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__KEY_COL1                           = IOMUX_PAD(0x049C, 0x01D4, 2, 0x06A4, 2, 0),
+	MX6_PAD_SD1_DATA0__EPDC_SDCE6                         = IOMUX_PAD(0x049C, 0x01D4, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__GPIO5_IO11                         = IOMUX_PAD(0x049C, 0x01D4, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA1__SD1_DATA1                          = IOMUX_PAD(0x04A0, 0x01D8, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__KEY_ROW1                           = IOMUX_PAD(0x04A0, 0x01D8, 2, 0x06C4, 2, 0),
+	MX6_PAD_SD1_DATA1__EPDC_SDCE7                         = IOMUX_PAD(0x04A0, 0x01D8, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__GPIO5_IO08                         = IOMUX_PAD(0x04A0, 0x01D8, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA2__SD1_DATA2                          = IOMUX_PAD(0x04A4, 0x01DC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__KEY_COL2                           = IOMUX_PAD(0x04A4, 0x01DC, 2, 0x06A8, 2, 0),
+	MX6_PAD_SD1_DATA2__EPDC_SDCE8                         = IOMUX_PAD(0x04A4, 0x01DC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__GPIO5_IO13                         = IOMUX_PAD(0x04A4, 0x01DC, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA3__SD1_DATA3                          = IOMUX_PAD(0x04A8, 0x01E0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__KEY_ROW2                           = IOMUX_PAD(0x04A8, 0x01E0, 2, 0x06C8, 2, 0),
+	MX6_PAD_SD1_DATA3__EPDC_SDCE9                         = IOMUX_PAD(0x04A8, 0x01E0, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__GPIO5_IO06                         = IOMUX_PAD(0x04A8, 0x01E0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA4__SD1_DATA4                          = IOMUX_PAD(0x04AC, 0x01E4, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA4__KEY_COL3                           = IOMUX_PAD(0x04AC, 0x01E4, 2, 0x06AC, 2, 0),
+	MX6_PAD_SD1_DATA4__EPDC_SDCLK_N                       = IOMUX_PAD(0x04AC, 0x01E4, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA4__UART4_DCE_RX                       = IOMUX_PAD(0x04AC, 0x01E4, 4, 0x075C, 6, 0),
+	MX6_PAD_SD1_DATA4__UART4_DTE_TX                       = IOMUX_PAD(0x04AC, 0x01E4, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA4__GPIO5_IO12                         = IOMUX_PAD(0x04AC, 0x01E4, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA5__SD1_DATA5                          = IOMUX_PAD(0x04B0, 0x01E8, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA5__KEY_ROW3                           = IOMUX_PAD(0x04B0, 0x01E8, 2, 0x06CC, 2, 0),
+	MX6_PAD_SD1_DATA5__EPDC_SDOED                         = IOMUX_PAD(0x04B0, 0x01E8, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA5__UART4_DCE_TX                       = IOMUX_PAD(0x04B0, 0x01E8, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA5__UART4_DTE_RX                       = IOMUX_PAD(0x04B0, 0x01E8, 4, 0x075C, 7, 0),
+	MX6_PAD_SD1_DATA5__GPIO5_IO09                         = IOMUX_PAD(0x04B0, 0x01E8, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA6__SD1_DATA6                          = IOMUX_PAD(0x04B4, 0x01EC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA6__KEY_COL4                           = IOMUX_PAD(0x04B4, 0x01EC, 2, 0x06B0, 2, 0),
+	MX6_PAD_SD1_DATA6__EPDC_SDOEZ                         = IOMUX_PAD(0x04B4, 0x01EC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA6__UART4_DCE_RTS                      = IOMUX_PAD(0x04B4, 0x01EC, 4, 0x0758, 4, 0),
+	MX6_PAD_SD1_DATA6__UART4_DTE_CTS                      = IOMUX_PAD(0x04B4, 0x01EC, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA6__GPIO5_IO07                         = IOMUX_PAD(0x04B4, 0x01EC, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA7__SD1_DATA7                          = IOMUX_PAD(0x04B8, 0x01F0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA7__KEY_ROW4                           = IOMUX_PAD(0x04B8, 0x01F0, 2, 0x06D0, 2, 0),
+	MX6_PAD_SD1_DATA7__CCM_PMIC_READY                     = IOMUX_PAD(0x04B8, 0x01F0, 3, 0x05AC, 3, 0),
+	MX6_PAD_SD1_DATA7__UART4_DCE_CTS                      = IOMUX_PAD(0x04B8, 0x01F0, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA7__UART4_DTE_RTS                      = IOMUX_PAD(0x04B8, 0x01F0, 4, 0x0758, 5, 0),
+	MX6_PAD_SD1_DATA7__GPIO5_IO10                         = IOMUX_PAD(0x04B8, 0x01F0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_RESET__SD2_RESET                          = IOMUX_PAD(0x04BC, 0x01F4, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_RESET__WDOG2_B                            = IOMUX_PAD(0x04BC, 0x01F4, 2, 0x0000, 0, 0),
+	MX6_PAD_SD2_RESET__SPDIF_OUT                          = IOMUX_PAD(0x04BC, 0x01F4, 3, 0x0000, 0, 0),
+	MX6_PAD_SD2_RESET__CSI_MCLK                           = IOMUX_PAD(0x04BC, 0x01F4, 4, 0x0000, 0, 0),
+	MX6_PAD_SD2_RESET__GPIO4_IO27                         = IOMUX_PAD(0x04BC, 0x01F4, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_CLK__SD2_CLK                              = IOMUX_PAD(0x04C0, 0x01F8, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_CLK__AUD4_RXFS                            = IOMUX_PAD(0x04C0, 0x01F8, 1, 0x0570, 1, 0),
+	MX6_PAD_SD2_CLK__ECSPI3_SCLK                          = IOMUX_PAD(0x04C0, 0x01F8, 2, 0x0630, 1, 0),
+	MX6_PAD_SD2_CLK__CSI_DATA00                           = IOMUX_PAD(0x04C0, 0x01F8, 3, 0x05C8, 1, 0),
+	MX6_PAD_SD2_CLK__GPIO5_IO05                           = IOMUX_PAD(0x04C0, 0x01F8, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_CMD__SD2_CMD                              = IOMUX_PAD(0x04C4, 0x01FC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_CMD__AUD4_RXC                             = IOMUX_PAD(0x04C4, 0x01FC, 1, 0x056C, 1, 0),
+	MX6_PAD_SD2_CMD__ECSPI3_SS0                           = IOMUX_PAD(0x04C4, 0x01FC, 2, 0x0648, 1, 0),
+	MX6_PAD_SD2_CMD__CSI_DATA01                           = IOMUX_PAD(0x04C4, 0x01FC, 3, 0x05CC, 1, 0),
+	MX6_PAD_SD2_CMD__EPIT1_OUT                            = IOMUX_PAD(0x04C4, 0x01FC, 4, 0x0000, 0, 0),
+	MX6_PAD_SD2_CMD__GPIO5_IO04                           = IOMUX_PAD(0x04C4, 0x01FC, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA0__SD2_DATA0                          = IOMUX_PAD(0x04C8, 0x0200, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA0__AUD4_RXD                           = IOMUX_PAD(0x04C8, 0x0200, 1, 0x0564, 2, 0),
+	MX6_PAD_SD2_DATA0__ECSPI3_MOSI                        = IOMUX_PAD(0x04C8, 0x0200, 2, 0x063C, 1, 0),
+	MX6_PAD_SD2_DATA0__CSI_DATA02                         = IOMUX_PAD(0x04C8, 0x0200, 3, 0x05D0, 1, 0),
+	MX6_PAD_SD2_DATA0__UART5_DCE_RTS                      = IOMUX_PAD(0x04C8, 0x0200, 4, 0x0760, 4, 0),
+	MX6_PAD_SD2_DATA0__UART5_DTE_CTS                      = IOMUX_PAD(0x04C8, 0x0200, 4, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA0__GPIO5_IO01                         = IOMUX_PAD(0x04C8, 0x0200, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA1__SD2_DATA1                          = IOMUX_PAD(0x04CC, 0x0204, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA1__AUD4_TXC                           = IOMUX_PAD(0x04CC, 0x0204, 1, 0x0574, 2, 0),
+	MX6_PAD_SD2_DATA1__ECSPI3_MISO                        = IOMUX_PAD(0x04CC, 0x0204, 2, 0x0638, 1, 0),
+	MX6_PAD_SD2_DATA1__CSI_DATA03                         = IOMUX_PAD(0x04CC, 0x0204, 3, 0x05D4, 1, 0),
+	MX6_PAD_SD2_DATA1__UART5_DCE_CTS                      = IOMUX_PAD(0x04CC, 0x0204, 4, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA1__UART5_DTE_RTS                      = IOMUX_PAD(0x04CC, 0x0204, 4, 0x0760, 5, 0),
+	MX6_PAD_SD2_DATA1__GPIO4_IO30                         = IOMUX_PAD(0x04CC, 0x0204, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA2__SD2_DATA2                          = IOMUX_PAD(0x04D0, 0x0208, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA2__AUD4_TXFS                          = IOMUX_PAD(0x04D0, 0x0208, 1, 0x0578, 2, 0),
+	MX6_PAD_SD2_DATA2__CSI_DATA04                         = IOMUX_PAD(0x04D0, 0x0208, 3, 0x05D8, 1, 0),
+	MX6_PAD_SD2_DATA2__UART5_DCE_RX                       = IOMUX_PAD(0x04D0, 0x0208, 4, 0x0764, 4, 0),
+	MX6_PAD_SD2_DATA2__UART5_DTE_TX                       = IOMUX_PAD(0x04D0, 0x0208, 4, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA2__GPIO5_IO03                         = IOMUX_PAD(0x04D0, 0x0208, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA3__SD2_DATA3                          = IOMUX_PAD(0x04D4, 0x020C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA3__AUD4_TXD                           = IOMUX_PAD(0x04D4, 0x020C, 1, 0x0568, 2, 0),
+	MX6_PAD_SD2_DATA3__CSI_DATA05                         = IOMUX_PAD(0x04D4, 0x020C, 3, 0x05DC, 1, 0),
+	MX6_PAD_SD2_DATA3__UART5_DCE_TX                       = IOMUX_PAD(0x04D4, 0x020C, 4, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA3__UART5_DTE_RX                       = IOMUX_PAD(0x04D4, 0x020C, 4, 0x0764, 5, 0),
+	MX6_PAD_SD2_DATA3__GPIO4_IO28                         = IOMUX_PAD(0x04D4, 0x020C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA4__SD2_DATA4                          = IOMUX_PAD(0x04D8, 0x0210, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA4__SD3_DATA4                          = IOMUX_PAD(0x04D8, 0x0210, 1, 0x0784, 1, 0),
+	MX6_PAD_SD2_DATA4__UART2_DCE_RX                       = IOMUX_PAD(0x04D8, 0x0210, 2, 0x074C, 2, 0),
+	MX6_PAD_SD2_DATA4__UART2_DTE_TX                       = IOMUX_PAD(0x04D8, 0x0210, 2, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA4__CSI_DATA06                         = IOMUX_PAD(0x04D8, 0x0210, 3, 0x05E0, 1, 0),
+	MX6_PAD_SD2_DATA4__SPDIF_OUT                          = IOMUX_PAD(0x04D8, 0x0210, 4, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA4__GPIO5_IO02                         = IOMUX_PAD(0x04D8, 0x0210, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA5__SD2_DATA5                          = IOMUX_PAD(0x04DC, 0x0214, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA5__SD3_DATA5                          = IOMUX_PAD(0x04DC, 0x0214, 1, 0x0788, 1, 0),
+	MX6_PAD_SD2_DATA5__UART2_DCE_TX                       = IOMUX_PAD(0x04DC, 0x0214, 2, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA5__UART2_DTE_RX                       = IOMUX_PAD(0x04DC, 0x0214, 2, 0x074C, 3, 0),
+	MX6_PAD_SD2_DATA5__CSI_DATA07                         = IOMUX_PAD(0x04DC, 0x0214, 3, 0x05E4, 1, 0),
+	MX6_PAD_SD2_DATA5__SPDIF_IN                           = IOMUX_PAD(0x04DC, 0x0214, 4, 0x0738, 1, 0),
+	MX6_PAD_SD2_DATA5__GPIO4_IO31                         = IOMUX_PAD(0x04DC, 0x0214, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA6__SD2_DATA6                          = IOMUX_PAD(0x04E0, 0x0218, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA6__SD3_DATA6                          = IOMUX_PAD(0x04E0, 0x0218, 1, 0x078C, 1, 0),
+	MX6_PAD_SD2_DATA6__UART2_DCE_RTS                      = IOMUX_PAD(0x04E0, 0x0218, 2, 0x0748, 2, 0),
+	MX6_PAD_SD2_DATA6__UART2_DTE_CTS                      = IOMUX_PAD(0x04E0, 0x0218, 2, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA6__CSI_DATA08                         = IOMUX_PAD(0x04E0, 0x0218, 3, 0x05E8, 1, 0),
+	MX6_PAD_SD2_DATA6__SD2_WP                             = IOMUX_PAD(0x04E0, 0x0218, 4, 0x077C, 1, 0),
+	MX6_PAD_SD2_DATA6__GPIO4_IO29                         = IOMUX_PAD(0x04E0, 0x0218, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA7__SD2_DATA7                          = IOMUX_PAD(0x04E4, 0x021C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA7__SD3_DATA7                          = IOMUX_PAD(0x04E4, 0x021C, 1, 0x0790, 1, 0),
+	MX6_PAD_SD2_DATA7__UART2_DCE_CTS                      = IOMUX_PAD(0x04E4, 0x021C, 2, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA7__UART2_DTE_RTS                      = IOMUX_PAD(0x04E4, 0x021C, 2, 0x0748, 3, 0),
+	MX6_PAD_SD2_DATA7__CSI_DATA09                         = IOMUX_PAD(0x04E4, 0x021C, 3, 0x05EC, 1, 0),
+	MX6_PAD_SD2_DATA7__SD2_CD_B                           = IOMUX_PAD(0x04E4, 0x021C, 4, 0x0778, 1, 0),
+	MX6_PAD_SD2_DATA7__GPIO5_IO00                         = IOMUX_PAD(0x04E4, 0x021C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD3_CLK__SD3_CLK                              = IOMUX_PAD(0x04E8, 0x0220, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_CLK__AUD5_RXFS                            = IOMUX_PAD(0x04E8, 0x0220, 1, 0x0588, 0, 0),
+	MX6_PAD_SD3_CLK__KEY_COL5                             = IOMUX_PAD(0x04E8, 0x0220, 2, 0x0694, 0, 0),
+	MX6_PAD_SD3_CLK__CSI_DATA10                           = IOMUX_PAD(0x04E8, 0x0220, 3, 0x05B0, 0, 0),
+	MX6_PAD_SD3_CLK__WDOG1_RESET_B_DEB                    = IOMUX_PAD(0x04E8, 0x0220, 4, 0x0000, 0, 0),
+	MX6_PAD_SD3_CLK__GPIO5_IO18                           = IOMUX_PAD(0x04E8, 0x0220, 5, 0x0000, 0, 0),
+	MX6_PAD_SD3_CLK__USB_OTG1_PWR                         = IOMUX_PAD(0x04E8, 0x0220, 6, 0x0000, 0, 0),
+
+	MX6_PAD_SD3_CMD__SD3_CMD                              = IOMUX_PAD(0x04EC, 0x0224, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_CMD__AUD5_RXC                             = IOMUX_PAD(0x04EC, 0x0224, 1, 0x0584, 0, 0),
+	MX6_PAD_SD3_CMD__KEY_ROW5                             = IOMUX_PAD(0x04EC, 0x0224, 2, 0x06B4, 0, 0),
+	MX6_PAD_SD3_CMD__CSI_DATA11                           = IOMUX_PAD(0x04EC, 0x0224, 3, 0x05B4, 0, 0),
+	MX6_PAD_SD3_CMD__USB_OTG2_ID                          = IOMUX_PAD(0x04EC, 0x0224, 4, 0x0560, 1, 0),
+	MX6_PAD_SD3_CMD__GPIO5_IO21                           = IOMUX_PAD(0x04EC, 0x0224, 5, 0x0000, 0, 0),
+	MX6_PAD_SD3_CMD__USB_OTG2_PWR                         = IOMUX_PAD(0x04EC, 0x0224, 6, 0x0000, 0, 0),
+
+	MX6_PAD_SD3_DATA0__SD3_DATA0                          = IOMUX_PAD(0x04F0, 0x0228, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA0__AUD5_RXD                           = IOMUX_PAD(0x04F0, 0x0228, 1, 0x057C, 0, 0),
+	MX6_PAD_SD3_DATA0__KEY_COL6                           = IOMUX_PAD(0x04F0, 0x0228, 2, 0x0698, 0, 0),
+	MX6_PAD_SD3_DATA0__CSI_DATA12                         = IOMUX_PAD(0x04F0, 0x0228, 3, 0x05B8, 0, 0),
+	MX6_PAD_SD3_DATA0__USB_OTG1_ID                        = IOMUX_PAD(0x04F0, 0x0228, 4, 0x055C, 1, 0),
+	MX6_PAD_SD3_DATA0__GPIO5_IO19                         = IOMUX_PAD(0x04F0, 0x0228, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD3_DATA1__SD3_DATA1                          = IOMUX_PAD(0x04F4, 0x022C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA1__AUD5_TXC                           = IOMUX_PAD(0x04F4, 0x022C, 1, 0x058C, 0, 0),
+	MX6_PAD_SD3_DATA1__KEY_ROW6                           = IOMUX_PAD(0x04F4, 0x022C, 2, 0x06B8, 0, 0),
+	MX6_PAD_SD3_DATA1__CSI_DATA13                         = IOMUX_PAD(0x04F4, 0x022C, 3, 0x05BC, 0, 0),
+	MX6_PAD_SD3_DATA1__SD1_VSELECT                        = IOMUX_PAD(0x04F4, 0x022C, 4, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA1__GPIO5_IO20                         = IOMUX_PAD(0x04F4, 0x022C, 5, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA1__JTAG_DE_B                          = IOMUX_PAD(0x04F4, 0x022C, 6, 0x0000, 0, 0),
+
+	MX6_PAD_SD3_DATA2__SD3_DATA2                          = IOMUX_PAD(0x04F8, 0x0230, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA2__AUD5_TXFS                          = IOMUX_PAD(0x04F8, 0x0230, 1, 0x0590, 0, 0),
+	MX6_PAD_SD3_DATA2__KEY_COL7                           = IOMUX_PAD(0x04F8, 0x0230, 2, 0x069C, 0, 0),
+	MX6_PAD_SD3_DATA2__CSI_DATA14                         = IOMUX_PAD(0x04F8, 0x0230, 3, 0x05C0, 0, 0),
+	MX6_PAD_SD3_DATA2__EPIT1_OUT                          = IOMUX_PAD(0x04F8, 0x0230, 4, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA2__GPIO5_IO16                         = IOMUX_PAD(0x04F8, 0x0230, 5, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA2__USB_OTG2_OC                        = IOMUX_PAD(0x04F8, 0x0230, 6, 0x0768, 0, 0),
+
+	MX6_PAD_SD3_DATA3__SD3_DATA3                          = IOMUX_PAD(0x04FC, 0x0234, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA3__AUD5_TXD                           = IOMUX_PAD(0x04FC, 0x0234, 1, 0x0580, 0, 0),
+	MX6_PAD_SD3_DATA3__KEY_ROW7                           = IOMUX_PAD(0x04FC, 0x0234, 2, 0x06BC, 0, 0),
+	MX6_PAD_SD3_DATA3__CSI_DATA15                         = IOMUX_PAD(0x04FC, 0x0234, 3, 0x05C4, 0, 0),
+	MX6_PAD_SD3_DATA3__EPIT2_OUT                          = IOMUX_PAD(0x04FC, 0x0234, 4, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA3__GPIO5_IO17                         = IOMUX_PAD(0x04FC, 0x0234, 5, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA3__USB_OTG1_OC                        = IOMUX_PAD(0x04FC, 0x0234, 6, 0x076C, 0, 0),
+
+	MX6_PAD_GPIO4_IO20__SD1_STROBE                        = IOMUX_PAD(0x0500, 0x0238, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO20__AUD6_RXFS                         = IOMUX_PAD(0x0500, 0x0238, 2, 0x05A0, 0, 0),
+	MX6_PAD_GPIO4_IO20__ECSPI4_SS0                        = IOMUX_PAD(0x0500, 0x0238, 3, 0x065C, 0, 0),
+	MX6_PAD_GPIO4_IO20__GPT_CAPTURE1                      = IOMUX_PAD(0x0500, 0x0238, 4, 0x0670, 0, 0),
+	MX6_PAD_GPIO4_IO20__GPIO4_IO20                        = IOMUX_PAD(0x0500, 0x0238, 5, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO4_IO21__SD2_STROBE                        = IOMUX_PAD(0x0504, 0x023C, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO21__AUD6_RXC                          = IOMUX_PAD(0x0504, 0x023C, 2, 0x059C, 0, 0),
+	MX6_PAD_GPIO4_IO21__ECSPI4_SCLK                       = IOMUX_PAD(0x0504, 0x023C, 3, 0x0650, 0, 0),
+	MX6_PAD_GPIO4_IO21__GPT_CAPTURE2                      = IOMUX_PAD(0x0504, 0x023C, 4, 0x0674, 0, 0),
+	MX6_PAD_GPIO4_IO21__GPIO4_IO21                        = IOMUX_PAD(0x0504, 0x023C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO4_IO19__SD3_STROBE                        = IOMUX_PAD(0x0508, 0x0240, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO19__AUD6_RXD                          = IOMUX_PAD(0x0508, 0x0240, 2, 0x0594, 0, 0),
+	MX6_PAD_GPIO4_IO19__ECSPI4_MOSI                       = IOMUX_PAD(0x0508, 0x0240, 3, 0x0658, 0, 0),
+	MX6_PAD_GPIO4_IO19__GPT_COMPARE1                      = IOMUX_PAD(0x0508, 0x0240, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO19__GPIO4_IO19                        = IOMUX_PAD(0x0508, 0x0240, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO25__AUD6_TXC                          = IOMUX_PAD(0x050C, 0x0244, 2, 0x05A4, 0, 0),
+	MX6_PAD_GPIO4_IO25__ECSPI4_MISO                       = IOMUX_PAD(0x050C, 0x0244, 3, 0x0654, 0, 0),
+	MX6_PAD_GPIO4_IO25__GPT_COMPARE2                      = IOMUX_PAD(0x050C, 0x0244, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO25__GPIO4_IO25                        = IOMUX_PAD(0x050C, 0x0244, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO18__AUD6_TXFS                         = IOMUX_PAD(0x0510, 0x0248, 2, 0x05A8, 0, 0),
+	MX6_PAD_GPIO4_IO18__ECSPI4_SS1                        = IOMUX_PAD(0x0510, 0x0248, 3, 0x0660, 0, 0),
+	MX6_PAD_GPIO4_IO18__GPT_COMPARE3                      = IOMUX_PAD(0x0510, 0x0248, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO18__GPIO4_IO18                        = IOMUX_PAD(0x0510, 0x0248, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO24__AUD6_TXD                          = IOMUX_PAD(0x0514, 0x024C, 2, 0x0598, 0, 0),
+	MX6_PAD_GPIO4_IO24__ECSPI4_SS2                        = IOMUX_PAD(0x0514, 0x024C, 3, 0x0664, 0, 0),
+	MX6_PAD_GPIO4_IO24__GPT_CLKIN                         = IOMUX_PAD(0x0514, 0x024C, 4, 0x0678, 0, 0),
+	MX6_PAD_GPIO4_IO24__GPIO4_IO24                        = IOMUX_PAD(0x0514, 0x024C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO23__AUDIO_CLK_OUT                     = IOMUX_PAD(0x0518, 0x0250, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO23__SD1_RESET                         = IOMUX_PAD(0x0518, 0x0250, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO23__SD3_RESET                         = IOMUX_PAD(0x0518, 0x0250, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO23__GPIO4_IO23                        = IOMUX_PAD(0x0518, 0x0250, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO17__USB_OTG1_ID                       = IOMUX_PAD(0x051C, 0x0254, 2, 0x055C, 2, 0),
+	MX6_PAD_GPIO4_IO17__SD1_VSELECT                       = IOMUX_PAD(0x051C, 0x0254, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO17__SD3_VSELECT                       = IOMUX_PAD(0x051C, 0x0254, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO17__GPIO4_IO17                        = IOMUX_PAD(0x051C, 0x0254, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO22__SPDIF_IN                          = IOMUX_PAD(0x0520, 0x0258, 2, 0x0738, 0, 0),
+	MX6_PAD_GPIO4_IO22__SD1_WP                            = IOMUX_PAD(0x0520, 0x0258, 3, 0x0774, 0, 0),
+	MX6_PAD_GPIO4_IO22__SD3_WP                            = IOMUX_PAD(0x0520, 0x0258, 4, 0x0794, 1, 0),
+	MX6_PAD_GPIO4_IO22__GPIO4_IO22                        = IOMUX_PAD(0x0520, 0x0258, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO16__SPDIF_OUT                         = IOMUX_PAD(0x0524, 0x025C, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO16__SD1_CD_B                          = IOMUX_PAD(0x0524, 0x025C, 3, 0x0770, 0, 0),
+	MX6_PAD_GPIO4_IO16__SD3_CD_B                          = IOMUX_PAD(0x0524, 0x025C, 4, 0x0780, 1, 0),
+	MX6_PAD_GPIO4_IO16__GPIO4_IO16                        = IOMUX_PAD(0x0524, 0x025C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO26__WDOG1_B                           = IOMUX_PAD(0x0528, 0x0260, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO26__PWM4_OUT                          = IOMUX_PAD(0x0528, 0x0260, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO26__CCM_PMIC_READY                    = IOMUX_PAD(0x0528, 0x0260, 4, 0x05AC, 1, 0),
+	MX6_PAD_GPIO4_IO26__GPIO4_IO26                        = IOMUX_PAD(0x0528, 0x0260, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO26__SPDIF_EXT_CLK                     = IOMUX_PAD(0x0528, 0x0260, 6, 0x073C, 0, 0),
+};
+#endif  /* __ASM_ARCH_IMX6SLL_PINS_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6sl_pins.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6sl_pins.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6sl_pins.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6sl_pins.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2013 - 2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_MX6_MX6SL_PINS_H__
+#define __ASM_ARCH_MX6_MX6SL_PINS_H__
+
+#include <asm/imx-common/iomux-v3.h>
+
+enum {
+	MX6_PAD_ECSPI1_MISO__ECSPI_MISO				= IOMUX_PAD(0x0358, 0x0068, 0, 0x0684, 0, 0),
+	MX6_PAD_ECSPI1_MOSI__ECSPI_MOSI				= IOMUX_PAD(0x035C, 0x006C, 0, 0x0688, 0, 0),
+	MX6_PAD_ECSPI1_SCLK__ECSPI_SCLK				= IOMUX_PAD(0x0360, 0x0070, 0, 0x067C, 0, 0),
+	MX6_PAD_ECSPI1_SS0__GPIO4_IO11				= IOMUX_PAD(0x0364, 0x0074, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__USDHC1_CLK					= IOMUX_PAD(0x0534, 0x022C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__USDHC1_CMD					= IOMUX_PAD(0x0538, 0x0230, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT0__USDHC1_DAT0				= IOMUX_PAD(0x053C, 0x0234, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT1__USDHC1_DAT1				= IOMUX_PAD(0x0540, 0x0238, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT2__USDHC1_DAT2				= IOMUX_PAD(0x0544, 0x023C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT3__USDHC1_DAT3				= IOMUX_PAD(0x0548, 0x0240, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT4__USDHC1_DAT4				= IOMUX_PAD(0x054C, 0x0244, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT5__USDHC1_DAT5				= IOMUX_PAD(0x0550, 0x0248, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT6__USDHC1_DAT6				= IOMUX_PAD(0x0554, 0x024C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT7__USDHC1_DAT7				= IOMUX_PAD(0x0558, 0x0250, 0, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW7__GPIO_4_7					= IOMUX_PAD(0x04B0, 0x01A8, 5, 0x0000, 0, 0),
+	MX6_PAD_SD2_CLK__USDHC2_CLK				= IOMUX_PAD(0x055C, 0x0254, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_CMD__USDHC2_CMD				= IOMUX_PAD(0x0560, 0x0258, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DAT0__USDHC2_DAT0				= IOMUX_PAD(0x0564, 0x025C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DAT1__USDHC2_DAT1				= IOMUX_PAD(0x0568, 0x0260, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DAT2__USDHC2_DAT2				= IOMUX_PAD(0x056C, 0x0264, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DAT3__USDHC2_DAT3				= IOMUX_PAD(0x0570, 0x0268, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DAT4__USDHC2_DAT4				= IOMUX_PAD(0X0574, 0X026C, 0, 0X0000, 0, 0),
+	MX6_PAD_SD2_DAT5__USDHC2_DAT5				= IOMUX_PAD(0X0578, 0X0270, 0, 0X0000, 0, 0),
+	MX6_PAD_SD2_DAT6__USDHC2_DAT6				= IOMUX_PAD(0X057C, 0X0274, 0, 0X0000, 0, 0),
+	MX6_PAD_SD2_DAT7__USDHC2_DAT7				= IOMUX_PAD(0X0580, 0X0278, 0, 0X0000, 0, 0),
+	MX6_PAD_SD2_DAT7__GPIO_5_0					= IOMUX_PAD(0x0580, 0x0278, 5, 0x0000, 0, 0),
+	MX6_PAD_SD2_RST__USDHC2_RST				= IOMUX_PAD(0x0584, 0x027C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_CLK__USDHC3_CLK					= IOMUX_PAD(0x0588, 0x0280, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_CMD__USDHC3_CMD					= IOMUX_PAD(0x058C, 0x0284, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DAT0__USDHC3_DAT0				= IOMUX_PAD(0x0590, 0x0288, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DAT1__USDHC3_DAT1				= IOMUX_PAD(0x0594, 0x028C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DAT2__USDHC3_DAT2				= IOMUX_PAD(0x0598, 0x0290, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DAT3__USDHC3_DAT3				= IOMUX_PAD(0x059C, 0x0294, 0, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_32K__GPIO_3_22				= IOMUX_PAD(0x0530, 0x0228, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_RXD__UART1_RXD				= IOMUX_PAD(0x05A0, 0x0298, 0, 0x07FC, 0, 0),
+	MX6_PAD_UART1_TXD__UART1_TXD				= IOMUX_PAD(0x05A4, 0x029C, 0, 0x0000, 0, 0),
+
+	MX6_PAD_FEC_MDC__FEC_MDC				= IOMUX_PAD(0x41c, 0x12c, 0, 0x000, 0, 0),
+	MX6_PAD_FEC_MDIO__FEC_MDIO				= IOMUX_PAD(0x420, 0x130, 0, 0x6f4, 1, 0),
+	MX6_PAD_FEC_CRS_DV__FEC_RX_DV				= IOMUX_PAD(0x418, 0x128, 0, 0x704, 1, 0),
+	MX6_PAD_FEC_RXD0__FEC_RX_DATA0				= IOMUX_PAD(0x42c, 0x13c, 0, 0x6f8, 0, 0),
+	MX6_PAD_FEC_RXD1__FEC_RX_DATA1				= IOMUX_PAD(0x430, 0x140, 0, 0x6fc, 1, 0),
+	MX6_PAD_FEC_TX_EN__FEC_TX_EN				= IOMUX_PAD(0x438, 0x148, 0, 0x000, 0, 0),
+	MX6_PAD_FEC_TXD0__FEC_TX_DATA0				= IOMUX_PAD(0x43c, 0x14c, 0, 0x000, 0, 0),
+	MX6_PAD_FEC_TXD1__FEC_TX_DATA1				= IOMUX_PAD(0x440, 0x150, 0, 0x000, 0, 0),
+	MX6_PAD_FEC_REF_CLK__FEC_REF_OUT			= IOMUX_PAD(0x424, 0x134, 0x10, 0x000, 0, 0),
+	MX6_PAD_FEC_RX_ER__GPIO_4_19				= IOMUX_PAD(0x0428, 0x0138, 5, 0x0000, 0, 0),
+	MX6_PAD_FEC_TX_CLK__GPIO_4_21				= IOMUX_PAD(0x0434, 0x0144, 5, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_COL0__KPP_COL_0				= IOMUX_PAD(0x0474, 0x016C, 0, 0x0734, 0, 0),
+	MX6_PAD_KEY_COL1__KPP_COL_1				= IOMUX_PAD(0x0478, 0x0170, 0, 0x0738, 0, 0),
+	MX6_PAD_KEY_COL2__KPP_COL_2				= IOMUX_PAD(0x047C, 0x0174, 0, 0x073C, 0, 0),
+	MX6_PAD_KEY_COL3__KPP_COL_3				= IOMUX_PAD(0x0480, 0x0178, 0, 0x0740, 0, 0),
+	MX6_PAD_KEY_ROW0__KPP_ROW_0				= IOMUX_PAD(0x0494, 0x018C, 0, 0x0754, 0, 0),
+	MX6_PAD_KEY_ROW1__KPP_ROW_1				= IOMUX_PAD(0x0498, 0x0190, 0, 0x0758, 0, 0),
+	MX6_PAD_KEY_ROW2__KPP_ROW_2				= IOMUX_PAD(0x049C, 0x0194, 0, 0x075C, 0, 0),
+	MX6_PAD_KEY_ROW3__KPP_ROW_3				= IOMUX_PAD(0x04A0, 0x0198, 0, 0x0760, 0, 0),
+
+	MX6_PAD_KEY_COL4__USB_USBOTG1_PWR			= IOMUX_PAD(0x0484, 0x017C, 6, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL5__USB_USBOTG2_PWR			= IOMUX_PAD(0x0488, 0x0180, 6, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL6__GPIO_4_4				= IOMUX_PAD(0x048C, 0x0184, 5, 0x0000, 0, 0),
+
+	MX6_PAD_I2C1_SDA__I2C1_SDA				= IOMUX_PAD(0x0450, 0x0160, 0x10, 0x0720, 2, 0),
+	MX6_PAD_I2C1_SDA__GPIO_3_13				= IOMUX_PAD(0x0450, 0x0160, 5, 0x0000, 0, 0),
+	MX6_PAD_I2C1_SCL__I2C1_SCL				= IOMUX_PAD(0x044C, 0x015C, 0x10, 0x071C, 2, 0),
+	MX6_PAD_I2C1_SCL__GPIO_3_12				= IOMUX_PAD(0x044C, 0x015C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWRCOM__ANATOP_USBOTG1_ID			= IOMUX_PAD(0x03D0, 0x00E0, 4, 0x05DC, 0, 0),
+	MX6_PAD_EPDC_PWRCTRL2__GPIO_2_9				= IOMUX_PAD(0x03DC, 0x00EC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWRCTRL3__GPIO_2_10			= IOMUX_PAD(0x03E0, 0x00F0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWRSTAT__GPIO_2_13				= IOMUX_PAD(0x03E8, 0x00F8, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_VCOM0__GPIO_2_3				= IOMUX_PAD(0x0410, 0x0120, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWRWAKEUP__GPIO_2_14			= IOMUX_PAD(0x03EC, 0x00FC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWRCTRL0__GPIO_2_7				= IOMUX_PAD(0x03D4, 0x00E4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D0__EPDC_SDDO_0				= IOMUX_PAD(0x0380, 0x0090, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D1__EPDC_SDDO_1				= IOMUX_PAD(0x0384, 0x0094, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D2__EPDC_SDDO_2				= IOMUX_PAD(0x03A0, 0x00B0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D3__EPDC_SDDO_3				= IOMUX_PAD(0x03A4, 0x00B4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D4__EPDC_SDDO_4				= IOMUX_PAD(0x03A8, 0x00B8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D5__EPDC_SDDO_5				= IOMUX_PAD(0x03AC, 0x00BC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D6__EPDC_SDDO_6				= IOMUX_PAD(0x03B0, 0x00C0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D7__EPDC_SDDO_7				= IOMUX_PAD(0x03B4, 0x00C4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDCLK__EPDC_GDCLK				= IOMUX_PAD(0x03C0, 0x00D0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDSP__EPDC_GDSP				= IOMUX_PAD(0x03CC, 0x00DC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDOE__EPDC_GDOE				= IOMUX_PAD(0x03C4, 0x00D4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDRL__EPDC_GDRL				= IOMUX_PAD(0x03C8, 0x00D8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCLK__EPDC_SDCLK				= IOMUX_PAD(0x0400, 0x0110, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDOE__EPDC_SDOE				= IOMUX_PAD(0x0408, 0x0118, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDLE__EPDC_SDLE				= IOMUX_PAD(0x0404, 0x0114, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDSHR__EPDC_SDSHR				= IOMUX_PAD(0x040C, 0x011C, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR0__EPDC_BDR_0				= IOMUX_PAD(0x0378, 0x0088, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE0__EPDC_SDCE_0				= IOMUX_PAD(0x03F0, 0x0100, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE1__EPDC_SDCE_1				= IOMUX_PAD(0x03F4, 0x0104, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE2__EPDC_SDCE_2				= IOMUX_PAD(0x03F8, 0x0108, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D0__GPIO_1_7				= IOMUX_PAD(0x0380, 0x0090, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D1__GPIO_1_8				= IOMUX_PAD(0x0384, 0x0094, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D2__GPIO_1_9				= IOMUX_PAD(0x03A0, 0x00B0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D3__GPIO_1_10				= IOMUX_PAD(0x03A4, 0x00B4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D4__GPIO_1_11				= IOMUX_PAD(0x03A8, 0x00B8, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D5__GPIO_1_12				= IOMUX_PAD(0x03AC, 0x00BC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D6__GPIO_1_13				= IOMUX_PAD(0x03B0, 0x00C0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D7__GPIO_1_14				= IOMUX_PAD(0x03B4, 0x00C4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDCLK__GPIO_1_31				= IOMUX_PAD(0x03C0, 0x00D0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDSP__GPIO_2_2				= IOMUX_PAD(0x03CC, 0x00DC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDOE__GPIO_2_0				= IOMUX_PAD(0x03C4, 0x00D4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDRL__GPIO_2_1				= IOMUX_PAD(0x03C8, 0x00D8, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCLK__GPIO_1_23				= IOMUX_PAD(0x0400, 0x0110, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDOE__GPIO_1_25				= IOMUX_PAD(0x0408, 0x0118, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDLE__GPIO_1_24				= IOMUX_PAD(0x0404, 0x0114, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDSHR__GPIO_1_26				= IOMUX_PAD(0x040C, 0x011C, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR0__GPIO_2_5				= IOMUX_PAD(0x0378, 0x0088, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE0__GPIO_1_27				= IOMUX_PAD(0x03F0, 0x0100, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE1__GPIO_1_28				= IOMUX_PAD(0x03F4, 0x0104, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE2__GPIO_1_29				= IOMUX_PAD(0x03F8, 0x0108, 5, 0x0000, 0, 0),
+};
+#endif	/* __ASM_ARCH_MX6_MX6SL_PINS_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6sx-ddr.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6sx-ddr.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6sx-ddr.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6sx-ddr.h	2021-04-16 14:42:14.692580786 +0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_MX6SX_DDR_H__
+#define __ASM_ARCH_MX6SX_DDR_H__
+
+#ifndef CONFIG_MX6SX
+#error "wrong CPU"
+#endif
+
+#define MX6_IOM_DRAM_DQM0	0x020e02ec
+#define MX6_IOM_DRAM_DQM1	0x020e02f0
+#define MX6_IOM_DRAM_DQM2	0x020e02f4
+#define MX6_IOM_DRAM_DQM3	0x020e02f8
+
+#define MX6_IOM_DRAM_RAS	0x020e02fc
+#define MX6_IOM_DRAM_CAS	0x020e0300
+#define MX6_IOM_DRAM_SDODT0	0x020e0310
+#define MX6_IOM_DRAM_SDODT1	0x020e0314
+#define MX6_IOM_DRAM_SDBA2	0x020e0320
+#define MX6_IOM_DRAM_SDCKE0	0x020e0324
+#define MX6_IOM_DRAM_SDCKE1	0x020e0328
+#define MX6_IOM_DRAM_SDCLK_0	0x020e032c
+#define MX6_IOM_DRAM_RESET	0x020e0340
+
+#define MX6_IOM_DRAM_SDQS0	0x020e0330
+#define MX6_IOM_DRAM_SDQS1	0x020e0334
+#define MX6_IOM_DRAM_SDQS2	0x020e0338
+#define MX6_IOM_DRAM_SDQS3	0x020e033c
+
+#define MX6_IOM_GRP_ADDDS	0x020e05f4
+#define MX6_IOM_DDRMODE_CTL	0x020e05f8
+#define MX6_IOM_GRP_DDRPKE	0x020e05fc
+#define MX6_IOM_GRP_DDRMODE	0x020e0608
+#define MX6_IOM_GRP_B0DS	0x020e060c
+#define MX6_IOM_GRP_B1DS	0x020e0610
+#define MX6_IOM_GRP_CTLDS	0x020e0614
+#define MX6_IOM_GRP_DDR_TYPE	0x020e0618
+#define MX6_IOM_GRP_B2DS	0x020e061c
+#define MX6_IOM_GRP_B3DS	0x020e0620
+
+#endif	/*__ASM_ARCH_MX6SX_DDR_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6sx_pins.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6sx_pins.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6sx_pins.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6sx_pins.h	2021-04-16 14:42:14.692580786 +0800
@@ -0,0 +1,1675 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_MX6_MX6_PINS_H__
+#define __ASM_ARCH_MX6_MX6_PINS_H__
+
+#include <asm/imx-common/iomux-v3.h>
+
+enum {
+	 MX6_PAD_GPIO1_IO00__I2C1_SCL                           = IOMUX_PAD(0x035C, 0x0014, IOMUX_CONFIG_SION | 0, 0x07A8, 1, 0),
+	 MX6_PAD_GPIO1_IO00__USDHC1_VSELECT                     = IOMUX_PAD(0x035C, 0x0014, 1, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO00__SPDIF_LOCK                         = IOMUX_PAD(0x035C, 0x0014, 2, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO00__CCM_WAIT                           = IOMUX_PAD(0x035C, 0x0014, 3, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO00__WDOG1_WDOG_ANY                     = IOMUX_PAD(0x035C, 0x0014, 4, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO00__GPIO1_IO_0                         = IOMUX_PAD(0x035C, 0x0014, 5, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO00__SNVS_HP_WRAPPER_VIO_5              = IOMUX_PAD(0x035C, 0x0014, 6, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO00__PHY_DTB_1                          = IOMUX_PAD(0x035C, 0x0014, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_GPIO1_IO01__I2C1_SDA                           = IOMUX_PAD(0x0360, 0x0018, IOMUX_CONFIG_SION | 0, 0x07AC, 1, 0),
+	 MX6_PAD_GPIO1_IO01__USDHC1_RESET_B                     = IOMUX_PAD(0x0360, 0x0018, 1, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO01__SPDIF_SR_CLK                       = IOMUX_PAD(0x0360, 0x0018, 2, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO01__CCM_STOP                           = IOMUX_PAD(0x0360, 0x0018, 3, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO01__WDOG3_WDOG_B                       = IOMUX_PAD(0x0360, 0x0018, 4, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO01__GPIO1_IO_1                         = IOMUX_PAD(0x0360, 0x0018, 5, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO01__SNVS_HP_WRAPPER_VIO_5_CTL          = IOMUX_PAD(0x0360, 0x0018, 6, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO01__PHY_DTB_0                          = IOMUX_PAD(0x0360, 0x0018, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_GPIO1_IO02__I2C2_SCL                           = IOMUX_PAD(0x0364, 0x001C, IOMUX_CONFIG_SION | 0, 0x07B0, 1, 0),
+	 MX6_PAD_GPIO1_IO02__USDHC1_CD_B                        = IOMUX_PAD(0x0364, 0x001C, 1, 0x0864, 1, 0),
+	 MX6_PAD_GPIO1_IO02__CSI2_MCLK                          = IOMUX_PAD(0x0364, 0x001C, 2, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO02__CCM_DI0_EXT_CLK                    = IOMUX_PAD(0x0364, 0x001C, 3, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO02__WDOG1_WDOG_B                       = IOMUX_PAD(0x0364, 0x001C, 4, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO02__GPIO1_IO_2                         = IOMUX_PAD(0x0364, 0x001C, 5, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO02__CCM_REF_EN_B                       = IOMUX_PAD(0x0364, 0x001C, 6, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO02__PHY_TDI                            = IOMUX_PAD(0x0364, 0x001C, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_GPIO1_IO03__I2C2_SDA                           = IOMUX_PAD(0x0368, 0x0020, IOMUX_CONFIG_SION | 0, 0x07B4, 1, 0),
+	 MX6_PAD_GPIO1_IO03__USDHC1_WP                          = IOMUX_PAD(0x0368, 0x0020, 1, 0x0868, 1, 0),
+	 MX6_PAD_GPIO1_IO03__ENET1_REF_CLK_25M                  = IOMUX_PAD(0x0368, 0x0020, 2, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO03__CCM_DI1_EXT_CLK                    = IOMUX_PAD(0x0368, 0x0020, 3, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO03__WDOG2_WDOG_B                       = IOMUX_PAD(0x0368, 0x0020, 4, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO03__GPIO1_IO_3                         = IOMUX_PAD(0x0368, 0x0020, 5, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO03__CCM_PLL3_BYP                       = IOMUX_PAD(0x0368, 0x0020, 6, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO03__PHY_TCK                            = IOMUX_PAD(0x0368, 0x0020, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_GPIO1_IO04__UART1_TX                           = IOMUX_PAD(0x036C, 0x0024, 0, 0x0830, 0, 0),
+	 MX6_PAD_GPIO1_IO04__USDHC2_RESET_B                     = IOMUX_PAD(0x036C, 0x0024, 1, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO04__ENET1_MDC                          = IOMUX_PAD(0x036C, 0x0024, 2, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO04__OSC32K_32K_OUT                     = IOMUX_PAD(0x036C, 0x0024, 3, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO04__ENET2_REF_CLK2                     = IOMUX_PAD(0x036C, 0x0024, 4, 0x076C, 0, 0),
+	 MX6_PAD_GPIO1_IO04__GPIO1_IO_4                         = IOMUX_PAD(0x036C, 0x0024, 5, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO04__CCM_PLL2_BYP                       = IOMUX_PAD(0x036C, 0x0024, 6, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO04__PHY_TMS                            = IOMUX_PAD(0x036C, 0x0024, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_GPIO1_IO05__UART1_RX                           = IOMUX_PAD(0x0370, 0x0028, 0, 0x0830, 1, 0),
+	 MX6_PAD_GPIO1_IO05__USDHC2_VSELECT                     = IOMUX_PAD(0x0370, 0x0028, 1, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO05__ENET1_MDIO                         = IOMUX_PAD(0x0370, 0x0028, 2, 0x0764, 0, 0),
+	 MX6_PAD_GPIO1_IO05__ASRC_ASRC_EXT_CLK                  = IOMUX_PAD(0x0370, 0x0028, 3, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO05__ENET1_REF_CLK1                     = IOMUX_PAD(0x0370, 0x0028, 4, 0x0760, 0, 0),
+	 MX6_PAD_GPIO1_IO05__GPIO1_IO_5                         = IOMUX_PAD(0x0370, 0x0028, 5, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO05__SRC_TESTER_ACK                     = IOMUX_PAD(0x0370, 0x0028, 6, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO05__PHY_TDO                            = IOMUX_PAD(0x0370, 0x0028, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_GPIO1_IO06__UART2_TX                           = IOMUX_PAD(0x0374, 0x002C, 0, 0x0838, 0, 0),
+	 MX6_PAD_GPIO1_IO06__USDHC2_CD_B                        = IOMUX_PAD(0x0374, 0x002C, 1, 0x086C, 1, 0),
+	 MX6_PAD_GPIO1_IO06__ENET2_MDC                          = IOMUX_PAD(0x0374, 0x002C, 2, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO06__CSI1_MCLK                          = IOMUX_PAD(0x0374, 0x002C, 3, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO06__UART1_RTS_B                        = IOMUX_PAD(0x0374, 0x002C, 4, 0x082C, 0, 0),
+	 MX6_PAD_GPIO1_IO06__GPIO1_IO_6                         = IOMUX_PAD(0x0374, 0x002C, 5, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO06__SRC_ANY_PU_RESET                   = IOMUX_PAD(0x0374, 0x002C, 6, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO06__OCOTP_CTRL_WRAPPER_FUSE_LATCHED    = IOMUX_PAD(0x0374, 0x002C, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_GPIO1_IO07__UART2_RX                           = IOMUX_PAD(0x0378, 0x0030, 0, 0x0838, 1, 0),
+	 MX6_PAD_GPIO1_IO07__USDHC2_WP                          = IOMUX_PAD(0x0378, 0x0030, 1, 0x0870, 1, 0),
+	 MX6_PAD_GPIO1_IO07__ENET2_MDIO                         = IOMUX_PAD(0x0378, 0x0030, 2, 0x0770, 0, 0),
+	 MX6_PAD_GPIO1_IO07__AUDMUX_MCLK                        = IOMUX_PAD(0x0378, 0x0030, 3, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO07__UART1_CTS_B                        = IOMUX_PAD(0x0378, 0x0030, 4, 0x082C, 1, 0),
+	 MX6_PAD_GPIO1_IO07__GPIO1_IO_7                         = IOMUX_PAD(0x0378, 0x0030, 5, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO07__SRC_EARLY_RESET                    = IOMUX_PAD(0x0378, 0x0030, 6, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO07__DCIC2_OUT                          = IOMUX_PAD(0x0378, 0x0030, 7, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO07__VDEC_DEBUG_44                      = IOMUX_PAD(0x0378, 0x0030, 8, 0x0000, 0, 0),
+
+	 MX6_PAD_GPIO1_IO08__USB_OTG1_OC                        = IOMUX_PAD(0x037C, 0x0034, 0, 0x0860, 0, 0),
+	 MX6_PAD_GPIO1_IO08__WDOG1_WDOG_B                       = IOMUX_PAD(0x037C, 0x0034, 1, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO08__SDMA_EXT_EVENT_0                   = IOMUX_PAD(0x037C, 0x0034, 2, 0x081C, 0, 0),
+	 MX6_PAD_GPIO1_IO08__CCM_PMIC_RDY                       = IOMUX_PAD(0x037C, 0x0034, 3, 0x069C, 1, 0),
+	 MX6_PAD_GPIO1_IO08__UART2_RTS_B                        = IOMUX_PAD(0x037C, 0x0034, 4, 0x0834, 0, 0),
+	 MX6_PAD_GPIO1_IO08__GPIO1_IO_8                         = IOMUX_PAD(0x037C, 0x0034, 5, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO08__SRC_SYSTEM_RESET                   = IOMUX_PAD(0x037C, 0x0034, 6, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO08__DCIC1_OUT                          = IOMUX_PAD(0x037C, 0x0034, 7, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO08__VDEC_DEBUG_43                      = IOMUX_PAD(0x037C, 0x0034, 8, 0x0000, 0, 0),
+
+	 MX6_PAD_GPIO1_IO09__USB_OTG1_PWR                       = IOMUX_PAD(0x0380, 0x0038, 0, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO09__WDOG2_WDOG_B                       = IOMUX_PAD(0x0380, 0x0038, 1, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO09__SDMA_EXT_EVENT_1                   = IOMUX_PAD(0x0380, 0x0038, 2, 0x0820, 0, 0),
+	 MX6_PAD_GPIO1_IO09__CCM_OUT0                           = IOMUX_PAD(0x0380, 0x0038, 3, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO09__UART2_CTS_B                        = IOMUX_PAD(0x0380, 0x0038, 4, 0x0834, 1, 0),
+	 MX6_PAD_GPIO1_IO09__GPIO1_IO_9                         = IOMUX_PAD(0x0380, 0x0038, 5, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO09__SRC_INT_BOOT                       = IOMUX_PAD(0x0380, 0x0038, 6, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO09__OBSERVE_MUX_OUT_4                  = IOMUX_PAD(0x0380, 0x0038, 7, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO09__VDEC_DEBUG_42                      = IOMUX_PAD(0x0380, 0x0038, 8, 0x0000, 0, 0),
+
+	 MX6_PAD_GPIO1_IO10__ANATOP_OTG1_ID                     = IOMUX_PAD(0x0384, 0x003C, 0, 0x0624, 0, 0),
+	 MX6_PAD_GPIO1_IO10__SPDIF_EXT_CLK                      = IOMUX_PAD(0x0384, 0x003C, 1, 0x0828, 0, 0),
+	 MX6_PAD_GPIO1_IO10__PWM1_OUT                           = IOMUX_PAD(0x0384, 0x003C, 2, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO10__CCM_OUT1                           = IOMUX_PAD(0x0384, 0x003C, 3, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO10__CSI1_FIELD                         = IOMUX_PAD(0x0384, 0x003C, 4, 0x070C, 1, 0),
+	 MX6_PAD_GPIO1_IO10__GPIO1_IO_10                        = IOMUX_PAD(0x0384, 0x003C, 5, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO10__CSU_CSU_INT_DEB                    = IOMUX_PAD(0x0384, 0x003C, 6, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO10__OBSERVE_MUX_OUT_3                  = IOMUX_PAD(0x0384, 0x003C, 7, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO10__VDEC_DEBUG_41                      = IOMUX_PAD(0x0384, 0x003C, 8, 0x0000, 0, 0),
+
+	 MX6_PAD_GPIO1_IO11__USB_OTG2_OC                        = IOMUX_PAD(0x0388, 0x0040, 0, 0x085C, 0, 0),
+	 MX6_PAD_GPIO1_IO11__SPDIF_IN                           = IOMUX_PAD(0x0388, 0x0040, 1, 0x0824, 2, 0),
+	 MX6_PAD_GPIO1_IO11__PWM2_OUT                           = IOMUX_PAD(0x0388, 0x0040, 2, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO11__CCM_CLKO1                          = IOMUX_PAD(0x0388, 0x0040, 3, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO11__MLB_DATA                           = IOMUX_PAD(0x0388, 0x0040, 4, 0x07EC, 0, 0),
+	 MX6_PAD_GPIO1_IO11__GPIO1_IO_11                        = IOMUX_PAD(0x0388, 0x0040, 5, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO11__CSU_CSU_ALARM_AUT_0                = IOMUX_PAD(0x0388, 0x0040, 6, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO11__OBSERVE_MUX_OUT_2                  = IOMUX_PAD(0x0388, 0x0040, 7, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO11__VDEC_DEBUG_40                      = IOMUX_PAD(0x0388, 0x0040, 8, 0x0000, 0, 0),
+
+	 MX6_PAD_GPIO1_IO12__USB_OTG2_PWR                       = IOMUX_PAD(0x038C, 0x0044, 0, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO12__SPDIF_OUT                          = IOMUX_PAD(0x038C, 0x0044, 1, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO12__PWM3_OUT                           = IOMUX_PAD(0x038C, 0x0044, 2, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO12__CCM_CLKO2                          = IOMUX_PAD(0x038C, 0x0044, 3, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO12__MLB_CLK                            = IOMUX_PAD(0x038C, 0x0044, 4, 0x07E8, 0, 0),
+	 MX6_PAD_GPIO1_IO12__GPIO1_IO_12                        = IOMUX_PAD(0x038C, 0x0044, 5, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO12__CSU_CSU_ALARM_AUT_1                = IOMUX_PAD(0x038C, 0x0044, 6, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO12__OBSERVE_MUX_OUT_1                  = IOMUX_PAD(0x038C, 0x0044, 7, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO12__VDEC_DEBUG_39                      = IOMUX_PAD(0x038C, 0x0044, 8, 0x0000, 0, 0),
+
+	 MX6_PAD_GPIO1_IO13__WDOG1_WDOG_ANY                     = IOMUX_PAD(0x0390, 0x0048, 0, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO13__ANATOP_OTG2_ID                     = IOMUX_PAD(0x0390, 0x0048, 1, 0x0628, 0, 0),
+	 MX6_PAD_GPIO1_IO13__PWM4_OUT                           = IOMUX_PAD(0x0390, 0x0048, 2, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO13__CCM_OUT2                           = IOMUX_PAD(0x0390, 0x0048, 3, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO13__MLB_SIG                            = IOMUX_PAD(0x0390, 0x0048, 4, 0x07F0, 0, 0),
+	 MX6_PAD_GPIO1_IO13__GPIO1_IO_13                        = IOMUX_PAD(0x0390, 0x0048, 5, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO13__CSU_CSU_ALARM_AUT_2                = IOMUX_PAD(0x0390, 0x0048, 6, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO13__OBSERVE_MUX_OUT_0                  = IOMUX_PAD(0x0390, 0x0048, 7, 0x0000, 0, 0),
+	 MX6_PAD_GPIO1_IO13__VDEC_DEBUG_38                      = IOMUX_PAD(0x0390, 0x0048, 8, 0x0000, 0, 0),
+
+	 MX6_PAD_CSI_DATA00__CSI1_DATA_2                        = IOMUX_PAD(0x0394, 0x004C, 0, 0x06A8, 0, 0),
+	 MX6_PAD_CSI_DATA00__ESAI_TX_CLK                        = IOMUX_PAD(0x0394, 0x004C, 1, 0x078C, 1, 0),
+	 MX6_PAD_CSI_DATA00__AUDMUX_AUD6_TXC                    = IOMUX_PAD(0x0394, 0x004C, 2, 0x0684, 1, 0),
+	 MX6_PAD_CSI_DATA00__I2C1_SCL                           = IOMUX_PAD(0x0394, 0x004C, IOMUX_CONFIG_SION | 3, 0x07A8, 0, 0),
+	 MX6_PAD_CSI_DATA00__UART6_RI_B                         = IOMUX_PAD(0x0394, 0x004C, 4, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA00__GPIO1_IO_14                        = IOMUX_PAD(0x0394, 0x004C, 5, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA00__WEIM_DATA_23                       = IOMUX_PAD(0x0394, 0x004C, 6, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA00__SAI1_TX_BCLK                       = IOMUX_PAD(0x0394, 0x004C, 7, 0x0800, 0, 0),
+	 MX6_PAD_CSI_DATA00__VADC_DATA_4                        = IOMUX_PAD(0x0394, 0x004C, 8, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA00__MMDC_DEBUG_37                      = IOMUX_PAD(0x0394, 0x004C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_CSI_DATA01__CSI1_DATA_3                        = IOMUX_PAD(0x0398, 0x0050, 0, 0x06AC, 0, 0),
+	 MX6_PAD_CSI_DATA01__ESAI_TX_FS                         = IOMUX_PAD(0x0398, 0x0050, 1, 0x077C, 1, 0),
+	 MX6_PAD_CSI_DATA01__AUDMUX_AUD6_TXFS                   = IOMUX_PAD(0x0398, 0x0050, 2, 0x0688, 1, 0),
+	 MX6_PAD_CSI_DATA01__I2C1_SDA                           = IOMUX_PAD(0x0398, 0x0050, IOMUX_CONFIG_SION | 3, 0x07AC, 0, 0),
+	 MX6_PAD_CSI_DATA01__UART6_DSR_B                        = IOMUX_PAD(0x0398, 0x0050, 4, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA01__GPIO1_IO_15                        = IOMUX_PAD(0x0398, 0x0050, 5, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA01__WEIM_DATA_22                       = IOMUX_PAD(0x0398, 0x0050, 6, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA01__SAI1_TX_SYNC                       = IOMUX_PAD(0x0398, 0x0050, 7, 0x0804, 0, 0),
+	 MX6_PAD_CSI_DATA01__VADC_DATA_5                        = IOMUX_PAD(0x0398, 0x0050, 8, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA01__MMDC_DEBUG_38                      = IOMUX_PAD(0x0398, 0x0050, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_CSI_DATA02__CSI1_DATA_4                        = IOMUX_PAD(0x039C, 0x0054, 0, 0x06B0, 0, 0),
+	 MX6_PAD_CSI_DATA02__ESAI_RX_CLK                        = IOMUX_PAD(0x039C, 0x0054, 1, 0x0788, 1, 0),
+	 MX6_PAD_CSI_DATA02__AUDMUX_AUD6_RXC                    = IOMUX_PAD(0x039C, 0x0054, 2, 0x067C, 1, 0),
+	 MX6_PAD_CSI_DATA02__KPP_COL_5                          = IOMUX_PAD(0x039C, 0x0054, 3, 0x07C8, 0, 0),
+	 MX6_PAD_CSI_DATA02__UART6_DTR_B                        = IOMUX_PAD(0x039C, 0x0054, 4, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA02__GPIO1_IO_16                        = IOMUX_PAD(0x039C, 0x0054, 5, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA02__WEIM_DATA_21                       = IOMUX_PAD(0x039C, 0x0054, 6, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA02__SAI1_RX_BCLK                       = IOMUX_PAD(0x039C, 0x0054, 7, 0x07F4, 0, 0),
+	 MX6_PAD_CSI_DATA02__VADC_DATA_6                        = IOMUX_PAD(0x039C, 0x0054, 8, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA02__MMDC_DEBUG_39                      = IOMUX_PAD(0x039C, 0x0054, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_CSI_DATA03__CSI1_DATA_5                        = IOMUX_PAD(0x03A0, 0x0058, 0, 0x06B4, 0, 0),
+	 MX6_PAD_CSI_DATA03__ESAI_RX_FS                         = IOMUX_PAD(0x03A0, 0x0058, 1, 0x0778, 1, 0),
+	 MX6_PAD_CSI_DATA03__AUDMUX_AUD6_RXFS                   = IOMUX_PAD(0x03A0, 0x0058, 2, 0x0680, 1, 0),
+	 MX6_PAD_CSI_DATA03__KPP_ROW_5                          = IOMUX_PAD(0x03A0, 0x0058, 3, 0x07D4, 0, 0),
+	 MX6_PAD_CSI_DATA03__UART6_DCD_B                        = IOMUX_PAD(0x03A0, 0x0058, 4, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA03__GPIO1_IO_17                        = IOMUX_PAD(0x03A0, 0x0058, 5, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA03__WEIM_DATA_20                       = IOMUX_PAD(0x03A0, 0x0058, 6, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA03__SAI1_RX_SYNC                       = IOMUX_PAD(0x03A0, 0x0058, 7, 0x07FC, 0, 0),
+	 MX6_PAD_CSI_DATA03__VADC_DATA_7                        = IOMUX_PAD(0x03A0, 0x0058, 8, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA03__MMDC_DEBUG_40                      = IOMUX_PAD(0x03A0, 0x0058, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_CSI_DATA04__CSI1_DATA_6                        = IOMUX_PAD(0x03A4, 0x005C, 0, 0x06B8, 0, 0),
+	 MX6_PAD_CSI_DATA04__ESAI_TX1                           = IOMUX_PAD(0x03A4, 0x005C, 1, 0x0794, 1, 0),
+	 MX6_PAD_CSI_DATA04__SPDIF_OUT                          = IOMUX_PAD(0x03A4, 0x005C, 2, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA04__KPP_COL_6                          = IOMUX_PAD(0x03A4, 0x005C, 3, 0x07CC, 0, 0),
+	 MX6_PAD_CSI_DATA04__UART6_RX                           = IOMUX_PAD(0x03A4, 0x005C, 4, 0x0858, 0, 0),
+	 MX6_PAD_CSI_DATA04__GPIO1_IO_18                        = IOMUX_PAD(0x03A4, 0x005C, 5, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA04__WEIM_DATA_19                       = IOMUX_PAD(0x03A4, 0x005C, 6, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA04__PWM5_OUT                           = IOMUX_PAD(0x03A4, 0x005C, 7, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA04__VADC_DATA_8                        = IOMUX_PAD(0x03A4, 0x005C, 8, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA04__MMDC_DEBUG_41                      = IOMUX_PAD(0x03A4, 0x005C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_CSI_DATA05__CSI1_DATA_7                        = IOMUX_PAD(0x03A8, 0x0060, 0, 0x06BC, 0, 0),
+	 MX6_PAD_CSI_DATA05__ESAI_TX4_RX1                       = IOMUX_PAD(0x03A8, 0x0060, 1, 0x07A0, 1, 0),
+	 MX6_PAD_CSI_DATA05__SPDIF_IN                           = IOMUX_PAD(0x03A8, 0x0060, 2, 0x0824, 1, 0),
+	 MX6_PAD_CSI_DATA05__KPP_ROW_6                          = IOMUX_PAD(0x03A8, 0x0060, 3, 0x07D8, 0, 0),
+	 MX6_PAD_CSI_DATA05__UART6_TX                           = IOMUX_PAD(0x03A8, 0x0060, 4, 0x0858, 1, 0),
+	 MX6_PAD_CSI_DATA05__GPIO1_IO_19                        = IOMUX_PAD(0x03A8, 0x0060, 5, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA05__WEIM_DATA_18                       = IOMUX_PAD(0x03A8, 0x0060, 6, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA05__PWM6_OUT                           = IOMUX_PAD(0x03A8, 0x0060, 7, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA05__VADC_DATA_9                        = IOMUX_PAD(0x03A8, 0x0060, 8, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA05__MMDC_DEBUG_42                      = IOMUX_PAD(0x03A8, 0x0060, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_CSI_DATA06__CSI1_DATA_8                        = IOMUX_PAD(0x03AC, 0x0064, 0, 0x06C0, 0, 0),
+	 MX6_PAD_CSI_DATA06__ESAI_TX2_RX3                       = IOMUX_PAD(0x03AC, 0x0064, 1, 0x0798, 1, 0),
+	 MX6_PAD_CSI_DATA06__I2C4_SCL                           = IOMUX_PAD(0x03AC, 0x0064, IOMUX_CONFIG_SION | 2, 0x07C0, 2, 0),
+	 MX6_PAD_CSI_DATA06__KPP_COL_7                          = IOMUX_PAD(0x03AC, 0x0064, 3, 0x07D0, 0, 0),
+	 MX6_PAD_CSI_DATA06__UART6_RTS_B                        = IOMUX_PAD(0x03AC, 0x0064, 4, 0x0854, 0, 0),
+	 MX6_PAD_CSI_DATA06__GPIO1_IO_20                        = IOMUX_PAD(0x03AC, 0x0064, 5, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA06__WEIM_DATA_17                       = IOMUX_PAD(0x03AC, 0x0064, 6, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA06__DCIC2_OUT                          = IOMUX_PAD(0x03AC, 0x0064, 7, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA06__VADC_DATA_10                       = IOMUX_PAD(0x03AC, 0x0064, 8, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA06__MMDC_DEBUG_43                      = IOMUX_PAD(0x03AC, 0x0064, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_CSI_DATA07__CSI1_DATA_9                        = IOMUX_PAD(0x03B0, 0x0068, 0, 0x06C4, 0, 0),
+	 MX6_PAD_CSI_DATA07__ESAI_TX3_RX2                       = IOMUX_PAD(0x03B0, 0x0068, 1, 0x079C, 1, 0),
+	 MX6_PAD_CSI_DATA07__I2C4_SDA                           = IOMUX_PAD(0x03B0, 0x0068, IOMUX_CONFIG_SION | 2, 0x07C4, 2, 0),
+	 MX6_PAD_CSI_DATA07__KPP_ROW_7                          = IOMUX_PAD(0x03B0, 0x0068, 3, 0x07DC, 0, 0),
+	 MX6_PAD_CSI_DATA07__UART6_CTS_B                        = IOMUX_PAD(0x03B0, 0x0068, 4, 0x0854, 1, 0),
+	 MX6_PAD_CSI_DATA07__GPIO1_IO_21                        = IOMUX_PAD(0x03B0, 0x0068, 5, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA07__WEIM_DATA_16                       = IOMUX_PAD(0x03B0, 0x0068, 6, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA07__DCIC1_OUT                          = IOMUX_PAD(0x03B0, 0x0068, 7, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA07__VADC_DATA_11                       = IOMUX_PAD(0x03B0, 0x0068, 8, 0x0000, 0, 0),
+	 MX6_PAD_CSI_DATA07__MMDC_DEBUG_44                      = IOMUX_PAD(0x03B0, 0x0068, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_CSI_HSYNC__CSI1_HSYNC                          = IOMUX_PAD(0x03B4, 0x006C, 0, 0x0700, 0, 0),
+	 MX6_PAD_CSI_HSYNC__ESAI_TX0                            = IOMUX_PAD(0x03B4, 0x006C, 1, 0x0790, 1, 0),
+	 MX6_PAD_CSI_HSYNC__AUDMUX_AUD6_TXD                     = IOMUX_PAD(0x03B4, 0x006C, 2, 0x0678, 1, 0),
+	 MX6_PAD_CSI_HSYNC__UART4_RTS_B                         = IOMUX_PAD(0x03B4, 0x006C, 3, 0x0844, 2, 0),
+	 MX6_PAD_CSI_HSYNC__MQS_LEFT                            = IOMUX_PAD(0x03B4, 0x006C, 4, 0x0000, 0, 0),
+	 MX6_PAD_CSI_HSYNC__GPIO1_IO_22                         = IOMUX_PAD(0x03B4, 0x006C, 5, 0x0000, 0, 0),
+	 MX6_PAD_CSI_HSYNC__WEIM_DATA_25                        = IOMUX_PAD(0x03B4, 0x006C, 6, 0x0000, 0, 0),
+	 MX6_PAD_CSI_HSYNC__SAI1_TX_DATA_0                      = IOMUX_PAD(0x03B4, 0x006C, 7, 0x0000, 0, 0),
+	 MX6_PAD_CSI_HSYNC__VADC_DATA_2                         = IOMUX_PAD(0x03B4, 0x006C, 8, 0x0000, 0, 0),
+	 MX6_PAD_CSI_HSYNC__MMDC_DEBUG_35                       = IOMUX_PAD(0x03B4, 0x006C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_CSI_MCLK__CSI1_MCLK                            = IOMUX_PAD(0x03B8, 0x0070, 0, 0x0000, 0, 0),
+	 MX6_PAD_CSI_MCLK__ESAI_TX_HF_CLK                       = IOMUX_PAD(0x03B8, 0x0070, 1, 0x0784, 1, 0),
+	 MX6_PAD_CSI_MCLK__OSC32K_32K_OUT                       = IOMUX_PAD(0x03B8, 0x0070, 2, 0x0000, 0, 0),
+	 MX6_PAD_CSI_MCLK__UART4_RX                             = IOMUX_PAD(0x03B8, 0x0070, 3, 0x0848, 2, 0),
+	 MX6_PAD_CSI_MCLK__ANATOP_32K_OUT                       = IOMUX_PAD(0x03B8, 0x0070, 4, 0x0000, 0, 0),
+	 MX6_PAD_CSI_MCLK__GPIO1_IO_23                          = IOMUX_PAD(0x03B8, 0x0070, 5, 0x0000, 0, 0),
+	 MX6_PAD_CSI_MCLK__WEIM_DATA_26                         = IOMUX_PAD(0x03B8, 0x0070, 6, 0x0000, 0, 0),
+	 MX6_PAD_CSI_MCLK__CSI1_FIELD                           = IOMUX_PAD(0x03B8, 0x0070, 7, 0x070C, 0, 0),
+	 MX6_PAD_CSI_MCLK__VADC_DATA_1                          = IOMUX_PAD(0x03B8, 0x0070, 8, 0x0000, 0, 0),
+	 MX6_PAD_CSI_MCLK__MMDC_DEBUG_34                        = IOMUX_PAD(0x03B8, 0x0070, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_CSI_PIXCLK__CSI1_PIXCLK                        = IOMUX_PAD(0x03BC, 0x0074, 0, 0x0704, 0, 0),
+	 MX6_PAD_CSI_PIXCLK__ESAI_RX_HF_CLK                     = IOMUX_PAD(0x03BC, 0x0074, 1, 0x0780, 1, 0),
+	 MX6_PAD_CSI_PIXCLK__AUDMUX_MCLK                        = IOMUX_PAD(0x03BC, 0x0074, 2, 0x0000, 0, 0),
+	 MX6_PAD_CSI_PIXCLK__UART4_TX                           = IOMUX_PAD(0x03BC, 0x0074, 3, 0x0848, 3, 0),
+	 MX6_PAD_CSI_PIXCLK__ANATOP_24M_OUT                     = IOMUX_PAD(0x03BC, 0x0074, 4, 0x0000, 0, 0),
+	 MX6_PAD_CSI_PIXCLK__GPIO1_IO_24                        = IOMUX_PAD(0x03BC, 0x0074, 5, 0x0000, 0, 0),
+	 MX6_PAD_CSI_PIXCLK__WEIM_DATA_27                       = IOMUX_PAD(0x03BC, 0x0074, 6, 0x0000, 0, 0),
+	 MX6_PAD_CSI_PIXCLK__ESAI_TX_HF_CLK                     = IOMUX_PAD(0x03BC, 0x0074, 7, 0x0784, 2, 0),
+	 MX6_PAD_CSI_PIXCLK__VADC_CLK                           = IOMUX_PAD(0x03BC, 0x0074, 8, 0x0000, 0, 0),
+	 MX6_PAD_CSI_PIXCLK__MMDC_DEBUG_33                      = IOMUX_PAD(0x03BC, 0x0074, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_CSI_VSYNC__CSI1_VSYNC                          = IOMUX_PAD(0x03C0, 0x0078, 0, 0x0708, 0, 0),
+	 MX6_PAD_CSI_VSYNC__ESAI_TX5_RX0                        = IOMUX_PAD(0x03C0, 0x0078, 1, 0x07A4, 1, 0),
+	 MX6_PAD_CSI_VSYNC__AUDMUX_AUD6_RXD                     = IOMUX_PAD(0x03C0, 0x0078, 2, 0x0674, 1, 0),
+	 MX6_PAD_CSI_VSYNC__UART4_CTS_B                         = IOMUX_PAD(0x03C0, 0x0078, 3, 0x0844, 3, 0),
+	 MX6_PAD_CSI_VSYNC__MQS_RIGHT                           = IOMUX_PAD(0x03C0, 0x0078, 4, 0x0000, 0, 0),
+	 MX6_PAD_CSI_VSYNC__GPIO1_IO_25                         = IOMUX_PAD(0x03C0, 0x0078, 5, 0x0000, 0, 0),
+	 MX6_PAD_CSI_VSYNC__WEIM_DATA_24                        = IOMUX_PAD(0x03C0, 0x0078, 6, 0x0000, 0, 0),
+	 MX6_PAD_CSI_VSYNC__SAI1_RX_DATA_0                      = IOMUX_PAD(0x03C0, 0x0078, 7, 0x07F8, 0, 0),
+	 MX6_PAD_CSI_VSYNC__VADC_DATA_3                         = IOMUX_PAD(0x03C0, 0x0078, 8, 0x0000, 0, 0),
+	 MX6_PAD_CSI_VSYNC__MMDC_DEBUG_36                       = IOMUX_PAD(0x03C0, 0x0078, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_ENET1_COL__ENET1_COL                           = IOMUX_PAD(0x03C4, 0x007C, 0, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_COL__ENET2_MDC                           = IOMUX_PAD(0x03C4, 0x007C, 1, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_COL__AUDMUX_AUD4_TXC                     = IOMUX_PAD(0x03C4, 0x007C, 2, 0x0654, 1, 0),
+	 MX6_PAD_ENET1_COL__UART1_RI_B                          = IOMUX_PAD(0x03C4, 0x007C, 3, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_COL__SPDIF_EXT_CLK                       = IOMUX_PAD(0x03C4, 0x007C, 4, 0x0828, 1, 0),
+	 MX6_PAD_ENET1_COL__GPIO2_IO_0                          = IOMUX_PAD(0x03C4, 0x007C, 5, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_COL__CSI2_DATA_23                        = IOMUX_PAD(0x03C4, 0x007C, 6, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_COL__LCDIF2_DATA_16                      = IOMUX_PAD(0x03C4, 0x007C, 7, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_COL__VDEC_DEBUG_37                       = IOMUX_PAD(0x03C4, 0x007C, 8, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_COL__PCIE_CTRL_DEBUG_31                  = IOMUX_PAD(0x03C4, 0x007C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_ENET1_CRS__ENET1_CRS                           = IOMUX_PAD(0x03C8, 0x0080, 0, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_CRS__ENET2_MDIO                          = IOMUX_PAD(0x03C8, 0x0080, 1, 0x0770, 1, 0),
+	 MX6_PAD_ENET1_CRS__AUDMUX_AUD4_TXD                     = IOMUX_PAD(0x03C8, 0x0080, 2, 0x0648, 1, 0),
+	 MX6_PAD_ENET1_CRS__UART1_DCD_B                         = IOMUX_PAD(0x03C8, 0x0080, 3, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_CRS__SPDIF_LOCK                          = IOMUX_PAD(0x03C8, 0x0080, 4, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_CRS__GPIO2_IO_1                          = IOMUX_PAD(0x03C8, 0x0080, 5, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_CRS__CSI2_DATA_22                        = IOMUX_PAD(0x03C8, 0x0080, 6, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_CRS__LCDIF2_DATA_17                      = IOMUX_PAD(0x03C8, 0x0080, 7, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_CRS__VDEC_DEBUG_36                       = IOMUX_PAD(0x03C8, 0x0080, 8, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_CRS__PCIE_CTRL_DEBUG_30                  = IOMUX_PAD(0x03C8, 0x0080, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_ENET1_MDC__ENET1_MDC                           = IOMUX_PAD(0x03CC, 0x0084, 0, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_MDC__ENET2_MDC                           = IOMUX_PAD(0x03CC, 0x0084, 1, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_MDC__AUDMUX_AUD3_RXFS                    = IOMUX_PAD(0x03CC, 0x0084, 2, 0x0638, 1, 0),
+	 MX6_PAD_ENET1_MDC__ANATOP_24M_OUT                      = IOMUX_PAD(0x03CC, 0x0084, 3, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_MDC__EPIT2_OUT                           = IOMUX_PAD(0x03CC, 0x0084, 4, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_MDC__GPIO2_IO_2                          = IOMUX_PAD(0x03CC, 0x0084, 5, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_MDC__USB_OTG1_PWR                        = IOMUX_PAD(0x03CC, 0x0084, 6, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_MDC__PWM7_OUT                            = IOMUX_PAD(0x03CC, 0x0084, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_ENET1_MDIO__ENET1_MDIO                         = IOMUX_PAD(0x03D0, 0x0088, 0, 0x0764, 1, 0),
+	 MX6_PAD_ENET1_MDIO__ENET2_MDIO                         = IOMUX_PAD(0x03D0, 0x0088, 1, 0x0770, 2, 0),
+	 MX6_PAD_ENET1_MDIO__AUDMUX_MCLK                        = IOMUX_PAD(0x03D0, 0x0088, 2, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_MDIO__OSC32K_32K_OUT                     = IOMUX_PAD(0x03D0, 0x0088, 3, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_MDIO__EPIT1_OUT                          = IOMUX_PAD(0x03D0, 0x0088, 4, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_MDIO__GPIO2_IO_3                         = IOMUX_PAD(0x03D0, 0x0088, 5, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_MDIO__USB_OTG1_OC                        = IOMUX_PAD(0x03D0, 0x0088, 6, 0x0860, 1, 0),
+	 MX6_PAD_ENET1_MDIO__PWM8_OUT                           = IOMUX_PAD(0x03D0, 0x0088, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_ENET1_RX_CLK__ENET1_RX_CLK                     = IOMUX_PAD(0x03D4, 0x008C, 0, 0x0768, 0, 0),
+	 MX6_PAD_ENET1_RX_CLK__ENET1_REF_CLK_25M                = IOMUX_PAD(0x03D4, 0x008C, 1, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_RX_CLK__AUDMUX_AUD4_TXFS                 = IOMUX_PAD(0x03D4, 0x008C, 2, 0x0658, 1, 0),
+	 MX6_PAD_ENET1_RX_CLK__UART1_DSR_B                      = IOMUX_PAD(0x03D4, 0x008C, 3, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_RX_CLK__SPDIF_OUT                        = IOMUX_PAD(0x03D4, 0x008C, 4, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_RX_CLK__GPIO2_IO_4                       = IOMUX_PAD(0x03D4, 0x008C, 5, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_RX_CLK__CSI2_DATA_21                     = IOMUX_PAD(0x03D4, 0x008C, 6, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_RX_CLK__LCDIF2_DATA_18                   = IOMUX_PAD(0x03D4, 0x008C, 7, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_RX_CLK__VDEC_DEBUG_35                    = IOMUX_PAD(0x03D4, 0x008C, 8, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_RX_CLK__PCIE_CTRL_DEBUG_29               = IOMUX_PAD(0x03D4, 0x008C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_ENET1_TX_CLK__ENET1_TX_CLK                     = IOMUX_PAD(0x03D8, 0x0090, 0, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1                   = IOMUX_PAD(0x03D8, 0x0090, 1, 0x0760, 1, 0),
+	 MX6_PAD_ENET1_TX_CLK__AUDMUX_AUD4_RXD                  = IOMUX_PAD(0x03D8, 0x0090, 2, 0x0644, 1, 0),
+	 MX6_PAD_ENET1_TX_CLK__UART1_DTR_B                      = IOMUX_PAD(0x03D8, 0x0090, 3, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_TX_CLK__SPDIF_SR_CLK                     = IOMUX_PAD(0x03D8, 0x0090, 4, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_TX_CLK__GPIO2_IO_5                       = IOMUX_PAD(0x03D8, 0x0090, 5, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_TX_CLK__CSI2_DATA_20                     = IOMUX_PAD(0x03D8, 0x0090, 6, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_TX_CLK__LCDIF2_DATA_19                   = IOMUX_PAD(0x03D8, 0x0090, 7, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_TX_CLK__VDEC_DEBUG_34                    = IOMUX_PAD(0x03D8, 0x0090, 8, 0x0000, 0, 0),
+	 MX6_PAD_ENET1_TX_CLK__PCIE_CTRL_DEBUG_28               = IOMUX_PAD(0x03D8, 0x0090, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_ENET2_COL__ENET2_COL                           = IOMUX_PAD(0x03DC, 0x0094, 0, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_COL__ENET1_MDC                           = IOMUX_PAD(0x03DC, 0x0094, 1, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_COL__AUDMUX_AUD4_RXC                     = IOMUX_PAD(0x03DC, 0x0094, 2, 0x064C, 1, 0),
+	 MX6_PAD_ENET2_COL__UART1_RX                            = IOMUX_PAD(0x03DC, 0x0094, 3, 0x0830, 2, 0),
+	 MX6_PAD_ENET2_COL__SPDIF_IN                            = IOMUX_PAD(0x03DC, 0x0094, 4, 0x0824, 3, 0),
+	 MX6_PAD_ENET2_COL__GPIO2_IO_6                          = IOMUX_PAD(0x03DC, 0x0094, 5, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_COL__ANATOP_OTG1_ID                      = IOMUX_PAD(0x03DC, 0x0094, 6, 0x0624, 1, 0),
+	 MX6_PAD_ENET2_COL__LCDIF2_DATA_20                      = IOMUX_PAD(0x03DC, 0x0094, 7, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_COL__VDEC_DEBUG_33                       = IOMUX_PAD(0x03DC, 0x0094, 8, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_COL__PCIE_CTRL_DEBUG_27                  = IOMUX_PAD(0x03DC, 0x0094, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_ENET2_CRS__ENET2_CRS                           = IOMUX_PAD(0x03E0, 0x0098, 0, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_CRS__ENET1_MDIO                          = IOMUX_PAD(0x03E0, 0x0098, 1, 0x0764, 2, 0),
+	 MX6_PAD_ENET2_CRS__AUDMUX_AUD4_RXFS                    = IOMUX_PAD(0x03E0, 0x0098, 2, 0x0650, 1, 0),
+	 MX6_PAD_ENET2_CRS__UART1_TX                            = IOMUX_PAD(0x03E0, 0x0098, 3, 0x0830, 3, 0),
+	 MX6_PAD_ENET2_CRS__MLB_SIG                             = IOMUX_PAD(0x03E0, 0x0098, 4, 0x07F0, 1, 0),
+	 MX6_PAD_ENET2_CRS__GPIO2_IO_7                          = IOMUX_PAD(0x03E0, 0x0098, 5, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_CRS__ANATOP_OTG2_ID                      = IOMUX_PAD(0x03E0, 0x0098, 6, 0x0628, 1, 0),
+	 MX6_PAD_ENET2_CRS__LCDIF2_DATA_21                      = IOMUX_PAD(0x03E0, 0x0098, 7, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_CRS__VDEC_DEBUG_32                       = IOMUX_PAD(0x03E0, 0x0098, 8, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_CRS__PCIE_CTRL_DEBUG_26                  = IOMUX_PAD(0x03E0, 0x0098, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_ENET2_RX_CLK__ENET2_RX_CLK                     = IOMUX_PAD(0x03E4, 0x009C, 0, 0x0774, 0, 0),
+	 MX6_PAD_ENET2_RX_CLK__ENET2_REF_CLK_25M                = IOMUX_PAD(0x03E4, 0x009C, 1, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_RX_CLK__I2C3_SCL                         = IOMUX_PAD(0x03E4, 0x009C, IOMUX_CONFIG_SION | 2, 0x07B8, 1, 0),
+	 MX6_PAD_ENET2_RX_CLK__UART1_RTS_B                      = IOMUX_PAD(0x03E4, 0x009C, 3, 0x082C, 2, 0),
+	 MX6_PAD_ENET2_RX_CLK__MLB_DATA                         = IOMUX_PAD(0x03E4, 0x009C, 4, 0x07EC, 1, 0),
+	 MX6_PAD_ENET2_RX_CLK__GPIO2_IO_8                       = IOMUX_PAD(0x03E4, 0x009C, 5, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_RX_CLK__USB_OTG2_OC                      = IOMUX_PAD(0x03E4, 0x009C, 6, 0x085C, 1, 0),
+	 MX6_PAD_ENET2_RX_CLK__LCDIF2_DATA_22                   = IOMUX_PAD(0x03E4, 0x009C, 7, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_RX_CLK__VDEC_DEBUG_31                    = IOMUX_PAD(0x03E4, 0x009C, 8, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_RX_CLK__PCIE_CTRL_DEBUG_25               = IOMUX_PAD(0x03E4, 0x009C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_ENET2_TX_CLK__ENET2_TX_CLK                     = IOMUX_PAD(0x03E8, 0x00A0, 0, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2                   = IOMUX_PAD(0x03E8, 0x00A0, 1, 0x076C, 1, 0),
+	 MX6_PAD_ENET2_TX_CLK__I2C3_SDA                         = IOMUX_PAD(0x03E8, 0x00A0, IOMUX_CONFIG_SION | 2, 0x07BC, 1, 0),
+	 MX6_PAD_ENET2_TX_CLK__UART1_CTS_B                      = IOMUX_PAD(0x03E8, 0x00A0, 3, 0x082C, 3, 0),
+	 MX6_PAD_ENET2_TX_CLK__MLB_CLK                          = IOMUX_PAD(0x03E8, 0x00A0, 4, 0x07E8, 1, 0),
+	 MX6_PAD_ENET2_TX_CLK__GPIO2_IO_9                       = IOMUX_PAD(0x03E8, 0x00A0, 5, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_TX_CLK__USB_OTG2_PWR                     = IOMUX_PAD(0x03E8, 0x00A0, 6, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_TX_CLK__LCDIF2_DATA_23                   = IOMUX_PAD(0x03E8, 0x00A0, 7, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_TX_CLK__VDEC_DEBUG_30                    = IOMUX_PAD(0x03E8, 0x00A0, 8, 0x0000, 0, 0),
+	 MX6_PAD_ENET2_TX_CLK__PCIE_CTRL_DEBUG_24               = IOMUX_PAD(0x03E8, 0x00A0, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_KEY_COL0__KPP_COL_0                            = IOMUX_PAD(0x03EC, 0x00A4, 0, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL0__USDHC3_CD_B                          = IOMUX_PAD(0x03EC, 0x00A4, 1, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL0__UART6_RTS_B                          = IOMUX_PAD(0x03EC, 0x00A4, 2, 0x0854, 2, 0),
+	 MX6_PAD_KEY_COL0__ECSPI1_SCLK                          = IOMUX_PAD(0x03EC, 0x00A4, 3, 0x0710, 0, 0),
+	 MX6_PAD_KEY_COL0__AUDMUX_AUD5_TXC                      = IOMUX_PAD(0x03EC, 0x00A4, 4, 0x066C, 0, 0),
+	 MX6_PAD_KEY_COL0__GPIO2_IO_10                          = IOMUX_PAD(0x03EC, 0x00A4, 5, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL0__SDMA_EXT_EVENT_1                     = IOMUX_PAD(0x03EC, 0x00A4, 6, 0x0820, 1, 0),
+	 MX6_PAD_KEY_COL0__SAI2_TX_BCLK                         = IOMUX_PAD(0x03EC, 0x00A4, 7, 0x0814, 0, 0),
+	 MX6_PAD_KEY_COL0__VADC_DATA_0                          = IOMUX_PAD(0x03EC, 0x00A4, 8, 0x0000, 0, 0),
+
+	 MX6_PAD_KEY_COL1__KPP_COL_1                            = IOMUX_PAD(0x03F0, 0x00A8, 0, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL1__USDHC3_RESET_B                       = IOMUX_PAD(0x03F0, 0x00A8, 1, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL1__UART6_TX                             = IOMUX_PAD(0x03F0, 0x00A8, 2, 0x0858, 2, 0),
+	 MX6_PAD_KEY_COL1__ECSPI1_MISO                          = IOMUX_PAD(0x03F0, 0x00A8, 3, 0x0714, 0, 0),
+	 MX6_PAD_KEY_COL1__AUDMUX_AUD5_TXFS                     = IOMUX_PAD(0x03F0, 0x00A8, 4, 0x0670, 0, 0),
+	 MX6_PAD_KEY_COL1__GPIO2_IO_11                          = IOMUX_PAD(0x03F0, 0x00A8, 5, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL1__USDHC3_RESET                         = IOMUX_PAD(0x03F0, 0x00A8, 6, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL1__SAI2_TX_SYNC                         = IOMUX_PAD(0x03F0, 0x00A8, 7, 0x0818, 0, 0),
+
+	 MX6_PAD_KEY_COL2__KPP_COL_2                            = IOMUX_PAD(0x03F4, 0x00AC, 0, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL2__USDHC4_CD_B                          = IOMUX_PAD(0x03F4, 0x00AC, 1, 0x0874, 1, 0),
+	 MX6_PAD_KEY_COL2__UART5_RTS_B                          = IOMUX_PAD(0x03F4, 0x00AC, 2, 0x084C, 2, 0),
+	 MX6_PAD_KEY_COL2__CAN1_TX                              = IOMUX_PAD(0x03F4, 0x00AC, 3, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL2__CANFD_TX1                            = IOMUX_PAD(0x03F4, 0x00AC, 4, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL2__GPIO2_IO_12                          = IOMUX_PAD(0x03F4, 0x00AC, 5, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL2__WEIM_DATA_30                         = IOMUX_PAD(0x03F4, 0x00AC, 6, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL2__ECSPI1_RDY                           = IOMUX_PAD(0x03F4, 0x00AC, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_KEY_COL3__KPP_COL_3                            = IOMUX_PAD(0x03F8, 0x00B0, 0, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL3__USDHC4_LCTL                          = IOMUX_PAD(0x03F8, 0x00B0, 1, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL3__UART5_TX                             = IOMUX_PAD(0x03F8, 0x00B0, 2, 0x0850, 2, 0),
+	 MX6_PAD_KEY_COL3__CAN2_TX                              = IOMUX_PAD(0x03F8, 0x00B0, 3, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL3__CANFD_TX2                            = IOMUX_PAD(0x03F8, 0x00B0, 4, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL3__GPIO2_IO_13                          = IOMUX_PAD(0x03F8, 0x00B0, 5, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL3__WEIM_DATA_28                         = IOMUX_PAD(0x03F8, 0x00B0, 6, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL3__ECSPI1_SS2                           = IOMUX_PAD(0x03F8, 0x00B0, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_KEY_COL4__KPP_COL_4                            = IOMUX_PAD(0x03FC, 0x00B4, 0, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL4__ENET2_MDC                            = IOMUX_PAD(0x03FC, 0x00B4, 1, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL4__I2C3_SCL                             = IOMUX_PAD(0x03FC, 0x00B4, IOMUX_CONFIG_SION | 2, 0x07B8, 2, 0),
+	 MX6_PAD_KEY_COL4__USDHC2_LCTL                          = IOMUX_PAD(0x03FC, 0x00B4, 3, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL4__AUDMUX_AUD5_RXC                      = IOMUX_PAD(0x03FC, 0x00B4, 4, 0x0664, 0, 0),
+	 MX6_PAD_KEY_COL4__GPIO2_IO_14                          = IOMUX_PAD(0x03FC, 0x00B4, 5, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL4__WEIM_CRE                             = IOMUX_PAD(0x03FC, 0x00B4, 6, 0x0000, 0, 0),
+	 MX6_PAD_KEY_COL4__SAI2_RX_BCLK                         = IOMUX_PAD(0x03FC, 0x00B4, 7, 0x0808, 0, 0),
+
+	 MX6_PAD_KEY_ROW0__KPP_ROW_0                            = IOMUX_PAD(0x0400, 0x00B8, 0, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW0__USDHC3_WP                            = IOMUX_PAD(0x0400, 0x00B8, 1, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW0__UART6_CTS_B                          = IOMUX_PAD(0x0400, 0x00B8, 2, 0x0854, 3, 0),
+	 MX6_PAD_KEY_ROW0__ECSPI1_MOSI                          = IOMUX_PAD(0x0400, 0x00B8, 3, 0x0718, 0, 0),
+	 MX6_PAD_KEY_ROW0__AUDMUX_AUD5_TXD                      = IOMUX_PAD(0x0400, 0x00B8, 4, 0x0660, 0, 0),
+	 MX6_PAD_KEY_ROW0__GPIO2_IO_15                          = IOMUX_PAD(0x0400, 0x00B8, 5, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW0__SDMA_EXT_EVENT_0                     = IOMUX_PAD(0x0400, 0x00B8, 6, 0x081C, 1, 0),
+	 MX6_PAD_KEY_ROW0__SAI2_TX_DATA_0                       = IOMUX_PAD(0x0400, 0x00B8, 7, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW0__GPU_IDLE                             = IOMUX_PAD(0x0400, 0x00B8, 8, 0x0000, 0, 0),
+
+	 MX6_PAD_KEY_ROW1__KPP_ROW_1                            = IOMUX_PAD(0x0404, 0x00BC, 0, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW1__USDHC4_VSELECT                       = IOMUX_PAD(0x0404, 0x00BC, 1, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW1__UART6_RX                             = IOMUX_PAD(0x0404, 0x00BC, 2, 0x0858, 3, 0),
+	 MX6_PAD_KEY_ROW1__ECSPI1_SS0                           = IOMUX_PAD(0x0404, 0x00BC, 3, 0x071C, 0, 0),
+	 MX6_PAD_KEY_ROW1__AUDMUX_AUD5_RXD                      = IOMUX_PAD(0x0404, 0x00BC, 4, 0x065C, 0, 0),
+	 MX6_PAD_KEY_ROW1__GPIO2_IO_16                          = IOMUX_PAD(0x0404, 0x00BC, 5, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW1__WEIM_DATA_31                         = IOMUX_PAD(0x0404, 0x00BC, 6, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW1__SAI2_RX_DATA_0                       = IOMUX_PAD(0x0404, 0x00BC, 7, 0x080C, 0, 0),
+	 MX6_PAD_KEY_ROW1__M4_NMI                               = IOMUX_PAD(0x0404, 0x00BC, 8, 0x0000, 0, 0),
+
+	 MX6_PAD_KEY_ROW2__KPP_ROW_2                            = IOMUX_PAD(0x0408, 0x00C0, 0, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW2__USDHC4_WP                            = IOMUX_PAD(0x0408, 0x00C0, 1, 0x0878, 1, 0),
+	 MX6_PAD_KEY_ROW2__UART5_CTS_B                          = IOMUX_PAD(0x0408, 0x00C0, 2, 0x084C, 3, 0),
+	 MX6_PAD_KEY_ROW2__CAN1_RX                              = IOMUX_PAD(0x0408, 0x00C0, 3, 0x068C, 1, 0),
+	 MX6_PAD_KEY_ROW2__CANFD_RX1                            = IOMUX_PAD(0x0408, 0x00C0, 4, 0x0694, 1, 0),
+	 MX6_PAD_KEY_ROW2__GPIO2_IO_17                          = IOMUX_PAD(0x0408, 0x00C0, 5, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW2__WEIM_DATA_29                         = IOMUX_PAD(0x0408, 0x00C0, 6, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW2__ECSPI1_SS3                           = IOMUX_PAD(0x0408, 0x00C0, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_KEY_ROW3__KPP_ROW_3                            = IOMUX_PAD(0x040C, 0x00C4, 0, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW3__USDHC3_LCTL                          = IOMUX_PAD(0x040C, 0x00C4, 1, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW3__UART5_RX                             = IOMUX_PAD(0x040C, 0x00C4, 2, 0x0850, 3, 0),
+	 MX6_PAD_KEY_ROW3__CAN2_RX                              = IOMUX_PAD(0x040C, 0x00C4, 3, 0x0690, 1, 0),
+	 MX6_PAD_KEY_ROW3__CANFD_RX2                            = IOMUX_PAD(0x040C, 0x00C4, 4, 0x0698, 1, 0),
+	 MX6_PAD_KEY_ROW3__GPIO2_IO_18                          = IOMUX_PAD(0x040C, 0x00C4, 5, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW3__WEIM_DTACK_B                         = IOMUX_PAD(0x040C, 0x00C4, 6, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW3__ECSPI1_SS1                           = IOMUX_PAD(0x040C, 0x00C4, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_KEY_ROW4__KPP_ROW_4                            = IOMUX_PAD(0x0410, 0x00C8, 0, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW4__ENET2_MDIO                           = IOMUX_PAD(0x0410, 0x00C8, 1, 0x0770, 3, 0),
+	 MX6_PAD_KEY_ROW4__I2C3_SDA                             = IOMUX_PAD(0x0410, 0x00C8, IOMUX_CONFIG_SION | 2, 0x07BC, 2, 0),
+	 MX6_PAD_KEY_ROW4__USDHC1_LCTL                          = IOMUX_PAD(0x0410, 0x00C8, 3, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW4__AUDMUX_AUD5_RXFS                     = IOMUX_PAD(0x0410, 0x00C8, 4, 0x0668, 0, 0),
+	 MX6_PAD_KEY_ROW4__GPIO2_IO_19                          = IOMUX_PAD(0x0410, 0x00C8, 5, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW4__WEIM_ACLK_FREERUN                    = IOMUX_PAD(0x0410, 0x00C8, 6, 0x0000, 0, 0),
+	 MX6_PAD_KEY_ROW4__SAI2_RX_SYNC                         = IOMUX_PAD(0x0410, 0x00C8, 7, 0x0810, 0, 0),
+
+	 MX6_PAD_LCD1_CLK__LCDIF1_CLK                           = IOMUX_PAD(0x0414, 0x00CC, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_CLK__LCDIF1_WR_RWN                        = IOMUX_PAD(0x0414, 0x00CC, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_CLK__AUDMUX_AUD3_RXC                      = IOMUX_PAD(0x0414, 0x00CC, 2, 0x0634, 1, 0),
+	 MX6_PAD_LCD1_CLK__ENET1_1588_EVENT2_IN                 = IOMUX_PAD(0x0414, 0x00CC, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_CLK__CSI1_DATA_16                         = IOMUX_PAD(0x0414, 0x00CC, 4, 0x06DC, 0, 0),
+	 MX6_PAD_LCD1_CLK__GPIO3_IO_0                           = IOMUX_PAD(0x0414, 0x00CC, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_CLK__USDHC1_WP                            = IOMUX_PAD(0x0414, 0x00CC, 6, 0x0868, 0, 0),
+	 MX6_PAD_LCD1_CLK__SIM_M_HADDR_16                       = IOMUX_PAD(0x0414, 0x00CC, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_CLK__VADC_TEST_0                          = IOMUX_PAD(0x0414, 0x00CC, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_CLK__MMDC_DEBUG_0                         = IOMUX_PAD(0x0414, 0x00CC, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA00__LCDIF1_DATA_0                     = IOMUX_PAD(0x0418, 0x00D0, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA00__WEIM_CS1_B                        = IOMUX_PAD(0x0418, 0x00D0, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA00__M4_TRACE_0                        = IOMUX_PAD(0x0418, 0x00D0, 2, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA00__KITTEN_TRACE_0                    = IOMUX_PAD(0x0418, 0x00D0, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA00__CSI1_DATA_20                      = IOMUX_PAD(0x0418, 0x00D0, 4, 0x06EC, 0, 0),
+	 MX6_PAD_LCD1_DATA00__GPIO3_IO_1                        = IOMUX_PAD(0x0418, 0x00D0, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA00__SRC_BT_CFG_0                      = IOMUX_PAD(0x0418, 0x00D0, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA00__SIM_M_HADDR_21                    = IOMUX_PAD(0x0418, 0x00D0, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA00__VADC_TEST_5                       = IOMUX_PAD(0x0418, 0x00D0, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA00__MMDC_DEBUG_5                      = IOMUX_PAD(0x0418, 0x00D0, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA01__LCDIF1_DATA_1                     = IOMUX_PAD(0x041C, 0x00D4, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA01__WEIM_CS2_B                        = IOMUX_PAD(0x041C, 0x00D4, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA01__M4_TRACE_1                        = IOMUX_PAD(0x041C, 0x00D4, 2, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA01__KITTEN_TRACE_1                    = IOMUX_PAD(0x041C, 0x00D4, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA01__CSI1_DATA_21                      = IOMUX_PAD(0x041C, 0x00D4, 4, 0x06F0, 0, 0),
+	 MX6_PAD_LCD1_DATA01__GPIO3_IO_2                        = IOMUX_PAD(0x041C, 0x00D4, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA01__SRC_BT_CFG_1                      = IOMUX_PAD(0x041C, 0x00D4, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA01__SIM_M_HADDR_22                    = IOMUX_PAD(0x041C, 0x00D4, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA01__VADC_TEST_6                       = IOMUX_PAD(0x041C, 0x00D4, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA01__MMDC_DEBUG_6                      = IOMUX_PAD(0x041C, 0x00D4, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA02__LCDIF1_DATA_2                     = IOMUX_PAD(0x0420, 0x00D8, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA02__WEIM_CS3_B                        = IOMUX_PAD(0x0420, 0x00D8, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA02__M4_TRACE_2                        = IOMUX_PAD(0x0420, 0x00D8, 2, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA02__KITTEN_TRACE_2                    = IOMUX_PAD(0x0420, 0x00D8, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA02__CSI1_DATA_22                      = IOMUX_PAD(0x0420, 0x00D8, 4, 0x06F4, 0, 0),
+	 MX6_PAD_LCD1_DATA02__GPIO3_IO_3                        = IOMUX_PAD(0x0420, 0x00D8, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA02__SRC_BT_CFG_2                      = IOMUX_PAD(0x0420, 0x00D8, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA02__SIM_M_HADDR_23                    = IOMUX_PAD(0x0420, 0x00D8, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA02__VADC_TEST_7                       = IOMUX_PAD(0x0420, 0x00D8, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA02__MMDC_DEBUG_7                      = IOMUX_PAD(0x0420, 0x00D8, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA03__LCDIF1_DATA_3                     = IOMUX_PAD(0x0424, 0x00DC, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA03__WEIM_ADDR_24                      = IOMUX_PAD(0x0424, 0x00DC, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA03__M4_TRACE_3                        = IOMUX_PAD(0x0424, 0x00DC, 2, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA03__KITTEN_TRACE_3                    = IOMUX_PAD(0x0424, 0x00DC, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA03__CSI1_DATA_23                      = IOMUX_PAD(0x0424, 0x00DC, 4, 0x06F8, 0, 0),
+	 MX6_PAD_LCD1_DATA03__GPIO3_IO_4                        = IOMUX_PAD(0x0424, 0x00DC, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA03__SRC_BT_CFG_3                      = IOMUX_PAD(0x0424, 0x00DC, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA03__SIM_M_HADDR_24                    = IOMUX_PAD(0x0424, 0x00DC, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA03__VADC_TEST_8                       = IOMUX_PAD(0x0424, 0x00DC, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA03__MMDC_DEBUG_8                      = IOMUX_PAD(0x0424, 0x00DC, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA04__LCDIF1_DATA_4                     = IOMUX_PAD(0x0428, 0x00E0, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA04__WEIM_ADDR_25                      = IOMUX_PAD(0x0428, 0x00E0, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA04__KITTEN_TRACE_4                    = IOMUX_PAD(0x0428, 0x00E0, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA04__CSI1_VSYNC                        = IOMUX_PAD(0x0428, 0x00E0, 4, 0x0708, 1, 0),
+	 MX6_PAD_LCD1_DATA04__GPIO3_IO_5                        = IOMUX_PAD(0x0428, 0x00E0, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA04__SRC_BT_CFG_4                      = IOMUX_PAD(0x0428, 0x00E0, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA04__SIM_M_HADDR_25                    = IOMUX_PAD(0x0428, 0x00E0, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA04__VADC_TEST_9                       = IOMUX_PAD(0x0428, 0x00E0, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA04__MMDC_DEBUG_9                      = IOMUX_PAD(0x0428, 0x00E0, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA05__LCDIF1_DATA_5                     = IOMUX_PAD(0x042C, 0x00E4, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA05__WEIM_ADDR_26                      = IOMUX_PAD(0x042C, 0x00E4, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA05__KITTEN_TRACE_5                    = IOMUX_PAD(0x042C, 0x00E4, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA05__CSI1_HSYNC                        = IOMUX_PAD(0x042C, 0x00E4, 4, 0x0700, 1, 0),
+	 MX6_PAD_LCD1_DATA05__GPIO3_IO_6                        = IOMUX_PAD(0x042C, 0x00E4, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA05__SRC_BT_CFG_5                      = IOMUX_PAD(0x042C, 0x00E4, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA05__SIM_M_HADDR_26                    = IOMUX_PAD(0x042C, 0x00E4, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA05__VADC_TEST_10                      = IOMUX_PAD(0x042C, 0x00E4, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA05__MMDC_DEBUG_10                     = IOMUX_PAD(0x042C, 0x00E4, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA06__LCDIF1_DATA_6                     = IOMUX_PAD(0x0430, 0x00E8, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA06__WEIM_EB_B_2                       = IOMUX_PAD(0x0430, 0x00E8, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA06__KITTEN_TRACE_6                    = IOMUX_PAD(0x0430, 0x00E8, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA06__CSI1_PIXCLK                       = IOMUX_PAD(0x0430, 0x00E8, 4, 0x0704, 1, 0),
+	 MX6_PAD_LCD1_DATA06__GPIO3_IO_7                        = IOMUX_PAD(0x0430, 0x00E8, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA06__SRC_BT_CFG_6                      = IOMUX_PAD(0x0430, 0x00E8, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA06__SIM_M_HADDR_27                    = IOMUX_PAD(0x0430, 0x00E8, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA06__VADC_TEST_11                      = IOMUX_PAD(0x0430, 0x00E8, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA06__MMDC_DEBUG_11                     = IOMUX_PAD(0x0430, 0x00E8, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA07__LCDIF1_DATA_7                     = IOMUX_PAD(0x0434, 0x00EC, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA07__WEIM_EB_B_3                       = IOMUX_PAD(0x0434, 0x00EC, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA07__KITTEN_TRACE_7                    = IOMUX_PAD(0x0434, 0x00EC, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA07__CSI1_MCLK                         = IOMUX_PAD(0x0434, 0x00EC, 4, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA07__GPIO3_IO_8                        = IOMUX_PAD(0x0434, 0x00EC, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA07__SRC_BT_CFG_7                      = IOMUX_PAD(0x0434, 0x00EC, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA07__SIM_M_HADDR_28                    = IOMUX_PAD(0x0434, 0x00EC, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA07__VADC_TEST_12                      = IOMUX_PAD(0x0434, 0x00EC, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA07__MMDC_DEBUG_12                     = IOMUX_PAD(0x0434, 0x00EC, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA08__LCDIF1_DATA_8                     = IOMUX_PAD(0x0438, 0x00F0, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA08__WEIM_AD_8                         = IOMUX_PAD(0x0438, 0x00F0, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA08__KITTEN_TRACE_8                    = IOMUX_PAD(0x0438, 0x00F0, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA08__CSI1_DATA_9                       = IOMUX_PAD(0x0438, 0x00F0, 4, 0x06C4, 1, 0),
+	 MX6_PAD_LCD1_DATA08__GPIO3_IO_9                        = IOMUX_PAD(0x0438, 0x00F0, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA08__SRC_BT_CFG_8                      = IOMUX_PAD(0x0438, 0x00F0, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA08__SIM_M_HADDR_29                    = IOMUX_PAD(0x0438, 0x00F0, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA08__VADC_TEST_13                      = IOMUX_PAD(0x0438, 0x00F0, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA08__MMDC_DEBUG_13                     = IOMUX_PAD(0x0438, 0x00F0, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA09__LCDIF1_DATA_9                     = IOMUX_PAD(0x043C, 0x00F4, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA09__WEIM_AD_9                         = IOMUX_PAD(0x043C, 0x00F4, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA09__KITTEN_TRACE_9                    = IOMUX_PAD(0x043C, 0x00F4, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA09__CSI1_DATA_8                       = IOMUX_PAD(0x043C, 0x00F4, 4, 0x06C0, 1, 0),
+	 MX6_PAD_LCD1_DATA09__GPIO3_IO_10                       = IOMUX_PAD(0x043C, 0x00F4, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA09__SRC_BT_CFG_9                      = IOMUX_PAD(0x043C, 0x00F4, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA09__SIM_M_HADDR_30                    = IOMUX_PAD(0x043C, 0x00F4, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA09__VADC_TEST_14                      = IOMUX_PAD(0x043C, 0x00F4, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA09__MMDC_DEBUG_14                     = IOMUX_PAD(0x043C, 0x00F4, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA10__LCDIF1_DATA_10                    = IOMUX_PAD(0x0440, 0x00F8, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA10__WEIM_AD_10                        = IOMUX_PAD(0x0440, 0x00F8, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA10__KITTEN_TRACE_10                   = IOMUX_PAD(0x0440, 0x00F8, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA10__CSI1_DATA_7                       = IOMUX_PAD(0x0440, 0x00F8, 4, 0x06BC, 1, 0),
+	 MX6_PAD_LCD1_DATA10__GPIO3_IO_11                       = IOMUX_PAD(0x0440, 0x00F8, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA10__SRC_BT_CFG_10                     = IOMUX_PAD(0x0440, 0x00F8, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA10__SIM_M_HADDR_31                    = IOMUX_PAD(0x0440, 0x00F8, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA10__VADC_TEST_15                      = IOMUX_PAD(0x0440, 0x00F8, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA10__MMDC_DEBUG_15                     = IOMUX_PAD(0x0440, 0x00F8, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA11__LCDIF1_DATA_11                    = IOMUX_PAD(0x0444, 0x00FC, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA11__WEIM_AD_11                        = IOMUX_PAD(0x0444, 0x00FC, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA11__KITTEN_TRACE_11                   = IOMUX_PAD(0x0444, 0x00FC, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA11__CSI1_DATA_6                       = IOMUX_PAD(0x0444, 0x00FC, 4, 0x06B8, 1, 0),
+	 MX6_PAD_LCD1_DATA11__GPIO3_IO_12                       = IOMUX_PAD(0x0444, 0x00FC, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA11__SRC_BT_CFG_11                     = IOMUX_PAD(0x0444, 0x00FC, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA11__SIM_M_HBURST_0                    = IOMUX_PAD(0x0444, 0x00FC, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA11__VADC_TEST_16                      = IOMUX_PAD(0x0444, 0x00FC, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA11__MMDC_DEBUG_16                     = IOMUX_PAD(0x0444, 0x00FC, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA12__LCDIF1_DATA_12                    = IOMUX_PAD(0x0448, 0x0100, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA12__WEIM_AD_12                        = IOMUX_PAD(0x0448, 0x0100, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA12__KITTEN_TRACE_12                   = IOMUX_PAD(0x0448, 0x0100, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA12__CSI1_DATA_5                       = IOMUX_PAD(0x0448, 0x0100, 4, 0x06B4, 1, 0),
+	 MX6_PAD_LCD1_DATA12__GPIO3_IO_13                       = IOMUX_PAD(0x0448, 0x0100, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA12__SRC_BT_CFG_12                     = IOMUX_PAD(0x0448, 0x0100, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA12__SIM_M_HBURST_1                    = IOMUX_PAD(0x0448, 0x0100, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA12__VADC_TEST_17                      = IOMUX_PAD(0x0448, 0x0100, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA12__MMDC_DEBUG_17                     = IOMUX_PAD(0x0448, 0x0100, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA13__LCDIF1_DATA_13                    = IOMUX_PAD(0x044C, 0x0104, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA13__WEIM_AD_13                        = IOMUX_PAD(0x044C, 0x0104, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA13__KITTEN_TRACE_13                   = IOMUX_PAD(0x044C, 0x0104, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA13__CSI1_DATA_4                       = IOMUX_PAD(0x044C, 0x0104, 4, 0x06B0, 1, 0),
+	 MX6_PAD_LCD1_DATA13__GPIO3_IO_14                       = IOMUX_PAD(0x044C, 0x0104, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA13__SRC_BT_CFG_13                     = IOMUX_PAD(0x044C, 0x0104, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA13__SIM_M_HBURST_2                    = IOMUX_PAD(0x044C, 0x0104, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA13__VADC_TEST_18                      = IOMUX_PAD(0x044C, 0x0104, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA13__MMDC_DEBUG_18                     = IOMUX_PAD(0x044C, 0x0104, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA14__LCDIF1_DATA_14                    = IOMUX_PAD(0x0450, 0x0108, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA14__WEIM_AD_14                        = IOMUX_PAD(0x0450, 0x0108, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA14__KITTEN_TRACE_14                   = IOMUX_PAD(0x0450, 0x0108, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA14__CSI1_DATA_3                       = IOMUX_PAD(0x0450, 0x0108, 4, 0x06AC, 1, 0),
+	 MX6_PAD_LCD1_DATA14__GPIO3_IO_15                       = IOMUX_PAD(0x0450, 0x0108, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA14__SRC_BT_CFG_14                     = IOMUX_PAD(0x0450, 0x0108, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA14__SIM_M_HMASTLOCK                   = IOMUX_PAD(0x0450, 0x0108, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA14__VADC_TEST_19                      = IOMUX_PAD(0x0450, 0x0108, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA14__MMDC_DEBUG_19                     = IOMUX_PAD(0x0450, 0x0108, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA15__LCDIF1_DATA_15                    = IOMUX_PAD(0x0454, 0x010C, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA15__WEIM_AD_15                        = IOMUX_PAD(0x0454, 0x010C, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA15__KITTEN_TRACE_15                   = IOMUX_PAD(0x0454, 0x010C, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA15__CSI1_DATA_2                       = IOMUX_PAD(0x0454, 0x010C, 4, 0x06A8, 1, 0),
+	 MX6_PAD_LCD1_DATA15__GPIO3_IO_16                       = IOMUX_PAD(0x0454, 0x010C, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA15__SRC_BT_CFG_15                     = IOMUX_PAD(0x0454, 0x010C, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA15__SIM_M_HPROT_0                     = IOMUX_PAD(0x0454, 0x010C, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA15__VDEC_DEBUG_0                      = IOMUX_PAD(0x0454, 0x010C, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA15__MMDC_DEBUG_20                     = IOMUX_PAD(0x0454, 0x010C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA16__LCDIF1_DATA_16                    = IOMUX_PAD(0x0458, 0x0110, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA16__WEIM_ADDR_16                      = IOMUX_PAD(0x0458, 0x0110, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA16__M4_TRACE_CLK                      = IOMUX_PAD(0x0458, 0x0110, 2, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA16__KITTEN_TRACE_CLK                  = IOMUX_PAD(0x0458, 0x0110, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA16__CSI1_DATA_1                       = IOMUX_PAD(0x0458, 0x0110, 4, 0x06A4, 0, 0),
+	 MX6_PAD_LCD1_DATA16__GPIO3_IO_17                       = IOMUX_PAD(0x0458, 0x0110, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA16__SRC_BT_CFG_24                     = IOMUX_PAD(0x0458, 0x0110, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA16__SIM_M_HPROT_1                     = IOMUX_PAD(0x0458, 0x0110, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA16__VDEC_DEBUG_1                      = IOMUX_PAD(0x0458, 0x0110, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA16__MMDC_DEBUG_21                     = IOMUX_PAD(0x0458, 0x0110, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA17__LCDIF1_DATA_17                    = IOMUX_PAD(0x045C, 0x0114, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA17__WEIM_ADDR_17                      = IOMUX_PAD(0x045C, 0x0114, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA17__KITTEN_TRACE_CTL                  = IOMUX_PAD(0x045C, 0x0114, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA17__CSI1_DATA_0                       = IOMUX_PAD(0x045C, 0x0114, 4, 0x06A0, 0, 0),
+	 MX6_PAD_LCD1_DATA17__GPIO3_IO_18                       = IOMUX_PAD(0x045C, 0x0114, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA17__SRC_BT_CFG_25                     = IOMUX_PAD(0x045C, 0x0114, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA17__SIM_M_HPROT_2                     = IOMUX_PAD(0x045C, 0x0114, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA17__VDEC_DEBUG_2                      = IOMUX_PAD(0x045C, 0x0114, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA17__MMDC_DEBUG_22                     = IOMUX_PAD(0x045C, 0x0114, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA18__LCDIF1_DATA_18                    = IOMUX_PAD(0x0460, 0x0118, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA18__WEIM_ADDR_18                      = IOMUX_PAD(0x0460, 0x0118, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA18__M4_EVENTO                         = IOMUX_PAD(0x0460, 0x0118, 2, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA18__KITTEN_EVENTO                     = IOMUX_PAD(0x0460, 0x0118, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA18__CSI1_DATA_15                      = IOMUX_PAD(0x0460, 0x0118, 4, 0x06D8, 0, 0),
+	 MX6_PAD_LCD1_DATA18__GPIO3_IO_19                       = IOMUX_PAD(0x0460, 0x0118, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA18__SRC_BT_CFG_26                     = IOMUX_PAD(0x0460, 0x0118, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA18__SIM_M_HPROT_3                     = IOMUX_PAD(0x0460, 0x0118, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA18__VDEC_DEBUG_3                      = IOMUX_PAD(0x0460, 0x0118, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA18__MMDC_DEBUG_23                     = IOMUX_PAD(0x0460, 0x0118, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA19__LCDIF1_DATA_19                    = IOMUX_PAD(0x0464, 0x011C, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA19__WEIM_ADDR_19                      = IOMUX_PAD(0x0464, 0x011C, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA19__M4_TRACE_SWO                      = IOMUX_PAD(0x0464, 0x011C, 2, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA19__CSI1_DATA_14                      = IOMUX_PAD(0x0464, 0x011C, 4, 0x06D4, 0, 0),
+	 MX6_PAD_LCD1_DATA19__GPIO3_IO_20                       = IOMUX_PAD(0x0464, 0x011C, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA19__SRC_BT_CFG_27                     = IOMUX_PAD(0x0464, 0x011C, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA19__SIM_M_HREADYOUT                   = IOMUX_PAD(0x0464, 0x011C, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA19__VDEC_DEBUG_4                      = IOMUX_PAD(0x0464, 0x011C, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA19__MMDC_DEBUG_24                     = IOMUX_PAD(0x0464, 0x011C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA20__LCDIF1_DATA_20                    = IOMUX_PAD(0x0468, 0x0120, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA20__WEIM_ADDR_20                      = IOMUX_PAD(0x0468, 0x0120, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA20__PWM8_OUT                          = IOMUX_PAD(0x0468, 0x0120, 2, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA20__ENET1_1588_EVENT2_OUT             = IOMUX_PAD(0x0468, 0x0120, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA20__CSI1_DATA_13                      = IOMUX_PAD(0x0468, 0x0120, 4, 0x06D0, 0, 0),
+	 MX6_PAD_LCD1_DATA20__GPIO3_IO_21                       = IOMUX_PAD(0x0468, 0x0120, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA20__SRC_BT_CFG_28                     = IOMUX_PAD(0x0468, 0x0120, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA20__SIM_M_HRESP                       = IOMUX_PAD(0x0468, 0x0120, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA20__VDEC_DEBUG_5                      = IOMUX_PAD(0x0468, 0x0120, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA20__MMDC_DEBUG_25                     = IOMUX_PAD(0x0468, 0x0120, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA21__LCDIF1_DATA_21                    = IOMUX_PAD(0x046C, 0x0124, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA21__WEIM_ADDR_21                      = IOMUX_PAD(0x046C, 0x0124, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA21__PWM7_OUT                          = IOMUX_PAD(0x046C, 0x0124, 2, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA21__ENET1_1588_EVENT3_OUT             = IOMUX_PAD(0x046C, 0x0124, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA21__CSI1_DATA_12                      = IOMUX_PAD(0x046C, 0x0124, 4, 0x06CC, 0, 0),
+	 MX6_PAD_LCD1_DATA21__GPIO3_IO_22                       = IOMUX_PAD(0x046C, 0x0124, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA21__SRC_BT_CFG_29                     = IOMUX_PAD(0x046C, 0x0124, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA21__SIM_M_HSIZE_0                     = IOMUX_PAD(0x046C, 0x0124, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA21__VDEC_DEBUG_6                      = IOMUX_PAD(0x046C, 0x0124, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA21__MMDC_DEBUG_26                     = IOMUX_PAD(0x046C, 0x0124, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA22__LCDIF1_DATA_22                    = IOMUX_PAD(0x0470, 0x0128, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA22__WEIM_ADDR_22                      = IOMUX_PAD(0x0470, 0x0128, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA22__PWM6_OUT                          = IOMUX_PAD(0x0470, 0x0128, 2, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA22__ENET2_1588_EVENT2_OUT             = IOMUX_PAD(0x0470, 0x0128, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA22__CSI1_DATA_11                      = IOMUX_PAD(0x0470, 0x0128, 4, 0x06C8, 0, 0),
+	 MX6_PAD_LCD1_DATA22__GPIO3_IO_23                       = IOMUX_PAD(0x0470, 0x0128, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA22__SRC_BT_CFG_30                     = IOMUX_PAD(0x0470, 0x0128, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA22__SIM_M_HSIZE_1                     = IOMUX_PAD(0x0470, 0x0128, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA22__VDEC_DEBUG_7                      = IOMUX_PAD(0x0470, 0x0128, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA22__MMDC_DEBUG_27                     = IOMUX_PAD(0x0470, 0x0128, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_DATA23__LCDIF1_DATA_23                    = IOMUX_PAD(0x0474, 0x012C, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA23__WEIM_ADDR_23                      = IOMUX_PAD(0x0474, 0x012C, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA23__PWM5_OUT                          = IOMUX_PAD(0x0474, 0x012C, 2, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA23__ENET2_1588_EVENT3_OUT             = IOMUX_PAD(0x0474, 0x012C, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA23__CSI1_DATA_10                      = IOMUX_PAD(0x0474, 0x012C, 4, 0x06FC, 0, 0),
+	 MX6_PAD_LCD1_DATA23__GPIO3_IO_24                       = IOMUX_PAD(0x0474, 0x012C, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA23__SRC_BT_CFG_31                     = IOMUX_PAD(0x0474, 0x012C, 6, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA23__SIM_M_HSIZE_2                     = IOMUX_PAD(0x0474, 0x012C, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA23__VDEC_DEBUG_8                      = IOMUX_PAD(0x0474, 0x012C, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_DATA23__MMDC_DEBUG_28                     = IOMUX_PAD(0x0474, 0x012C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_ENABLE__LCDIF1_ENABLE                     = IOMUX_PAD(0x0478, 0x0130, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_ENABLE__LCDIF1_RD_E                       = IOMUX_PAD(0x0478, 0x0130, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_ENABLE__AUDMUX_AUD3_TXC                   = IOMUX_PAD(0x0478, 0x0130, 2, 0x063C, 1, 0),
+	 MX6_PAD_LCD1_ENABLE__ENET1_1588_EVENT3_IN              = IOMUX_PAD(0x0478, 0x0130, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_ENABLE__CSI1_DATA_17                      = IOMUX_PAD(0x0478, 0x0130, 4, 0x06E0, 0, 0),
+	 MX6_PAD_LCD1_ENABLE__GPIO3_IO_25                       = IOMUX_PAD(0x0478, 0x0130, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_ENABLE__USDHC1_CD_B                       = IOMUX_PAD(0x0478, 0x0130, 6, 0x0864, 0, 0),
+	 MX6_PAD_LCD1_ENABLE__SIM_M_HADDR_17                    = IOMUX_PAD(0x0478, 0x0130, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_ENABLE__VADC_TEST_1                       = IOMUX_PAD(0x0478, 0x0130, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_ENABLE__MMDC_DEBUG_1                      = IOMUX_PAD(0x0478, 0x0130, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_HSYNC__LCDIF1_HSYNC                       = IOMUX_PAD(0x047C, 0x0134, 0, 0x07E0, 0, 0),
+	 MX6_PAD_LCD1_HSYNC__LCDIF1_RS                          = IOMUX_PAD(0x047C, 0x0134, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_HSYNC__AUDMUX_AUD3_TXD                    = IOMUX_PAD(0x047C, 0x0134, 2, 0x0630, 1, 0),
+	 MX6_PAD_LCD1_HSYNC__ENET2_1588_EVENT2_IN               = IOMUX_PAD(0x047C, 0x0134, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_HSYNC__CSI1_DATA_18                       = IOMUX_PAD(0x047C, 0x0134, 4, 0x06E4, 0, 0),
+	 MX6_PAD_LCD1_HSYNC__GPIO3_IO_26                        = IOMUX_PAD(0x047C, 0x0134, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_HSYNC__USDHC2_WP                          = IOMUX_PAD(0x047C, 0x0134, 6, 0x0870, 0, 0),
+	 MX6_PAD_LCD1_HSYNC__SIM_M_HADDR_18                     = IOMUX_PAD(0x047C, 0x0134, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_HSYNC__VADC_TEST_2                        = IOMUX_PAD(0x047C, 0x0134, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_HSYNC__MMDC_DEBUG_2                       = IOMUX_PAD(0x047C, 0x0134, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_RESET__LCDIF1_RESET                       = IOMUX_PAD(0x0480, 0x0138, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_RESET__LCDIF1_CS                          = IOMUX_PAD(0x0480, 0x0138, 1, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_RESET__AUDMUX_AUD3_RXD                    = IOMUX_PAD(0x0480, 0x0138, 2, 0x062C, 1, 0),
+	 MX6_PAD_LCD1_RESET__KITTEN_EVENTI                      = IOMUX_PAD(0x0480, 0x0138, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_RESET__M4_EVENTI                          = IOMUX_PAD(0x0480, 0x0138, 4, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_RESET__GPIO3_IO_27                        = IOMUX_PAD(0x0480, 0x0138, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_RESET__CCM_PMIC_RDY                       = IOMUX_PAD(0x0480, 0x0138, 6, 0x069C, 0, 0),
+	 MX6_PAD_LCD1_RESET__SIM_M_HADDR_20                     = IOMUX_PAD(0x0480, 0x0138, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_RESET__VADC_TEST_4                        = IOMUX_PAD(0x0480, 0x0138, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_RESET__MMDC_DEBUG_4                       = IOMUX_PAD(0x0480, 0x0138, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_LCD1_VSYNC__LCDIF1_VSYNC                       = IOMUX_PAD(0x0484, 0x013C, 0, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_VSYNC__LCDIF1_BUSY                        = IOMUX_PAD(0x0484, 0x013C, 1, 0x07E0, 1, 0),
+	 MX6_PAD_LCD1_VSYNC__AUDMUX_AUD3_TXFS                   = IOMUX_PAD(0x0484, 0x013C, 2, 0x0640, 1, 0),
+	 MX6_PAD_LCD1_VSYNC__ENET2_1588_EVENT3_IN               = IOMUX_PAD(0x0484, 0x013C, 3, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_VSYNC__CSI1_DATA_19                       = IOMUX_PAD(0x0484, 0x013C, 4, 0x06E8, 0, 0),
+	 MX6_PAD_LCD1_VSYNC__GPIO3_IO_28                        = IOMUX_PAD(0x0484, 0x013C, 5, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_VSYNC__USDHC2_CD_B                        = IOMUX_PAD(0x0484, 0x013C, 6, 0x086C, 0, 0),
+	 MX6_PAD_LCD1_VSYNC__SIM_M_HADDR_19                     = IOMUX_PAD(0x0484, 0x013C, 7, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_VSYNC__VADC_TEST_3                        = IOMUX_PAD(0x0484, 0x013C, 8, 0x0000, 0, 0),
+	 MX6_PAD_LCD1_VSYNC__MMDC_DEBUG_3                       = IOMUX_PAD(0x0484, 0x013C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_ALE__RAWNAND_ALE                          = IOMUX_PAD(0x0488, 0x0140, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_ALE__I2C3_SDA                             = IOMUX_PAD(0x0488, 0x0140, IOMUX_CONFIG_SION | 1, 0x07BC, 0, 0),
+	 MX6_PAD_NAND_ALE__QSPI2_A_SS0_B                        = IOMUX_PAD(0x0488, 0x0140, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_ALE__ECSPI2_SS0                           = IOMUX_PAD(0x0488, 0x0140, 3, 0x072C, 0, 0),
+	 MX6_PAD_NAND_ALE__ESAI_TX3_RX2                         = IOMUX_PAD(0x0488, 0x0140, 4, 0x079C, 0, 0),
+	 MX6_PAD_NAND_ALE__GPIO4_IO_0                           = IOMUX_PAD(0x0488, 0x0140, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_ALE__WEIM_CS0_B                           = IOMUX_PAD(0x0488, 0x0140, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_ALE__TPSMP_HDATA_0                        = IOMUX_PAD(0x0488, 0x0140, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_ALE__ANATOP_USBPHY1_TSTI_TX_EN            = IOMUX_PAD(0x0488, 0x0140, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_ALE__SDMA_DEBUG_PC_12                     = IOMUX_PAD(0x0488, 0x0140, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B                      = IOMUX_PAD(0x048C, 0x0144, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CE0_B__USDHC2_VSELECT                     = IOMUX_PAD(0x048C, 0x0144, 1, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CE0_B__QSPI2_A_DATA_2                     = IOMUX_PAD(0x048C, 0x0144, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CE0_B__AUDMUX_AUD4_TXC                    = IOMUX_PAD(0x048C, 0x0144, 3, 0x0654, 0, 0),
+	 MX6_PAD_NAND_CE0_B__ESAI_TX_CLK                        = IOMUX_PAD(0x048C, 0x0144, 4, 0x078C, 0, 0),
+	 MX6_PAD_NAND_CE0_B__GPIO4_IO_1                         = IOMUX_PAD(0x048C, 0x0144, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CE0_B__WEIM_LBA_B                         = IOMUX_PAD(0x048C, 0x0144, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CE0_B__TPSMP_HDATA_3                      = IOMUX_PAD(0x048C, 0x0144, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CE0_B__ANATOP_USBPHY1_TSTI_TX_HIZ         = IOMUX_PAD(0x048C, 0x0144, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CE0_B__SDMA_DEBUG_PC_9                    = IOMUX_PAD(0x048C, 0x0144, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B                      = IOMUX_PAD(0x0490, 0x0148, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CE1_B__USDHC3_RESET_B                     = IOMUX_PAD(0x0490, 0x0148, 1, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CE1_B__QSPI2_A_DATA_3                     = IOMUX_PAD(0x0490, 0x0148, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CE1_B__AUDMUX_AUD4_TXD                    = IOMUX_PAD(0x0490, 0x0148, 3, 0x0648, 0, 0),
+	 MX6_PAD_NAND_CE1_B__ESAI_TX0                           = IOMUX_PAD(0x0490, 0x0148, 4, 0x0790, 0, 0),
+	 MX6_PAD_NAND_CE1_B__GPIO4_IO_2                         = IOMUX_PAD(0x0490, 0x0148, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CE1_B__WEIM_OE                            = IOMUX_PAD(0x0490, 0x0148, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CE1_B__TPSMP_HDATA_4                      = IOMUX_PAD(0x0490, 0x0148, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CE1_B__ANATOP_USBPHY1_TSTI_TX_LS_MODE     = IOMUX_PAD(0x0490, 0x0148, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CE1_B__SDMA_DEBUG_PC_8                    = IOMUX_PAD(0x0490, 0x0148, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_CLE__RAWNAND_CLE                          = IOMUX_PAD(0x0494, 0x014C, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CLE__I2C3_SCL                             = IOMUX_PAD(0x0494, 0x014C, IOMUX_CONFIG_SION | 1, 0x07B8, 0, 0),
+	 MX6_PAD_NAND_CLE__QSPI2_A_SCLK                         = IOMUX_PAD(0x0494, 0x014C, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CLE__ECSPI2_SCLK                          = IOMUX_PAD(0x0494, 0x014C, 3, 0x0720, 0, 0),
+	 MX6_PAD_NAND_CLE__ESAI_TX2_RX3                         = IOMUX_PAD(0x0494, 0x014C, 4, 0x0798, 0, 0),
+	 MX6_PAD_NAND_CLE__GPIO4_IO_3                           = IOMUX_PAD(0x0494, 0x014C, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CLE__WEIM_BCLK                            = IOMUX_PAD(0x0494, 0x014C, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CLE__TPSMP_CLK                            = IOMUX_PAD(0x0494, 0x014C, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CLE__ANATOP_USBPHY1_TSTI_TX_DP            = IOMUX_PAD(0x0494, 0x014C, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_CLE__SDMA_DEBUG_PC_13                     = IOMUX_PAD(0x0494, 0x014C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_DATA00__RAWNAND_DATA00                    = IOMUX_PAD(0x0498, 0x0150, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA00__USDHC1_DATA4                      = IOMUX_PAD(0x0498, 0x0150, 1, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA00__QSPI2_B_DATA_1                    = IOMUX_PAD(0x0498, 0x0150, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA00__ECSPI5_MISO                       = IOMUX_PAD(0x0498, 0x0150, 3, 0x0754, 0, 0),
+	 MX6_PAD_NAND_DATA00__ESAI_RX_CLK                       = IOMUX_PAD(0x0498, 0x0150, 4, 0x0788, 0, 0),
+	 MX6_PAD_NAND_DATA00__GPIO4_IO_4                        = IOMUX_PAD(0x0498, 0x0150, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA00__WEIM_AD_0                         = IOMUX_PAD(0x0498, 0x0150, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA00__TPSMP_HDATA_7                     = IOMUX_PAD(0x0498, 0x0150, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA00__ANATOP_USBPHY1_TSTO_RX_DISCON_DET = IOMUX_PAD(0x0498, 0x0150, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA00__SDMA_DEBUG_EVT_CHN_LINES_5        = IOMUX_PAD(0x0498, 0x0150, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_DATA01__RAWNAND_DATA01                    = IOMUX_PAD(0x049C, 0x0154, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA01__USDHC1_DATA5                      = IOMUX_PAD(0x049C, 0x0154, 1, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA01__QSPI2_B_DATA_0                    = IOMUX_PAD(0x049C, 0x0154, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA01__ECSPI5_MOSI                       = IOMUX_PAD(0x049C, 0x0154, 3, 0x0758, 0, 0),
+	 MX6_PAD_NAND_DATA01__ESAI_RX_FS                        = IOMUX_PAD(0x049C, 0x0154, 4, 0x0778, 0, 0),
+	 MX6_PAD_NAND_DATA01__GPIO4_IO_5                        = IOMUX_PAD(0x049C, 0x0154, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA01__WEIM_AD_1                         = IOMUX_PAD(0x049C, 0x0154, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA01__TPSMP_HDATA_8                     = IOMUX_PAD(0x049C, 0x0154, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA01__ANATOP_USBPHY1_TSTO_RX_HS_RXD     = IOMUX_PAD(0x049C, 0x0154, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA01__SDMA_DEBUG_EVT_CHN_LINES_4        = IOMUX_PAD(0x049C, 0x0154, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_DATA02__RAWNAND_DATA02                    = IOMUX_PAD(0x04A0, 0x0158, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA02__USDHC1_DATA6                      = IOMUX_PAD(0x04A0, 0x0158, 1, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA02__QSPI2_B_SCLK                      = IOMUX_PAD(0x04A0, 0x0158, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA02__ECSPI5_SCLK                       = IOMUX_PAD(0x04A0, 0x0158, 3, 0x0750, 0, 0),
+	 MX6_PAD_NAND_DATA02__ESAI_TX_HF_CLK                    = IOMUX_PAD(0x04A0, 0x0158, 4, 0x0784, 0, 0),
+	 MX6_PAD_NAND_DATA02__GPIO4_IO_6                        = IOMUX_PAD(0x04A0, 0x0158, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA02__WEIM_AD_2                         = IOMUX_PAD(0x04A0, 0x0158, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA02__TPSMP_HDATA_9                     = IOMUX_PAD(0x04A0, 0x0158, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA02__ANATOP_USBPHY2_TSTO_PLL_CLK20DIV  = IOMUX_PAD(0x04A0, 0x0158, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA02__SDMA_DEBUG_EVT_CHN_LINES_3        = IOMUX_PAD(0x04A0, 0x0158, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_DATA03__RAWNAND_DATA03                    = IOMUX_PAD(0x04A4, 0x015C, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA03__USDHC1_DATA7                      = IOMUX_PAD(0x04A4, 0x015C, 1, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA03__QSPI2_B_SS0_B                     = IOMUX_PAD(0x04A4, 0x015C, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA03__ECSPI5_SS0                        = IOMUX_PAD(0x04A4, 0x015C, 3, 0x075C, 0, 0),
+	 MX6_PAD_NAND_DATA03__ESAI_RX_HF_CLK                    = IOMUX_PAD(0x04A4, 0x015C, 4, 0x0780, 0, 0),
+	 MX6_PAD_NAND_DATA03__GPIO4_IO_7                        = IOMUX_PAD(0x04A4, 0x015C, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA03__WEIM_AD_3                         = IOMUX_PAD(0x04A4, 0x015C, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA03__TPSMP_HDATA_10                    = IOMUX_PAD(0x04A4, 0x015C, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA03__ANATOP_USBPHY1_TSTO_RX_SQUELCH    = IOMUX_PAD(0x04A4, 0x015C, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA03__SDMA_DEBUG_EVT_CHN_LINES_6        = IOMUX_PAD(0x04A4, 0x015C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_DATA04__RAWNAND_DATA04                    = IOMUX_PAD(0x04A8, 0x0160, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA04__USDHC2_DATA4                      = IOMUX_PAD(0x04A8, 0x0160, 1, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA04__QSPI2_B_SS1_B                     = IOMUX_PAD(0x04A8, 0x0160, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA04__UART3_RTS_B                       = IOMUX_PAD(0x04A8, 0x0160, 3, 0x083C, 0, 0),
+	 MX6_PAD_NAND_DATA04__AUDMUX_AUD4_RXFS                  = IOMUX_PAD(0x04A8, 0x0160, 4, 0x0650, 0, 0),
+	 MX6_PAD_NAND_DATA04__GPIO4_IO_8                        = IOMUX_PAD(0x04A8, 0x0160, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA04__WEIM_AD_4                         = IOMUX_PAD(0x04A8, 0x0160, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA04__TPSMP_HDATA_11                    = IOMUX_PAD(0x04A8, 0x0160, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA04__ANATOP_USBPHY2_TSTO_RX_SQUELCH    = IOMUX_PAD(0x04A8, 0x0160, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA04__SDMA_DEBUG_CORE_STATE_0           = IOMUX_PAD(0x04A8, 0x0160, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_DATA05__RAWNAND_DATA05                    = IOMUX_PAD(0x04AC, 0x0164, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA05__USDHC2_DATA5                      = IOMUX_PAD(0x04AC, 0x0164, 1, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA05__QSPI2_B_DQS                       = IOMUX_PAD(0x04AC, 0x0164, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA05__UART3_CTS_B                       = IOMUX_PAD(0x04AC, 0x0164, 3, 0x083C, 1, 0),
+	 MX6_PAD_NAND_DATA05__AUDMUX_AUD4_RXC                   = IOMUX_PAD(0x04AC, 0x0164, 4, 0x064C, 0, 0),
+	 MX6_PAD_NAND_DATA05__GPIO4_IO_9                        = IOMUX_PAD(0x04AC, 0x0164, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA05__WEIM_AD_5                         = IOMUX_PAD(0x04AC, 0x0164, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA05__TPSMP_HDATA_12                    = IOMUX_PAD(0x04AC, 0x0164, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA05__ANATOP_USBPHY2_TSTO_RX_DISCON_DET = IOMUX_PAD(0x04AC, 0x0164, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA05__SDMA_DEBUG_CORE_STATE_1           = IOMUX_PAD(0x04AC, 0x0164, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_DATA06__RAWNAND_DATA06                    = IOMUX_PAD(0x04B0, 0x0168, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA06__USDHC2_DATA6                      = IOMUX_PAD(0x04B0, 0x0168, 1, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA06__QSPI2_A_SS1_B                     = IOMUX_PAD(0x04B0, 0x0168, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA06__UART3_RX                          = IOMUX_PAD(0x04B0, 0x0168, 3, 0x0840, 0, 0),
+	 MX6_PAD_NAND_DATA06__PWM3_OUT                          = IOMUX_PAD(0x04B0, 0x0168, 4, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA06__GPIO4_IO_10                       = IOMUX_PAD(0x04B0, 0x0168, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA06__WEIM_AD_6                         = IOMUX_PAD(0x04B0, 0x0168, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA06__TPSMP_HDATA_13                    = IOMUX_PAD(0x04B0, 0x0168, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA06__ANATOP_USBPHY2_TSTO_RX_FS_RXD     = IOMUX_PAD(0x04B0, 0x0168, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA06__SDMA_DEBUG_CORE_STATE_2           = IOMUX_PAD(0x04B0, 0x0168, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_DATA07__RAWNAND_DATA07                    = IOMUX_PAD(0x04B4, 0x016C, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA07__USDHC2_DATA7                      = IOMUX_PAD(0x04B4, 0x016C, 1, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA07__QSPI2_A_DQS                       = IOMUX_PAD(0x04B4, 0x016C, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA07__UART3_TX                          = IOMUX_PAD(0x04B4, 0x016C, 3, 0x0840, 1, 0),
+	 MX6_PAD_NAND_DATA07__PWM4_OUT                          = IOMUX_PAD(0x04B4, 0x016C, 4, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA07__GPIO4_IO_11                       = IOMUX_PAD(0x04B4, 0x016C, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA07__WEIM_AD_7                         = IOMUX_PAD(0x04B4, 0x016C, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA07__TPSMP_HDATA_14                    = IOMUX_PAD(0x04B4, 0x016C, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA07__ANATOP_USBPHY1_TSTO_RX_FS_RXD     = IOMUX_PAD(0x04B4, 0x016C, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_DATA07__SDMA_DEBUG_CORE_STATE_3           = IOMUX_PAD(0x04B4, 0x016C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_RE_B__RAWNAND_RE_B                        = IOMUX_PAD(0x04B8, 0x0170, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_RE_B__USDHC2_RESET_B                      = IOMUX_PAD(0x04B8, 0x0170, 1, 0x0000, 0, 0),
+	 MX6_PAD_NAND_RE_B__QSPI2_B_DATA_3                      = IOMUX_PAD(0x04B8, 0x0170, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_RE_B__AUDMUX_AUD4_TXFS                    = IOMUX_PAD(0x04B8, 0x0170, 3, 0x0658, 0, 0),
+	 MX6_PAD_NAND_RE_B__ESAI_TX_FS                          = IOMUX_PAD(0x04B8, 0x0170, 4, 0x077C, 0, 0),
+	 MX6_PAD_NAND_RE_B__GPIO4_IO_12                         = IOMUX_PAD(0x04B8, 0x0170, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_RE_B__WEIM_RW                             = IOMUX_PAD(0x04B8, 0x0170, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_RE_B__TPSMP_HDATA_5                       = IOMUX_PAD(0x04B8, 0x0170, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_RE_B__ANATOP_USBPHY2_TSTO_RX_HS_RXD       = IOMUX_PAD(0x04B8, 0x0170, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_RE_B__SDMA_DEBUG_PC_7                     = IOMUX_PAD(0x04B8, 0x0170, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_READY_B__RAWNAND_READY_B                  = IOMUX_PAD(0x04BC, 0x0174, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_READY_B__USDHC1_VSELECT                   = IOMUX_PAD(0x04BC, 0x0174, 1, 0x0000, 0, 0),
+	 MX6_PAD_NAND_READY_B__QSPI2_A_DATA_1                   = IOMUX_PAD(0x04BC, 0x0174, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_READY_B__ECSPI2_MISO                      = IOMUX_PAD(0x04BC, 0x0174, 3, 0x0724, 0, 0),
+	 MX6_PAD_NAND_READY_B__ESAI_TX1                         = IOMUX_PAD(0x04BC, 0x0174, 4, 0x0794, 0, 0),
+	 MX6_PAD_NAND_READY_B__GPIO4_IO_13                      = IOMUX_PAD(0x04BC, 0x0174, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_READY_B__WEIM_EB_B_1                      = IOMUX_PAD(0x04BC, 0x0174, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_READY_B__TPSMP_HDATA_2                    = IOMUX_PAD(0x04BC, 0x0174, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_READY_B__ANATOP_USBPHY1_TSTI_TX_DN        = IOMUX_PAD(0x04BC, 0x0174, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_READY_B__SDMA_DEBUG_PC_10                 = IOMUX_PAD(0x04BC, 0x0174, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_WE_B__RAWNAND_WE_B                        = IOMUX_PAD(0x04C0, 0x0178, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_WE_B__USDHC4_VSELECT                      = IOMUX_PAD(0x04C0, 0x0178, 1, 0x0000, 0, 0),
+	 MX6_PAD_NAND_WE_B__QSPI2_B_DATA_2                      = IOMUX_PAD(0x04C0, 0x0178, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_WE_B__AUDMUX_AUD4_RXD                     = IOMUX_PAD(0x04C0, 0x0178, 3, 0x0644, 0, 0),
+	 MX6_PAD_NAND_WE_B__ESAI_TX5_RX0                        = IOMUX_PAD(0x04C0, 0x0178, 4, 0x07A4, 0, 0),
+	 MX6_PAD_NAND_WE_B__GPIO4_IO_14                         = IOMUX_PAD(0x04C0, 0x0178, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_WE_B__WEIM_WAIT                           = IOMUX_PAD(0x04C0, 0x0178, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_WE_B__TPSMP_HDATA_6                       = IOMUX_PAD(0x04C0, 0x0178, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_WE_B__ANATOP_USBPHY1_TSTO_PLL_CLK20DIV    = IOMUX_PAD(0x04C0, 0x0178, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_WE_B__SDMA_DEBUG_PC_6                     = IOMUX_PAD(0x04C0, 0x0178, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_NAND_WP_B__RAWNAND_WP_B                        = IOMUX_PAD(0x04C4, 0x017C, 0, 0x0000, 0, 0),
+	 MX6_PAD_NAND_WP_B__USDHC1_RESET_B                      = IOMUX_PAD(0x04C4, 0x017C, 1, 0x0000, 0, 0),
+	 MX6_PAD_NAND_WP_B__QSPI2_A_DATA_0                      = IOMUX_PAD(0x04C4, 0x017C, 2, 0x0000, 0, 0),
+	 MX6_PAD_NAND_WP_B__ECSPI2_MOSI                         = IOMUX_PAD(0x04C4, 0x017C, 3, 0x0728, 0, 0),
+	 MX6_PAD_NAND_WP_B__ESAI_TX4_RX1                        = IOMUX_PAD(0x04C4, 0x017C, 4, 0x07A0, 0, 0),
+	 MX6_PAD_NAND_WP_B__GPIO4_IO_15                         = IOMUX_PAD(0x04C4, 0x017C, 5, 0x0000, 0, 0),
+	 MX6_PAD_NAND_WP_B__WEIM_EB_B_0                         = IOMUX_PAD(0x04C4, 0x017C, 6, 0x0000, 0, 0),
+	 MX6_PAD_NAND_WP_B__TPSMP_HDATA_1                       = IOMUX_PAD(0x04C4, 0x017C, 7, 0x0000, 0, 0),
+	 MX6_PAD_NAND_WP_B__ANATOP_USBPHY1_TSTI_TX_HS_MODE      = IOMUX_PAD(0x04C4, 0x017C, 8, 0x0000, 0, 0),
+	 MX6_PAD_NAND_WP_B__SDMA_DEBUG_PC_11                    = IOMUX_PAD(0x04C4, 0x017C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1A_DATA0__QSPI1_A_DATA_0                   = IOMUX_PAD(0x04C8, 0x0180, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA0__USB_OTG2_OC                      = IOMUX_PAD(0x04C8, 0x0180, 1, 0x085C, 2, 0),
+	 MX6_PAD_QSPI1A_DATA0__ECSPI1_MOSI                      = IOMUX_PAD(0x04C8, 0x0180, 2, 0x0718, 1, 0),
+	 MX6_PAD_QSPI1A_DATA0__ESAI_TX4_RX1                     = IOMUX_PAD(0x04C8, 0x0180, 3, 0x07A0, 2, 0),
+	 MX6_PAD_QSPI1A_DATA0__CSI1_DATA_14                     = IOMUX_PAD(0x04C8, 0x0180, 4, 0x06D4, 1, 0),
+	 MX6_PAD_QSPI1A_DATA0__GPIO4_IO_16                      = IOMUX_PAD(0x04C8, 0x0180, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA0__WEIM_DATA_6                      = IOMUX_PAD(0x04C8, 0x0180, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA0__SIM_M_HADDR_3                    = IOMUX_PAD(0x04C8, 0x0180, 7, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA0__SDMA_DEBUG_BUS_DEVICE_3          = IOMUX_PAD(0x04C8, 0x0180, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1A_DATA1__QSPI1_A_DATA_1                   = IOMUX_PAD(0x04CC, 0x0184, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA1__ANATOP_OTG1_ID                   = IOMUX_PAD(0x04CC, 0x0184, 1, 0x0624, 2, 0),
+	 MX6_PAD_QSPI1A_DATA1__ECSPI1_MISO                      = IOMUX_PAD(0x04CC, 0x0184, 2, 0x0714, 1, 0),
+	 MX6_PAD_QSPI1A_DATA1__ESAI_TX1                         = IOMUX_PAD(0x04CC, 0x0184, 3, 0x0794, 2, 0),
+	 MX6_PAD_QSPI1A_DATA1__CSI1_DATA_13                     = IOMUX_PAD(0x04CC, 0x0184, 4, 0x06D0, 1, 0),
+	 MX6_PAD_QSPI1A_DATA1__GPIO4_IO_17                      = IOMUX_PAD(0x04CC, 0x0184, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA1__WEIM_DATA_5                      = IOMUX_PAD(0x04CC, 0x0184, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA1__SIM_M_HADDR_4                    = IOMUX_PAD(0x04CC, 0x0184, 7, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA1__SDMA_DEBUG_PC_0                  = IOMUX_PAD(0x04CC, 0x0184, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1A_DATA2__QSPI1_A_DATA_2                   = IOMUX_PAD(0x04D0, 0x0188, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA2__USB_OTG1_PWR                     = IOMUX_PAD(0x04D0, 0x0188, 1, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA2__ECSPI5_SS1                       = IOMUX_PAD(0x04D0, 0x0188, 2, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA2__ESAI_TX_CLK                      = IOMUX_PAD(0x04D0, 0x0188, 3, 0x078C, 2, 0),
+	 MX6_PAD_QSPI1A_DATA2__CSI1_DATA_12                     = IOMUX_PAD(0x04D0, 0x0188, 4, 0x06CC, 1, 0),
+	 MX6_PAD_QSPI1A_DATA2__GPIO4_IO_18                      = IOMUX_PAD(0x04D0, 0x0188, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA2__WEIM_DATA_4                      = IOMUX_PAD(0x04D0, 0x0188, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA2__SIM_M_HADDR_6                    = IOMUX_PAD(0x04D0, 0x0188, 7, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA2__SDMA_DEBUG_PC_1                  = IOMUX_PAD(0x04D0, 0x0188, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1A_DATA3__QSPI1_A_DATA_3                   = IOMUX_PAD(0x04D4, 0x018C, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA3__USB_OTG1_OC                      = IOMUX_PAD(0x04D4, 0x018C, 1, 0x0860, 2, 0),
+	 MX6_PAD_QSPI1A_DATA3__ECSPI5_SS2                       = IOMUX_PAD(0x04D4, 0x018C, 2, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA3__ESAI_TX0                         = IOMUX_PAD(0x04D4, 0x018C, 3, 0x0790, 2, 0),
+	 MX6_PAD_QSPI1A_DATA3__CSI1_DATA_11                     = IOMUX_PAD(0x04D4, 0x018C, 4, 0x06C8, 1, 0),
+	 MX6_PAD_QSPI1A_DATA3__GPIO4_IO_19                      = IOMUX_PAD(0x04D4, 0x018C, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA3__WEIM_DATA_3                      = IOMUX_PAD(0x04D4, 0x018C, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA3__SIM_M_HADDR_7                    = IOMUX_PAD(0x04D4, 0x018C, 7, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DATA3__SDMA_DEBUG_PC_2                  = IOMUX_PAD(0x04D4, 0x018C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1A_DQS__QSPI1_A_DQS                        = IOMUX_PAD(0x04D8, 0x0190, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DQS__CAN2_TX                            = IOMUX_PAD(0x04D8, 0x0190, 1, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DQS__CANFD_TX2                          = IOMUX_PAD(0x04D8, 0x0190, 2, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DQS__ECSPI5_MOSI                        = IOMUX_PAD(0x04D8, 0x0190, 3, 0x0758, 1, 0),
+	 MX6_PAD_QSPI1A_DQS__CSI1_DATA_15                       = IOMUX_PAD(0x04D8, 0x0190, 4, 0x06D8, 1, 0),
+	 MX6_PAD_QSPI1A_DQS__GPIO4_IO_20                        = IOMUX_PAD(0x04D8, 0x0190, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DQS__WEIM_DATA_7                        = IOMUX_PAD(0x04D8, 0x0190, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DQS__SIM_M_HADDR_13                     = IOMUX_PAD(0x04D8, 0x0190, 7, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_DQS__SDMA_DEBUG_BUS_DEVICE_4            = IOMUX_PAD(0x04D8, 0x0190, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1A_SCLK__QSPI1_A_SCLK                      = IOMUX_PAD(0x04DC, 0x0194, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_SCLK__ANATOP_OTG2_ID                    = IOMUX_PAD(0x04DC, 0x0194, 1, 0x0628, 2, 0),
+	 MX6_PAD_QSPI1A_SCLK__ECSPI1_SCLK                       = IOMUX_PAD(0x04DC, 0x0194, 2, 0x0710, 1, 0),
+	 MX6_PAD_QSPI1A_SCLK__ESAI_TX2_RX3                      = IOMUX_PAD(0x04DC, 0x0194, 3, 0x0798, 2, 0),
+	 MX6_PAD_QSPI1A_SCLK__CSI1_DATA_1                       = IOMUX_PAD(0x04DC, 0x0194, 4, 0x06A4, 1, 0),
+	 MX6_PAD_QSPI1A_SCLK__GPIO4_IO_21                       = IOMUX_PAD(0x04DC, 0x0194, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_SCLK__WEIM_DATA_0                       = IOMUX_PAD(0x04DC, 0x0194, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_SCLK__SIM_M_HADDR_0                     = IOMUX_PAD(0x04DC, 0x0194, 7, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_SCLK__SDMA_DEBUG_PC_5                   = IOMUX_PAD(0x04DC, 0x0194, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1A_SS0_B__QSPI1_A_SS0_B                    = IOMUX_PAD(0x04E0, 0x0198, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_SS0_B__USB_OTG2_PWR                     = IOMUX_PAD(0x04E0, 0x0198, 1, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_SS0_B__ECSPI1_SS0                       = IOMUX_PAD(0x04E0, 0x0198, 2, 0x071C, 1, 0),
+	 MX6_PAD_QSPI1A_SS0_B__ESAI_TX3_RX2                     = IOMUX_PAD(0x04E0, 0x0198, 3, 0x079C, 2, 0),
+	 MX6_PAD_QSPI1A_SS0_B__CSI1_DATA_0                      = IOMUX_PAD(0x04E0, 0x0198, 4, 0x06A0, 1, 0),
+	 MX6_PAD_QSPI1A_SS0_B__GPIO4_IO_22                      = IOMUX_PAD(0x04E0, 0x0198, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_SS0_B__WEIM_DATA_1                      = IOMUX_PAD(0x04E0, 0x0198, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_SS0_B__SIM_M_HADDR_1                    = IOMUX_PAD(0x04E0, 0x0198, 7, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_SS0_B__SDMA_DEBUG_PC_4                  = IOMUX_PAD(0x04E0, 0x0198, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1A_SS1_B__QSPI1_A_SS1_B                    = IOMUX_PAD(0x04E4, 0x019C, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_SS1_B__CAN1_RX                          = IOMUX_PAD(0x04E4, 0x019C, 1, 0x068C, 2, 0),
+	 MX6_PAD_QSPI1A_SS1_B__CANFD_RX1                        = IOMUX_PAD(0x04E4, 0x019C, 2, 0x0694, 2, 0),
+	 MX6_PAD_QSPI1A_SS1_B__ECSPI5_MISO                      = IOMUX_PAD(0x04E4, 0x019C, 3, 0x0754, 1, 0),
+	 MX6_PAD_QSPI1A_SS1_B__CSI1_DATA_10                     = IOMUX_PAD(0x04E4, 0x019C, 4, 0x06FC, 1, 0),
+	 MX6_PAD_QSPI1A_SS1_B__GPIO4_IO_23                      = IOMUX_PAD(0x04E4, 0x019C, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_SS1_B__WEIM_DATA_2                      = IOMUX_PAD(0x04E4, 0x019C, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_SS1_B__SIM_M_HADDR_12                   = IOMUX_PAD(0x04E4, 0x019C, 7, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1A_SS1_B__SDMA_DEBUG_PC_3                  = IOMUX_PAD(0x04E4, 0x019C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1B_DATA0__QSPI1_B_DATA_0                   = IOMUX_PAD(0x04E8, 0x01A0, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DATA0__UART3_CTS_B                      = IOMUX_PAD(0x04E8, 0x01A0, 1, 0x083C, 4, 0),
+	 MX6_PAD_QSPI1B_DATA0__ECSPI3_MOSI                      = IOMUX_PAD(0x04E8, 0x01A0, 2, 0x0738, 1, 0),
+	 MX6_PAD_QSPI1B_DATA0__ESAI_RX_FS                       = IOMUX_PAD(0x04E8, 0x01A0, 3, 0x0778, 2, 0),
+	 MX6_PAD_QSPI1B_DATA0__CSI1_DATA_22                     = IOMUX_PAD(0x04E8, 0x01A0, 4, 0x06F4, 1, 0),
+	 MX6_PAD_QSPI1B_DATA0__GPIO4_IO_24                      = IOMUX_PAD(0x04E8, 0x01A0, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DATA0__WEIM_DATA_14                     = IOMUX_PAD(0x04E8, 0x01A0, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DATA0__SIM_M_HADDR_9                    = IOMUX_PAD(0x04E8, 0x01A0, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1B_DATA1__QSPI1_B_DATA_1                   = IOMUX_PAD(0x04EC, 0x01A4, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DATA1__UART3_RTS_B                      = IOMUX_PAD(0x04EC, 0x01A4, 1, 0x083C, 5, 0),
+	 MX6_PAD_QSPI1B_DATA1__ECSPI3_MISO                      = IOMUX_PAD(0x04EC, 0x01A4, 2, 0x0734, 1, 0),
+	 MX6_PAD_QSPI1B_DATA1__ESAI_RX_CLK                      = IOMUX_PAD(0x04EC, 0x01A4, 3, 0x0788, 2, 0),
+	 MX6_PAD_QSPI1B_DATA1__CSI1_DATA_21                     = IOMUX_PAD(0x04EC, 0x01A4, 4, 0x06F0, 1, 0),
+	 MX6_PAD_QSPI1B_DATA1__GPIO4_IO_25                      = IOMUX_PAD(0x04EC, 0x01A4, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DATA1__WEIM_DATA_13                     = IOMUX_PAD(0x04EC, 0x01A4, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DATA1__SIM_M_HADDR_8                    = IOMUX_PAD(0x04EC, 0x01A4, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1B_DATA2__QSPI1_B_DATA_2                   = IOMUX_PAD(0x04F0, 0x01A8, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DATA2__I2C2_SDA                         = IOMUX_PAD(0x04F0, 0x01A8, IOMUX_CONFIG_SION | 1, 0x07B4, 2, 0),
+	 MX6_PAD_QSPI1B_DATA2__ECSPI5_RDY                       = IOMUX_PAD(0x04F0, 0x01A8, 2, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DATA2__ESAI_TX5_RX0                     = IOMUX_PAD(0x04F0, 0x01A8, 3, 0x07A4, 2, 0),
+	 MX6_PAD_QSPI1B_DATA2__CSI1_DATA_20                     = IOMUX_PAD(0x04F0, 0x01A8, 4, 0x06EC, 1, 0),
+	 MX6_PAD_QSPI1B_DATA2__GPIO4_IO_26                      = IOMUX_PAD(0x04F0, 0x01A8, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DATA2__WEIM_DATA_12                     = IOMUX_PAD(0x04F0, 0x01A8, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DATA2__SIM_M_HADDR_5                    = IOMUX_PAD(0x04F0, 0x01A8, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1B_DATA3__QSPI1_B_DATA_3                   = IOMUX_PAD(0x04F4, 0x01AC, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DATA3__I2C2_SCL                         = IOMUX_PAD(0x04F4, 0x01AC, IOMUX_CONFIG_SION | 1, 0x07B0, 2, 0),
+	 MX6_PAD_QSPI1B_DATA3__ECSPI5_SS3                       = IOMUX_PAD(0x04F4, 0x01AC, 2, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DATA3__ESAI_TX_FS                       = IOMUX_PAD(0x04F4, 0x01AC, 3, 0x077C, 2, 0),
+	 MX6_PAD_QSPI1B_DATA3__CSI1_DATA_19                     = IOMUX_PAD(0x04F4, 0x01AC, 4, 0x06E8, 1, 0),
+	 MX6_PAD_QSPI1B_DATA3__GPIO4_IO_27                      = IOMUX_PAD(0x04F4, 0x01AC, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DATA3__WEIM_DATA_11                     = IOMUX_PAD(0x04F4, 0x01AC, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DATA3__SIM_M_HADDR_2                    = IOMUX_PAD(0x04F4, 0x01AC, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1B_DQS__QSPI1_B_DQS                        = IOMUX_PAD(0x04F8, 0x01B0, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DQS__CAN1_TX                            = IOMUX_PAD(0x04F8, 0x01B0, 1, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DQS__CANFD_TX1                          = IOMUX_PAD(0x04F8, 0x01B0, 2, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DQS__ECSPI5_SS0                         = IOMUX_PAD(0x04F8, 0x01B0, 3, 0x075C, 1, 0),
+	 MX6_PAD_QSPI1B_DQS__CSI1_DATA_23                       = IOMUX_PAD(0x04F8, 0x01B0, 4, 0x06F8, 1, 0),
+	 MX6_PAD_QSPI1B_DQS__GPIO4_IO_28                        = IOMUX_PAD(0x04F8, 0x01B0, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DQS__WEIM_DATA_15                       = IOMUX_PAD(0x04F8, 0x01B0, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_DQS__SIM_M_HADDR_15                     = IOMUX_PAD(0x04F8, 0x01B0, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1B_SCLK__QSPI1_B_SCLK                      = IOMUX_PAD(0x04FC, 0x01B4, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_SCLK__UART3_RX                          = IOMUX_PAD(0x04FC, 0x01B4, 1, 0x0840, 4, 0),
+	 MX6_PAD_QSPI1B_SCLK__ECSPI3_SCLK                       = IOMUX_PAD(0x04FC, 0x01B4, 2, 0x0730, 1, 0),
+	 MX6_PAD_QSPI1B_SCLK__ESAI_RX_HF_CLK                    = IOMUX_PAD(0x04FC, 0x01B4, 3, 0x0780, 2, 0),
+	 MX6_PAD_QSPI1B_SCLK__CSI1_DATA_16                      = IOMUX_PAD(0x04FC, 0x01B4, 4, 0x06DC, 1, 0),
+	 MX6_PAD_QSPI1B_SCLK__GPIO4_IO_29                       = IOMUX_PAD(0x04FC, 0x01B4, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_SCLK__WEIM_DATA_8                       = IOMUX_PAD(0x04FC, 0x01B4, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_SCLK__SIM_M_HADDR_11                    = IOMUX_PAD(0x04FC, 0x01B4, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1B_SS0_B__QSPI1_B_SS0_B                    = IOMUX_PAD(0x0500, 0x01B8, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_SS0_B__UART3_TX                         = IOMUX_PAD(0x0500, 0x01B8, 1, 0x0840, 5, 0),
+	 MX6_PAD_QSPI1B_SS0_B__ECSPI3_SS0                       = IOMUX_PAD(0x0500, 0x01B8, 2, 0x073C, 1, 0),
+	 MX6_PAD_QSPI1B_SS0_B__ESAI_TX_HF_CLK                   = IOMUX_PAD(0x0500, 0x01B8, 3, 0x0784, 3, 0),
+	 MX6_PAD_QSPI1B_SS0_B__CSI1_DATA_17                     = IOMUX_PAD(0x0500, 0x01B8, 4, 0x06E0, 1, 0),
+	 MX6_PAD_QSPI1B_SS0_B__GPIO4_IO_30                      = IOMUX_PAD(0x0500, 0x01B8, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_SS0_B__WEIM_DATA_9                      = IOMUX_PAD(0x0500, 0x01B8, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_SS0_B__SIM_M_HADDR_10                   = IOMUX_PAD(0x0500, 0x01B8, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_QSPI1B_SS1_B__QSPI1_B_SS1_B                    = IOMUX_PAD(0x0504, 0x01BC, 0, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_SS1_B__CAN2_RX                          = IOMUX_PAD(0x0504, 0x01BC, 1, 0x0690, 2, 0),
+	 MX6_PAD_QSPI1B_SS1_B__CANFD_RX2                        = IOMUX_PAD(0x0504, 0x01BC, 2, 0x0698, 2, 0),
+	 MX6_PAD_QSPI1B_SS1_B__ECSPI5_SCLK                      = IOMUX_PAD(0x0504, 0x01BC, 3, 0x0750, 1, 0),
+	 MX6_PAD_QSPI1B_SS1_B__CSI1_DATA_18                     = IOMUX_PAD(0x0504, 0x01BC, 4, 0x06E4, 1, 0),
+	 MX6_PAD_QSPI1B_SS1_B__GPIO4_IO_31                      = IOMUX_PAD(0x0504, 0x01BC, 5, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_SS1_B__WEIM_DATA_10                     = IOMUX_PAD(0x0504, 0x01BC, 6, 0x0000, 0, 0),
+	 MX6_PAD_QSPI1B_SS1_B__SIM_M_HADDR_14                   = IOMUX_PAD(0x0504, 0x01BC, 7, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII1_RD0__ENET1_RX_DATA_0                    = IOMUX_PAD(0x0508, 0x01C0, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD0__GPIO5_IO_0                         = IOMUX_PAD(0x0508, 0x01C0, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD0__CSI2_DATA_10                       = IOMUX_PAD(0x0508, 0x01C0, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD0__ANATOP_TESTI_0                     = IOMUX_PAD(0x0508, 0x01C0, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD0__RAWNAND_TESTER_TRIGGER             = IOMUX_PAD(0x0508, 0x01C0, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD0__PCIE_CTRL_DEBUG_0                  = IOMUX_PAD(0x0508, 0x01C0, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII1_RD1__ENET1_RX_DATA_1                    = IOMUX_PAD(0x050C, 0x01C4, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD1__GPIO5_IO_1                         = IOMUX_PAD(0x050C, 0x01C4, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD1__CSI2_DATA_11                       = IOMUX_PAD(0x050C, 0x01C4, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD1__ANATOP_TESTI_1                     = IOMUX_PAD(0x050C, 0x01C4, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD1__USDHC1_TESTER_TRIGGER              = IOMUX_PAD(0x050C, 0x01C4, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD1__PCIE_CTRL_DEBUG_1                  = IOMUX_PAD(0x050C, 0x01C4, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII1_RD2__ENET1_RX_DATA_2                    = IOMUX_PAD(0x0510, 0x01C8, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD2__GPIO5_IO_2                         = IOMUX_PAD(0x0510, 0x01C8, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD2__CSI2_DATA_12                       = IOMUX_PAD(0x0510, 0x01C8, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD2__ANATOP_TESTI_2                     = IOMUX_PAD(0x0510, 0x01C8, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD2__USDHC2_TESTER_TRIGGER              = IOMUX_PAD(0x0510, 0x01C8, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD2__PCIE_CTRL_DEBUG_2                  = IOMUX_PAD(0x0510, 0x01C8, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII1_RD3__ENET1_RX_DATA_3                    = IOMUX_PAD(0x0514, 0x01CC, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD3__GPIO5_IO_3                         = IOMUX_PAD(0x0514, 0x01CC, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD3__CSI2_DATA_13                       = IOMUX_PAD(0x0514, 0x01CC, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD3__ANATOP_TESTI_3                     = IOMUX_PAD(0x0514, 0x01CC, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD3__USDHC3_TESTER_TRIGGER              = IOMUX_PAD(0x0514, 0x01CC, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RD3__PCIE_CTRL_DEBUG_3                  = IOMUX_PAD(0x0514, 0x01CC, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII1_RX_CTL__ENET1_RX_EN                     = IOMUX_PAD(0x0518, 0x01D0, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RX_CTL__GPIO5_IO_4                      = IOMUX_PAD(0x0518, 0x01D0, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RX_CTL__CSI2_DATA_14                    = IOMUX_PAD(0x0518, 0x01D0, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RX_CTL__ANATOP_TESTO_0                  = IOMUX_PAD(0x0518, 0x01D0, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RX_CTL__USDHC4_TESTER_TRIGGER           = IOMUX_PAD(0x0518, 0x01D0, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RX_CTL__PCIE_CTRL_DEBUG_4               = IOMUX_PAD(0x0518, 0x01D0, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII1_RXC__ENET1_RX_CLK                       = IOMUX_PAD(0x051C, 0x01D4, 0, 0x0768, 1, 0),
+	 MX6_PAD_RGMII1_RXC__ENET1_RX_ER                        = IOMUX_PAD(0x051C, 0x01D4, 1, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RXC__GPIO5_IO_5                         = IOMUX_PAD(0x051C, 0x01D4, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RXC__CSI2_DATA_15                       = IOMUX_PAD(0x051C, 0x01D4, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RXC__ANATOP_TESTO_1                     = IOMUX_PAD(0x051C, 0x01D4, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RXC__ECSPI1_TESTER_TRIGGER              = IOMUX_PAD(0x051C, 0x01D4, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_RXC__PCIE_CTRL_DEBUG_5                  = IOMUX_PAD(0x051C, 0x01D4, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII1_TD0__ENET1_TX_DATA_0                    = IOMUX_PAD(0x0520, 0x01D8, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD0__SAI2_RX_SYNC                       = IOMUX_PAD(0x0520, 0x01D8, 2, 0x0810, 1, 0),
+	 MX6_PAD_RGMII1_TD0__GPIO5_IO_6                         = IOMUX_PAD(0x0520, 0x01D8, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD0__CSI2_DATA_16                       = IOMUX_PAD(0x0520, 0x01D8, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD0__ANATOP_TESTO_2                     = IOMUX_PAD(0x0520, 0x01D8, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD0__ECSPI2_TESTER_TRIGGER              = IOMUX_PAD(0x0520, 0x01D8, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD0__PCIE_CTRL_DEBUG_6                  = IOMUX_PAD(0x0520, 0x01D8, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII1_TD1__ENET1_TX_DATA_1                    = IOMUX_PAD(0x0524, 0x01DC, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD1__SAI2_RX_BCLK                       = IOMUX_PAD(0x0524, 0x01DC, 2, 0x0808, 1, 0),
+	 MX6_PAD_RGMII1_TD1__GPIO5_IO_7                         = IOMUX_PAD(0x0524, 0x01DC, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD1__CSI2_DATA_17                       = IOMUX_PAD(0x0524, 0x01DC, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD1__ANATOP_TESTO_3                     = IOMUX_PAD(0x0524, 0x01DC, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD1__ECSPI3_TESTER_TRIGGER              = IOMUX_PAD(0x0524, 0x01DC, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD1__PCIE_CTRL_DEBUG_7                  = IOMUX_PAD(0x0524, 0x01DC, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII1_TD2__ENET1_TX_DATA_2                    = IOMUX_PAD(0x0528, 0x01E0, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD2__SAI2_TX_SYNC                       = IOMUX_PAD(0x0528, 0x01E0, 2, 0x0818, 1, 0),
+	 MX6_PAD_RGMII1_TD2__GPIO5_IO_8                         = IOMUX_PAD(0x0528, 0x01E0, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD2__CSI2_DATA_18                       = IOMUX_PAD(0x0528, 0x01E0, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD2__ANATOP_TESTO_4                     = IOMUX_PAD(0x0528, 0x01E0, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD2__ECSPI4_TESTER_TRIGGER              = IOMUX_PAD(0x0528, 0x01E0, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD2__PCIE_CTRL_DEBUG_8                  = IOMUX_PAD(0x0528, 0x01E0, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII1_TD3__ENET1_TX_DATA_3                    = IOMUX_PAD(0x052C, 0x01E4, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD3__SAI2_TX_BCLK                       = IOMUX_PAD(0x052C, 0x01E4, 2, 0x0814, 1, 0),
+	 MX6_PAD_RGMII1_TD3__GPIO5_IO_9                         = IOMUX_PAD(0x052C, 0x01E4, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD3__CSI2_DATA_19                       = IOMUX_PAD(0x052C, 0x01E4, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD3__ANATOP_TESTO_5                     = IOMUX_PAD(0x052C, 0x01E4, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD3__ECSPI5_TESTER_TRIGGER              = IOMUX_PAD(0x052C, 0x01E4, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TD3__PCIE_CTRL_DEBUG_9                  = IOMUX_PAD(0x052C, 0x01E4, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII1_TX_CTL__ENET1_TX_EN                     = IOMUX_PAD(0x0530, 0x01E8, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TX_CTL__SAI2_RX_DATA_0                  = IOMUX_PAD(0x0530, 0x01E8, 2, 0x080C, 1, 0),
+	 MX6_PAD_RGMII1_TX_CTL__GPIO5_IO_10                     = IOMUX_PAD(0x0530, 0x01E8, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TX_CTL__CSI2_DATA_0                     = IOMUX_PAD(0x0530, 0x01E8, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TX_CTL__ANATOP_TESTO_6                  = IOMUX_PAD(0x0530, 0x01E8, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TX_CTL__QSPI1_TESTER_TRIGGER            = IOMUX_PAD(0x0530, 0x01E8, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TX_CTL__PCIE_CTRL_DEBUG_10              = IOMUX_PAD(0x0530, 0x01E8, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII1_TXC__ENET1_RGMII_TXC                    = IOMUX_PAD(0x0534, 0x01EC, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TXC__ENET1_TX_ER                        = IOMUX_PAD(0x0534, 0x01EC, 1, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TXC__SAI2_TX_DATA_0                     = IOMUX_PAD(0x0534, 0x01EC, 2, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TXC__GPIO5_IO_11                        = IOMUX_PAD(0x0534, 0x01EC, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TXC__CSI2_DATA_1                        = IOMUX_PAD(0x0534, 0x01EC, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TXC__ANATOP_TESTO_7                     = IOMUX_PAD(0x0534, 0x01EC, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TXC__QSPI2_TESTER_TRIGGER               = IOMUX_PAD(0x0534, 0x01EC, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII1_TXC__PCIE_CTRL_DEBUG_11                 = IOMUX_PAD(0x0534, 0x01EC, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII2_RD0__ENET2_RX_DATA_0                    = IOMUX_PAD(0x0538, 0x01F0, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD0__PWM4_OUT                           = IOMUX_PAD(0x0538, 0x01F0, 2, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD0__GPIO5_IO_12                        = IOMUX_PAD(0x0538, 0x01F0, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD0__CSI2_DATA_2                        = IOMUX_PAD(0x0538, 0x01F0, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD0__ANATOP_TESTO_8                     = IOMUX_PAD(0x0538, 0x01F0, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD0__VDEC_DEBUG_18                      = IOMUX_PAD(0x0538, 0x01F0, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD0__PCIE_CTRL_DEBUG_12                 = IOMUX_PAD(0x0538, 0x01F0, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII2_RD1__ENET2_RX_DATA_1                    = IOMUX_PAD(0x053C, 0x01F4, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD1__PWM3_OUT                           = IOMUX_PAD(0x053C, 0x01F4, 2, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD1__GPIO5_IO_13                        = IOMUX_PAD(0x053C, 0x01F4, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD1__CSI2_DATA_3                        = IOMUX_PAD(0x053C, 0x01F4, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD1__ANATOP_TESTO_9                     = IOMUX_PAD(0x053C, 0x01F4, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD1__VDEC_DEBUG_19                      = IOMUX_PAD(0x053C, 0x01F4, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD1__PCIE_CTRL_DEBUG_13                 = IOMUX_PAD(0x053C, 0x01F4, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII2_RD2__ENET2_RX_DATA_2                    = IOMUX_PAD(0x0540, 0x01F8, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD2__PWM2_OUT                           = IOMUX_PAD(0x0540, 0x01F8, 2, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD2__GPIO5_IO_14                        = IOMUX_PAD(0x0540, 0x01F8, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD2__CSI2_DATA_4                        = IOMUX_PAD(0x0540, 0x01F8, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD2__ANATOP_TESTO_10                    = IOMUX_PAD(0x0540, 0x01F8, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD2__VDEC_DEBUG_20                      = IOMUX_PAD(0x0540, 0x01F8, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD2__PCIE_CTRL_DEBUG_14                 = IOMUX_PAD(0x0540, 0x01F8, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII2_RD3__ENET2_RX_DATA_3                    = IOMUX_PAD(0x0544, 0x01FC, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD3__PWM1_OUT                           = IOMUX_PAD(0x0544, 0x01FC, 2, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD3__GPIO5_IO_15                        = IOMUX_PAD(0x0544, 0x01FC, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD3__CSI2_DATA_5                        = IOMUX_PAD(0x0544, 0x01FC, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD3__ANATOP_TESTO_11                    = IOMUX_PAD(0x0544, 0x01FC, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD3__VDEC_DEBUG_21                      = IOMUX_PAD(0x0544, 0x01FC, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RD3__PCIE_CTRL_DEBUG_15                 = IOMUX_PAD(0x0544, 0x01FC, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII2_RX_CTL__ENET2_RX_EN                     = IOMUX_PAD(0x0548, 0x0200, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RX_CTL__GPIO5_IO_16                     = IOMUX_PAD(0x0548, 0x0200, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RX_CTL__CSI2_DATA_6                     = IOMUX_PAD(0x0548, 0x0200, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RX_CTL__ANATOP_TESTO_12                 = IOMUX_PAD(0x0548, 0x0200, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RX_CTL__VDEC_DEBUG_22                   = IOMUX_PAD(0x0548, 0x0200, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RX_CTL__PCIE_CTRL_DEBUG_16              = IOMUX_PAD(0x0548, 0x0200, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII2_RXC__ENET2_RX_CLK                       = IOMUX_PAD(0x054C, 0x0204, 0, 0x0774, 1, 0),
+	 MX6_PAD_RGMII2_RXC__ENET2_RX_ER                        = IOMUX_PAD(0x054C, 0x0204, 1, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RXC__GPIO5_IO_17                        = IOMUX_PAD(0x054C, 0x0204, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RXC__CSI2_DATA_7                        = IOMUX_PAD(0x054C, 0x0204, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RXC__ANATOP_TESTO_13                    = IOMUX_PAD(0x054C, 0x0204, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RXC__VDEC_DEBUG_23                      = IOMUX_PAD(0x054C, 0x0204, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_RXC__PCIE_CTRL_DEBUG_17                 = IOMUX_PAD(0x054C, 0x0204, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII2_TD0__ENET2_TX_DATA_0                    = IOMUX_PAD(0x0550, 0x0208, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD0__SAI1_RX_SYNC                       = IOMUX_PAD(0x0550, 0x0208, 2, 0x07FC, 1, 0),
+	 MX6_PAD_RGMII2_TD0__PWM8_OUT                           = IOMUX_PAD(0x0550, 0x0208, 3, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD0__GPIO5_IO_18                        = IOMUX_PAD(0x0550, 0x0208, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD0__CSI2_DATA_8                        = IOMUX_PAD(0x0550, 0x0208, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD0__ANATOP_TESTO_14                    = IOMUX_PAD(0x0550, 0x0208, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD0__VDEC_DEBUG_24                      = IOMUX_PAD(0x0550, 0x0208, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD0__PCIE_CTRL_DEBUG_18                 = IOMUX_PAD(0x0550, 0x0208, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII2_TD1__ENET2_TX_DATA_1                    = IOMUX_PAD(0x0554, 0x020C, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD1__SAI1_RX_BCLK                       = IOMUX_PAD(0x0554, 0x020C, 2, 0x07F4, 1, 0),
+	 MX6_PAD_RGMII2_TD1__PWM7_OUT                           = IOMUX_PAD(0x0554, 0x020C, 3, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD1__GPIO5_IO_19                        = IOMUX_PAD(0x0554, 0x020C, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD1__CSI2_DATA_9                        = IOMUX_PAD(0x0554, 0x020C, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD1__ANATOP_TESTO_15                    = IOMUX_PAD(0x0554, 0x020C, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD1__VDEC_DEBUG_25                      = IOMUX_PAD(0x0554, 0x020C, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD1__PCIE_CTRL_DEBUG_19                 = IOMUX_PAD(0x0554, 0x020C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII2_TD2__ENET2_TX_DATA_2                    = IOMUX_PAD(0x0558, 0x0210, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD2__SAI1_TX_SYNC                       = IOMUX_PAD(0x0558, 0x0210, 2, 0x0804, 1, 0),
+	 MX6_PAD_RGMII2_TD2__PWM6_OUT                           = IOMUX_PAD(0x0558, 0x0210, 3, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD2__GPIO5_IO_20                        = IOMUX_PAD(0x0558, 0x0210, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD2__CSI2_VSYNC                         = IOMUX_PAD(0x0558, 0x0210, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD2__SJC_FAIL                           = IOMUX_PAD(0x0558, 0x0210, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD2__VDEC_DEBUG_26                      = IOMUX_PAD(0x0558, 0x0210, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD2__PCIE_CTRL_DEBUG_20                 = IOMUX_PAD(0x0558, 0x0210, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII2_TD3__ENET2_TX_DATA_3                    = IOMUX_PAD(0x055C, 0x0214, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD3__SAI1_TX_BCLK                       = IOMUX_PAD(0x055C, 0x0214, 2, 0x0800, 1, 0),
+	 MX6_PAD_RGMII2_TD3__PWM5_OUT                           = IOMUX_PAD(0x055C, 0x0214, 3, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD3__GPIO5_IO_21                        = IOMUX_PAD(0x055C, 0x0214, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD3__CSI2_HSYNC                         = IOMUX_PAD(0x055C, 0x0214, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD3__SJC_JTAG_ACT                       = IOMUX_PAD(0x055C, 0x0214, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD3__VDEC_DEBUG_27                      = IOMUX_PAD(0x055C, 0x0214, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TD3__PCIE_CTRL_DEBUG_21                 = IOMUX_PAD(0x055C, 0x0214, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII2_TX_CTL__ENET2_TX_EN                     = IOMUX_PAD(0x0560, 0x0218, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TX_CTL__SAI1_RX_DATA_0                  = IOMUX_PAD(0x0560, 0x0218, 2, 0x07F8, 1, 0),
+	 MX6_PAD_RGMII2_TX_CTL__GPIO5_IO_22                     = IOMUX_PAD(0x0560, 0x0218, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TX_CTL__CSI2_FIELD                      = IOMUX_PAD(0x0560, 0x0218, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TX_CTL__SJC_DE_B                        = IOMUX_PAD(0x0560, 0x0218, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TX_CTL__VDEC_DEBUG_28                   = IOMUX_PAD(0x0560, 0x0218, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TX_CTL__PCIE_CTRL_DEBUG_22              = IOMUX_PAD(0x0560, 0x0218, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_RGMII2_TXC__ENET2_RGMII_TXC                    = IOMUX_PAD(0x0564, 0x021C, 0, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TXC__ENET2_TX_ER                        = IOMUX_PAD(0x0564, 0x021C, 1, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TXC__SAI1_TX_DATA_0                     = IOMUX_PAD(0x0564, 0x021C, 2, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TXC__GPIO5_IO_23                        = IOMUX_PAD(0x0564, 0x021C, 5, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TXC__CSI2_PIXCLK                        = IOMUX_PAD(0x0564, 0x021C, 6, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TXC__SJC_DONE                           = IOMUX_PAD(0x0564, 0x021C, 7, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TXC__VDEC_DEBUG_29                      = IOMUX_PAD(0x0564, 0x021C, 8, 0x0000, 0, 0),
+	 MX6_PAD_RGMII2_TXC__PCIE_CTRL_DEBUG_23                 = IOMUX_PAD(0x0564, 0x021C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD1_CLK__USDHC1_CLK                            = IOMUX_PAD(0x0568, 0x0220, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CLK__AUDMUX_AUD5_RXFS                      = IOMUX_PAD(0x0568, 0x0220, 1, 0x0668, 1, 0),
+	 MX6_PAD_SD1_CLK__WDOG2_WDOG_B                          = IOMUX_PAD(0x0568, 0x0220, 2, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CLK__GPT_CLK                               = IOMUX_PAD(0x0568, 0x0220, 3, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CLK__WDOG2_WDOG_RST_B_DEB                  = IOMUX_PAD(0x0568, 0x0220, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CLK__GPIO6_IO_0                            = IOMUX_PAD(0x0568, 0x0220, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CLK__ENET2_1588_EVENT1_OUT                 = IOMUX_PAD(0x0568, 0x0220, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CLK__CCM_OUT1                              = IOMUX_PAD(0x0568, 0x0220, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CLK__VADC_ADC_PROC_CLK                     = IOMUX_PAD(0x0568, 0x0220, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CLK__MMDC_DEBUG_45                         = IOMUX_PAD(0x0568, 0x0220, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD1_CMD__USDHC1_CMD                            = IOMUX_PAD(0x056C, 0x0224, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CMD__AUDMUX_AUD5_RXC                       = IOMUX_PAD(0x056C, 0x0224, 1, 0x0664, 1, 0),
+	 MX6_PAD_SD1_CMD__WDOG1_WDOG_B                          = IOMUX_PAD(0x056C, 0x0224, 2, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CMD__GPT_COMPARE1                          = IOMUX_PAD(0x056C, 0x0224, 3, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CMD__WDOG1_WDOG_RST_B_DEB                  = IOMUX_PAD(0x056C, 0x0224, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CMD__GPIO6_IO_1                            = IOMUX_PAD(0x056C, 0x0224, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CMD__ENET2_1588_EVENT1_IN                  = IOMUX_PAD(0x056C, 0x0224, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CMD__CCM_CLKO1                             = IOMUX_PAD(0x056C, 0x0224, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CMD__VADC_EXT_SYSCLK                       = IOMUX_PAD(0x056C, 0x0224, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD1_CMD__MMDC_DEBUG_46                         = IOMUX_PAD(0x056C, 0x0224, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD1_DATA0__USDHC1_DATA0                        = IOMUX_PAD(0x0570, 0x0228, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA0__AUDMUX_AUD5_RXD                     = IOMUX_PAD(0x0570, 0x0228, 1, 0x065C, 1, 0),
+	 MX6_PAD_SD1_DATA0__CAAM_WRAPPER_RNG_OSC_OBS            = IOMUX_PAD(0x0570, 0x0228, 2, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA0__GPT_CAPTURE1                        = IOMUX_PAD(0x0570, 0x0228, 3, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA0__UART2_RX                            = IOMUX_PAD(0x0570, 0x0228, 4, 0x0838, 2, 0),
+	 MX6_PAD_SD1_DATA0__GPIO6_IO_2                          = IOMUX_PAD(0x0570, 0x0228, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA0__ENET1_1588_EVENT1_IN                = IOMUX_PAD(0x0570, 0x0228, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA0__CCM_OUT2                            = IOMUX_PAD(0x0570, 0x0228, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA0__VADC_CLAMP_UP                       = IOMUX_PAD(0x0570, 0x0228, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA0__MMDC_DEBUG_48                       = IOMUX_PAD(0x0570, 0x0228, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD1_DATA1__USDHC1_DATA1                        = IOMUX_PAD(0x0574, 0x022C, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA1__AUDMUX_AUD5_TXC                     = IOMUX_PAD(0x0574, 0x022C, 1, 0x066C, 1, 0),
+	 MX6_PAD_SD1_DATA1__PWM4_OUT                            = IOMUX_PAD(0x0574, 0x022C, 2, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA1__GPT_CAPTURE2                        = IOMUX_PAD(0x0574, 0x022C, 3, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA1__UART2_TX                            = IOMUX_PAD(0x0574, 0x022C, 4, 0x0838, 3, 0),
+	 MX6_PAD_SD1_DATA1__GPIO6_IO_3                          = IOMUX_PAD(0x0574, 0x022C, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA1__ENET1_1588_EVENT1_OUT               = IOMUX_PAD(0x0574, 0x022C, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA1__CCM_CLKO2                           = IOMUX_PAD(0x0574, 0x022C, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA1__VADC_CLAMP_DOWN                     = IOMUX_PAD(0x0574, 0x022C, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA1__MMDC_DEBUG_47                       = IOMUX_PAD(0x0574, 0x022C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD1_DATA2__USDHC1_DATA2                        = IOMUX_PAD(0x0578, 0x0230, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA2__AUDMUX_AUD5_TXFS                    = IOMUX_PAD(0x0578, 0x0230, 1, 0x0670, 1, 0),
+	 MX6_PAD_SD1_DATA2__PWM3_OUT                            = IOMUX_PAD(0x0578, 0x0230, 2, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA2__GPT_COMPARE2                        = IOMUX_PAD(0x0578, 0x0230, 3, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA2__UART2_CTS_B                         = IOMUX_PAD(0x0578, 0x0230, 4, 0x0834, 2, 0),
+	 MX6_PAD_SD1_DATA2__GPIO6_IO_4                          = IOMUX_PAD(0x0578, 0x0230, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA2__ECSPI4_RDY                          = IOMUX_PAD(0x0578, 0x0230, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA2__CCM_OUT0                            = IOMUX_PAD(0x0578, 0x0230, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA2__VADC_EXT_PD_N                       = IOMUX_PAD(0x0578, 0x0230, 8, 0x0000, 0, 0),
+
+	 MX6_PAD_SD1_DATA3__USDHC1_DATA3                        = IOMUX_PAD(0x057C, 0x0234, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA3__AUDMUX_AUD5_TXD                     = IOMUX_PAD(0x057C, 0x0234, 1, 0x0660, 1, 0),
+	 MX6_PAD_SD1_DATA3__AUDMUX_AUD5_RXD                     = IOMUX_PAD(0x057C, 0x0234, 2, 0x065C, 2, 0),
+	 MX6_PAD_SD1_DATA3__GPT_COMPARE3                        = IOMUX_PAD(0x057C, 0x0234, 3, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA3__UART2_RTS_B                         = IOMUX_PAD(0x057C, 0x0234, 4, 0x0834, 3, 0),
+	 MX6_PAD_SD1_DATA3__GPIO6_IO_5                          = IOMUX_PAD(0x057C, 0x0234, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA3__ECSPI4_SS1                          = IOMUX_PAD(0x057C, 0x0234, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD1_DATA3__CCM_PMIC_RDY                        = IOMUX_PAD(0x057C, 0x0234, 7, 0x069C, 2, 0),
+	 MX6_PAD_SD1_DATA3__VADC_RST_N                          = IOMUX_PAD(0x057C, 0x0234, 8, 0x0000, 0, 0),
+
+	 MX6_PAD_SD2_CLK__USDHC2_CLK                            = IOMUX_PAD(0x0580, 0x0238, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD2_CLK__AUDMUX_AUD6_RXFS                      = IOMUX_PAD(0x0580, 0x0238, 1, 0x0680, 2, 0),
+	 MX6_PAD_SD2_CLK__KPP_COL_5                             = IOMUX_PAD(0x0580, 0x0238, 2, 0x07C8, 1, 0),
+	 MX6_PAD_SD2_CLK__ECSPI4_SCLK                           = IOMUX_PAD(0x0580, 0x0238, 3, 0x0740, 1, 0),
+	 MX6_PAD_SD2_CLK__MLB_SIG                               = IOMUX_PAD(0x0580, 0x0238, 4, 0x07F0, 2, 0),
+	 MX6_PAD_SD2_CLK__GPIO6_IO_6                            = IOMUX_PAD(0x0580, 0x0238, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD2_CLK__MQS_RIGHT                             = IOMUX_PAD(0x0580, 0x0238, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD2_CLK__WDOG1_WDOG_ANY                        = IOMUX_PAD(0x0580, 0x0238, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD2_CLK__VADC_CLAMP_CURRENT_5                  = IOMUX_PAD(0x0580, 0x0238, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD2_CLK__MMDC_DEBUG_29                         = IOMUX_PAD(0x0580, 0x0238, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD2_CMD__USDHC2_CMD                            = IOMUX_PAD(0x0584, 0x023C, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD2_CMD__AUDMUX_AUD6_RXC                       = IOMUX_PAD(0x0584, 0x023C, 1, 0x067C, 2, 0),
+	 MX6_PAD_SD2_CMD__KPP_ROW_5                             = IOMUX_PAD(0x0584, 0x023C, 2, 0x07D4, 1, 0),
+	 MX6_PAD_SD2_CMD__ECSPI4_MOSI                           = IOMUX_PAD(0x0584, 0x023C, 3, 0x0748, 1, 0),
+	 MX6_PAD_SD2_CMD__MLB_CLK                               = IOMUX_PAD(0x0584, 0x023C, 4, 0x07E8, 2, 0),
+	 MX6_PAD_SD2_CMD__GPIO6_IO_7                            = IOMUX_PAD(0x0584, 0x023C, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD2_CMD__MQS_LEFT                              = IOMUX_PAD(0x0584, 0x023C, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD2_CMD__WDOG3_WDOG_B                          = IOMUX_PAD(0x0584, 0x023C, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD2_CMD__VADC_CLAMP_CURRENT_4                  = IOMUX_PAD(0x0584, 0x023C, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD2_CMD__MMDC_DEBUG_30                         = IOMUX_PAD(0x0584, 0x023C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD2_DATA0__USDHC2_DATA0                        = IOMUX_PAD(0x0588, 0x0240, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA0__AUDMUX_AUD6_RXD                     = IOMUX_PAD(0x0588, 0x0240, 1, 0x0674, 2, 0),
+	 MX6_PAD_SD2_DATA0__KPP_ROW_7                           = IOMUX_PAD(0x0588, 0x0240, 2, 0x07DC, 1, 0),
+	 MX6_PAD_SD2_DATA0__PWM1_OUT                            = IOMUX_PAD(0x0588, 0x0240, 3, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA0__I2C4_SDA                            = IOMUX_PAD(0x0588, 0x0240, IOMUX_CONFIG_SION | 4, 0x07C4, 3, 0),
+	 MX6_PAD_SD2_DATA0__GPIO6_IO_8                          = IOMUX_PAD(0x0588, 0x0240, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA0__ECSPI4_SS3                          = IOMUX_PAD(0x0588, 0x0240, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA0__UART4_RX                            = IOMUX_PAD(0x0588, 0x0240, 7, 0x0848, 4, 0),
+	 MX6_PAD_SD2_DATA0__VADC_CLAMP_CURRENT_0                = IOMUX_PAD(0x0588, 0x0240, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA0__MMDC_DEBUG_50                       = IOMUX_PAD(0x0588, 0x0240, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD2_DATA1__USDHC2_DATA1                        = IOMUX_PAD(0x058C, 0x0244, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA1__AUDMUX_AUD6_TXC                     = IOMUX_PAD(0x058C, 0x0244, 1, 0x0684, 2, 0),
+	 MX6_PAD_SD2_DATA1__KPP_COL_7                           = IOMUX_PAD(0x058C, 0x0244, 2, 0x07D0, 1, 0),
+	 MX6_PAD_SD2_DATA1__PWM2_OUT                            = IOMUX_PAD(0x058C, 0x0244, 3, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA1__I2C4_SCL                            = IOMUX_PAD(0x058C, 0x0244, IOMUX_CONFIG_SION | 4, 0x07C0, 3, 0),
+	 MX6_PAD_SD2_DATA1__GPIO6_IO_9                          = IOMUX_PAD(0x058C, 0x0244, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA1__ECSPI4_SS2                          = IOMUX_PAD(0x058C, 0x0244, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA1__UART4_TX                            = IOMUX_PAD(0x058C, 0x0244, 7, 0x0848, 5, 0),
+	 MX6_PAD_SD2_DATA1__VADC_CLAMP_CURRENT_1                = IOMUX_PAD(0x058C, 0x0244, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA1__MMDC_DEBUG_49                       = IOMUX_PAD(0x058C, 0x0244, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD2_DATA2__USDHC2_DATA2                        = IOMUX_PAD(0x0590, 0x0248, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA2__AUDMUX_AUD6_TXFS                    = IOMUX_PAD(0x0590, 0x0248, 1, 0x0688, 2, 0),
+	 MX6_PAD_SD2_DATA2__KPP_ROW_6                           = IOMUX_PAD(0x0590, 0x0248, 2, 0x07D8, 1, 0),
+	 MX6_PAD_SD2_DATA2__ECSPI4_SS0                          = IOMUX_PAD(0x0590, 0x0248, 3, 0x074C, 1, 0),
+	 MX6_PAD_SD2_DATA2__SDMA_EXT_EVENT_0                    = IOMUX_PAD(0x0590, 0x0248, 4, 0x081C, 2, 0),
+	 MX6_PAD_SD2_DATA2__GPIO6_IO_10                         = IOMUX_PAD(0x0590, 0x0248, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA2__SPDIF_OUT                           = IOMUX_PAD(0x0590, 0x0248, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA2__UART6_RX                            = IOMUX_PAD(0x0590, 0x0248, 7, 0x0858, 4, 0),
+	 MX6_PAD_SD2_DATA2__VADC_CLAMP_CURRENT_2                = IOMUX_PAD(0x0590, 0x0248, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA2__MMDC_DEBUG_32                       = IOMUX_PAD(0x0590, 0x0248, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD2_DATA3__USDHC2_DATA3                        = IOMUX_PAD(0x0594, 0x024C, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA3__AUDMUX_AUD6_TXD                     = IOMUX_PAD(0x0594, 0x024C, 1, 0x0678, 2, 0),
+	 MX6_PAD_SD2_DATA3__KPP_COL_6                           = IOMUX_PAD(0x0594, 0x024C, 2, 0x07CC, 1, 0),
+	 MX6_PAD_SD2_DATA3__ECSPI4_MISO                         = IOMUX_PAD(0x0594, 0x024C, 3, 0x0744, 1, 0),
+	 MX6_PAD_SD2_DATA3__MLB_DATA                            = IOMUX_PAD(0x0594, 0x024C, 4, 0x07EC, 2, 0),
+	 MX6_PAD_SD2_DATA3__GPIO6_IO_11                         = IOMUX_PAD(0x0594, 0x024C, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA3__SPDIF_IN                            = IOMUX_PAD(0x0594, 0x024C, 6, 0x0824, 4, 0),
+	 MX6_PAD_SD2_DATA3__UART6_TX                            = IOMUX_PAD(0x0594, 0x024C, 7, 0x0858, 5, 0),
+	 MX6_PAD_SD2_DATA3__VADC_CLAMP_CURRENT_3                = IOMUX_PAD(0x0594, 0x024C, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD2_DATA3__MMDC_DEBUG_31                       = IOMUX_PAD(0x0594, 0x024C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD3_CLK__USDHC3_CLK                            = IOMUX_PAD(0x0598, 0x0250, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD3_CLK__UART4_CTS_B                           = IOMUX_PAD(0x0598, 0x0250, 1, 0x0844, 0, 0),
+	 MX6_PAD_SD3_CLK__ECSPI4_SCLK                           = IOMUX_PAD(0x0598, 0x0250, 2, 0x0740, 0, 0),
+	 MX6_PAD_SD3_CLK__AUDMUX_AUD6_RXFS                      = IOMUX_PAD(0x0598, 0x0250, 3, 0x0680, 0, 0),
+	 MX6_PAD_SD3_CLK__LCDIF2_VSYNC                          = IOMUX_PAD(0x0598, 0x0250, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD3_CLK__GPIO7_IO_0                            = IOMUX_PAD(0x0598, 0x0250, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD3_CLK__LCDIF2_BUSY                           = IOMUX_PAD(0x0598, 0x0250, 6, 0x07E4, 0, 0),
+	 MX6_PAD_SD3_CLK__TPSMP_HDATA_29                        = IOMUX_PAD(0x0598, 0x0250, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD3_CLK__SDMA_DEBUG_EVENT_CHANNEL_5            = IOMUX_PAD(0x0598, 0x0250, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD3_CMD__USDHC3_CMD                            = IOMUX_PAD(0x059C, 0x0254, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD3_CMD__UART4_TX                              = IOMUX_PAD(0x059C, 0x0254, 1, 0x0848, 0, 0),
+	 MX6_PAD_SD3_CMD__ECSPI4_MOSI                           = IOMUX_PAD(0x059C, 0x0254, 2, 0x0748, 0, 0),
+	 MX6_PAD_SD3_CMD__AUDMUX_AUD6_RXC                       = IOMUX_PAD(0x059C, 0x0254, 3, 0x067C, 0, 0),
+	 MX6_PAD_SD3_CMD__LCDIF2_HSYNC                          = IOMUX_PAD(0x059C, 0x0254, 4, 0x07E4, 1, 0),
+	 MX6_PAD_SD3_CMD__GPIO7_IO_1                            = IOMUX_PAD(0x059C, 0x0254, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD3_CMD__LCDIF2_RS                             = IOMUX_PAD(0x059C, 0x0254, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD3_CMD__TPSMP_HDATA_28                        = IOMUX_PAD(0x059C, 0x0254, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD3_CMD__SDMA_DEBUG_EVENT_CHANNEL_4            = IOMUX_PAD(0x059C, 0x0254, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD3_DATA0__USDHC3_DATA0                        = IOMUX_PAD(0x05A0, 0x0258, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA0__I2C4_SCL                            = IOMUX_PAD(0x05A0, 0x0258, IOMUX_CONFIG_SION | 1, 0x07C0, 0, 0),
+	 MX6_PAD_SD3_DATA0__ECSPI2_SS1                          = IOMUX_PAD(0x05A0, 0x0258, 2, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA0__AUDMUX_AUD6_RXD                     = IOMUX_PAD(0x05A0, 0x0258, 3, 0x0674, 0, 0),
+	 MX6_PAD_SD3_DATA0__LCDIF2_DATA_1                       = IOMUX_PAD(0x05A0, 0x0258, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA0__GPIO7_IO_2                          = IOMUX_PAD(0x05A0, 0x0258, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA0__DCIC1_OUT                           = IOMUX_PAD(0x05A0, 0x0258, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA0__TPSMP_HDATA_30                      = IOMUX_PAD(0x05A0, 0x0258, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA0__GPU_DEBUG_0                         = IOMUX_PAD(0x05A0, 0x0258, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA0__SDMA_DEBUG_EVT_CHN_LINES_0          = IOMUX_PAD(0x05A0, 0x0258, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD3_DATA1__USDHC3_DATA1                        = IOMUX_PAD(0x05A4, 0x025C, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA1__I2C4_SDA                            = IOMUX_PAD(0x05A4, 0x025C, IOMUX_CONFIG_SION | 1, 0x07C4, 0, 0),
+	 MX6_PAD_SD3_DATA1__ECSPI2_SS2                          = IOMUX_PAD(0x05A4, 0x025C, 2, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA1__AUDMUX_AUD6_TXC                     = IOMUX_PAD(0x05A4, 0x025C, 3, 0x0684, 0, 0),
+	 MX6_PAD_SD3_DATA1__LCDIF2_DATA_0                       = IOMUX_PAD(0x05A4, 0x025C, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA1__GPIO7_IO_3                          = IOMUX_PAD(0x05A4, 0x025C, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA1__DCIC2_OUT                           = IOMUX_PAD(0x05A4, 0x025C, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA1__TPSMP_HDATA_31                      = IOMUX_PAD(0x05A4, 0x025C, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA1__GPU_DEBUG_1                         = IOMUX_PAD(0x05A4, 0x025C, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA1__SDMA_DEBUG_EVT_CHN_LINES_1          = IOMUX_PAD(0x05A4, 0x025C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD3_DATA2__USDHC3_DATA2                        = IOMUX_PAD(0x05A8, 0x0260, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA2__UART4_RTS_B                         = IOMUX_PAD(0x05A8, 0x0260, 1, 0x0844, 1, 0),
+	 MX6_PAD_SD3_DATA2__ECSPI4_SS0                          = IOMUX_PAD(0x05A8, 0x0260, 2, 0x074C, 0, 0),
+	 MX6_PAD_SD3_DATA2__AUDMUX_AUD6_TXFS                    = IOMUX_PAD(0x05A8, 0x0260, 3, 0x0688, 0, 0),
+	 MX6_PAD_SD3_DATA2__LCDIF2_CLK                          = IOMUX_PAD(0x05A8, 0x0260, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA2__GPIO7_IO_4                          = IOMUX_PAD(0x05A8, 0x0260, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA2__LCDIF2_WR_RWN                       = IOMUX_PAD(0x05A8, 0x0260, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA2__TPSMP_HDATA_26                      = IOMUX_PAD(0x05A8, 0x0260, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA2__GPU_DEBUG_2                         = IOMUX_PAD(0x05A8, 0x0260, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA2__SDMA_DEBUG_EVENT_CHANNEL_2          = IOMUX_PAD(0x05A8, 0x0260, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD3_DATA3__USDHC3_DATA3                        = IOMUX_PAD(0x05AC, 0x0264, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA3__UART4_RX                            = IOMUX_PAD(0x05AC, 0x0264, 1, 0x0848, 1, 0),
+	 MX6_PAD_SD3_DATA3__ECSPI4_MISO                         = IOMUX_PAD(0x05AC, 0x0264, 2, 0x0744, 0, 0),
+	 MX6_PAD_SD3_DATA3__AUDMUX_AUD6_TXD                     = IOMUX_PAD(0x05AC, 0x0264, 3, 0x0678, 0, 0),
+	 MX6_PAD_SD3_DATA3__LCDIF2_ENABLE                       = IOMUX_PAD(0x05AC, 0x0264, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA3__GPIO7_IO_5                          = IOMUX_PAD(0x05AC, 0x0264, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA3__LCDIF2_RD_E                         = IOMUX_PAD(0x05AC, 0x0264, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA3__TPSMP_HDATA_27                      = IOMUX_PAD(0x05AC, 0x0264, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA3__GPU_DEBUG_3                         = IOMUX_PAD(0x05AC, 0x0264, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA3__SDMA_DEBUG_EVENT_CHANNEL_3          = IOMUX_PAD(0x05AC, 0x0264, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD3_DATA4__USDHC3_DATA4                        = IOMUX_PAD(0x05B0, 0x0268, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA4__CAN2_RX                             = IOMUX_PAD(0x05B0, 0x0268, 1, 0x0690, 0, 0),
+	 MX6_PAD_SD3_DATA4__CANFD_RX2                           = IOMUX_PAD(0x05B0, 0x0268, 2, 0x0698, 0, 0),
+	 MX6_PAD_SD3_DATA4__UART3_RX                            = IOMUX_PAD(0x05B0, 0x0268, 3, 0x0840, 2, 0),
+	 MX6_PAD_SD3_DATA4__LCDIF2_DATA_3                       = IOMUX_PAD(0x05B0, 0x0268, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA4__GPIO7_IO_6                          = IOMUX_PAD(0x05B0, 0x0268, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA4__ENET2_1588_EVENT0_IN                = IOMUX_PAD(0x05B0, 0x0268, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA4__TPSMP_HTRANS_1                      = IOMUX_PAD(0x05B0, 0x0268, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA4__GPU_DEBUG_4                         = IOMUX_PAD(0x05B0, 0x0268, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA4__SDMA_DEBUG_BUS_DEVICE_0             = IOMUX_PAD(0x05B0, 0x0268, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD3_DATA5__USDHC3_DATA5                        = IOMUX_PAD(0x05B4, 0x026C, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA5__CAN1_TX                             = IOMUX_PAD(0x05B4, 0x026C, 1, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA5__CANFD_TX1                           = IOMUX_PAD(0x05B4, 0x026C, 2, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA5__UART3_TX                            = IOMUX_PAD(0x05B4, 0x026C, 3, 0x0840, 3, 0),
+	 MX6_PAD_SD3_DATA5__LCDIF2_DATA_2                       = IOMUX_PAD(0x05B4, 0x026C, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA5__GPIO7_IO_7                          = IOMUX_PAD(0x05B4, 0x026C, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA5__ENET2_1588_EVENT0_OUT               = IOMUX_PAD(0x05B4, 0x026C, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA5__SIM_M_HWRITE                        = IOMUX_PAD(0x05B4, 0x026C, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA5__GPU_DEBUG_5                         = IOMUX_PAD(0x05B4, 0x026C, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA5__SDMA_DEBUG_BUS_DEVICE_1             = IOMUX_PAD(0x05B4, 0x026C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD3_DATA6__USDHC3_DATA6                        = IOMUX_PAD(0x05B8, 0x0270, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA6__CAN2_TX                             = IOMUX_PAD(0x05B8, 0x0270, 1, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA6__CANFD_TX2                           = IOMUX_PAD(0x05B8, 0x0270, 2, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA6__UART3_RTS_B                         = IOMUX_PAD(0x05B8, 0x0270, 3, 0x083C, 2, 0),
+	 MX6_PAD_SD3_DATA6__LCDIF2_DATA_4                       = IOMUX_PAD(0x05B8, 0x0270, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA6__GPIO7_IO_8                          = IOMUX_PAD(0x05B8, 0x0270, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA6__ENET1_1588_EVENT0_OUT               = IOMUX_PAD(0x05B8, 0x0270, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA6__TPSMP_HTRANS_0                      = IOMUX_PAD(0x05B8, 0x0270, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA6__GPU_DEBUG_7                         = IOMUX_PAD(0x05B8, 0x0270, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA6__SDMA_DEBUG_EVT_CHN_LINES_7          = IOMUX_PAD(0x05B8, 0x0270, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD3_DATA7__USDHC3_DATA7                        = IOMUX_PAD(0x05BC, 0x0274, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA7__CAN1_RX                             = IOMUX_PAD(0x05BC, 0x0274, 1, 0x068C, 0, 0),
+	 MX6_PAD_SD3_DATA7__CANFD_RX1                           = IOMUX_PAD(0x05BC, 0x0274, 2, 0x0694, 0, 0),
+	 MX6_PAD_SD3_DATA7__UART3_CTS_B                         = IOMUX_PAD(0x05BC, 0x0274, 3, 0x083C, 3, 0),
+	 MX6_PAD_SD3_DATA7__LCDIF2_DATA_5                       = IOMUX_PAD(0x05BC, 0x0274, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA7__GPIO7_IO_9                          = IOMUX_PAD(0x05BC, 0x0274, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA7__ENET1_1588_EVENT0_IN                = IOMUX_PAD(0x05BC, 0x0274, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA7__TPSMP_HDATA_DIR                     = IOMUX_PAD(0x05BC, 0x0274, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA7__GPU_DEBUG_6                         = IOMUX_PAD(0x05BC, 0x0274, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD3_DATA7__SDMA_DEBUG_EVT_CHN_LINES_2          = IOMUX_PAD(0x05BC, 0x0274, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD4_CLK__USDHC4_CLK                            = IOMUX_PAD(0x05C0, 0x0278, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD4_CLK__RAWNAND_DATA15                        = IOMUX_PAD(0x05C0, 0x0278, 1, 0x0000, 0, 0),
+	 MX6_PAD_SD4_CLK__ECSPI2_MISO                           = IOMUX_PAD(0x05C0, 0x0278, 2, 0x0724, 1, 0),
+	 MX6_PAD_SD4_CLK__AUDMUX_AUD3_RXFS                      = IOMUX_PAD(0x05C0, 0x0278, 3, 0x0638, 0, 0),
+	 MX6_PAD_SD4_CLK__LCDIF2_DATA_13                        = IOMUX_PAD(0x05C0, 0x0278, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD4_CLK__GPIO6_IO_12                           = IOMUX_PAD(0x05C0, 0x0278, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD4_CLK__ECSPI3_SS2                            = IOMUX_PAD(0x05C0, 0x0278, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD4_CLK__TPSMP_HDATA_20                        = IOMUX_PAD(0x05C0, 0x0278, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD4_CLK__VDEC_DEBUG_12                         = IOMUX_PAD(0x05C0, 0x0278, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD4_CLK__SDMA_DEBUG_EVENT_CHANNEL_SEL          = IOMUX_PAD(0x05C0, 0x0278, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD4_CMD__USDHC4_CMD                            = IOMUX_PAD(0x05C4, 0x027C, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD4_CMD__RAWNAND_DATA14                        = IOMUX_PAD(0x05C4, 0x027C, 1, 0x0000, 0, 0),
+	 MX6_PAD_SD4_CMD__ECSPI2_MOSI                           = IOMUX_PAD(0x05C4, 0x027C, 2, 0x0728, 1, 0),
+	 MX6_PAD_SD4_CMD__AUDMUX_AUD3_RXC                       = IOMUX_PAD(0x05C4, 0x027C, 3, 0x0634, 0, 0),
+	 MX6_PAD_SD4_CMD__LCDIF2_DATA_14                        = IOMUX_PAD(0x05C4, 0x027C, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD4_CMD__GPIO6_IO_13                           = IOMUX_PAD(0x05C4, 0x027C, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD4_CMD__ECSPI3_SS1                            = IOMUX_PAD(0x05C4, 0x027C, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD4_CMD__TPSMP_HDATA_19                        = IOMUX_PAD(0x05C4, 0x027C, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD4_CMD__VDEC_DEBUG_11                         = IOMUX_PAD(0x05C4, 0x027C, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD4_CMD__SDMA_DEBUG_CORE_RUN                   = IOMUX_PAD(0x05C4, 0x027C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD4_DATA0__USDHC4_DATA0                        = IOMUX_PAD(0x05C8, 0x0280, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA0__RAWNAND_DATA10                      = IOMUX_PAD(0x05C8, 0x0280, 1, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA0__ECSPI2_SS0                          = IOMUX_PAD(0x05C8, 0x0280, 2, 0x072C, 1, 0),
+	 MX6_PAD_SD4_DATA0__AUDMUX_AUD3_RXD                     = IOMUX_PAD(0x05C8, 0x0280, 3, 0x062C, 0, 0),
+	 MX6_PAD_SD4_DATA0__LCDIF2_DATA_12                      = IOMUX_PAD(0x05C8, 0x0280, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA0__GPIO6_IO_14                         = IOMUX_PAD(0x05C8, 0x0280, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA0__ECSPI3_SS3                          = IOMUX_PAD(0x05C8, 0x0280, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA0__TPSMP_HDATA_21                      = IOMUX_PAD(0x05C8, 0x0280, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA0__VDEC_DEBUG_13                       = IOMUX_PAD(0x05C8, 0x0280, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA0__SDMA_DEBUG_MODE                     = IOMUX_PAD(0x05C8, 0x0280, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD4_DATA1__USDHC4_DATA1                        = IOMUX_PAD(0x05CC, 0x0284, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA1__RAWNAND_DATA11                      = IOMUX_PAD(0x05CC, 0x0284, 1, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA1__ECSPI2_SCLK                         = IOMUX_PAD(0x05CC, 0x0284, 2, 0x0720, 1, 0),
+	 MX6_PAD_SD4_DATA1__AUDMUX_AUD3_TXC                     = IOMUX_PAD(0x05CC, 0x0284, 3, 0x063C, 0, 0),
+	 MX6_PAD_SD4_DATA1__LCDIF2_DATA_11                      = IOMUX_PAD(0x05CC, 0x0284, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA1__GPIO6_IO_15                         = IOMUX_PAD(0x05CC, 0x0284, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA1__ECSPI3_RDY                          = IOMUX_PAD(0x05CC, 0x0284, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA1__TPSMP_HDATA_22                      = IOMUX_PAD(0x05CC, 0x0284, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA1__VDEC_DEBUG_14                       = IOMUX_PAD(0x05CC, 0x0284, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA1__SDMA_DEBUG_BUS_ERROR                = IOMUX_PAD(0x05CC, 0x0284, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD4_DATA2__USDHC4_DATA2                        = IOMUX_PAD(0x05D0, 0x0288, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA2__RAWNAND_DATA12                      = IOMUX_PAD(0x05D0, 0x0288, 1, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA2__I2C2_SDA                            = IOMUX_PAD(0x05D0, 0x0288, IOMUX_CONFIG_SION | 2, 0x07B4, 0, 0),
+	 MX6_PAD_SD4_DATA2__AUDMUX_AUD3_TXFS                    = IOMUX_PAD(0x05D0, 0x0288, 3, 0x0640, 0, 0),
+	 MX6_PAD_SD4_DATA2__LCDIF2_DATA_10                      = IOMUX_PAD(0x05D0, 0x0288, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA2__GPIO6_IO_16                         = IOMUX_PAD(0x05D0, 0x0288, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA2__ECSPI2_SS3                          = IOMUX_PAD(0x05D0, 0x0288, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA2__TPSMP_HDATA_23                      = IOMUX_PAD(0x05D0, 0x0288, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA2__VDEC_DEBUG_15                       = IOMUX_PAD(0x05D0, 0x0288, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA2__SDMA_DEBUG_BUS_RWB                  = IOMUX_PAD(0x05D0, 0x0288, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD4_DATA3__USDHC4_DATA3                        = IOMUX_PAD(0x05D4, 0x028C, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA3__RAWNAND_DATA13                      = IOMUX_PAD(0x05D4, 0x028C, 1, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA3__I2C2_SCL                            = IOMUX_PAD(0x05D4, 0x028C, IOMUX_CONFIG_SION | 2, 0x07B0, 0, 0),
+	 MX6_PAD_SD4_DATA3__AUDMUX_AUD3_TXD                     = IOMUX_PAD(0x05D4, 0x028C, 3, 0x0630, 0, 0),
+	 MX6_PAD_SD4_DATA3__LCDIF2_DATA_9                       = IOMUX_PAD(0x05D4, 0x028C, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA3__GPIO6_IO_17                         = IOMUX_PAD(0x05D4, 0x028C, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA3__ECSPI2_RDY                          = IOMUX_PAD(0x05D4, 0x028C, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA3__TPSMP_HDATA_24                      = IOMUX_PAD(0x05D4, 0x028C, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA3__VDEC_DEBUG_16                       = IOMUX_PAD(0x05D4, 0x028C, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA3__SDMA_DEBUG_MATCHED_DMBUS            = IOMUX_PAD(0x05D4, 0x028C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD4_DATA4__USDHC4_DATA4                        = IOMUX_PAD(0x05D8, 0x0290, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA4__RAWNAND_DATA09                      = IOMUX_PAD(0x05D8, 0x0290, 1, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA4__UART5_RX                            = IOMUX_PAD(0x05D8, 0x0290, 2, 0x0850, 0, 0),
+	 MX6_PAD_SD4_DATA4__ECSPI3_SCLK                         = IOMUX_PAD(0x05D8, 0x0290, 3, 0x0730, 0, 0),
+	 MX6_PAD_SD4_DATA4__LCDIF2_DATA_8                       = IOMUX_PAD(0x05D8, 0x0290, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA4__GPIO6_IO_18                         = IOMUX_PAD(0x05D8, 0x0290, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA4__SPDIF_OUT                           = IOMUX_PAD(0x05D8, 0x0290, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA4__TPSMP_HDATA_16                      = IOMUX_PAD(0x05D8, 0x0290, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA4__USB_OTG_HOST_MODE                   = IOMUX_PAD(0x05D8, 0x0290, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA4__SDMA_DEBUG_RTBUFFER_WRITE           = IOMUX_PAD(0x05D8, 0x0290, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD4_DATA5__USDHC4_DATA5                        = IOMUX_PAD(0x05DC, 0x0294, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA5__RAWNAND_CE2_B                       = IOMUX_PAD(0x05DC, 0x0294, 1, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA5__UART5_TX                            = IOMUX_PAD(0x05DC, 0x0294, 2, 0x0850, 1, 0),
+	 MX6_PAD_SD4_DATA5__ECSPI3_MOSI                         = IOMUX_PAD(0x05DC, 0x0294, 3, 0x0738, 0, 0),
+	 MX6_PAD_SD4_DATA5__LCDIF2_DATA_7                       = IOMUX_PAD(0x05DC, 0x0294, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA5__GPIO6_IO_19                         = IOMUX_PAD(0x05DC, 0x0294, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA5__SPDIF_IN                            = IOMUX_PAD(0x05DC, 0x0294, 6, 0x0824, 0, 0),
+	 MX6_PAD_SD4_DATA5__TPSMP_HDATA_17                      = IOMUX_PAD(0x05DC, 0x0294, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA5__VDEC_DEBUG_9                        = IOMUX_PAD(0x05DC, 0x0294, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA5__SDMA_DEBUG_EVENT_CHANNEL_0          = IOMUX_PAD(0x05DC, 0x0294, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD4_DATA6__USDHC4_DATA6                        = IOMUX_PAD(0x05E0, 0x0298, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA6__RAWNAND_CE3_B                       = IOMUX_PAD(0x05E0, 0x0298, 1, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA6__UART5_RTS_B                         = IOMUX_PAD(0x05E0, 0x0298, 2, 0x084C, 0, 0),
+	 MX6_PAD_SD4_DATA6__ECSPI3_MISO                         = IOMUX_PAD(0x05E0, 0x0298, 3, 0x0734, 0, 0),
+	 MX6_PAD_SD4_DATA6__LCDIF2_DATA_6                       = IOMUX_PAD(0x05E0, 0x0298, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA6__GPIO6_IO_20                         = IOMUX_PAD(0x05E0, 0x0298, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA6__USDHC4_WP                           = IOMUX_PAD(0x05E0, 0x0298, 6, 0x0878, 0, 0),
+	 MX6_PAD_SD4_DATA6__TPSMP_HDATA_18                      = IOMUX_PAD(0x05E0, 0x0298, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA6__VDEC_DEBUG_10                       = IOMUX_PAD(0x05E0, 0x0298, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA6__SDMA_DEBUG_EVENT_CHANNEL_1          = IOMUX_PAD(0x05E0, 0x0298, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD4_DATA7__USDHC4_DATA7                        = IOMUX_PAD(0x05E4, 0x029C, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA7__RAWNAND_DATA08                      = IOMUX_PAD(0x05E4, 0x029C, 1, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA7__UART5_CTS_B                         = IOMUX_PAD(0x05E4, 0x029C, 2, 0x084C, 1, 0),
+	 MX6_PAD_SD4_DATA7__ECSPI3_SS0                          = IOMUX_PAD(0x05E4, 0x029C, 3, 0x073C, 0, 0),
+	 MX6_PAD_SD4_DATA7__LCDIF2_DATA_15                      = IOMUX_PAD(0x05E4, 0x029C, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA7__GPIO6_IO_21                         = IOMUX_PAD(0x05E4, 0x029C, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA7__USDHC4_CD_B                         = IOMUX_PAD(0x05E4, 0x029C, 6, 0x0874, 0, 0),
+	 MX6_PAD_SD4_DATA7__TPSMP_HDATA_15                      = IOMUX_PAD(0x05E4, 0x029C, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA7__USB_OTG_PWR_WAKE                    = IOMUX_PAD(0x05E4, 0x029C, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD4_DATA7__SDMA_DEBUG_YIELD                    = IOMUX_PAD(0x05E4, 0x029C, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_SD4_RESET_B__USDHC4_RESET_B                    = IOMUX_PAD(0x05E8, 0x02A0, 0, 0x0000, 0, 0),
+	 MX6_PAD_SD4_RESET_B__RAWNAND_DQS                       = IOMUX_PAD(0x05E8, 0x02A0, 1, 0x0000, 0, 0),
+	 MX6_PAD_SD4_RESET_B__USDHC4_RESET                      = IOMUX_PAD(0x05E8, 0x02A0, 2, 0x0000, 0, 0),
+	 MX6_PAD_SD4_RESET_B__AUDMUX_MCLK                       = IOMUX_PAD(0x05E8, 0x02A0, 3, 0x0000, 0, 0),
+	 MX6_PAD_SD4_RESET_B__LCDIF2_RESET                      = IOMUX_PAD(0x05E8, 0x02A0, 4, 0x0000, 0, 0),
+	 MX6_PAD_SD4_RESET_B__GPIO6_IO_22                       = IOMUX_PAD(0x05E8, 0x02A0, 5, 0x0000, 0, 0),
+	 MX6_PAD_SD4_RESET_B__LCDIF2_CS                         = IOMUX_PAD(0x05E8, 0x02A0, 6, 0x0000, 0, 0),
+	 MX6_PAD_SD4_RESET_B__TPSMP_HDATA_25                    = IOMUX_PAD(0x05E8, 0x02A0, 7, 0x0000, 0, 0),
+	 MX6_PAD_SD4_RESET_B__VDEC_DEBUG_17                     = IOMUX_PAD(0x05E8, 0x02A0, 8, 0x0000, 0, 0),
+	 MX6_PAD_SD4_RESET_B__SDMA_DEBUG_BUS_DEVICE_2           = IOMUX_PAD(0x05E8, 0x02A0, 9, 0x0000, 0, 0),
+
+	 MX6_PAD_USB_H_DATA__USB_H_DATA                         = IOMUX_PAD(0x05EC, 0x02A4, 0, 0x0000, 0, 0),
+	 MX6_PAD_USB_H_DATA__PWM2_OUT                           = IOMUX_PAD(0x05EC, 0x02A4, 1, 0x0000, 0, 0),
+	 MX6_PAD_USB_H_DATA__ANATOP_24M_OUT                     = IOMUX_PAD(0x05EC, 0x02A4, 2, 0x0000, 0, 0),
+	 MX6_PAD_USB_H_DATA__I2C4_SDA                           = IOMUX_PAD(0x05EC, 0x02A4, IOMUX_CONFIG_SION | 3, 0x07C4, 1, 0),
+	 MX6_PAD_USB_H_DATA__WDOG3_WDOG_B                       = IOMUX_PAD(0x05EC, 0x02A4, 4, 0x0000, 0, 0),
+	 MX6_PAD_USB_H_DATA__GPIO7_IO_10                        = IOMUX_PAD(0x05EC, 0x02A4, 5, 0x0000, 0, 0),
+
+	 MX6_PAD_USB_H_STROBE__USB_H_STROBE                     = IOMUX_PAD(0x05F0, 0x02A8, 0, 0x0000, 0, 0),
+	 MX6_PAD_USB_H_STROBE__PWM1_OUT                         = IOMUX_PAD(0x05F0, 0x02A8, 1, 0x0000, 0, 0),
+	 MX6_PAD_USB_H_STROBE__ANATOP_32K_OUT                   = IOMUX_PAD(0x05F0, 0x02A8, 2, 0x0000, 0, 0),
+	 MX6_PAD_USB_H_STROBE__I2C4_SCL                         = IOMUX_PAD(0x05F0, 0x02A8, IOMUX_CONFIG_SION | 3, 0x07C0, 1, 0),
+	 MX6_PAD_USB_H_STROBE__WDOG3_WDOG_RST_B_DEB             = IOMUX_PAD(0x05F0, 0x02A8, 4, 0x0000, 0, 0),
+	 MX6_PAD_USB_H_STROBE__GPIO7_IO_11                      = IOMUX_PAD(0x05F0, 0x02A8, 5, 0x0000, 0, 0),
+};
+#endif  /* __ASM_ARCH_MX6_ MX6_PINS_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6sx_rdc.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6sx_rdc.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6sx_rdc.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6sx_rdc.h	2021-04-16 14:42:14.692580786 +0800
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:  GPL-2.0+
+ */
+
+#ifndef __MX6SX_RDC_H__
+#define __MX6SX_RDC_H__
+
+#define RDC_SEMA_PROC_ID 2  /* The processor ID for main CPU */
+
+enum {
+	RDC_PER_PWM1 = 0,
+	RDC_PER_PWM2,
+	RDC_PER_PWM3,
+	RDC_PER_PWM4,
+	RDC_PER_CAN1,
+	RDC_PER_CAN2,
+	RDC_PER_GPT,
+	RDC_PER_GPIO1,
+	RDC_PER_GPIO2,
+	RDC_PER_GPIO3,
+	RDC_PER_GPIO4,
+	RDC_PER_GPIO5,
+	RDC_PER_GPIO6,
+	RDC_PER_GPIO7,
+	RDC_PER_KPP,
+	RDC_PER_WDOG1,
+	RDC_PER_WODG2,
+	RDC_PER_CCM,
+	RDC_PER_ANATOPDIG,
+	RDC_PER_SNVSHP,
+	RDC_PER_EPIT1,
+	RDC_PER_EPIT2,
+	RDC_PER_SRC,
+	RDC_PER_GPC,
+	RDC_PER_IOMUXC,
+	RDC_PER_IOMUXCGPR,
+	RDC_PER_CANFD1,
+	RDC_PER_SDMA,
+	RDC_PER_CANFD2,
+	RDC_PER_SEMA1,
+	RDC_PER_SEMA2,
+	RDC_PER_RDC,
+	RDC_PER_AIPSTZ1_GE1,
+	RDC_PER_AIPSTZ2_GE2,
+	RDC_PER_USBO2H_PL301,
+	RDC_PER_USBO2H_USB,
+	RDC_PER_ENET1,
+	RDC_PER_MLB25,
+	RDC_PER_USDHC1,
+	RDC_PER_USDHC2,
+	RDC_PER_USDHC3,
+	RDC_PER_USDHC4,
+	RDC_PER_I2C1,
+	RDC_PER_I2C2,
+	RDC_PER_I2C3,
+	RDC_PER_ROMCP,
+	RDC_PER_MMDC,
+	RDC_PER_ENET2,
+	RDC_PER_EIM,
+	RDC_PER_OCOTP,
+	RDC_PER_CSU,
+	RDC_PER_PERFMON1,
+	RDC_PER_PERFMON2,
+	RDC_PER_AXIMON,
+	RDC_PER_TZASC1,
+	RDC_PER_SAI1,
+	RDC_PER_AUDMUX,
+	RDC_PER_SAI2,
+	RDC_PER_QSPI1,
+	RDC_PER_QSPI2,
+	RDC_PER_UART2,
+	RDC_PER_UART3,
+	RDC_PER_UART4,
+	RDC_PER_UART5,
+	RDC_PER_I2C4,
+	RDC_PER_QOSC,
+	RDC_PER_CAAM,
+	RDC_PER_DAP,
+	RDC_PER_ADC1,
+	RDC_PER_ADC2,
+	RDC_PER_WDOG3,
+	RDC_PER_ECSPI5,
+	RDC_PER_SEMA4,
+	RDC_PER_MUPORT1,
+	RDC_PER_CANFD_CPU,
+	RDC_PER_MUPORT2,
+	RDC_PER_UART6,
+	RDC_PER_PWM5,
+	RDC_PER_PWM6,
+	RDC_PER_PWM7,
+	RDC_PER_PWM8,
+	RDC_PER_AIPSTZ3_GE0,
+	RDC_PER_AIPSTZ3_GE1,
+	RDC_PER_RESERVED1,
+	RDC_PER_SPDIF,
+	RDC_PER_ECSPI1,
+	RDC_PER_ECSPI2,
+	RDC_PER_ECSPI3,
+	RDC_PER_ECSPI4,
+	RDC_PER_RESERVED2,
+	RDC_PER_RESERVED3,
+	RDC_PER_UART1,
+	RDC_PER_ESAI,
+	RDC_PER_SSI1,
+	RDC_PER_SSI2,
+	RDC_PER_SSI3,
+	RDC_PER_ASRC,
+	RDC_PER_RESERVED4,
+	RDC_PER_SPBA_MA,
+	RDC_PER_GIS,
+	RDC_PER_DCIC1,
+	RDC_PER_DCIC2,
+	RDC_PER_CSI1,
+	RDC_PER_PXP,
+	RDC_PER_CSI2,
+	RDC_PER_LCDIF1,
+	RDC_PER_LCDIF2,
+	RDC_PER_VADC,
+	RDC_PER_VDEC,
+	RDC_PER_SPBA_DISPLAYMIX,
+};
+
+enum {
+	RDC_MA_A9_L2CACHE = 0,
+	RDC_MA_M4,
+	RDC_MA_GPU,
+	RDC_MA_CSI1,
+	RDC_MA_CSI2,
+	RDC_MA_LCDIF1,
+	RDC_MA_LCDIF2,
+	RDC_MA_PXP,
+	RDC_MA_PCIE_CTRL,
+	RDC_MA_DAP,
+	RDC_MA_CAAM,
+	RDC_MA_SDMA_PERI,
+	RDC_MA_SDMA_BURST,
+	RDC_MA_APBHDMA,
+	RDC_MA_RAWNAND,
+	RDC_MA_USDHC1,
+	RDC_MA_USDHC2,
+	RDC_MA_USDHC3,
+	RDC_MA_USDHC4,
+	RDC_MA_USB,
+	RDC_MA_MLB,
+	RDC_MA_TEST,
+	RDC_MA_ENET1_TX,
+	RDC_MA_ENET1_RX,
+	RDC_MA_ENET2_TX,
+	RDC_MA_ENET2_RX,
+	RDC_MA_SDMA,
+};
+
+#endif	/* __MX6SX_RDC_H__*/
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6ul-ddr.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6ul-ddr.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6ul-ddr.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6ul-ddr.h	2021-04-16 14:42:14.692580786 +0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_MX6UL_DDR_H__
+#define __ASM_ARCH_MX6UL_DDR_H__
+
+#ifndef CONFIG_MX6UL
+#error "wrong CPU"
+#endif
+
+#define MX6_IOM_DRAM_DQM0	0x020e0244
+#define MX6_IOM_DRAM_DQM1	0x020e0248
+
+#define MX6_IOM_DRAM_RAS	0x020e024c
+#define MX6_IOM_DRAM_CAS	0x020e0250
+#define MX6_IOM_DRAM_CS0	0x020e0254
+#define MX6_IOM_DRAM_CS1	0x020e0258
+#define MX6_IOM_DRAM_SDWE_B	0x020e025c
+#define MX6_IOM_DRAM_SDODT0	0x020e0260
+#define MX6_IOM_DRAM_SDODT1	0x020e0264
+#define MX6_IOM_DRAM_SDBA0	0x020e0268
+#define MX6_IOM_DRAM_SDBA1	0x020e026c
+#define MX6_IOM_DRAM_SDBA2	0x020e0270
+#define MX6_IOM_DRAM_SDCKE0	0x020e0274
+#define MX6_IOM_DRAM_SDCKE1	0x020e0278
+#define MX6_IOM_DRAM_SDCLK_0	0x020e027c
+#define MX6_IOM_DRAM_SDQS0	0x020e0280
+#define MX6_IOM_DRAM_SDQS1	0x020e0284
+#define MX6_IOM_DRAM_RESET	0x020e0288
+
+#define MX6_IOM_GRP_ADDDS	0x020e0490
+#define MX6_IOM_DDRMODE_CTL	0x020e0494
+#define MX6_IOM_GRP_B0DS	0x020e0498
+#define MX6_IOM_GRP_DDRPK	0x020e049c
+#define MX6_IOM_GRP_CTLDS	0x020e04a0
+#define MX6_IOM_GRP_B1DS	0x020e04a4
+#define MX6_IOM_GRP_DDRHYS	0x020e04a8
+#define MX6_IOM_GRP_DDRPKE	0x020e04ac
+#define MX6_IOM_GRP_DDRMODE	0x020e04b0
+#define MX6_IOM_GRP_DDR_TYPE	0x020e04b4
+
+#endif	/*__ASM_ARCH_MX6SX_DDR_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6ull_pins.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6ull_pins.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6ull_pins.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6ull_pins.h	2021-04-16 14:42:14.692580786 +0800
@@ -0,0 +1,1091 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_IMX6ULL_PINS_H__
+#define __ASM_ARCH_IMX6ULL_PINS_H__
+
+#include <asm/imx-common/iomux-v3.h>
+
+enum {
+	MX6_PAD_BOOT_MODE0__GPIO5_IO10	                       = IOMUX_PAD(0x0044, 0x0000, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_BOOT_MODE1__GPIO5_IO11	                       = IOMUX_PAD(0x0048, 0x0004, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+
+	/*
+	 * The TAMPER Pin can be used for GPIO, which depends on
+	 * TAMPER_PIN_DISABLE[1:0] settings.
+	 */
+	MX6_PAD_SNVS_TAMPER0__GPIO5_IO00                       = IOMUX_PAD(0x004C, 0x0008, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER1__GPIO5_IO01                       = IOMUX_PAD(0x0050, 0x000C, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER2__GPIO5_IO02                       = IOMUX_PAD(0x0054, 0x0010, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER3__GPIO5_IO03                       = IOMUX_PAD(0x0058, 0x0014, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER4__GPIO5_IO04                       = IOMUX_PAD(0x005C, 0x0018, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER5__GPIO5_IO05                       = IOMUX_PAD(0x0060, 0x001C, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER6__GPIO5_IO06                       = IOMUX_PAD(0x0064, 0x0020, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER7__GPIO5_IO07                       = IOMUX_PAD(0x0068, 0x0024, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER8__GPIO5_IO08                       = IOMUX_PAD(0x006C, 0x0028, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER9__GPIO5_IO09                       = IOMUX_PAD(0x0070, 0x002C, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_MOD__SJC_MOD                             = IOMUX_PAD(0x02D0, 0x0044, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__GPT2_CLK                            = IOMUX_PAD(0x02D0, 0x0044, 1, 0x05A0, 0, 0),
+	MX6_PAD_JTAG_MOD__SPDIF_OUT                           = IOMUX_PAD(0x02D0, 0x0044, 2, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__ENET1_REF_CLK_25M                   = IOMUX_PAD(0x02D0, 0x0044, 3, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__CCM_PMIC_RDY                        = IOMUX_PAD(0x02D0, 0x0044, 4, 0x04C0, 0, 0),
+	MX6_PAD_JTAG_MOD__GPIO1_IO10                          = IOMUX_PAD(0x02D0, 0x0044, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__SDMA_EXT_EVENT00                    = IOMUX_PAD(0x02D0, 0x0044, 6, 0x0610, 0, 0),
+
+	MX6_PAD_JTAG_TMS__SJC_TMS                             = IOMUX_PAD(0x02D4, 0x0048, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__GPT2_CAPTURE1                       = IOMUX_PAD(0x02D4, 0x0048, 1, 0x0598, 0, 0),
+	MX6_PAD_JTAG_TMS__SAI2_MCLK                           = IOMUX_PAD(0x02D4, 0x0048, 2, 0x05F0, 0, 0),
+	MX6_PAD_JTAG_TMS__CCM_CLKO1                           = IOMUX_PAD(0x02D4, 0x0048, 3, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__CCM_WAIT                            = IOMUX_PAD(0x02D4, 0x0048, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__GPIO1_IO11                          = IOMUX_PAD(0x02D4, 0x0048, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__SDMA_EXT_EVENT01                    = IOMUX_PAD(0x02D4, 0x0048, 6, 0x0614, 0, 0),
+	MX6_PAD_JTAG_TMS__EPIT1_OUT                           = IOMUX_PAD(0x02D4, 0x0048, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TDO__SJC_TDO                             = IOMUX_PAD(0x02D8, 0x004C, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__GPT2_CAPTURE2                       = IOMUX_PAD(0x02D8, 0x004C, 1, 0x059C, 0, 0),
+	MX6_PAD_JTAG_TDO__SAI2_TX_SYNC                        = IOMUX_PAD(0x02D8, 0x004C, 2, 0x05FC, 0, 0),
+	MX6_PAD_JTAG_TDO__CCM_CLKO2                           = IOMUX_PAD(0x02D8, 0x004C, 3, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__CCM_STOP                            = IOMUX_PAD(0x02D8, 0x004C, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__GPIO1_IO12                          = IOMUX_PAD(0x02D8, 0x004C, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__MQS_RIGHT                           = IOMUX_PAD(0x02D8, 0x004C, 6, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__EPIT2_OUT                           = IOMUX_PAD(0x02D8, 0x004C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TDI__SJC_TDI                             = IOMUX_PAD(0x02DC, 0x0050, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__GPT2_COMPARE1                       = IOMUX_PAD(0x02DC, 0x0050, 1, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__SAI2_TX_BCLK                        = IOMUX_PAD(0x02DC, 0x0050, 2, 0x05F8, 0, 0),
+	MX6_PAD_JTAG_TDI__PWM6_OUT                            = IOMUX_PAD(0x02DC, 0x0050, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__GPIO1_IO13                          = IOMUX_PAD(0x02DC, 0x0050, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__MQS_LEFT                            = IOMUX_PAD(0x02DC, 0x0050, 6, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__SIM1_POWER_FAIL                     = IOMUX_PAD(0x02DC, 0x0050, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TCK__SJC_TCK                             = IOMUX_PAD(0x02E0, 0x0054, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__GPT2_COMPARE2                       = IOMUX_PAD(0x02E0, 0x0054, 1, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__SAI2_RX_DATA                        = IOMUX_PAD(0x02E0, 0x0054, 2, 0x05F4, 0, 0),
+	MX6_PAD_JTAG_TCK__PWM7_OUT                            = IOMUX_PAD(0x02E0, 0x0054, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__GPIO1_IO14                          = IOMUX_PAD(0x02E0, 0x0054, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__SIM2_POWER_FAIL                     = IOMUX_PAD(0x02E0, 0x0054, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TRST_B__SJC_TRSTB                        = IOMUX_PAD(0x02E4, 0x0058, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__GPT2_COMPARE3                    = IOMUX_PAD(0x02E4, 0x0058, 1, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__SAI2_TX_DATA                     = IOMUX_PAD(0x02E4, 0x0058, 2, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__PWM8_OUT                         = IOMUX_PAD(0x02E4, 0x0058, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__GPIO1_IO15                       = IOMUX_PAD(0x02E4, 0x0058, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__CAAM_RNG_OSC_OBS                 = IOMUX_PAD(0x02E4, 0x0058, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO00__I2C2_SCL                          = IOMUX_PAD(0x02E8, 0x005C, IOMUX_CONFIG_SION | 0, 0x05AC, 1, 0),
+	MX6_PAD_GPIO1_IO00__GPT1_CAPTURE1                     = IOMUX_PAD(0x02E8, 0x005C, 1, 0x058C, 0, 0),
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID                    = IOMUX_PAD(0x02E8, 0x005C, 2, 0x04B8, 0, 0),
+	MX6_PAD_GPIO1_IO00__ENET1_REF_CLK1                    = IOMUX_PAD(0x02E8, 0x005C, 3, 0x0574, 0, 0),
+	MX6_PAD_GPIO1_IO00__MQS_RIGHT                         = IOMUX_PAD(0x02E8, 0x005C, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__GPIO1_IO00                        = IOMUX_PAD(0x02E8, 0x005C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__ENET1_1588_EVENT0_IN              = IOMUX_PAD(0x02E8, 0x005C, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__SRC_SYSTEM_RESET                  = IOMUX_PAD(0x02E8, 0x005C, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__WDOG3_WDOG_B                      = IOMUX_PAD(0x02E8, 0x005C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO01__I2C2_SDA                          = IOMUX_PAD(0x02EC, 0x0060, IOMUX_CONFIG_SION | 0, 0x05B0, 1, 0),
+	MX6_PAD_GPIO1_IO01__GPT1_COMPARE1                     = IOMUX_PAD(0x02EC, 0x0060, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__USB_OTG1_OC                       = IOMUX_PAD(0x02EC, 0x0060, 2, 0x0664, 0, 0),
+	MX6_PAD_GPIO1_IO01__ENET2_REF_CLK2                    = IOMUX_PAD(0x02EC, 0x0060, 3, 0x057C, 0, 0),
+	MX6_PAD_GPIO1_IO01__MQS_LEFT                          = IOMUX_PAD(0x02EC, 0x0060, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__GPIO1_IO01                        = IOMUX_PAD(0x02EC, 0x0060, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__ENET1_1588_EVENT0_OUT             = IOMUX_PAD(0x02EC, 0x0060, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__SRC_EARLY_RESET                   = IOMUX_PAD(0x02EC, 0x0060, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__WDOG1_WDOG_B                      = IOMUX_PAD(0x02EC, 0x0060, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO02__I2C1_SCL                          = IOMUX_PAD(0x02F0, 0x0064, IOMUX_CONFIG_SION | 0, 0x05A4, 0, 0),
+	MX6_PAD_GPIO1_IO02__GPT1_COMPARE2                     = IOMUX_PAD(0x02F0, 0x0064, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__USB_OTG2_PWR                      = IOMUX_PAD(0x02F0, 0x0064, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__ENET1_REF_CLK_25M                 = IOMUX_PAD(0x02F0, 0x0064, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__USDHC1_WP                         = IOMUX_PAD(0x02F0, 0x0064, 4, 0x066C, 0, 0),
+	MX6_PAD_GPIO1_IO02__GPIO1_IO02                        = IOMUX_PAD(0x02F0, 0x0064, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__SDMA_EXT_EVENT00                  = IOMUX_PAD(0x02F0, 0x0064, 6, 0x0610, 1, 0),
+	MX6_PAD_GPIO1_IO02__SRC_ANY_PU_RESET                  = IOMUX_PAD(0x02F0, 0x0064, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__UART1_DCE_TX                      = IOMUX_PAD(0x02F0, 0x0064, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__UART1_DTE_RX                      = IOMUX_PAD(0x02F0, 0x0064, 8, 0x0624, 0, 0),
+
+	MX6_PAD_GPIO1_IO03__I2C1_SDA                          = IOMUX_PAD(0x02F4, 0x0068, IOMUX_CONFIG_SION | 0, 0x05A8, 1, 0),
+	MX6_PAD_GPIO1_IO03__GPT1_COMPARE3                     = IOMUX_PAD(0x02F4, 0x0068, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__USB_OTG2_OC                       = IOMUX_PAD(0x02F4, 0x0068, 2, 0x0660, 0, 0),
+	MX6_PAD_GPIO1_IO03__USDHC1_CD_B                       = IOMUX_PAD(0x02F4, 0x0068, 4, 0x0668, 0, 0),
+	MX6_PAD_GPIO1_IO03__GPIO1_IO03                        = IOMUX_PAD(0x02F4, 0x0068, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__CCM_DI0_EXT_CLK                   = IOMUX_PAD(0x02F4, 0x0068, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__SRC_TESTER_ACK                    = IOMUX_PAD(0x02F4, 0x0068, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__UART1_DCE_RX                      = IOMUX_PAD(0x02F4, 0x0068, 8, 0x0624, 1, 0),
+	MX6_PAD_GPIO1_IO03__UART1_DTE_TX                      = IOMUX_PAD(0x02F4, 0x0068, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO04__ENET1_REF_CLK1                    = IOMUX_PAD(0x02F8, 0x006C, 0, 0x0574, 1, 0),
+	MX6_PAD_GPIO1_IO04__PWM3_OUT                          = IOMUX_PAD(0x02F8, 0x006C, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__USB_OTG1_PWR                      = IOMUX_PAD(0x02F8, 0x006C, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__USDHC1_RESET_B                    = IOMUX_PAD(0x02F8, 0x006C, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__GPIO1_IO04                        = IOMUX_PAD(0x02F8, 0x006C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__ENET2_1588_EVENT0_IN              = IOMUX_PAD(0x02F8, 0x006C, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__UART5_DCE_TX                      = IOMUX_PAD(0x02F8, 0x006C, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__UART5_DTE_RX                      = IOMUX_PAD(0x02F8, 0x006C, 8, 0x0644, 2, 0),
+
+	MX6_PAD_GPIO1_IO05__ENET2_REF_CLK2                    = IOMUX_PAD(0x02FC, 0x0070, 0, 0x057C, 1, 0),
+	MX6_PAD_GPIO1_IO05__PWM4_OUT                          = IOMUX_PAD(0x02FC, 0x0070, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__ANATOP_OTG2_ID                    = IOMUX_PAD(0x02FC, 0x0070, 2, 0x04BC, 0, 0),
+	MX6_PAD_GPIO1_IO05__CSI_FIELD                         = IOMUX_PAD(0x02FC, 0x0070, 3, 0x0530, 0, 0),
+	MX6_PAD_GPIO1_IO05__USDHC1_VSELECT                    = IOMUX_PAD(0x02FC, 0x0070, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__GPIO1_IO05                        = IOMUX_PAD(0x02FC, 0x0070, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__ENET2_1588_EVENT0_OUT             = IOMUX_PAD(0x02FC, 0x0070, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__UART5_DCE_RX                      = IOMUX_PAD(0x02FC, 0x0070, 8, 0x0644, 3, 0),
+	MX6_PAD_GPIO1_IO05__UART5_DTE_TX                      = IOMUX_PAD(0x02FC, 0x0070, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO06__ENET1_MDIO                        = IOMUX_PAD(0x0300, 0x0074, 0, 0x0578, 0, 0),
+	MX6_PAD_GPIO1_IO06__ENET2_MDIO                        = IOMUX_PAD(0x0300, 0x0074, 1, 0x0580, 0, 0),
+	MX6_PAD_GPIO1_IO06__USB_OTG_PWR_WAKE                  = IOMUX_PAD(0x0300, 0x0074, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__CSI_MCLK                          = IOMUX_PAD(0x0300, 0x0074, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__USDHC2_WP                         = IOMUX_PAD(0x0300, 0x0074, 4, 0x069C, 0, 0),
+	MX6_PAD_GPIO1_IO06__GPIO1_IO06                        = IOMUX_PAD(0x0300, 0x0074, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__CCM_WAIT                          = IOMUX_PAD(0x0300, 0x0074, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__CCM_REF_EN_B                      = IOMUX_PAD(0x0300, 0x0074, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__UART1_DCE_CTS                     = IOMUX_PAD(0x0300, 0x0074, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__UART1_DTE_RTS                     = IOMUX_PAD(0x0300, 0x0074, 8, 0x0620, 0, 0),
+
+	MX6_PAD_GPIO1_IO07__ENET1_MDC                         = IOMUX_PAD(0x0304, 0x0078, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__ENET2_MDC                         = IOMUX_PAD(0x0304, 0x0078, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__USB_OTG_HOST_MODE                 = IOMUX_PAD(0x0304, 0x0078, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__CSI_PIXCLK                        = IOMUX_PAD(0x0304, 0x0078, 3, 0x0528, 0, 0),
+	MX6_PAD_GPIO1_IO07__USDHC2_CD_B                       = IOMUX_PAD(0x0304, 0x0078, 4, 0x0674, 1, 0),
+	MX6_PAD_GPIO1_IO07__GPIO1_IO07                        = IOMUX_PAD(0x0304, 0x0078, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__CCM_STOP                          = IOMUX_PAD(0x0304, 0x0078, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__UART1_DCE_RTS                     = IOMUX_PAD(0x0304, 0x0078, 8, 0x0620, 1, 0),
+	MX6_PAD_GPIO1_IO07__UART1_DTE_CTS                     = IOMUX_PAD(0x0304, 0x0078, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO08__PWM1_OUT                          = IOMUX_PAD(0x0308, 0x007C, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__WDOG1_WDOG_B                      = IOMUX_PAD(0x0308, 0x007C, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__SPDIF_OUT                         = IOMUX_PAD(0x0308, 0x007C, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__CSI_VSYNC                         = IOMUX_PAD(0x0308, 0x007C, 3, 0x052C, 1, 0),
+	MX6_PAD_GPIO1_IO08__USDHC2_VSELECT                    = IOMUX_PAD(0x0308, 0x007C, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__GPIO1_IO08                        = IOMUX_PAD(0x0308, 0x007C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__CCM_PMIC_RDY                      = IOMUX_PAD(0x0308, 0x007C, 6, 0x04C0, 1, 0),
+	MX6_PAD_GPIO1_IO08__UART5_DCE_RTS                     = IOMUX_PAD(0x0308, 0x007C, 8, 0x0640, 1, 0),
+	MX6_PAD_GPIO1_IO08__UART5_DTE_CTS                     = IOMUX_PAD(0x0308, 0x007C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO09__PWM2_OUT                          = IOMUX_PAD(0x030C, 0x0080, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__WDOG1_WDOG_ANY                    = IOMUX_PAD(0x030C, 0x0080, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__SPDIF_IN                          = IOMUX_PAD(0x030C, 0x0080, 2, 0x0618, 0, 0),
+	MX6_PAD_GPIO1_IO09__CSI_HSYNC                         = IOMUX_PAD(0x030C, 0x0080, 3, 0x0524, 1, 0),
+	MX6_PAD_GPIO1_IO09__USDHC2_RESET_B                    = IOMUX_PAD(0x030C, 0x0080, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09                        = IOMUX_PAD(0x030C, 0x0080, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__USDHC1_RESET_B                    = IOMUX_PAD(0x030C, 0x0080, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__UART5_DCE_CTS                     = IOMUX_PAD(0x030C, 0x0080, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__UART5_DTE_RTS                     = IOMUX_PAD(0x030C, 0x0080, 8, 0x0640, 2, 0),
+
+	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX                   = IOMUX_PAD(0x0310, 0x0084, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_TX_DATA__UART1_DTE_RX                   = IOMUX_PAD(0x0310, 0x0084, 0, 0x0624, 2, 0),
+	MX6_PAD_UART1_TX_DATA__ENET1_RDATA02                  = IOMUX_PAD(0x0310, 0x0084, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_TX_DATA__I2C3_SCL                       = IOMUX_PAD(0x0310, 0x0084, IOMUX_CONFIG_SION | 2, 0x05B4, 0, 0),
+	MX6_PAD_UART1_TX_DATA__CSI_DATA02                     = IOMUX_PAD(0x0310, 0x0084, 3, 0x04C4, 1, 0),
+	MX6_PAD_UART1_TX_DATA__GPT1_COMPARE1                  = IOMUX_PAD(0x0310, 0x0084, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_TX_DATA__GPIO1_IO16                     = IOMUX_PAD(0x0310, 0x0084, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_TX_DATA__SPDIF_OUT                      = IOMUX_PAD(0x0310, 0x0084, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX                   = IOMUX_PAD(0x0314, 0x0088, 0, 0x0624, 3, 0),
+
+	MX6_PAD_UART1_RX_DATA__UART1_DTE_TX                   = IOMUX_PAD(0x0314, 0x0088, 0, 0x0000, 0, 0),
+	MX6_PAD_UART1_RX_DATA__ENET1_RDATA03                  = IOMUX_PAD(0x0314, 0x0088, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_RX_DATA__I2C3_SDA                       = IOMUX_PAD(0x0314, 0x0088, IOMUX_CONFIG_SION | 2, 0x05B8, 0, 0),
+	MX6_PAD_UART1_RX_DATA__CSI_DATA03                     = IOMUX_PAD(0x0314, 0x0088, 3, 0x04C8, 1, 0),
+	MX6_PAD_UART1_RX_DATA__GPT1_CLK                       = IOMUX_PAD(0x0314, 0x0088, 4, 0x0594, 0, 0),
+	MX6_PAD_UART1_RX_DATA__GPIO1_IO17                     = IOMUX_PAD(0x0314, 0x0088, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_RX_DATA__SPDIF_IN                       = IOMUX_PAD(0x0314, 0x0088, 8, 0x0618, 1, 0),
+
+	MX6_PAD_UART1_CTS_B__UART1_DCE_CTS                    = IOMUX_PAD(0x0318, 0x008C, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_CTS_B__UART1_DTE_RTS                    = IOMUX_PAD(0x0318, 0x008C, 0, 0x0620, 2, 0),
+	MX6_PAD_UART1_CTS_B__ENET1_RX_CLK                     = IOMUX_PAD(0x0318, 0x008C, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_CTS_B__USDHC1_WP                        = IOMUX_PAD(0x0318, 0x008C, 2, 0x066C, 1, 0),
+	MX6_PAD_UART1_CTS_B__CSI_DATA04                       = IOMUX_PAD(0x0318, 0x008C, 3, 0x04D8, 0, 0),
+	MX6_PAD_UART1_CTS_B__ENET2_1588_EVENT1_IN             = IOMUX_PAD(0x0318, 0x008C, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_CTS_B__GPIO1_IO18                       = IOMUX_PAD(0x0318, 0x008C, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_CTS_B__USDHC2_WP                        = IOMUX_PAD(0x0318, 0x008C, 8, 0x069C, 1, 0),
+
+	MX6_PAD_UART1_RTS_B__UART1_DCE_RTS                    = IOMUX_PAD(0x031C, 0x0090, 0, 0x0620, 3, 0),
+
+	MX6_PAD_UART1_RTS_B__UART1_DTE_CTS                    = IOMUX_PAD(0x031C, 0x0090, 0, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__ENET1_TX_ER                      = IOMUX_PAD(0x031C, 0x0090, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__USDHC1_CD_B                      = IOMUX_PAD(0x031C, 0x0090, 2, 0x0668, 1, 0),
+	MX6_PAD_UART1_RTS_B__CSI_DATA05                       = IOMUX_PAD(0x031C, 0x0090, 3, 0x04CC, 1, 0),
+	MX6_PAD_UART1_RTS_B__ENET2_1588_EVENT1_OUT            = IOMUX_PAD(0x031C, 0x0090, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__GPIO1_IO19                       = IOMUX_PAD(0x031C, 0x0090, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__USDHC2_CD_B                      = IOMUX_PAD(0x031C, 0x0090, 8, 0x0674, 2, 0),
+
+	MX6_PAD_UART2_TX_DATA__UART2_DCE_TX                   = IOMUX_PAD(0x0320, 0x0094, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART2_TX_DATA__UART2_DTE_RX                   = IOMUX_PAD(0x0320, 0x0094, 0, 0x062C, 0, 0),
+	MX6_PAD_UART2_TX_DATA__ENET1_TDATA02                  = IOMUX_PAD(0x0320, 0x0094, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_TX_DATA__I2C4_SCL                       = IOMUX_PAD(0x0320, 0x0094, IOMUX_CONFIG_SION | 2, 0x05BC, 0, 0),
+	MX6_PAD_UART2_TX_DATA__CSI_DATA06                     = IOMUX_PAD(0x0320, 0x0094, 3, 0x04DC, 0, 0),
+	MX6_PAD_UART2_TX_DATA__GPT1_CAPTURE1                  = IOMUX_PAD(0x0320, 0x0094, 4, 0x058C, 1, 0),
+	MX6_PAD_UART2_TX_DATA__GPIO1_IO20                     = IOMUX_PAD(0x0320, 0x0094, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_TX_DATA__ECSPI3_SS0                     = IOMUX_PAD(0x0320, 0x0094, 8, 0x0560, 0, 0),
+
+	MX6_PAD_UART2_RX_DATA__UART2_DCE_RX                   = IOMUX_PAD(0x0324, 0x0098, 0, 0x062C, 1, 0),
+
+	MX6_PAD_UART2_RX_DATA__UART2_DTE_TX                   = IOMUX_PAD(0x0324, 0x0098, 0, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__ENET1_TDATA03                  = IOMUX_PAD(0x0324, 0x0098, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__I2C4_SDA                       = IOMUX_PAD(0x0324, 0x0098, IOMUX_CONFIG_SION | 2, 0x05C0, 0, 0),
+	MX6_PAD_UART2_RX_DATA__CSI_DATA07                     = IOMUX_PAD(0x0324, 0x0098, 3, 0x04E0, 0, 0),
+	MX6_PAD_UART2_RX_DATA__GPT1_CAPTURE2                  = IOMUX_PAD(0x0324, 0x0098, 4, 0x0590, 0, 0),
+	MX6_PAD_UART2_RX_DATA__GPIO1_IO21                     = IOMUX_PAD(0x0324, 0x0098, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__SJC_DONE                       = IOMUX_PAD(0x0324, 0x0098, 7, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__ECSPI3_SCLK                    = IOMUX_PAD(0x0324, 0x0098, 8, 0x0554, 0, 0),
+
+	MX6_PAD_UART2_CTS_B__UART2_DCE_CTS                    = IOMUX_PAD(0x0328, 0x009C, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART2_CTS_B__UART2_DTE_RTS                    = IOMUX_PAD(0x0328, 0x009C, 0, 0x0628, 0, 0),
+	MX6_PAD_UART2_CTS_B__ENET1_CRS                        = IOMUX_PAD(0x0328, 0x009C, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__FLEXCAN2_TX                      = IOMUX_PAD(0x0328, 0x009C, 2, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__CSI_DATA08                       = IOMUX_PAD(0x0328, 0x009C, 3, 0x04E4, 0, 0),
+	MX6_PAD_UART2_CTS_B__GPT1_COMPARE2                    = IOMUX_PAD(0x0328, 0x009C, 4, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__GPIO1_IO22                       = IOMUX_PAD(0x0328, 0x009C, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__SJC_DE_B                         = IOMUX_PAD(0x0328, 0x009C, 7, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__ECSPI3_MOSI                      = IOMUX_PAD(0x0328, 0x009C, 8, 0x055C, 0, 0),
+
+	MX6_PAD_UART2_RTS_B__UART2_DCE_RTS                    = IOMUX_PAD(0x032C, 0x00A0, 0, 0x0628, 1, 0),
+
+	MX6_PAD_UART2_RTS_B__UART2_DTE_CTS                    = IOMUX_PAD(0x032C, 0x00A0, 0, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__ENET1_COL                        = IOMUX_PAD(0x032C, 0x00A0, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__FLEXCAN2_RX                      = IOMUX_PAD(0x032C, 0x00A0, 2, 0x0588, 0, 0),
+	MX6_PAD_UART2_RTS_B__CSI_DATA09                       = IOMUX_PAD(0x032C, 0x00A0, 3, 0x04E8, 0, 0),
+	MX6_PAD_UART2_RTS_B__GPT1_COMPARE3                    = IOMUX_PAD(0x032C, 0x00A0, 4, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__GPIO1_IO23                       = IOMUX_PAD(0x032C, 0x00A0, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__SJC_FAIL                         = IOMUX_PAD(0x032C, 0x00A0, 7, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__ECSPI3_MISO                      = IOMUX_PAD(0x032C, 0x00A0, 8, 0x0558, 0, 0),
+
+	MX6_PAD_UART3_TX_DATA__UART3_DCE_TX                   = IOMUX_PAD(0x0330, 0x00A4, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_TX_DATA__UART3_DTE_RX                   = IOMUX_PAD(0x0330, 0x00A4, 0, 0x0634, 0, 0),
+	MX6_PAD_UART3_TX_DATA__ENET2_RDATA02                  = IOMUX_PAD(0x0330, 0x00A4, 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__SIM1_PORT0_PD                  = IOMUX_PAD(0x0330, 0x00A4, 2, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__CSI_DATA01                     = IOMUX_PAD(0x0330, 0x00A4, 3, 0x04D4, 0, 0),
+	MX6_PAD_UART3_TX_DATA__UART2_DCE_CTS                  = IOMUX_PAD(0x0330, 0x00A4, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__UART2_DTE_RTS                  = IOMUX_PAD(0x0330, 0x00A4, 4, 0x0628, 2, 0),
+	MX6_PAD_UART3_TX_DATA__GPIO1_IO24                     = IOMUX_PAD(0x0330, 0x00A4, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__SJC_JTAG_ACT                   = IOMUX_PAD(0x0330, 0x00A4, 7, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__ANATOP_OTG1_ID                 = IOMUX_PAD(0x0330, 0x00A4, 8, 0x04B8, 1, 0),
+
+	MX6_PAD_UART3_RX_DATA__UART3_DCE_RX                   = IOMUX_PAD(0x0334, 0x00A8, 0, 0x0634, 1, 0),
+
+	MX6_PAD_UART3_RX_DATA__UART3_DTE_TX                   = IOMUX_PAD(0x0334, 0x00A8, 0, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__ENET2_RDATA03                  = IOMUX_PAD(0x0334, 0x00A8, 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__SIM2_PORT0_PD                  = IOMUX_PAD(0x0334, 0x00A8, 2, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__CSI_DATA00                     = IOMUX_PAD(0x0334, 0x00A8, 3, 0x04D0, 0, 0),
+	MX6_PAD_UART3_RX_DATA__UART2_DCE_RTS                  = IOMUX_PAD(0x0334, 0x00A8, 4, 0x0628, 3, 0),
+	MX6_PAD_UART3_RX_DATA__UART2_DTE_CTS                  = IOMUX_PAD(0x0334, 0x00A8, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__GPIO1_IO25                     = IOMUX_PAD(0x0334, 0x00A8, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__EPIT1_OUT                      = IOMUX_PAD(0x0334, 0x00A8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_CTS_B__UART3_DCE_CTS                    = IOMUX_PAD(0x0338, 0x00AC, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_CTS_B__UART3_DTE_RTS                    = IOMUX_PAD(0x0338, 0x00AC, 0, 0x0630, 0, 0),
+	MX6_PAD_UART3_CTS_B__ENET2_RX_CLK                     = IOMUX_PAD(0x0338, 0x00AC, IOMUX_CONFIG_SION | 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__FLEXCAN1_TX                      = IOMUX_PAD(0x0338, 0x00AC, 2, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__CSI_DATA10                       = IOMUX_PAD(0x0338, 0x00AC, 3, 0x04EC, 0, 0),
+	MX6_PAD_UART3_CTS_B__ENET1_1588_EVENT1_IN             = IOMUX_PAD(0x0338, 0x00AC, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__GPIO1_IO26                       = IOMUX_PAD(0x0338, 0x00AC, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__EPIT2_OUT                        = IOMUX_PAD(0x0338, 0x00AC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_RTS_B__UART3_DCE_RTS                    = IOMUX_PAD(0x033C, 0x00B0, 0, 0x0630, 1, 0),
+
+	MX6_PAD_UART3_RTS_B__UART3_DTE_CTS                    = IOMUX_PAD(0x033C, 0x00B0, 0, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__ENET2_TX_ER                      = IOMUX_PAD(0x033C, 0x00B0, 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__FLEXCAN1_RX                      = IOMUX_PAD(0x033C, 0x00B0, 2, 0x0584, 0, 0),
+	MX6_PAD_UART3_RTS_B__CSI_DATA11                       = IOMUX_PAD(0x033C, 0x00B0, 3, 0x04F0, 0, 0),
+	MX6_PAD_UART3_RTS_B__ENET1_1588_EVENT1_OUT            = IOMUX_PAD(0x033C, 0x00B0, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__GPIO1_IO27                       = IOMUX_PAD(0x033C, 0x00B0, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__WDOG1_WDOG_B                     = IOMUX_PAD(0x033C, 0x00B0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART4_TX_DATA__UART4_DCE_TX                   = IOMUX_PAD(0x0340, 0x00B4, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART4_TX_DATA__UART4_DTE_RX                   = IOMUX_PAD(0x0340, 0x00B4, 0, 0x063C, 0, 0),
+	MX6_PAD_UART4_TX_DATA__ENET2_TDATA02                  = IOMUX_PAD(0x0340, 0x00B4, 1, 0x0000, 0, 0),
+	MX6_PAD_UART4_TX_DATA__I2C1_SCL                       = IOMUX_PAD(0x0340, 0x00B4, IOMUX_CONFIG_SION | 2, 0x05A4, 1, 0),
+	MX6_PAD_UART4_TX_DATA__CSI_DATA12                     = IOMUX_PAD(0x0340, 0x00B4, 3, 0x04F4, 0, 0),
+	MX6_PAD_UART4_TX_DATA__CSU_CSU_ALARM_AUT02            = IOMUX_PAD(0x0340, 0x00B4, 4, 0x0000, 0, 0),
+	MX6_PAD_UART4_TX_DATA__GPIO1_IO28                     = IOMUX_PAD(0x0340, 0x00B4, 5, 0x0000, 0, 0),
+	MX6_PAD_UART4_TX_DATA__ECSPI2_SCLK                    = IOMUX_PAD(0x0340, 0x00B4, 8, 0x0544, 1, 0),
+
+	MX6_PAD_UART4_RX_DATA__UART4_DCE_RX                   = IOMUX_PAD(0x0344, 0x00B8, 0, 0x063C, 1, 0),
+
+	MX6_PAD_UART4_RX_DATA__UART4_DTE_TX                   = IOMUX_PAD(0x0344, 0x00B8, 0, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__ENET2_TDATA03                  = IOMUX_PAD(0x0344, 0x00B8, 1, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__I2C1_SDA                       = IOMUX_PAD(0x0344, 0x00B8, IOMUX_CONFIG_SION | 2, 0x05A8, 2, 0),
+	MX6_PAD_UART4_RX_DATA__CSI_DATA13                     = IOMUX_PAD(0x0344, 0x00B8, 3, 0x04F8, 0, 0),
+	MX6_PAD_UART4_RX_DATA__CSU_CSU_ALARM_AUT01            = IOMUX_PAD(0x0344, 0x00B8, 4, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__GPIO1_IO29                     = IOMUX_PAD(0x0344, 0x00B8, 5, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__ECSPI2_SS0                     = IOMUX_PAD(0x0344, 0x00B8, 8, 0x0550, 1, 0),
+	MX6_PAD_UART5_TX_DATA__GPIO1_IO30                     = IOMUX_PAD(0x0348, 0x00BC, 5, 0x0000, 0, 0),
+	MX6_PAD_UART5_TX_DATA__ECSPI2_MOSI                    = IOMUX_PAD(0x0348, 0x00BC, 8, 0x054C, 0, 0),
+
+	MX6_PAD_UART5_TX_DATA__UART5_DCE_TX                   = IOMUX_PAD(0x0348, 0x00BC, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART5_TX_DATA__UART5_DTE_RX                   = IOMUX_PAD(0x0348, 0x00BC, 0, 0x0644, 4, 0),
+	MX6_PAD_UART5_TX_DATA__ENET2_CRS                      = IOMUX_PAD(0x0348, 0x00BC, 1, 0x0000, 0, 0),
+	MX6_PAD_UART5_TX_DATA__I2C2_SCL                       = IOMUX_PAD(0x0348, 0x00BC, IOMUX_CONFIG_SION | 2, 0x05AC, 2, 0),
+	MX6_PAD_UART5_TX_DATA__CSI_DATA14                     = IOMUX_PAD(0x0348, 0x00BC, 3, 0x04FC, 0, 0),
+	MX6_PAD_UART5_TX_DATA__CSU_CSU_ALARM_AUT00            = IOMUX_PAD(0x0348, 0x00BC, 4, 0x0000, 0, 0),
+
+	MX6_PAD_UART5_RX_DATA__UART5_DCE_RX                   = IOMUX_PAD(0x034C, 0x00C0, 0, 0x0644, 5, 0),
+
+	MX6_PAD_UART5_RX_DATA__UART5_DTE_TX                   = IOMUX_PAD(0x034C, 0x00C0, 0, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__ENET2_COL                      = IOMUX_PAD(0x034C, 0x00C0, 1, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__I2C2_SDA                       = IOMUX_PAD(0x034C, 0x00C0, IOMUX_CONFIG_SION | 2, 0x05B0, 2, 0),
+	MX6_PAD_UART5_RX_DATA__CSI_DATA15                     = IOMUX_PAD(0x034C, 0x00C0, 3, 0x0500, 0, 0),
+	MX6_PAD_UART5_RX_DATA__CSU_CSU_INT_DEB                = IOMUX_PAD(0x034C, 0x00C0, 4, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__GPIO1_IO31                     = IOMUX_PAD(0x034C, 0x00C0, 5, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__ECSPI2_MISO                    = IOMUX_PAD(0x034C, 0x00C0, 8, 0x0548, 1, 0),
+
+	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00                 = IOMUX_PAD(0x0350, 0x00C4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__UART4_DCE_RTS                 = IOMUX_PAD(0x0350, 0x00C4, 1, 0x0638, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__UART4_DTE_CTS                 = IOMUX_PAD(0x0350, 0x00C4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__PWM1_OUT                      = IOMUX_PAD(0x0350, 0x00C4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__CSI_DATA16                    = IOMUX_PAD(0x0350, 0x00C4, 3, 0x0504, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__FLEXCAN1_TX                   = IOMUX_PAD(0x0350, 0x00C4, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__GPIO2_IO00                    = IOMUX_PAD(0x0350, 0x00C4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__KPP_ROW00                     = IOMUX_PAD(0x0350, 0x00C4, 6, 0x05D0, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__USDHC1_LCTL                   = IOMUX_PAD(0x0350, 0x00C4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01                 = IOMUX_PAD(0x0354, 0x00C8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__UART4_DCE_CTS                 = IOMUX_PAD(0x0354, 0x00C8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__UART4_DTE_RTS                 = IOMUX_PAD(0x0354, 0x00C8, 1, 0x0638, 1, 0),
+	MX6_PAD_ENET1_RX_DATA1__PWM2_OUT                      = IOMUX_PAD(0x0354, 0x00C8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__CSI_DATA17                    = IOMUX_PAD(0x0354, 0x00C8, 3, 0x0508, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__FLEXCAN1_RX                   = IOMUX_PAD(0x0354, 0x00C8, 4, 0x0584, 1, 0),
+	MX6_PAD_ENET1_RX_DATA1__GPIO2_IO01                    = IOMUX_PAD(0x0354, 0x00C8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__KPP_COL00                     = IOMUX_PAD(0x0354, 0x00C8, 6, 0x05C4, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__USDHC2_LCTL                   = IOMUX_PAD(0x0354, 0x00C8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN                      = IOMUX_PAD(0x0358, 0x00CC, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__UART5_DCE_RTS                    = IOMUX_PAD(0x0358, 0x00CC, 1, 0x0640, 3, 0),
+	MX6_PAD_ENET1_RX_EN__UART5_DTE_CTS                    = IOMUX_PAD(0x0358, 0x00CC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__CSI_DATA18                       = IOMUX_PAD(0x0358, 0x00CC, 3, 0x050C, 0, 0),
+	MX6_PAD_ENET1_RX_EN__FLEXCAN2_TX                      = IOMUX_PAD(0x0358, 0x00CC, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__GPIO2_IO02                       = IOMUX_PAD(0x0358, 0x00CC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__KPP_ROW01                        = IOMUX_PAD(0x0358, 0x00CC, 6, 0x05D4, 0, 0),
+	MX6_PAD_ENET1_RX_EN__USDHC1_VSELECT                   = IOMUX_PAD(0x0358, 0x00CC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00                 = IOMUX_PAD(0x035C, 0x00D0, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__UART5_DCE_CTS                 = IOMUX_PAD(0x035C, 0x00D0, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__UART5_DTE_RTS                 = IOMUX_PAD(0x035C, 0x00D0, 1, 0x0640, 4, 0),
+	MX6_PAD_ENET1_TX_DATA0__CSI_DATA19                    = IOMUX_PAD(0x035C, 0x00D0, 3, 0x0510, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__FLEXCAN2_RX                   = IOMUX_PAD(0x035C, 0x00D0, 4, 0x0588, 1, 0),
+	MX6_PAD_ENET1_TX_DATA0__GPIO2_IO03                    = IOMUX_PAD(0x035C, 0x00D0, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__KPP_COL01                     = IOMUX_PAD(0x035C, 0x00D0, 6, 0x05C8, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__USDHC2_VSELECT                = IOMUX_PAD(0x035C, 0x00D0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01                 = IOMUX_PAD(0x0360, 0x00D4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__UART6_DCE_CTS                 = IOMUX_PAD(0x0360, 0x00D4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__UART6_DTE_RTS                 = IOMUX_PAD(0x0360, 0x00D4, 1, 0x0648, 2, 0),
+	MX6_PAD_ENET1_TX_DATA1__PWM5_OUT                      = IOMUX_PAD(0x0360, 0x00D4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__CSI_DATA20                    = IOMUX_PAD(0x0360, 0x00D4, 3, 0x0514, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__ENET2_MDIO                    = IOMUX_PAD(0x0360, 0x00D4, 4, 0x0580, 1, 0),
+	MX6_PAD_ENET1_TX_DATA1__GPIO2_IO04                    = IOMUX_PAD(0x0360, 0x00D4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__KPP_ROW02                     = IOMUX_PAD(0x0360, 0x00D4, 6, 0x05D8, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__WDOG1_WDOG_RST_B_DEB          = IOMUX_PAD(0x0360, 0x00D4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN                      = IOMUX_PAD(0x0364, 0x00D8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__UART6_DCE_RTS                    = IOMUX_PAD(0x0364, 0x00D8, 1, 0x0648, 3, 0),
+	MX6_PAD_ENET1_TX_EN__UART6_DTE_CTS                    = IOMUX_PAD(0x0364, 0x00D8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__PWM6_OUT                         = IOMUX_PAD(0x0364, 0x00D8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__CSI_DATA21                       = IOMUX_PAD(0x0364, 0x00D8, 3, 0x0518, 0, 0),
+	MX6_PAD_ENET1_TX_EN__ENET2_MDC                        = IOMUX_PAD(0x0364, 0x00D8, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__GPIO2_IO05                       = IOMUX_PAD(0x0364, 0x00D8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__KPP_COL02                        = IOMUX_PAD(0x0364, 0x00D8, 6, 0x05CC, 0, 0),
+	MX6_PAD_ENET1_TX_EN__WDOG2_WDOG_RST_B_DEB             = IOMUX_PAD(0x0364, 0x00D8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_CLK__ENET1_TX_CLK                    = IOMUX_PAD(0x0368, 0x00DC, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__UART7_DCE_CTS                   = IOMUX_PAD(0x0368, 0x00DC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__UART7_DTE_RTS                   = IOMUX_PAD(0x0368, 0x00DC, 1, 0x0650, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__PWM7_OUT                        = IOMUX_PAD(0x0368, 0x00DC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__CSI_DATA22                      = IOMUX_PAD(0x0368, 0x00DC, 3, 0x051C, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1                  = IOMUX_PAD(0x0368, 0x00DC, IOMUX_CONFIG_SION | 4, 0x0574, 2, 0),
+	MX6_PAD_ENET1_TX_CLK__GPIO2_IO06                      = IOMUX_PAD(0x0368, 0x00DC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__KPP_ROW03                       = IOMUX_PAD(0x0368, 0x00DC, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__GPT1_CLK                        = IOMUX_PAD(0x0368, 0x00DC, 8, 0x0594, 1, 0),
+
+	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER                      = IOMUX_PAD(0x036C, 0x00E0, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__UART7_DCE_RTS                    = IOMUX_PAD(0x036C, 0x00E0, 1, 0x0650, 1, 0),
+	MX6_PAD_ENET1_RX_ER__UART7_DTE_CTS                    = IOMUX_PAD(0x036C, 0x00E0, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__PWM8_OUT                         = IOMUX_PAD(0x036C, 0x00E0, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__CSI_DATA23                       = IOMUX_PAD(0x036C, 0x00E0, 3, 0x0520, 0, 0),
+	MX6_PAD_ENET1_RX_ER__EIM_CRE                          = IOMUX_PAD(0x036C, 0x00E0, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__GPIO2_IO07                       = IOMUX_PAD(0x036C, 0x00E0, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__KPP_COL03                        = IOMUX_PAD(0x036C, 0x00E0, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__GPT1_CAPTURE2                    = IOMUX_PAD(0x036C, 0x00E0, 8, 0x0590, 1, 0),
+
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00                 = IOMUX_PAD(0x0370, 0x00E4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__UART6_DCE_TX                  = IOMUX_PAD(0x0370, 0x00E4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__UART6_DTE_RX                  = IOMUX_PAD(0x0370, 0x00E4, 1, 0x064C, 1, 0),
+	MX6_PAD_ENET2_RX_DATA0__SIM1_PORT0_TRXD               = IOMUX_PAD(0x0370, 0x00E4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__I2C3_SCL                      = IOMUX_PAD(0x0370, 0x00E4, IOMUX_CONFIG_SION | 3, 0x05B4, 1, 0),
+	MX6_PAD_ENET2_RX_DATA0__ENET1_MDIO                    = IOMUX_PAD(0x0370, 0x00E4, 4, 0x0578, 1, 0),
+	MX6_PAD_ENET2_RX_DATA0__GPIO2_IO08                    = IOMUX_PAD(0x0370, 0x00E4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__KPP_ROW04                     = IOMUX_PAD(0x0370, 0x00E4, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__USB_OTG1_PWR                  = IOMUX_PAD(0x0370, 0x00E4, 8, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__EPDC_SDDO08                   = IOMUX_PAD(0x0370, 0x00E4, 9, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01                 = IOMUX_PAD(0x0374, 0x00E8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__UART6_DCE_RX                  = IOMUX_PAD(0x0374, 0x00E8, 1, 0x064C, 2, 0),
+	MX6_PAD_ENET2_RX_DATA1__UART6_DTE_TX                  = IOMUX_PAD(0x0374, 0x00E8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__SIM1_PORT0_CLK                = IOMUX_PAD(0x0374, 0x00E8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__I2C3_SDA                      = IOMUX_PAD(0x0374, 0x00E8, IOMUX_CONFIG_SION | 3, 0x05B8, 1, 0),
+	MX6_PAD_ENET2_RX_DATA1__ENET1_MDC                     = IOMUX_PAD(0x0374, 0x00E8, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__GPIO2_IO09                    = IOMUX_PAD(0x0374, 0x00E8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__KPP_COL04                     = IOMUX_PAD(0x0374, 0x00E8, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__USB_OTG1_OC                   = IOMUX_PAD(0x0374, 0x00E8, 8, 0x0664, 1, 0),
+	MX6_PAD_ENET2_RX_DATA1__EPDC_SDDO09                   = IOMUX_PAD(0x0374, 0x00E8, 9, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN                      = IOMUX_PAD(0x0378, 0x00EC, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__UART7_DCE_TX                     = IOMUX_PAD(0x0378, 0x00EC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__UART7_DTE_RX                     = IOMUX_PAD(0x0378, 0x00EC, 1, 0x0654, 0, 0),
+	MX6_PAD_ENET2_RX_EN__SIM1_PORT0_RST_B                 = IOMUX_PAD(0x0378, 0x00EC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__I2C4_SCL                         = IOMUX_PAD(0x0378, 0x00EC, IOMUX_CONFIG_SION | 3, 0x05BC, 1, 0),
+	MX6_PAD_ENET2_RX_EN__EIM_ADDR26                       = IOMUX_PAD(0x0378, 0x00EC, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__GPIO2_IO10                       = IOMUX_PAD(0x0378, 0x00EC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__KPP_ROW05                        = IOMUX_PAD(0x0378, 0x00EC, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__ENET1_REF_CLK_25M                = IOMUX_PAD(0x0378, 0x00EC, 8, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__EPDC_SDDO10                      = IOMUX_PAD(0x0378, 0x00EC, 9, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00                 = IOMUX_PAD(0x037C, 0x00F0, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__UART7_DCE_RX                  = IOMUX_PAD(0x037C, 0x00F0, 1, 0x0654, 1, 0),
+	MX6_PAD_ENET2_TX_DATA0__UART7_DTE_TX                  = IOMUX_PAD(0x037C, 0x00F0, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__SIM1_PORT0_SVEN               = IOMUX_PAD(0x037C, 0x00F0, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__I2C4_SDA                      = IOMUX_PAD(0x037C, 0x00F0, IOMUX_CONFIG_SION | 3, 0x05C0, 1, 0),
+	MX6_PAD_ENET2_TX_DATA0__EIM_EB_B02                    = IOMUX_PAD(0x037C, 0x00F0, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__GPIO2_IO11                    = IOMUX_PAD(0x037C, 0x00F0, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__KPP_COL05                     = IOMUX_PAD(0x037C, 0x00F0, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__EPDC_SDDO11                   = IOMUX_PAD(0x037C, 0x00F0, 9, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01                 = IOMUX_PAD(0x0380, 0x00F4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__UART8_DCE_TX                  = IOMUX_PAD(0x0380, 0x00F4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__UART8_DTE_RX                  = IOMUX_PAD(0x0380, 0x00F4, 1, 0x065C, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__SIM2_PORT0_TRXD               = IOMUX_PAD(0x0380, 0x00F4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__ECSPI4_SCLK                   = IOMUX_PAD(0x0380, 0x00F4, 3, 0x0564, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__EIM_EB_B03                    = IOMUX_PAD(0x0380, 0x00F4, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__GPIO2_IO12                    = IOMUX_PAD(0x0380, 0x00F4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__KPP_ROW06                     = IOMUX_PAD(0x0380, 0x00F4, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__USB_OTG2_PWR                  = IOMUX_PAD(0x0380, 0x00F4, 8, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__EPDC_SDDO12                   = IOMUX_PAD(0x0380, 0x00F4, 9, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN                      = IOMUX_PAD(0x0384, 0x00F8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__UART8_DCE_RX                     = IOMUX_PAD(0x0384, 0x00F8, 1, 0x065C, 1, 0),
+	MX6_PAD_ENET2_TX_EN__UART8_DTE_TX                     = IOMUX_PAD(0x0384, 0x00F8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__SIM2_PORT0_CLK                   = IOMUX_PAD(0x0384, 0x00F8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__ECSPI4_MOSI                      = IOMUX_PAD(0x0384, 0x00F8, 3, 0x056C, 0, 0),
+	MX6_PAD_ENET2_TX_EN__EIM_ACLK_FREERUN                 = IOMUX_PAD(0x0384, 0x00F8, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__GPIO2_IO13                       = IOMUX_PAD(0x0384, 0x00F8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__KPP_COL06                        = IOMUX_PAD(0x0384, 0x00F8, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__USB_OTG2_OC                      = IOMUX_PAD(0x0384, 0x00F8, 8, 0x0660, 1, 0),
+	MX6_PAD_ENET2_TX_EN__EPDC_SDDO13                      = IOMUX_PAD(0x0384, 0x00F8, 9, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_CLK__ENET2_TX_CLK                    = IOMUX_PAD(0x0388, 0x00FC, IOMUX_CONFIG_SION | 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__UART8_DCE_CTS                   = IOMUX_PAD(0x0388, 0x00FC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__UART8_DTE_RTS                   = IOMUX_PAD(0x0388, 0x00FC, 1, 0x0658, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__SIM2_PORT0_RST_B                = IOMUX_PAD(0x0388, 0x00FC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__ECSPI4_MISO                     = IOMUX_PAD(0x0388, 0x00FC, 3, 0x0568, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2                  = IOMUX_PAD(0x0388, 0x00FC, IOMUX_CONFIG_SION | 4, 0x057C, 2, 0),
+	MX6_PAD_ENET2_TX_CLK__GPIO2_IO14                      = IOMUX_PAD(0x0388, 0x00FC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__KPP_ROW07                       = IOMUX_PAD(0x0388, 0x00FC, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__ANATOP_OTG2_ID                  = IOMUX_PAD(0x0388, 0x00FC, 8, 0x04BC, 1, 0),
+	MX6_PAD_ENET2_TX_CLK__EPDC_SDDO14                     = IOMUX_PAD(0x0388, 0x00FC, 9, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER                      = IOMUX_PAD(0x038C, 0x0100, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__UART8_DCE_RTS                    = IOMUX_PAD(0x038C, 0x0100, 1, 0x0658, 1, 0),
+	MX6_PAD_ENET2_RX_ER__UART8_DTE_CTS                    = IOMUX_PAD(0x038C, 0x0100, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__SIM2_PORT0_SVEN                  = IOMUX_PAD(0x038C, 0x0100, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__ECSPI4_SS0                       = IOMUX_PAD(0x038C, 0x0100, 3, 0x0570, 0, 0),
+	MX6_PAD_ENET2_RX_ER__EIM_ADDR25                       = IOMUX_PAD(0x038C, 0x0100, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__GPIO2_IO15                       = IOMUX_PAD(0x038C, 0x0100, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__KPP_COL07                        = IOMUX_PAD(0x038C, 0x0100, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__WDOG1_WDOG_ANY                   = IOMUX_PAD(0x038C, 0x0100, 8, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__EPDC_SDDO15                      = IOMUX_PAD(0x038C, 0x0100, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_CLK__LCDIF_CLK                            = IOMUX_PAD(0x0390, 0x0104, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__LCDIF_WR_RWN                         = IOMUX_PAD(0x0390, 0x0104, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__UART4_DCE_TX                         = IOMUX_PAD(0x0390, 0x0104, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__UART4_DTE_RX                         = IOMUX_PAD(0x0390, 0x0104, 2, 0x063C, 2, 0),
+	MX6_PAD_LCD_CLK__SAI3_MCLK                            = IOMUX_PAD(0x0390, 0x0104, 3, 0x0600, 0, 0),
+	MX6_PAD_LCD_CLK__EIM_CS2_B                            = IOMUX_PAD(0x0390, 0x0104, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__GPIO3_IO00                           = IOMUX_PAD(0x0390, 0x0104, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__WDOG1_WDOG_RST_B_DEB                 = IOMUX_PAD(0x0390, 0x0104, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__EPDC_SDCLK                           = IOMUX_PAD(0x0390, 0x0104, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE                      = IOMUX_PAD(0x0394, 0x0108, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__LCDIF_RD_E                        = IOMUX_PAD(0x0394, 0x0108, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__UART4_DCE_RX                      = IOMUX_PAD(0x0394, 0x0108, 2, 0x063C, 3, 0),
+	MX6_PAD_LCD_ENABLE__UART4_DTE_TX                      = IOMUX_PAD(0x0394, 0x0108, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__SAI3_TX_SYNC                      = IOMUX_PAD(0x0394, 0x0108, 3, 0x060C, 0, 0),
+	MX6_PAD_LCD_ENABLE__EIM_CS3_B                         = IOMUX_PAD(0x0394, 0x0108, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__GPIO3_IO01                        = IOMUX_PAD(0x0394, 0x0108, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__ECSPI2_RDY                        = IOMUX_PAD(0x0394, 0x0108, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__EPDC_SDLE                         = IOMUX_PAD(0x0394, 0x0108, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC                        = IOMUX_PAD(0x0398, 0x010C, 0, 0x05DC, 0, 0),
+	MX6_PAD_LCD_HSYNC__LCDIF_RS                           = IOMUX_PAD(0x0398, 0x010C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__UART4_DCE_CTS                      = IOMUX_PAD(0x0398, 0x010C, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__UART4_DTE_RTS                      = IOMUX_PAD(0x0398, 0x010C, 2, 0x0638, 2, 0),
+	MX6_PAD_LCD_HSYNC__SAI3_TX_BCLK                       = IOMUX_PAD(0x0398, 0x010C, 3, 0x0608, 0, 0),
+	MX6_PAD_LCD_HSYNC__WDOG3_WDOG_RST_B_DEB               = IOMUX_PAD(0x0398, 0x010C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__GPIO3_IO02                         = IOMUX_PAD(0x0398, 0x010C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__ECSPI2_SS1                         = IOMUX_PAD(0x0398, 0x010C, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__EPDC_SDOE                          = IOMUX_PAD(0x0398, 0x010C, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC                        = IOMUX_PAD(0x039C, 0x0110, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__LCDIF_BUSY                         = IOMUX_PAD(0x039C, 0x0110, 1, 0x05DC, 1, 0),
+	MX6_PAD_LCD_VSYNC__UART4_DCE_RTS                      = IOMUX_PAD(0x039C, 0x0110, 2, 0x0638, 3, 0),
+	MX6_PAD_LCD_VSYNC__UART4_DTE_CTS                      = IOMUX_PAD(0x039C, 0x0110, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__SAI3_RX_DATA                       = IOMUX_PAD(0x039C, 0x0110, 3, 0x0604, 0, 0),
+	MX6_PAD_LCD_VSYNC__WDOG2_WDOG_B                       = IOMUX_PAD(0x039C, 0x0110, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__GPIO3_IO03                         = IOMUX_PAD(0x039C, 0x0110, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__ECSPI2_SS2                         = IOMUX_PAD(0x039C, 0x0110, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__EPDC_SDCE0                         = IOMUX_PAD(0x039C, 0x0110, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_RESET__LCDIF_RESET                        = IOMUX_PAD(0x03A0, 0x0114, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__LCDIF_CS                           = IOMUX_PAD(0x03A0, 0x0114, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__CA7_MX6ULL_EVENTI                  = IOMUX_PAD(0x03A0, 0x0114, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__SAI3_TX_DATA                       = IOMUX_PAD(0x03A0, 0x0114, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__WDOG1_WDOG_ANY                     = IOMUX_PAD(0x03A0, 0x0114, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__GPIO3_IO04                         = IOMUX_PAD(0x03A0, 0x0114, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__ECSPI2_SS3                         = IOMUX_PAD(0x03A0, 0x0114, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__EPDC_GDOE                          = IOMUX_PAD(0x03A0, 0x0114, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00                      = IOMUX_PAD(0x03A4, 0x0118, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__PWM1_OUT                          = IOMUX_PAD(0x03A4, 0x0118, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__ENET1_1588_EVENT2_IN              = IOMUX_PAD(0x03A4, 0x0118, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__I2C3_SDA                          = IOMUX_PAD(0x03A4, 0x0118, IOMUX_CONFIG_SION | 4, 0x05B8, 2, 0),
+	MX6_PAD_LCD_DATA00__GPIO3_IO05                        = IOMUX_PAD(0x03A4, 0x0118, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__SRC_BT_CFG00                      = IOMUX_PAD(0x03A4, 0x0118, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__SAI1_MCLK                         = IOMUX_PAD(0x03A4, 0x0118, 8, 0x05E0, 1, 0),
+	MX6_PAD_LCD_DATA00__EPDC_SDDO00                       = IOMUX_PAD(0x03A4, 0x0118, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01                      = IOMUX_PAD(0x03A8, 0x011C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__PWM2_OUT                          = IOMUX_PAD(0x03A8, 0x011C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__ENET1_1588_EVENT2_OUT             = IOMUX_PAD(0x03A8, 0x011C, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__I2C3_SCL                          = IOMUX_PAD(0x03A8, 0x011C, IOMUX_CONFIG_SION | 4, 0x05B4, 2, 0),
+	MX6_PAD_LCD_DATA01__GPIO3_IO06                        = IOMUX_PAD(0x03A8, 0x011C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__SRC_BT_CFG01                      = IOMUX_PAD(0x03A8, 0x011C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__SAI1_TX_SYNC                      = IOMUX_PAD(0x03A8, 0x011C, 8, 0x05EC, 0, 0),
+	MX6_PAD_LCD_DATA01__EPDC_SDDO01                       = IOMUX_PAD(0x03A8, 0x011C, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02                      = IOMUX_PAD(0x03AC, 0x0120, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__PWM3_OUT                          = IOMUX_PAD(0x03AC, 0x0120, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__ENET1_1588_EVENT3_IN              = IOMUX_PAD(0x03AC, 0x0120, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__I2C4_SDA                          = IOMUX_PAD(0x03AC, 0x0120, IOMUX_CONFIG_SION | 4, 0x05C0, 2, 0),
+	MX6_PAD_LCD_DATA02__GPIO3_IO07                        = IOMUX_PAD(0x03AC, 0x0120, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__SRC_BT_CFG02                      = IOMUX_PAD(0x03AC, 0x0120, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__SAI1_TX_BCLK                      = IOMUX_PAD(0x03AC, 0x0120, 8, 0x05E8, 0, 0),
+	MX6_PAD_LCD_DATA02__EPDC_SDDO02                       = IOMUX_PAD(0x03AC, 0x0120, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03                      = IOMUX_PAD(0x03B0, 0x0124, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__PWM4_OUT                          = IOMUX_PAD(0x03B0, 0x0124, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__ENET1_1588_EVENT3_OUT             = IOMUX_PAD(0x03B0, 0x0124, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__I2C4_SCL                          = IOMUX_PAD(0x03B0, 0x0124, IOMUX_CONFIG_SION | 4, 0x05BC, 2, 0),
+	MX6_PAD_LCD_DATA03__GPIO3_IO08                        = IOMUX_PAD(0x03B0, 0x0124, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__SRC_BT_CFG03                      = IOMUX_PAD(0x03B0, 0x0124, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__SAI1_RX_DATA                      = IOMUX_PAD(0x03B0, 0x0124, 8, 0x05E4, 0, 0),
+	MX6_PAD_LCD_DATA03__EPDC_SDDO03                       = IOMUX_PAD(0x03B0, 0x0124, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04                      = IOMUX_PAD(0x03B4, 0x0128, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__UART8_DCE_CTS                     = IOMUX_PAD(0x03B4, 0x0128, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__UART8_DTE_RTS                     = IOMUX_PAD(0x03B4, 0x0128, 1, 0x0658, 2, 0),
+	MX6_PAD_LCD_DATA04__ENET2_1588_EVENT2_IN              = IOMUX_PAD(0x03B4, 0x0128, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SPDIF_SR_CLK                      = IOMUX_PAD(0x03B4, 0x0128, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__GPIO3_IO09                        = IOMUX_PAD(0x03B4, 0x0128, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SRC_BT_CFG04                      = IOMUX_PAD(0x03B4, 0x0128, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SAI1_TX_DATA                      = IOMUX_PAD(0x03B4, 0x0128, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__EPDC_SDDO04                       = IOMUX_PAD(0x03B4, 0x0128, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05                      = IOMUX_PAD(0x03B8, 0x012C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__UART8_DCE_RTS                     = IOMUX_PAD(0x03B8, 0x012C, 1, 0x0658, 3, 0),
+	MX6_PAD_LCD_DATA05__UART8_DTE_CTS                     = IOMUX_PAD(0x03B8, 0x012C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__ENET2_1588_EVENT2_OUT             = IOMUX_PAD(0x03B8, 0x012C, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__SPDIF_OUT                         = IOMUX_PAD(0x03B8, 0x012C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__GPIO3_IO10                        = IOMUX_PAD(0x03B8, 0x012C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__SRC_BT_CFG05                      = IOMUX_PAD(0x03B8, 0x012C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__ECSPI1_SS1                        = IOMUX_PAD(0x03B8, 0x012C, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__EPDC_SDDO05                       = IOMUX_PAD(0x03B8, 0x012C, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06                      = IOMUX_PAD(0x03BC, 0x0130, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__UART7_DCE_CTS                     = IOMUX_PAD(0x03BC, 0x0130, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__UART7_DTE_RTS                     = IOMUX_PAD(0x03BC, 0x0130, 1, 0x0650, 2, 0),
+	MX6_PAD_LCD_DATA06__ENET2_1588_EVENT3_IN              = IOMUX_PAD(0x03BC, 0x0130, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__SPDIF_LOCK                        = IOMUX_PAD(0x03BC, 0x0130, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__GPIO3_IO11                        = IOMUX_PAD(0x03BC, 0x0130, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__SRC_BT_CFG06                      = IOMUX_PAD(0x03BC, 0x0130, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__ECSPI1_SS2                        = IOMUX_PAD(0x03BC, 0x0130, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__EPDC_SDDO06                       = IOMUX_PAD(0x03BC, 0x0130, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07                      = IOMUX_PAD(0x03C0, 0x0134, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__UART7_DCE_RTS                     = IOMUX_PAD(0x03C0, 0x0134, 1, 0x0650, 3, 0),
+	MX6_PAD_LCD_DATA07__UART7_DTE_CTS                     = IOMUX_PAD(0x03C0, 0x0134, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__ENET2_1588_EVENT3_OUT             = IOMUX_PAD(0x03C0, 0x0134, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__SPDIF_EXT_CLK                     = IOMUX_PAD(0x03C0, 0x0134, 4, 0x061C, 0, 0),
+	MX6_PAD_LCD_DATA07__GPIO3_IO12                        = IOMUX_PAD(0x03C0, 0x0134, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__SRC_BT_CFG07                      = IOMUX_PAD(0x03C0, 0x0134, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__ECSPI1_SS3                        = IOMUX_PAD(0x03C0, 0x0134, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__EPDC_SDDO07                       = IOMUX_PAD(0x03C0, 0x0134, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08                      = IOMUX_PAD(0x03C4, 0x0138, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__SPDIF_IN                          = IOMUX_PAD(0x03C4, 0x0138, 1, 0x0618, 2, 0),
+	MX6_PAD_LCD_DATA08__CSI_DATA16                        = IOMUX_PAD(0x03C4, 0x0138, 3, 0x0504, 1, 0),
+	MX6_PAD_LCD_DATA08__EIM_DATA00                        = IOMUX_PAD(0x03C4, 0x0138, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__GPIO3_IO13                        = IOMUX_PAD(0x03C4, 0x0138, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__SRC_BT_CFG08                      = IOMUX_PAD(0x03C4, 0x0138, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__FLEXCAN1_TX                       = IOMUX_PAD(0x03C4, 0x0138, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09                      = IOMUX_PAD(0x03C8, 0x013C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__SAI3_MCLK                         = IOMUX_PAD(0x03C8, 0x013C, 1, 0x0600, 1, 0),
+	MX6_PAD_LCD_DATA09__CSI_DATA17                        = IOMUX_PAD(0x03C8, 0x013C, 3, 0x0508, 1, 0),
+	MX6_PAD_LCD_DATA09__EIM_DATA01                        = IOMUX_PAD(0x03C8, 0x013C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__GPIO3_IO14                        = IOMUX_PAD(0x03C8, 0x013C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__SRC_BT_CFG09                      = IOMUX_PAD(0x03C8, 0x013C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__FLEXCAN1_RX                       = IOMUX_PAD(0x03C8, 0x013C, 8, 0x0584, 2, 0),
+
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10                      = IOMUX_PAD(0x03CC, 0x0140, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__SAI3_RX_SYNC                      = IOMUX_PAD(0x03CC, 0x0140, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__CSI_DATA18                        = IOMUX_PAD(0x03CC, 0x0140, 3, 0x050C, 1, 0),
+	MX6_PAD_LCD_DATA10__EIM_DATA02                        = IOMUX_PAD(0x03CC, 0x0140, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__GPIO3_IO15                        = IOMUX_PAD(0x03CC, 0x0140, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__SRC_BT_CFG10                      = IOMUX_PAD(0x03CC, 0x0140, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__FLEXCAN2_TX                       = IOMUX_PAD(0x03CC, 0x0140, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11                      = IOMUX_PAD(0x03D0, 0x0144, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__SAI3_RX_BCLK                      = IOMUX_PAD(0x03D0, 0x0144, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__CSI_DATA19                        = IOMUX_PAD(0x03D0, 0x0144, 3, 0x0510, 1, 0),
+	MX6_PAD_LCD_DATA11__EIM_DATA03                        = IOMUX_PAD(0x03D0, 0x0144, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__GPIO3_IO16                        = IOMUX_PAD(0x03D0, 0x0144, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__SRC_BT_CFG11                      = IOMUX_PAD(0x03D0, 0x0144, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__FLEXCAN2_RX                       = IOMUX_PAD(0x03D0, 0x0144, 8, 0x0588, 2, 0),
+
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12                      = IOMUX_PAD(0x03D4, 0x0148, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__SAI3_TX_SYNC                      = IOMUX_PAD(0x03D4, 0x0148, 1, 0x060C, 1, 0),
+	MX6_PAD_LCD_DATA12__CSI_DATA20                        = IOMUX_PAD(0x03D4, 0x0148, 3, 0x0514, 1, 0),
+	MX6_PAD_LCD_DATA12__EIM_DATA04                        = IOMUX_PAD(0x03D4, 0x0148, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__GPIO3_IO17                        = IOMUX_PAD(0x03D4, 0x0148, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__SRC_BT_CFG12                      = IOMUX_PAD(0x03D4, 0x0148, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__ECSPI1_RDY                        = IOMUX_PAD(0x03D4, 0x0148, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13                      = IOMUX_PAD(0x03D8, 0x014C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__SAI3_TX_BCLK                      = IOMUX_PAD(0x03D8, 0x014C, 1, 0x0608, 1, 0),
+	MX6_PAD_LCD_DATA13__CSI_DATA21                        = IOMUX_PAD(0x03D8, 0x014C, 3, 0x0518, 1, 0),
+	MX6_PAD_LCD_DATA13__EIM_DATA05                        = IOMUX_PAD(0x03D8, 0x014C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__GPIO3_IO18                        = IOMUX_PAD(0x03D8, 0x014C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__SRC_BT_CFG13                      = IOMUX_PAD(0x03D8, 0x014C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__USDHC2_RESET_B                    = IOMUX_PAD(0x03D8, 0x014C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14                      = IOMUX_PAD(0x03DC, 0x0150, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__SAI3_RX_DATA                      = IOMUX_PAD(0x03DC, 0x0150, 1, 0x0604, 1, 0),
+	MX6_PAD_LCD_DATA14__CSI_DATA22                        = IOMUX_PAD(0x03DC, 0x0150, 3, 0x051C, 1, 0),
+	MX6_PAD_LCD_DATA14__EIM_DATA06                        = IOMUX_PAD(0x03DC, 0x0150, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__GPIO3_IO19                        = IOMUX_PAD(0x03DC, 0x0150, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__SRC_BT_CFG14                      = IOMUX_PAD(0x03DC, 0x0150, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__USDHC2_DATA4                      = IOMUX_PAD(0x03DC, 0x0150, 8, 0x068C, 0, 0),
+	MX6_PAD_LCD_DATA14__EPDC_SDSHR                        = IOMUX_PAD(0x03DC, 0x0150, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15                      = IOMUX_PAD(0x03E0, 0x0154, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__SAI3_TX_DATA                      = IOMUX_PAD(0x03E0, 0x0154, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__CSI_DATA23                        = IOMUX_PAD(0x03E0, 0x0154, 3, 0x0520, 1, 0),
+	MX6_PAD_LCD_DATA15__EIM_DATA07                        = IOMUX_PAD(0x03E0, 0x0154, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__GPIO3_IO20                        = IOMUX_PAD(0x03E0, 0x0154, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__SRC_BT_CFG15                      = IOMUX_PAD(0x03E0, 0x0154, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__USDHC2_DATA5                      = IOMUX_PAD(0x03E0, 0x0154, 8, 0x0690, 0, 0),
+	MX6_PAD_LCD_DATA15__EPDC_GDRL                         = IOMUX_PAD(0x03E0, 0x0154, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA16__LCDIF_DATA16                      = IOMUX_PAD(0x03E4, 0x0158, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__UART7_DCE_TX                      = IOMUX_PAD(0x03E4, 0x0158, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__UART7_DTE_RX                      = IOMUX_PAD(0x03E4, 0x0158, 1, 0x0654, 2, 0),
+	MX6_PAD_LCD_DATA16__CSI_DATA01                        = IOMUX_PAD(0x03E4, 0x0158, 3, 0x04D4, 1, 0),
+	MX6_PAD_LCD_DATA16__EIM_DATA08                        = IOMUX_PAD(0x03E4, 0x0158, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__GPIO3_IO21                        = IOMUX_PAD(0x03E4, 0x0158, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__SRC_BT_CFG24                      = IOMUX_PAD(0x03E4, 0x0158, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__USDHC2_DATA6                      = IOMUX_PAD(0x03E4, 0x0158, 8, 0x0694, 0, 0),
+	MX6_PAD_LCD_DATA16__EPDC_GDCLK                        = IOMUX_PAD(0x03E4, 0x0158, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA17__LCDIF_DATA17                      = IOMUX_PAD(0x03E8, 0x015C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__UART7_DCE_RX                      = IOMUX_PAD(0x03E8, 0x015C, 1, 0x0654, 3, 0),
+	MX6_PAD_LCD_DATA17__UART7_DTE_TX                      = IOMUX_PAD(0x03E8, 0x015C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__CSI_DATA00                        = IOMUX_PAD(0x03E8, 0x015C, 3, 0x04D0, 1, 0),
+	MX6_PAD_LCD_DATA17__EIM_DATA09                        = IOMUX_PAD(0x03E8, 0x015C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__GPIO3_IO22                        = IOMUX_PAD(0x03E8, 0x015C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__SRC_BT_CFG25                      = IOMUX_PAD(0x03E8, 0x015C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__USDHC2_DATA7                      = IOMUX_PAD(0x03E8, 0x015C, 8, 0x0698, 0, 0),
+	MX6_PAD_LCD_DATA17__EPDC_GDSP                         = IOMUX_PAD(0x03E8, 0x015C, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA18__LCDIF_DATA18                      = IOMUX_PAD(0x03EC, 0x0160, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__PWM5_OUT                          = IOMUX_PAD(0x03EC, 0x0160, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__CA7_MX6ULL_EVENTO                 = IOMUX_PAD(0x03EC, 0x0160, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__CSI_DATA10                        = IOMUX_PAD(0x03EC, 0x0160, 3, 0x04EC, 1, 0),
+	MX6_PAD_LCD_DATA18__EIM_DATA10                        = IOMUX_PAD(0x03EC, 0x0160, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__GPIO3_IO23                        = IOMUX_PAD(0x03EC, 0x0160, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__SRC_BT_CFG26                      = IOMUX_PAD(0x03EC, 0x0160, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__USDHC2_CMD                        = IOMUX_PAD(0x03EC, 0x0160, 8, 0x0678, 1, 0),
+	MX6_PAD_LCD_DATA19__EIM_DATA11                        = IOMUX_PAD(0x03F0, 0x0164, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__GPIO3_IO24                        = IOMUX_PAD(0x03F0, 0x0164, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__SRC_BT_CFG27                      = IOMUX_PAD(0x03F0, 0x0164, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__USDHC2_CLK                        = IOMUX_PAD(0x03F0, 0x0164, 8, 0x0670, 1, 0),
+
+	MX6_PAD_LCD_DATA19__LCDIF_DATA19                      = IOMUX_PAD(0x03F0, 0x0164, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__PWM6_OUT                          = IOMUX_PAD(0x03F0, 0x0164, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__WDOG1_WDOG_ANY                    = IOMUX_PAD(0x03F0, 0x0164, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__CSI_DATA11                        = IOMUX_PAD(0x03F0, 0x0164, 3, 0x04F0, 1, 0),
+	MX6_PAD_LCD_DATA20__EIM_DATA12                        = IOMUX_PAD(0x03F4, 0x0168, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__GPIO3_IO25                        = IOMUX_PAD(0x03F4, 0x0168, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__SRC_BT_CFG28                      = IOMUX_PAD(0x03F4, 0x0168, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__USDHC2_DATA0                      = IOMUX_PAD(0x03F4, 0x0168, 8, 0x067C, 1, 0),
+
+	MX6_PAD_LCD_DATA20__LCDIF_DATA20                      = IOMUX_PAD(0x03F4, 0x0168, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__UART8_DCE_TX                      = IOMUX_PAD(0x03F4, 0x0168, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__UART8_DTE_RX                      = IOMUX_PAD(0x03F4, 0x0168, 1, 0x065C, 2, 0),
+	MX6_PAD_LCD_DATA20__ECSPI1_SCLK                       = IOMUX_PAD(0x03F4, 0x0168, 2, 0x0534, 0, 0),
+	MX6_PAD_LCD_DATA20__CSI_DATA12                        = IOMUX_PAD(0x03F4, 0x0168, 3, 0x04F4, 1, 0),
+
+	MX6_PAD_LCD_DATA21__LCDIF_DATA21                      = IOMUX_PAD(0x03F8, 0x016C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__UART8_DCE_RX                      = IOMUX_PAD(0x03F8, 0x016C, 1, 0x065C, 3, 0),
+	MX6_PAD_LCD_DATA21__UART8_DTE_TX                      = IOMUX_PAD(0x03F8, 0x016C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__ECSPI1_SS0                        = IOMUX_PAD(0x03F8, 0x016C, 2, 0x0540, 0, 0),
+	MX6_PAD_LCD_DATA21__CSI_DATA13                        = IOMUX_PAD(0x03F8, 0x016C, 3, 0x04F8, 1, 0),
+	MX6_PAD_LCD_DATA21__EIM_DATA13                        = IOMUX_PAD(0x03F8, 0x016C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__GPIO3_IO26                        = IOMUX_PAD(0x03F8, 0x016C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__SRC_BT_CFG29                      = IOMUX_PAD(0x03F8, 0x016C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__USDHC2_DATA1                      = IOMUX_PAD(0x03F8, 0x016C, 8, 0x0680, 1, 0),
+	MX6_PAD_LCD_DATA21__EPDC_SDCE1                        = IOMUX_PAD(0x03F8, 0x016C, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA22__LCDIF_DATA22                      = IOMUX_PAD(0x03FC, 0x0170, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__MQS_RIGHT                         = IOMUX_PAD(0x03FC, 0x0170, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__ECSPI1_MOSI                       = IOMUX_PAD(0x03FC, 0x0170, 2, 0x053C, 0, 0),
+	MX6_PAD_LCD_DATA22__CSI_DATA14                        = IOMUX_PAD(0x03FC, 0x0170, 3, 0x04FC, 1, 0),
+	MX6_PAD_LCD_DATA22__EIM_DATA14                        = IOMUX_PAD(0x03FC, 0x0170, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__GPIO3_IO27                        = IOMUX_PAD(0x03FC, 0x0170, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__SRC_BT_CFG30                      = IOMUX_PAD(0x03FC, 0x0170, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__USDHC2_DATA2                      = IOMUX_PAD(0x03FC, 0x0170, 8, 0x0684, 0, 0),
+
+	MX6_PAD_LCD_DATA23__LCDIF_DATA23                      = IOMUX_PAD(0x0400, 0x0174, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__MQS_LEFT                          = IOMUX_PAD(0x0400, 0x0174, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__ECSPI1_MISO                       = IOMUX_PAD(0x0400, 0x0174, 2, 0x0538, 0, 0),
+	MX6_PAD_LCD_DATA23__CSI_DATA15                        = IOMUX_PAD(0x0400, 0x0174, 3, 0x0500, 1, 0),
+	MX6_PAD_LCD_DATA23__EIM_DATA15                        = IOMUX_PAD(0x0400, 0x0174, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__GPIO3_IO28                        = IOMUX_PAD(0x0400, 0x0174, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__SRC_BT_CFG31                      = IOMUX_PAD(0x0400, 0x0174, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__USDHC2_DATA3                      = IOMUX_PAD(0x0400, 0x0174, 8, 0x0688, 1, 0),
+
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B                       = IOMUX_PAD(0x0404, 0x0178, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__USDHC2_CLK                         = IOMUX_PAD(0x0404, 0x0178, 1, 0x0670, 2, 0),
+	MX6_PAD_NAND_RE_B__QSPI_B_SCLK                        = IOMUX_PAD(0x0404, 0x0178, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__KPP_ROW00                          = IOMUX_PAD(0x0404, 0x0178, 3, 0x05D0, 1, 0),
+	MX6_PAD_NAND_RE_B__EIM_EB_B00                         = IOMUX_PAD(0x0404, 0x0178, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__GPIO4_IO00                         = IOMUX_PAD(0x0404, 0x0178, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__ECSPI3_SS2                         = IOMUX_PAD(0x0404, 0x0178, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B                       = IOMUX_PAD(0x0408, 0x017C, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__USDHC2_CMD                         = IOMUX_PAD(0x0408, 0x017C, 1, 0x0678, 2, 0),
+	MX6_PAD_NAND_WE_B__QSPI_B_SS0_B                       = IOMUX_PAD(0x0408, 0x017C, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__KPP_COL00                          = IOMUX_PAD(0x0408, 0x017C, 3, 0x05C4, 1, 0),
+	MX6_PAD_NAND_WE_B__EIM_EB_B01                         = IOMUX_PAD(0x0408, 0x017C, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__GPIO4_IO01                         = IOMUX_PAD(0x0408, 0x017C, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__ECSPI3_SS3                         = IOMUX_PAD(0x0408, 0x017C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00                   = IOMUX_PAD(0x040C, 0x0180, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0                     = IOMUX_PAD(0x040C, 0x0180, 1, 0x067C, 2, 0),
+	MX6_PAD_NAND_DATA00__QSPI_B_SS1_B                     = IOMUX_PAD(0x040C, 0x0180, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__KPP_ROW01                        = IOMUX_PAD(0x040C, 0x0180, 3, 0x05D4, 1, 0),
+	MX6_PAD_NAND_DATA00__EIM_AD08                         = IOMUX_PAD(0x040C, 0x0180, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__GPIO4_IO02                       = IOMUX_PAD(0x040C, 0x0180, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__ECSPI4_RDY                       = IOMUX_PAD(0x040C, 0x0180, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01                   = IOMUX_PAD(0x0410, 0x0184, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1                     = IOMUX_PAD(0x0410, 0x0184, 1, 0x0680, 2, 0),
+	MX6_PAD_NAND_DATA01__QSPI_B_DQS                       = IOMUX_PAD(0x0410, 0x0184, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__KPP_COL01                        = IOMUX_PAD(0x0410, 0x0184, 3, 0x05C8, 1, 0),
+	MX6_PAD_NAND_DATA01__EIM_AD09                         = IOMUX_PAD(0x0410, 0x0184, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__GPIO4_IO03                       = IOMUX_PAD(0x0410, 0x0184, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__ECSPI4_SS1                       = IOMUX_PAD(0x0410, 0x0184, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02                   = IOMUX_PAD(0x0414, 0x0188, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2                     = IOMUX_PAD(0x0414, 0x0188, 1, 0x0684, 1, 0),
+	MX6_PAD_NAND_DATA02__QSPI_B_DATA00                    = IOMUX_PAD(0x0414, 0x0188, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__KPP_ROW02                        = IOMUX_PAD(0x0414, 0x0188, 3, 0x05D8, 1, 0),
+	MX6_PAD_NAND_DATA02__EIM_AD10                         = IOMUX_PAD(0x0414, 0x0188, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__GPIO4_IO04                       = IOMUX_PAD(0x0414, 0x0188, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__ECSPI4_SS2                       = IOMUX_PAD(0x0414, 0x0188, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03                   = IOMUX_PAD(0x0418, 0x018C, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3                     = IOMUX_PAD(0x0418, 0x018C, 1, 0x0688, 2, 0),
+	MX6_PAD_NAND_DATA03__QSPI_B_DATA01                    = IOMUX_PAD(0x0418, 0x018C, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__KPP_COL02                        = IOMUX_PAD(0x0418, 0x018C, 3, 0x05CC, 1, 0),
+	MX6_PAD_NAND_DATA03__EIM_AD11                         = IOMUX_PAD(0x0418, 0x018C, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__GPIO4_IO05                       = IOMUX_PAD(0x0418, 0x018C, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__ECSPI4_SS3                       = IOMUX_PAD(0x0418, 0x018C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04                   = IOMUX_PAD(0x041C, 0x0190, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__USDHC2_DATA4                     = IOMUX_PAD(0x041C, 0x0190, 1, 0x068C, 1, 0),
+	MX6_PAD_NAND_DATA04__QSPI_B_DATA02                    = IOMUX_PAD(0x041C, 0x0190, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__ECSPI4_SCLK                      = IOMUX_PAD(0x041C, 0x0190, 3, 0x0564, 1, 0),
+	MX6_PAD_NAND_DATA04__EIM_AD12                         = IOMUX_PAD(0x041C, 0x0190, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__GPIO4_IO06                       = IOMUX_PAD(0x041C, 0x0190, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__UART2_DCE_TX                     = IOMUX_PAD(0x041C, 0x0190, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__UART2_DTE_RX                     = IOMUX_PAD(0x041C, 0x0190, 8, 0x062C, 2, 0),
+
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05                   = IOMUX_PAD(0x0420, 0x0194, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__USDHC2_DATA5                     = IOMUX_PAD(0x0420, 0x0194, 1, 0x0690, 1, 0),
+	MX6_PAD_NAND_DATA05__QSPI_B_DATA03                    = IOMUX_PAD(0x0420, 0x0194, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__ECSPI4_MOSI                      = IOMUX_PAD(0x0420, 0x0194, 3, 0x056C, 1, 0),
+	MX6_PAD_NAND_DATA05__EIM_AD13                         = IOMUX_PAD(0x0420, 0x0194, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__GPIO4_IO07                       = IOMUX_PAD(0x0420, 0x0194, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__UART2_DCE_RX                     = IOMUX_PAD(0x0420, 0x0194, 8, 0x062C, 3, 0),
+	MX6_PAD_NAND_DATA05__UART2_DTE_TX                     = IOMUX_PAD(0x0420, 0x0194, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06                   = IOMUX_PAD(0x0424, 0x0198, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__USDHC2_DATA6                     = IOMUX_PAD(0x0424, 0x0198, 1, 0x0694, 1, 0),
+	MX6_PAD_NAND_DATA06__SAI2_RX_BCLK                     = IOMUX_PAD(0x0424, 0x0198, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__ECSPI4_MISO                      = IOMUX_PAD(0x0424, 0x0198, 3, 0x0568, 1, 0),
+	MX6_PAD_NAND_DATA06__EIM_AD14                         = IOMUX_PAD(0x0424, 0x0198, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__GPIO4_IO08                       = IOMUX_PAD(0x0424, 0x0198, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__UART2_DCE_CTS                    = IOMUX_PAD(0x0424, 0x0198, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__UART2_DTE_RTS                    = IOMUX_PAD(0x0424, 0x0198, 8, 0x0628, 4, 0),
+
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07                   = IOMUX_PAD(0x0428, 0x019C, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__USDHC2_DATA7                     = IOMUX_PAD(0x0428, 0x019C, 1, 0x0698, 1, 0),
+	MX6_PAD_NAND_DATA07__QSPI_A_SS1_B                     = IOMUX_PAD(0x0428, 0x019C, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__ECSPI4_SS0                       = IOMUX_PAD(0x0428, 0x019C, 3, 0x0570, 1, 0),
+	MX6_PAD_NAND_DATA07__EIM_AD15                         = IOMUX_PAD(0x0428, 0x019C, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__GPIO4_IO09                       = IOMUX_PAD(0x0428, 0x019C, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__UART2_DCE_RTS                    = IOMUX_PAD(0x0428, 0x019C, 8, 0x0628, 5, 0),
+	MX6_PAD_NAND_DATA07__UART2_DTE_CTS                    = IOMUX_PAD(0x0428, 0x019C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_ALE__RAWNAND_ALE                         = IOMUX_PAD(0x042C, 0x01A0, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__USDHC2_RESET_B                      = IOMUX_PAD(0x042C, 0x01A0, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__QSPI_A_DQS                          = IOMUX_PAD(0x042C, 0x01A0, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__PWM3_OUT                            = IOMUX_PAD(0x042C, 0x01A0, 3, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__EIM_ADDR17                          = IOMUX_PAD(0x042C, 0x01A0, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__GPIO4_IO10                          = IOMUX_PAD(0x042C, 0x01A0, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__ECSPI3_SS1                          = IOMUX_PAD(0x042C, 0x01A0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B                       = IOMUX_PAD(0x0430, 0x01A4, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__USDHC1_RESET_B                     = IOMUX_PAD(0x0430, 0x01A4, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__QSPI_A_SCLK                        = IOMUX_PAD(0x0430, 0x01A4, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__PWM4_OUT                           = IOMUX_PAD(0x0430, 0x01A4, 3, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__EIM_BCLK                           = IOMUX_PAD(0x0430, 0x01A4, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__GPIO4_IO11                         = IOMUX_PAD(0x0430, 0x01A4, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__ECSPI3_RDY                         = IOMUX_PAD(0x0430, 0x01A4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B                 = IOMUX_PAD(0x0434, 0x01A8, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__USDHC1_DATA4                    = IOMUX_PAD(0x0434, 0x01A8, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__QSPI_A_DATA00                   = IOMUX_PAD(0x0434, 0x01A8, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__ECSPI3_SS0                      = IOMUX_PAD(0x0434, 0x01A8, 3, 0x0560, 1, 0),
+	MX6_PAD_NAND_READY_B__EIM_CS1_B                       = IOMUX_PAD(0x0434, 0x01A8, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__GPIO4_IO12                      = IOMUX_PAD(0x0434, 0x01A8, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__UART3_DCE_TX                    = IOMUX_PAD(0x0434, 0x01A8, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__UART3_DTE_RX                    = IOMUX_PAD(0x0434, 0x01A8, 8, 0x0634, 2, 0),
+
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B                     = IOMUX_PAD(0x0438, 0x01AC, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__USDHC1_DATA5                      = IOMUX_PAD(0x0438, 0x01AC, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01                     = IOMUX_PAD(0x0438, 0x01AC, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__ECSPI3_SCLK                       = IOMUX_PAD(0x0438, 0x01AC, 3, 0x0554, 1, 0),
+	MX6_PAD_NAND_CE0_B__EIM_DTACK_B                       = IOMUX_PAD(0x0438, 0x01AC, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__GPIO4_IO13                        = IOMUX_PAD(0x0438, 0x01AC, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__UART3_DCE_RX                      = IOMUX_PAD(0x0438, 0x01AC, 8, 0x0634, 3, 0),
+	MX6_PAD_NAND_CE0_B__UART3_DTE_TX                      = IOMUX_PAD(0x0438, 0x01AC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B                     = IOMUX_PAD(0x043C, 0x01B0, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__USDHC1_DATA6                      = IOMUX_PAD(0x043C, 0x01B0, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02                     = IOMUX_PAD(0x043C, 0x01B0, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__ECSPI3_MOSI                       = IOMUX_PAD(0x043C, 0x01B0, 3, 0x055C, 1, 0),
+	MX6_PAD_NAND_CE1_B__EIM_ADDR18                        = IOMUX_PAD(0x043C, 0x01B0, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__GPIO4_IO14                        = IOMUX_PAD(0x043C, 0x01B0, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__UART3_DCE_CTS                     = IOMUX_PAD(0x043C, 0x01B0, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__UART3_DTE_RTS                     = IOMUX_PAD(0x043C, 0x01B0, 8, 0x0630, 2, 0),
+
+	MX6_PAD_NAND_CLE__RAWNAND_CLE                         = IOMUX_PAD(0x0440, 0x01B4, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__USDHC1_DATA7                        = IOMUX_PAD(0x0440, 0x01B4, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__QSPI_A_DATA03                       = IOMUX_PAD(0x0440, 0x01B4, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__ECSPI3_MISO                         = IOMUX_PAD(0x0440, 0x01B4, 3, 0x0558, 1, 0),
+	MX6_PAD_NAND_CLE__EIM_ADDR16                          = IOMUX_PAD(0x0440, 0x01B4, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__GPIO4_IO15                          = IOMUX_PAD(0x0440, 0x01B4, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__UART3_DCE_RTS                       = IOMUX_PAD(0x0440, 0x01B4, 8, 0x0630, 3, 0),
+	MX6_PAD_NAND_CLE__UART3_DTE_CTS                       = IOMUX_PAD(0x0440, 0x01B4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DQS__RAWNAND_DQS                         = IOMUX_PAD(0x0444, 0x01B8, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__CSI_FIELD                           = IOMUX_PAD(0x0444, 0x01B8, 1, 0x0530, 1, 0),
+	MX6_PAD_NAND_DQS__QSPI_A_SS0_B                        = IOMUX_PAD(0x0444, 0x01B8, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__PWM5_OUT                            = IOMUX_PAD(0x0444, 0x01B8, 3, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__EIM_WAIT                            = IOMUX_PAD(0x0444, 0x01B8, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__GPIO4_IO16                          = IOMUX_PAD(0x0444, 0x01B8, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__SDMA_EXT_EVENT01                    = IOMUX_PAD(0x0444, 0x01B8, 6, 0x0614, 1, 0),
+	MX6_PAD_NAND_DQS__SPDIF_EXT_CLK                       = IOMUX_PAD(0x0444, 0x01B8, 8, 0x061C, 1, 0),
+
+	MX6_PAD_SD1_CMD__USDHC1_CMD                           = IOMUX_PAD(0x0448, 0x01BC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__GPT2_COMPARE1                        = IOMUX_PAD(0x0448, 0x01BC, 1, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__SAI2_RX_SYNC                         = IOMUX_PAD(0x0448, 0x01BC, 2, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__SPDIF_OUT                            = IOMUX_PAD(0x0448, 0x01BC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__EIM_ADDR19                           = IOMUX_PAD(0x0448, 0x01BC, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__GPIO2_IO16                           = IOMUX_PAD(0x0448, 0x01BC, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__SDMA_EXT_EVENT00                     = IOMUX_PAD(0x0448, 0x01BC, 6, 0x0610, 2, 0),
+	MX6_PAD_SD1_CMD__USB_OTG1_PWR                         = IOMUX_PAD(0x0448, 0x01BC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_CLK__USDHC1_CLK                           = IOMUX_PAD(0x044C, 0x01C0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__GPT2_COMPARE2                        = IOMUX_PAD(0x044C, 0x01C0, 1, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__SAI2_MCLK                            = IOMUX_PAD(0x044C, 0x01C0, 2, 0x05F0, 1, 0),
+	MX6_PAD_SD1_CLK__SPDIF_IN                             = IOMUX_PAD(0x044C, 0x01C0, 3, 0x0618, 3, 0),
+	MX6_PAD_SD1_CLK__EIM_ADDR20                           = IOMUX_PAD(0x044C, 0x01C0, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__GPIO2_IO17                           = IOMUX_PAD(0x044C, 0x01C0, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__USB_OTG1_OC                          = IOMUX_PAD(0x044C, 0x01C0, 8, 0x0664, 2, 0),
+
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0                       = IOMUX_PAD(0x0450, 0x01C4, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__GPT2_COMPARE3                      = IOMUX_PAD(0x0450, 0x01C4, 1, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__SAI2_TX_SYNC                       = IOMUX_PAD(0x0450, 0x01C4, 2, 0x05FC, 1, 0),
+	MX6_PAD_SD1_DATA0__FLEXCAN1_TX                        = IOMUX_PAD(0x0450, 0x01C4, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__EIM_ADDR21                         = IOMUX_PAD(0x0450, 0x01C4, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__GPIO2_IO18                         = IOMUX_PAD(0x0450, 0x01C4, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__ANATOP_OTG1_ID                     = IOMUX_PAD(0x0450, 0x01C4, 8, 0x04B8, 2, 0),
+
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1                       = IOMUX_PAD(0x0454, 0x01C8, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__GPT2_CLK                           = IOMUX_PAD(0x0454, 0x01C8, 1, 0x05A0, 1, 0),
+	MX6_PAD_SD1_DATA1__SAI2_TX_BCLK                       = IOMUX_PAD(0x0454, 0x01C8, 2, 0x05F8, 1, 0),
+	MX6_PAD_SD1_DATA1__FLEXCAN1_RX                        = IOMUX_PAD(0x0454, 0x01C8, 3, 0x0584, 3, 0),
+	MX6_PAD_SD1_DATA1__EIM_ADDR22                         = IOMUX_PAD(0x0454, 0x01C8, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__GPIO2_IO19                         = IOMUX_PAD(0x0454, 0x01C8, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__USB_OTG2_PWR                       = IOMUX_PAD(0x0454, 0x01C8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2                       = IOMUX_PAD(0x0458, 0x01CC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__GPT2_CAPTURE1                      = IOMUX_PAD(0x0458, 0x01CC, 1, 0x0598, 1, 0),
+	MX6_PAD_SD1_DATA2__SAI2_RX_DATA                       = IOMUX_PAD(0x0458, 0x01CC, 2, 0x05F4, 1, 0),
+	MX6_PAD_SD1_DATA2__FLEXCAN2_TX                        = IOMUX_PAD(0x0458, 0x01CC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__EIM_ADDR23                         = IOMUX_PAD(0x0458, 0x01CC, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__GPIO2_IO20                         = IOMUX_PAD(0x0458, 0x01CC, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__CCM_CLKO1                          = IOMUX_PAD(0x0458, 0x01CC, 6, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__USB_OTG2_OC                        = IOMUX_PAD(0x0458, 0x01CC, 8, 0x0660, 2, 0),
+
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3                       = IOMUX_PAD(0x045C, 0x01D0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__GPT2_CAPTURE2                      = IOMUX_PAD(0x045C, 0x01D0, 1, 0x059C, 1, 0),
+	MX6_PAD_SD1_DATA3__SAI2_TX_DATA                       = IOMUX_PAD(0x045C, 0x01D0, 2, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__FLEXCAN2_RX                        = IOMUX_PAD(0x045C, 0x01D0, 3, 0x0588, 3, 0),
+	MX6_PAD_SD1_DATA3__EIM_ADDR24                         = IOMUX_PAD(0x045C, 0x01D0, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__GPIO2_IO21                         = IOMUX_PAD(0x045C, 0x01D0, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__CCM_CLKO2                          = IOMUX_PAD(0x045C, 0x01D0, 6, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__ANATOP_OTG2_ID                     = IOMUX_PAD(0x045C, 0x01D0, 8, 0x04BC, 2, 0),
+
+	MX6_PAD_CSI_MCLK__CSI_MCLK                            = IOMUX_PAD(0x0460, 0x01D4, 0, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__USDHC2_CD_B                         = IOMUX_PAD(0x0460, 0x01D4, 1, 0x0674, 0, 0),
+	MX6_PAD_CSI_MCLK__RAWNAND_CE2_B                       = IOMUX_PAD(0x0460, 0x01D4, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__I2C1_SDA                            = IOMUX_PAD(0x0460, 0x01D4, IOMUX_CONFIG_SION | 3, 0x05A8, 0, 0),
+	MX6_PAD_CSI_MCLK__EIM_CS0_B                           = IOMUX_PAD(0x0460, 0x01D4, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__GPIO4_IO17                          = IOMUX_PAD(0x0460, 0x01D4, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__SNVS_HP_VIO_5_CTL                   = IOMUX_PAD(0x0460, 0x01D4, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__UART6_DCE_TX                        = IOMUX_PAD(0x0460, 0x01D4, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__UART6_DTE_RX                        = IOMUX_PAD(0x0460, 0x01D4, 8, 0x064C, 0, 0),
+
+	MX6_PAD_CSI_PIXCLK__CSI_PIXCLK                        = IOMUX_PAD(0x0464, 0x01D8, 0, 0x0528, 1, 0),
+	MX6_PAD_CSI_PIXCLK__USDHC2_WP                         = IOMUX_PAD(0x0464, 0x01D8, 1, 0x069C, 2, 0),
+	MX6_PAD_CSI_PIXCLK__RAWNAND_CE3_B                     = IOMUX_PAD(0x0464, 0x01D8, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__I2C1_SCL                          = IOMUX_PAD(0x0464, 0x01D8, IOMUX_CONFIG_SION | 3, 0x05A4, 2, 0),
+	MX6_PAD_CSI_PIXCLK__EIM_OE                            = IOMUX_PAD(0x0464, 0x01D8, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__GPIO4_IO18                        = IOMUX_PAD(0x0464, 0x01D8, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__SNVS_HP_VIO_5                     = IOMUX_PAD(0x0464, 0x01D8, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__UART6_DCE_RX                      = IOMUX_PAD(0x0464, 0x01D8, 8, 0x064C, 3, 0),
+	MX6_PAD_CSI_PIXCLK__UART6_DTE_TX                      = IOMUX_PAD(0x0464, 0x01D8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_VSYNC__CSI_VSYNC                          = IOMUX_PAD(0x0468, 0x01DC, 0, 0x052C, 0, 0),
+	MX6_PAD_CSI_VSYNC__USDHC2_CLK                         = IOMUX_PAD(0x0468, 0x01DC, 1, 0x0670, 0, 0),
+	MX6_PAD_CSI_VSYNC__SIM1_PORT1_CLK                     = IOMUX_PAD(0x0468, 0x01DC, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__I2C2_SDA                           = IOMUX_PAD(0x0468, 0x01DC, IOMUX_CONFIG_SION | 3, 0x05B0, 0, 0),
+	MX6_PAD_CSI_VSYNC__EIM_RW                             = IOMUX_PAD(0x0468, 0x01DC, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__GPIO4_IO19                         = IOMUX_PAD(0x0468, 0x01DC, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__PWM7_OUT                           = IOMUX_PAD(0x0468, 0x01DC, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__UART6_DCE_RTS                      = IOMUX_PAD(0x0468, 0x01DC, 8, 0x0648, 0, 0),
+	MX6_PAD_CSI_VSYNC__UART6_DTE_CTS                      = IOMUX_PAD(0x0468, 0x01DC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_HSYNC__CSI_HSYNC                          = IOMUX_PAD(0x046C, 0x01E0, 0, 0x0524, 0, 0),
+	MX6_PAD_CSI_HSYNC__USDHC2_CMD                         = IOMUX_PAD(0x046C, 0x01E0, 1, 0x0678, 0, 0),
+	MX6_PAD_CSI_HSYNC__SIM1_PORT1_PD                      = IOMUX_PAD(0x046C, 0x01E0, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__I2C2_SCL                           = IOMUX_PAD(0x046C, 0x01E0, IOMUX_CONFIG_SION | 3, 0x05AC, 0, 0),
+	MX6_PAD_CSI_HSYNC__EIM_LBA_B                          = IOMUX_PAD(0x046C, 0x01E0, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__GPIO4_IO20                         = IOMUX_PAD(0x046C, 0x01E0, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__PWM8_OUT                           = IOMUX_PAD(0x046C, 0x01E0, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__UART6_DCE_CTS                      = IOMUX_PAD(0x046C, 0x01E0, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__UART6_DTE_RTS                      = IOMUX_PAD(0x046C, 0x01E0, 8, 0x0648, 1, 0),
+
+	MX6_PAD_CSI_DATA00__CSI_DATA02                        = IOMUX_PAD(0x0470, 0x01E4, 0, 0x04C4, 0, 0),
+	MX6_PAD_CSI_DATA00__USDHC2_DATA0                      = IOMUX_PAD(0x0470, 0x01E4, 1, 0x067C, 0, 0),
+	MX6_PAD_CSI_DATA00__SIM1_PORT1_RST_B                  = IOMUX_PAD(0x0470, 0x01E4, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__ECSPI2_SCLK                       = IOMUX_PAD(0x0470, 0x01E4, 3, 0x0544, 0, 0),
+	MX6_PAD_CSI_DATA00__EIM_AD00                          = IOMUX_PAD(0x0470, 0x01E4, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__GPIO4_IO21                        = IOMUX_PAD(0x0470, 0x01E4, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__SRC_INT_BOOT                      = IOMUX_PAD(0x0470, 0x01E4, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__UART5_DCE_TX                      = IOMUX_PAD(0x0470, 0x01E4, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__UART5_DTE_RX                      = IOMUX_PAD(0x0470, 0x01E4, 8, 0x0644, 0, 0),
+
+	MX6_PAD_CSI_DATA01__CSI_DATA03                        = IOMUX_PAD(0x0474, 0x01E8, 0, 0x04C8, 0, 0),
+	MX6_PAD_CSI_DATA01__USDHC2_DATA1                      = IOMUX_PAD(0x0474, 0x01E8, 1, 0x0680, 0, 0),
+	MX6_PAD_CSI_DATA01__SIM1_PORT1_SVEN                   = IOMUX_PAD(0x0474, 0x01E8, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA01__ECSPI2_SS0                        = IOMUX_PAD(0x0474, 0x01E8, 3, 0x0550, 0, 0),
+	MX6_PAD_CSI_DATA01__EIM_AD01                          = IOMUX_PAD(0x0474, 0x01E8, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA01__GPIO4_IO22                        = IOMUX_PAD(0x0474, 0x01E8, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA01__SAI1_MCLK                         = IOMUX_PAD(0x0474, 0x01E8, 6, 0x05E0, 0, 0),
+	MX6_PAD_CSI_DATA01__UART5_DCE_RX                      = IOMUX_PAD(0x0474, 0x01E8, 8, 0x0644, 1, 0),
+	MX6_PAD_CSI_DATA01__UART5_DTE_TX                      = IOMUX_PAD(0x0474, 0x01E8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_DATA02__CSI_DATA04                        = IOMUX_PAD(0x0478, 0x01EC, 0, 0x04D8, 1, 0),
+	MX6_PAD_CSI_DATA02__USDHC2_DATA2                      = IOMUX_PAD(0x0478, 0x01EC, 1, 0x0684, 2, 0),
+	MX6_PAD_CSI_DATA02__SIM1_PORT1_TRXD                   = IOMUX_PAD(0x0478, 0x01EC, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__ECSPI2_MOSI                       = IOMUX_PAD(0x0478, 0x01EC, 3, 0x054C, 1, 0),
+	MX6_PAD_CSI_DATA02__EIM_AD02                          = IOMUX_PAD(0x0478, 0x01EC, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__GPIO4_IO23                        = IOMUX_PAD(0x0478, 0x01EC, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__SAI1_RX_SYNC                      = IOMUX_PAD(0x0478, 0x01EC, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__UART5_DCE_RTS                     = IOMUX_PAD(0x0478, 0x01EC, 8, 0x0640, 5, 0),
+	MX6_PAD_CSI_DATA02__UART5_DTE_CTS                     = IOMUX_PAD(0x0478, 0x01EC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_DATA03__CSI_DATA05                        = IOMUX_PAD(0x047C, 0x01F0, 0, 0x04CC, 0, 0),
+	MX6_PAD_CSI_DATA03__USDHC2_DATA3                      = IOMUX_PAD(0x047C, 0x01F0, 1, 0x0688, 0, 0),
+	MX6_PAD_CSI_DATA03__SIM2_PORT1_PD                     = IOMUX_PAD(0x047C, 0x01F0, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__ECSPI2_MISO                       = IOMUX_PAD(0x047C, 0x01F0, 3, 0x0548, 0, 0),
+	MX6_PAD_CSI_DATA03__EIM_AD03                          = IOMUX_PAD(0x047C, 0x01F0, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__GPIO4_IO24                        = IOMUX_PAD(0x047C, 0x01F0, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__SAI1_RX_BCLK                      = IOMUX_PAD(0x047C, 0x01F0, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__UART5_DCE_CTS                     = IOMUX_PAD(0x047C, 0x01F0, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__UART5_DTE_RTS                     = IOMUX_PAD(0x047C, 0x01F0, 8, 0x0640, 0, 0),
+
+	MX6_PAD_CSI_DATA04__CSI_DATA06                        = IOMUX_PAD(0x0480, 0x01F4, 0, 0x04DC, 1, 0),
+	MX6_PAD_CSI_DATA04__USDHC2_DATA4                      = IOMUX_PAD(0x0480, 0x01F4, 1, 0x068C, 2, 0),
+	MX6_PAD_CSI_DATA04__SIM2_PORT1_CLK                    = IOMUX_PAD(0x0480, 0x01F4, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA04__ECSPI1_SCLK                       = IOMUX_PAD(0x0480, 0x01F4, 3, 0x0534, 1, 0),
+	MX6_PAD_CSI_DATA04__EIM_AD04                          = IOMUX_PAD(0x0480, 0x01F4, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA04__GPIO4_IO25                        = IOMUX_PAD(0x0480, 0x01F4, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA04__SAI1_TX_SYNC                      = IOMUX_PAD(0x0480, 0x01F4, 6, 0x05EC, 1, 0),
+	MX6_PAD_CSI_DATA04__USDHC1_WP                         = IOMUX_PAD(0x0480, 0x01F4, 8, 0x066C, 2, 0),
+
+	MX6_PAD_CSI_DATA05__CSI_DATA07                        = IOMUX_PAD(0x0484, 0x01F8, 0, 0x04E0, 1, 0),
+	MX6_PAD_CSI_DATA05__USDHC2_DATA5                      = IOMUX_PAD(0x0484, 0x01F8, 1, 0x0690, 2, 0),
+	MX6_PAD_CSI_DATA05__SIM2_PORT1_RST_B                  = IOMUX_PAD(0x0484, 0x01F8, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA05__ECSPI1_SS0                        = IOMUX_PAD(0x0484, 0x01F8, 3, 0x0540, 1, 0),
+	MX6_PAD_CSI_DATA05__EIM_AD05                          = IOMUX_PAD(0x0484, 0x01F8, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA05__GPIO4_IO26                        = IOMUX_PAD(0x0484, 0x01F8, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA05__SAI1_TX_BCLK                      = IOMUX_PAD(0x0484, 0x01F8, 6, 0x05E8, 1, 0),
+	MX6_PAD_CSI_DATA05__USDHC1_CD_B                       = IOMUX_PAD(0x0484, 0x01F8, 8, 0x0668, 2, 0),
+
+	MX6_PAD_CSI_DATA06__CSI_DATA08                        = IOMUX_PAD(0x0488, 0x01FC, 0, 0x04E4, 1, 0),
+	MX6_PAD_CSI_DATA06__USDHC2_DATA6                      = IOMUX_PAD(0x0488, 0x01FC, 1, 0x0694, 2, 0),
+	MX6_PAD_CSI_DATA06__SIM2_PORT1_SVEN                   = IOMUX_PAD(0x0488, 0x01FC, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA06__ECSPI1_MOSI                       = IOMUX_PAD(0x0488, 0x01FC, 3, 0x053C, 1, 0),
+	MX6_PAD_CSI_DATA06__EIM_AD06                          = IOMUX_PAD(0x0488, 0x01FC, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA06__GPIO4_IO27                        = IOMUX_PAD(0x0488, 0x01FC, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA06__SAI1_RX_DATA                      = IOMUX_PAD(0x0488, 0x01FC, 6, 0x05E4, 1, 0),
+	MX6_PAD_CSI_DATA06__USDHC1_RESET_B                    = IOMUX_PAD(0x0488, 0x01FC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_DATA07__CSI_DATA09                        = IOMUX_PAD(0x048C, 0x0200, 0, 0x04E8, 1, 0),
+	MX6_PAD_CSI_DATA07__USDHC2_DATA7                      = IOMUX_PAD(0x048C, 0x0200, 1, 0x0698, 2, 0),
+	MX6_PAD_CSI_DATA07__SIM2_PORT1_TRXD                   = IOMUX_PAD(0x048C, 0x0200, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__ECSPI1_MISO                       = IOMUX_PAD(0x048C, 0x0200, 3, 0x0538, 1, 0),
+	MX6_PAD_CSI_DATA07__EIM_AD07                          = IOMUX_PAD(0x048C, 0x0200, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__GPIO4_IO28                        = IOMUX_PAD(0x048C, 0x0200, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__SAI1_TX_DATA                      = IOMUX_PAD(0x048C, 0x0200, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__USDHC1_VSELECT                    = IOMUX_PAD(0x048C, 0x0200, 8, 0x0000, 0, 0),
+};
+#endif  /* __ASM_ARCH_IMX6ULL_PINS_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mx6ul_pins.h ebf_6ull_uboot/arch/arm/include/asm/arch/mx6ul_pins.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mx6ul_pins.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mx6ul_pins.h	2021-04-16 14:42:14.692580786 +0800
@@ -0,0 +1,1090 @@
+/*
+ * Copyright (C) 2015 - 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_IMX6UL_PINS_H__
+#define __ASM_ARCH_IMX6UL_PINS_H__
+
+#include <asm/imx-common/iomux-v3.h>
+
+enum {
+
+	MX6_PAD_BOOT_MODE0__GPIO5_IO10	                        = IOMUX_PAD(0x02A0, 0x0014, 5, 0x0000, 0, 0),
+	MX6_PAD_BOOT_MODE1__GPIO5_IO11	                        = IOMUX_PAD(0x02A4, 0x0018, 5, 0x0000, 0, 0),
+	/*
+	 * The TAMPER Pin can be used for GPIO, which depends on
+	 * fusemap TAMPER_PIN_DISABLE[1:0] settings.
+	 */
+	MX6_PAD_SNVS_TAMPER0__GPIO5_IO00                       = IOMUX_PAD(0x02A8, 0x001C, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER1__GPIO5_IO01                       = IOMUX_PAD(0x02AC, 0x0020, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER2__GPIO5_IO02                       = IOMUX_PAD(0x02B0, 0x0024, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER3__GPIO5_IO03                       = IOMUX_PAD(0x02B4, 0x0028, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER4__GPIO5_IO04                       = IOMUX_PAD(0x02B8, 0x002C, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER5__GPIO5_IO05                       = IOMUX_PAD(0x02BC, 0x0030, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER6__GPIO5_IO06                       = IOMUX_PAD(0x02C0, 0x0034, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER7__GPIO5_IO07                       = IOMUX_PAD(0x02C4, 0x0038, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER8__GPIO5_IO08                       = IOMUX_PAD(0x02C8, 0x003C, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER9__GPIO5_IO09                       = IOMUX_PAD(0x02CC, 0x0040, 5, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_MOD__SJC_MOD                              = IOMUX_PAD(0x02D0, 0x0044, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__GPT2_CLK                             = IOMUX_PAD(0x02D0, 0x0044, 1, 0x05A0, 0, 0),
+	MX6_PAD_JTAG_MOD__SPDIF_OUT                            = IOMUX_PAD(0x02D0, 0x0044, 2, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__ENET1_REF_CLK_25M                    = IOMUX_PAD(0x02D0, 0x0044, 3, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__CCM_PMIC_RDY                         = IOMUX_PAD(0x02D0, 0x0044, 4, 0x04C0, 0, 0),
+	MX6_PAD_JTAG_MOD__GPIO1_IO10                           = IOMUX_PAD(0x02D0, 0x0044, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__SDMA_EXT_EVENT00                     = IOMUX_PAD(0x02D0, 0x0044, 6, 0x0610, 0, 0),
+
+	MX6_PAD_JTAG_TMS__SJC_TMS                              = IOMUX_PAD(0x02D4, 0x0048, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__GPT2_CAPTURE1                        = IOMUX_PAD(0x02D4, 0x0048, 1, 0x0598, 0, 0),
+	MX6_PAD_JTAG_TMS__SAI2_MCLK                            = IOMUX_PAD(0x02D4, 0x0048, 2, 0x05F0, 0, 0),
+	MX6_PAD_JTAG_TMS__CCM_CLKO1                            = IOMUX_PAD(0x02D4, 0x0048, 3, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__CCM_WAIT                             = IOMUX_PAD(0x02D4, 0x0048, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__GPIO1_IO11                           = IOMUX_PAD(0x02D4, 0x0048, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__SDMA_EXT_EVENT01                     = IOMUX_PAD(0x02D4, 0x0048, 6, 0x0614, 0, 0),
+	MX6_PAD_JTAG_TMS__EPIT1_OUT                            = IOMUX_PAD(0x02D4, 0x0048, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TDO__SJC_TDO                              = IOMUX_PAD(0x02D8, 0x004C, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__GPT2_CAPTURE2                        = IOMUX_PAD(0x02D8, 0x004C, 1, 0x059C, 0, 0),
+	MX6_PAD_JTAG_TDO__SAI2_TX_SYNC                         = IOMUX_PAD(0x02D8, 0x004C, 2, 0x05FC, 0, 0),
+	MX6_PAD_JTAG_TDO__CCM_CLKO2                            = IOMUX_PAD(0x02D8, 0x004C, 3, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__CCM_STOP                             = IOMUX_PAD(0x02D8, 0x004C, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__GPIO1_IO12                           = IOMUX_PAD(0x02D8, 0x004C, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__MQS_RIGHT                            = IOMUX_PAD(0x02D8, 0x004C, 6, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__EPIT2_OUT                            = IOMUX_PAD(0x02D8, 0x004C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TDI__SJC_TDI                              = IOMUX_PAD(0x02DC, 0x0050, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__GPT2_COMPARE1                        = IOMUX_PAD(0x02DC, 0x0050, 1, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__SAI2_TX_BCLK                         = IOMUX_PAD(0x02DC, 0x0050, 2, 0x05F8, 0, 0),
+	MX6_PAD_JTAG_TDI__PWM6_OUT                             = IOMUX_PAD(0x02DC, 0x0050, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__GPIO1_IO13                           = IOMUX_PAD(0x02DC, 0x0050, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__MQS_LEFT                             = IOMUX_PAD(0x02DC, 0x0050, 6, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__SIM1_POWER_FAIL                      = IOMUX_PAD(0x02DC, 0x0050, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TCK__SJC_TCK                              = IOMUX_PAD(0x02E0, 0x0054, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__GPT2_COMPARE2                        = IOMUX_PAD(0x02E0, 0x0054, 1, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__SAI2_RX_DATA                         = IOMUX_PAD(0x02E0, 0x0054, 2, 0x05F4, 0, 0),
+	MX6_PAD_JTAG_TCK__PWM7_OUT                             = IOMUX_PAD(0x02E0, 0x0054, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__GPIO1_IO14                           = IOMUX_PAD(0x02E0, 0x0054, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__REF_CLK_32K                          = IOMUX_PAD(0x02E0, 0x0054, 6, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__SIM2_POWER_FAIL                      = IOMUX_PAD(0x02E0, 0x0054, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TRST_B__SJC_TRSTB                         = IOMUX_PAD(0x02E4, 0x0058, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__GPT2_COMPARE3                     = IOMUX_PAD(0x02E4, 0x0058, 1, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__SAI2_TX_DATA                      = IOMUX_PAD(0x02E4, 0x0058, 2, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__PWM8_OUT                          = IOMUX_PAD(0x02E4, 0x0058, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__GPIO1_IO15                        = IOMUX_PAD(0x02E4, 0x0058, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__REF_CLK_24M                       = IOMUX_PAD(0x02E4, 0x0058, 6, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__CAAM_RNG_OSC_OBS                  = IOMUX_PAD(0x02E4, 0x0058, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO00__I2C2_SCL                           = IOMUX_PAD(0x02E8, 0x005C, IOMUX_CONFIG_SION | 0, 0x05AC, 1, 0),
+	MX6_PAD_GPIO1_IO00__GPT1_CAPTURE1                      = IOMUX_PAD(0x02E8, 0x005C, 1, 0x058C, 0, 0),
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID                     = IOMUX_PAD(0x02E8, 0x005C, 2, 0x04B8, 0, 0),
+	MX6_PAD_GPIO1_IO00__ENET1_REF_CLK1                     = IOMUX_PAD(0x02E8, 0x005C, 3, 0x0574, 0, 0),
+	MX6_PAD_GPIO1_IO00__MQS_RIGHT                          = IOMUX_PAD(0x02E8, 0x005C, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__GPIO1_IO00                         = IOMUX_PAD(0x02E8, 0x005C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__ENET1_1588_EVENT0_IN               = IOMUX_PAD(0x02E8, 0x005C, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__SRC_SYSTEM_RESET                   = IOMUX_PAD(0x02E8, 0x005C, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__WDOG3_WDOG_B                       = IOMUX_PAD(0x02E8, 0x005C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO01__I2C2_SDA                           = IOMUX_PAD(0x02EC, 0x0060, IOMUX_CONFIG_SION | 0, 0x05B0, 1, 0),
+	MX6_PAD_GPIO1_IO01__GPT1_COMPARE1                      = IOMUX_PAD(0x02EC, 0x0060, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__USB_OTG1_OC                        = IOMUX_PAD(0x02EC, 0x0060, 2, 0x0664, 0, 0),
+	MX6_PAD_GPIO1_IO01__ENET2_REF_CLK2                     = IOMUX_PAD(0x02EC, 0x0060, 3, 0x057C, 0, 0),
+	MX6_PAD_GPIO1_IO01__MQS_LEFT                           = IOMUX_PAD(0x02EC, 0x0060, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__GPIO1_IO01                         = IOMUX_PAD(0x02EC, 0x0060, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__ENET1_1588_EVENT0_OUT              = IOMUX_PAD(0x02EC, 0x0060, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__SRC_EARLY_RESET                    = IOMUX_PAD(0x02EC, 0x0060, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__WDOG1_WDOG_B                       = IOMUX_PAD(0x02EC, 0x0060, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO02__I2C1_SCL                           = IOMUX_PAD(0x02F0, 0x0064, IOMUX_CONFIG_SION | 0, 0x05A4, 0, 0),
+	MX6_PAD_GPIO1_IO02__GPT1_COMPARE2                      = IOMUX_PAD(0x02F0, 0x0064, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__USB_OTG2_PWR                       = IOMUX_PAD(0x02F0, 0x0064, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__ENET1_REF_CLK_25M                  = IOMUX_PAD(0x02F0, 0x0064, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__USDHC1_WP                          = IOMUX_PAD(0x02F0, 0x0064, 4, 0x066C, 0, 0),
+	MX6_PAD_GPIO1_IO02__GPIO1_IO02                         = IOMUX_PAD(0x02F0, 0x0064, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__SDMA_EXT_EVENT00                   = IOMUX_PAD(0x02F0, 0x0064, 6, 0x0610, 1, 0),
+	MX6_PAD_GPIO1_IO02__SRC_ANY_PU_RESET                   = IOMUX_PAD(0x02F0, 0x0064, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__UART1_DCE_TX                       = IOMUX_PAD(0x02F0, 0x0064, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__UART1_DTE_RX                       = IOMUX_PAD(0x02F0, 0x0064, 8, 0x0624, 0, 0),
+
+	MX6_PAD_GPIO1_IO03__I2C1_SDA                           = IOMUX_PAD(0x02F4, 0x0068, IOMUX_CONFIG_SION | 0, 0x05A8, 1, 0),
+	MX6_PAD_GPIO1_IO03__GPT1_COMPARE3                      = IOMUX_PAD(0x02F4, 0x0068, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__USB_OTG2_OC                        = IOMUX_PAD(0x02F4, 0x0068, 2, 0x0660, 0, 0),
+	MX6_PAD_GPIO1_IO03__REF_CLK_32K                        = IOMUX_PAD(0x02F4, 0x0068, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__USDHC1_CD_B                        = IOMUX_PAD(0x02F4, 0x0068, 4, 0x0668, 0, 0),
+	MX6_PAD_GPIO1_IO03__GPIO1_IO03                         = IOMUX_PAD(0x02F4, 0x0068, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__CCM_DI0_EXT_CLK                    = IOMUX_PAD(0x02F4, 0x0068, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__SRC_TESTER_ACK                     = IOMUX_PAD(0x02F4, 0x0068, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__UART1_DCE_RX                       = IOMUX_PAD(0x02F4, 0x0068, 8, 0x0624, 1, 0),
+	MX6_PAD_GPIO1_IO03__UART1_DTE_TX                       = IOMUX_PAD(0x02F4, 0x0068, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO04__ENET1_REF_CLK1                     = IOMUX_PAD(0x02F8, 0x006C, 0, 0x0574, 1, 0),
+	MX6_PAD_GPIO1_IO04__PWM3_OUT                           = IOMUX_PAD(0x02F8, 0x006C, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__USB_OTG1_PWR                       = IOMUX_PAD(0x02F8, 0x006C, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__REF_CLK_24M                        = IOMUX_PAD(0x02F8, 0x006C, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__USDHC1_RESET_B                     = IOMUX_PAD(0x02F8, 0x006C, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__GPIO1_IO04                         = IOMUX_PAD(0x02F8, 0x006C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__ENET2_1588_EVENT0_IN               = IOMUX_PAD(0x02F8, 0x006C, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__UART5_DCE_TX                       = IOMUX_PAD(0x02F8, 0x006C, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__UART5_DTE_RX                       = IOMUX_PAD(0x02F8, 0x006C, 8, 0x0644, 2, 0),
+
+	MX6_PAD_GPIO1_IO05__ENET2_REF_CLK2                     = IOMUX_PAD(0x02FC, 0x0070, 0, 0x057C, 1, 0),
+	MX6_PAD_GPIO1_IO05__PWM4_OUT                           = IOMUX_PAD(0x02FC, 0x0070, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__ANATOP_OTG2_ID                     = IOMUX_PAD(0x02FC, 0x0070, 2, 0x04BC, 0, 0),
+	MX6_PAD_GPIO1_IO05__CSI_FIELD                          = IOMUX_PAD(0x02FC, 0x0070, 3, 0x0530, 0, 0),
+	MX6_PAD_GPIO1_IO05__USDHC1_VSELECT                     = IOMUX_PAD(0x02FC, 0x0070, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__GPIO1_IO05                         = IOMUX_PAD(0x02FC, 0x0070, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__ENET2_1588_EVENT0_OUT              = IOMUX_PAD(0x02FC, 0x0070, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__UART5_DCE_RX                       = IOMUX_PAD(0x02FC, 0x0070, 8, 0x0644, 3, 0),
+	MX6_PAD_GPIO1_IO05__UART5_DTE_TX                       = IOMUX_PAD(0x02FC, 0x0070, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO06__ENET1_MDIO                         = IOMUX_PAD(0x0300, 0x0074, 0, 0x0578, 0, 0),
+	MX6_PAD_GPIO1_IO06__ENET2_MDIO                         = IOMUX_PAD(0x0300, 0x0074, 1, 0x0580, 0, 0),
+	MX6_PAD_GPIO1_IO06__USB_OTG_PWR_WAKE                   = IOMUX_PAD(0x0300, 0x0074, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__CSI_MCLK                           = IOMUX_PAD(0x0300, 0x0074, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__USDHC2_WP                          = IOMUX_PAD(0x0300, 0x0074, 4, 0x069C, 0, 0),
+	MX6_PAD_GPIO1_IO06__GPIO1_IO06                         = IOMUX_PAD(0x0300, 0x0074, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__CCM_WAIT                           = IOMUX_PAD(0x0300, 0x0074, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__CCM_REF_EN_B                       = IOMUX_PAD(0x0300, 0x0074, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__UART1_DCE_CTS                      = IOMUX_PAD(0x0300, 0x0074, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__UART1_DTE_RTS                      = IOMUX_PAD(0x0300, 0x0074, 8, 0x0620, 0, 0),
+
+	MX6_PAD_GPIO1_IO07__ENET1_MDC                          = IOMUX_PAD(0x0304, 0x0078, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__ENET2_MDC                          = IOMUX_PAD(0x0304, 0x0078, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__USB_OTG_HOST_MODE                  = IOMUX_PAD(0x0304, 0x0078, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__CSI_PIXCLK                         = IOMUX_PAD(0x0304, 0x0078, 3, 0x0528, 0, 0),
+	MX6_PAD_GPIO1_IO07__USDHC2_CD_B                        = IOMUX_PAD(0x0304, 0x0078, 4, 0x0674, 1, 0),
+	MX6_PAD_GPIO1_IO07__GPIO1_IO07                         = IOMUX_PAD(0x0304, 0x0078, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__CCM_STOP                           = IOMUX_PAD(0x0304, 0x0078, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__UART1_DCE_RTS                      = IOMUX_PAD(0x0304, 0x0078, 8, 0x0620, 1, 0),
+	MX6_PAD_GPIO1_IO07__UART1_DTE_CTS                      = IOMUX_PAD(0x0304, 0x0078, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO08__PWM1_OUT                           = IOMUX_PAD(0x0308, 0x007C, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__WDOG1_WDOG_B                       = IOMUX_PAD(0x0308, 0x007C, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__SPDIF_OUT                          = IOMUX_PAD(0x0308, 0x007C, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__CSI_VSYNC                          = IOMUX_PAD(0x0308, 0x007C, 3, 0x052C, 1, 0),
+	MX6_PAD_GPIO1_IO08__USDHC2_VSELECT                     = IOMUX_PAD(0x0308, 0x007C, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__GPIO1_IO08                         = IOMUX_PAD(0x0308, 0x007C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__CCM_PMIC_RDY                       = IOMUX_PAD(0x0308, 0x007C, 6, 0x04C0, 1, 0),
+	MX6_PAD_GPIO1_IO08__UART5_DCE_RTS                      = IOMUX_PAD(0x0308, 0x007C, 8, 0x0640, 1, 0),
+	MX6_PAD_GPIO1_IO08__UART5_DTE_CTS                      = IOMUX_PAD(0x0308, 0x007C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO09__PWM2_OUT                           = IOMUX_PAD(0x030C, 0x0080, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__WDOG1_WDOG_ANY                     = IOMUX_PAD(0x030C, 0x0080, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__SPDIF_IN                           = IOMUX_PAD(0x030C, 0x0080, 2, 0x0618, 0, 0),
+	MX6_PAD_GPIO1_IO09__CSI_HSYNC                          = IOMUX_PAD(0x030C, 0x0080, 3, 0x0524, 1, 0),
+	MX6_PAD_GPIO1_IO09__USDHC2_RESET_B                     = IOMUX_PAD(0x030C, 0x0080, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09                         = IOMUX_PAD(0x030C, 0x0080, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__USDHC1_RESET_B                     = IOMUX_PAD(0x030C, 0x0080, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__UART5_DCE_CTS                      = IOMUX_PAD(0x030C, 0x0080, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__UART5_DTE_RTS                      = IOMUX_PAD(0x030C, 0x0080, 8, 0x0640, 2, 0),
+
+	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX                    = IOMUX_PAD(0x0310, 0x0084, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_TX_DATA__UART1_DTE_RX                    = IOMUX_PAD(0x0310, 0x0084, 0, 0x0624, 2, 0),
+	MX6_PAD_UART1_TX_DATA__ENET1_RDATA02                   = IOMUX_PAD(0x0310, 0x0084, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_TX_DATA__I2C3_SCL                        = IOMUX_PAD(0x0310, 0x0084, IOMUX_CONFIG_SION | 2, 0x05B4, 0, 0),
+	MX6_PAD_UART1_TX_DATA__CSI_DATA02                      = IOMUX_PAD(0x0310, 0x0084, 3, 0x04C4, 1, 0),
+	MX6_PAD_UART1_TX_DATA__GPT1_COMPARE1                   = IOMUX_PAD(0x0310, 0x0084, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_TX_DATA__GPIO1_IO16                      = IOMUX_PAD(0x0310, 0x0084, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_TX_DATA__SPDIF_OUT                       = IOMUX_PAD(0x0310, 0x0084, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX                    = IOMUX_PAD(0x0314, 0x0088, 0, 0x0624, 3, 0),
+
+	MX6_PAD_UART1_RX_DATA__UART1_DTE_TX                    = IOMUX_PAD(0x0314, 0x0088, 0, 0x0000, 0, 0),
+	MX6_PAD_UART1_RX_DATA__ENET1_RDATA03                   = IOMUX_PAD(0x0314, 0x0088, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_RX_DATA__I2C3_SDA                        = IOMUX_PAD(0x0314, 0x0088, IOMUX_CONFIG_SION | 2, 0x05B8, 0, 0),
+	MX6_PAD_UART1_RX_DATA__CSI_DATA03                      = IOMUX_PAD(0x0314, 0x0088, 3, 0x04C8, 1, 0),
+	MX6_PAD_UART1_RX_DATA__GPT1_CLK                        = IOMUX_PAD(0x0314, 0x0088, 4, 0x0594, 0, 0),
+	MX6_PAD_UART1_RX_DATA__GPIO1_IO17                      = IOMUX_PAD(0x0314, 0x0088, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_RX_DATA__SPDIF_IN                        = IOMUX_PAD(0x0314, 0x0088, 8, 0x0618, 1, 0),
+
+	MX6_PAD_UART1_CTS_B__UART1_DCE_CTS                     = IOMUX_PAD(0x0318, 0x008C, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_CTS_B__UART1_DTE_RTS                     = IOMUX_PAD(0x0318, 0x008C, 0, 0x0620, 2, 0),
+	MX6_PAD_UART1_CTS_B__ENET1_RX_CLK                      = IOMUX_PAD(0x0318, 0x008C, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_CTS_B__USDHC1_WP                         = IOMUX_PAD(0x0318, 0x008C, 2, 0x066C, 1, 0),
+	MX6_PAD_UART1_CTS_B__CSI_DATA04                        = IOMUX_PAD(0x0318, 0x008C, 3, 0x04D8, 0, 0),
+	MX6_PAD_UART1_CTS_B__ENET2_1588_EVENT1_IN              = IOMUX_PAD(0x0318, 0x008C, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_CTS_B__GPIO1_IO18                        = IOMUX_PAD(0x0318, 0x008C, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_CTS_B__USDHC2_WP                         = IOMUX_PAD(0x0318, 0x008C, 8, 0x069C, 1, 0),
+
+	MX6_PAD_UART1_RTS_B__UART1_DCE_RTS                     = IOMUX_PAD(0x031C, 0x0090, 0, 0x0620, 3, 0),
+
+	MX6_PAD_UART1_RTS_B__UART1_DTE_CTS                     = IOMUX_PAD(0x031C, 0x0090, 0, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__ENET1_TX_ER                       = IOMUX_PAD(0x031C, 0x0090, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__USDHC1_CD_B                       = IOMUX_PAD(0x031C, 0x0090, 2, 0x0668, 1, 0),
+	MX6_PAD_UART1_RTS_B__CSI_DATA05                        = IOMUX_PAD(0x031C, 0x0090, 3, 0x04CC, 1, 0),
+	MX6_PAD_UART1_RTS_B__ENET2_1588_EVENT1_OUT             = IOMUX_PAD(0x031C, 0x0090, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__GPIO1_IO19                        = IOMUX_PAD(0x031C, 0x0090, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__USDHC2_CD_B                       = IOMUX_PAD(0x031C, 0x0090, 8, 0x0674, 2, 0),
+
+	MX6_PAD_UART2_TX_DATA__UART2_DCE_TX                    = IOMUX_PAD(0x0320, 0x0094, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART2_TX_DATA__UART2_DTE_RX                    = IOMUX_PAD(0x0320, 0x0094, 0, 0x062C, 0, 0),
+	MX6_PAD_UART2_TX_DATA__ENET1_TDATA02                   = IOMUX_PAD(0x0320, 0x0094, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_TX_DATA__I2C4_SCL                        = IOMUX_PAD(0x0320, 0x0094, IOMUX_CONFIG_SION | 2, 0x05BC, 0, 0),
+	MX6_PAD_UART2_TX_DATA__CSI_DATA06                      = IOMUX_PAD(0x0320, 0x0094, 3, 0x04DC, 0, 0),
+	MX6_PAD_UART2_TX_DATA__GPT1_CAPTURE1                   = IOMUX_PAD(0x0320, 0x0094, 4, 0x058C, 1, 0),
+	MX6_PAD_UART2_TX_DATA__GPIO1_IO20                      = IOMUX_PAD(0x0320, 0x0094, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_TX_DATA__ECSPI3_SS0                      = IOMUX_PAD(0x0320, 0x0094, 8, 0x0560, 0, 0),
+
+	MX6_PAD_UART2_RX_DATA__UART2_DCE_RX                    = IOMUX_PAD(0x0324, 0x0098, 0, 0x062C, 1, 0),
+
+	MX6_PAD_UART2_RX_DATA__UART2_DTE_TX                    = IOMUX_PAD(0x0324, 0x0098, 0, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__ENET1_TDATA03                   = IOMUX_PAD(0x0324, 0x0098, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__I2C4_SDA                        = IOMUX_PAD(0x0324, 0x0098, IOMUX_CONFIG_SION | 2, 0x05C0, 0, 0),
+	MX6_PAD_UART2_RX_DATA__CSI_DATA07                      = IOMUX_PAD(0x0324, 0x0098, 3, 0x04E0, 0, 0),
+	MX6_PAD_UART2_RX_DATA__GPT1_CAPTURE2                   = IOMUX_PAD(0x0324, 0x0098, 4, 0x0590, 0, 0),
+	MX6_PAD_UART2_RX_DATA__GPIO1_IO21                      = IOMUX_PAD(0x0324, 0x0098, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__SJC_DONE                        = IOMUX_PAD(0x0324, 0x0098, 7, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__ECSPI3_SCLK                     = IOMUX_PAD(0x0324, 0x0098, 8, 0x0554, 0, 0),
+
+	MX6_PAD_UART2_CTS_B__UART2_DCE_CTS                     = IOMUX_PAD(0x0328, 0x009C, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART2_CTS_B__UART2_DTE_RTS                     = IOMUX_PAD(0x0328, 0x009C, 0, 0x0628, 0, 0),
+	MX6_PAD_UART2_CTS_B__ENET1_CRS                         = IOMUX_PAD(0x0328, 0x009C, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__FLEXCAN2_TX                       = IOMUX_PAD(0x0328, 0x009C, 2, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__CSI_DATA08                        = IOMUX_PAD(0x0328, 0x009C, 3, 0x04E4, 0, 0),
+	MX6_PAD_UART2_CTS_B__GPT1_COMPARE2                     = IOMUX_PAD(0x0328, 0x009C, 4, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__GPIO1_IO22                        = IOMUX_PAD(0x0328, 0x009C, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__SJC_DE_B                          = IOMUX_PAD(0x0328, 0x009C, 7, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__ECSPI3_MOSI                       = IOMUX_PAD(0x0328, 0x009C, 8, 0x055C, 0, 0),
+
+	MX6_PAD_UART2_RTS_B__UART2_DCE_RTS                     = IOMUX_PAD(0x032C, 0x00A0, 0, 0x0628, 1, 0),
+
+	MX6_PAD_UART2_RTS_B__UART2_DTE_CTS                     = IOMUX_PAD(0x032C, 0x00A0, 0, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__ENET1_COL                         = IOMUX_PAD(0x032C, 0x00A0, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__FLEXCAN2_RX                       = IOMUX_PAD(0x032C, 0x00A0, 2, 0x0588, 0, 0),
+	MX6_PAD_UART2_RTS_B__CSI_DATA09                        = IOMUX_PAD(0x032C, 0x00A0, 3, 0x04E8, 0, 0),
+	MX6_PAD_UART2_RTS_B__GPT1_COMPARE3                     = IOMUX_PAD(0x032C, 0x00A0, 4, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__GPIO1_IO23                        = IOMUX_PAD(0x032C, 0x00A0, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__SJC_FAIL                          = IOMUX_PAD(0x032C, 0x00A0, 7, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__ECSPI3_MISO                       = IOMUX_PAD(0x032C, 0x00A0, 8, 0x0558, 0, 0),
+
+	MX6_PAD_UART3_TX_DATA__UART3_DCE_TX                    = IOMUX_PAD(0x0330, 0x00A4, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_TX_DATA__UART3_DTE_RX                    = IOMUX_PAD(0x0330, 0x00A4, 0, 0x0634, 0, 0),
+	MX6_PAD_UART3_TX_DATA__ENET2_RDATA02                   = IOMUX_PAD(0x0330, 0x00A4, 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__SIM1_PORT0_PD                   = IOMUX_PAD(0x0330, 0x00A4, 2, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__CSI_DATA01                      = IOMUX_PAD(0x0330, 0x00A4, 3, 0x04D4, 0, 0),
+	MX6_PAD_UART3_TX_DATA__UART2_DCE_CTS                   = IOMUX_PAD(0x0330, 0x00A4, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__UART2_DTE_RTS                   = IOMUX_PAD(0x0330, 0x00A4, 4, 0x0628, 2, 0),
+	MX6_PAD_UART3_TX_DATA__GPIO1_IO24                      = IOMUX_PAD(0x0330, 0x00A4, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__SJC_JTAG_ACT                    = IOMUX_PAD(0x0330, 0x00A4, 7, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__ANATOP_OTG1_ID                  = IOMUX_PAD(0x0330, 0x00A4, 8, 0x04B8, 1, 0),
+
+	MX6_PAD_UART3_RX_DATA__UART3_DCE_RX                    = IOMUX_PAD(0x0334, 0x00A8, 0, 0x0634, 1, 0),
+
+	MX6_PAD_UART3_RX_DATA__UART3_DTE_TX                    = IOMUX_PAD(0x0334, 0x00A8, 0, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__ENET2_RDATA03                   = IOMUX_PAD(0x0334, 0x00A8, 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__SIM2_PORT0_PD                   = IOMUX_PAD(0x0334, 0x00A8, 2, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__CSI_DATA00                      = IOMUX_PAD(0x0334, 0x00A8, 3, 0x04D0, 0, 0),
+	MX6_PAD_UART3_RX_DATA__UART2_DCE_RTS                   = IOMUX_PAD(0x0334, 0x00A8, 4, 0x0628, 3, 0),
+	MX6_PAD_UART3_RX_DATA__UART2_DTE_CTS                   = IOMUX_PAD(0x0334, 0x00A8, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__GPIO1_IO25                      = IOMUX_PAD(0x0334, 0x00A8, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__EPIT1_OUT                       = IOMUX_PAD(0x0334, 0x00A8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_CTS_B__UART3_DCE_CTS                     = IOMUX_PAD(0x0338, 0x00AC, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_CTS_B__UART3_DTE_RTS                     = IOMUX_PAD(0x0338, 0x00AC, 0, 0x0630, 0, 0),
+	MX6_PAD_UART3_CTS_B__ENET2_RX_CLK                      = IOMUX_PAD(0x0338, 0x00AC, IOMUX_CONFIG_SION | 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__FLEXCAN1_TX                       = IOMUX_PAD(0x0338, 0x00AC, 2, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__CSI_DATA10                        = IOMUX_PAD(0x0338, 0x00AC, 3, 0x04EC, 0, 0),
+	MX6_PAD_UART3_CTS_B__ENET1_1588_EVENT1_IN              = IOMUX_PAD(0x0338, 0x00AC, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__GPIO1_IO26                        = IOMUX_PAD(0x0338, 0x00AC, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__EPIT2_OUT                         = IOMUX_PAD(0x0338, 0x00AC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_RTS_B__UART3_DCE_RTS                     = IOMUX_PAD(0x033C, 0x00B0, 0, 0x0630, 1, 0),
+
+	MX6_PAD_UART3_RTS_B__UART3_DTE_CTS                     = IOMUX_PAD(0x033C, 0x00B0, 0, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__ENET2_TX_ER                       = IOMUX_PAD(0x033C, 0x00B0, 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__FLEXCAN1_RX                       = IOMUX_PAD(0x033C, 0x00B0, 2, 0x0584, 0, 0),
+	MX6_PAD_UART3_RTS_B__CSI_DATA11                        = IOMUX_PAD(0x033C, 0x00B0, 3, 0x04F0, 0, 0),
+	MX6_PAD_UART3_RTS_B__ENET1_1588_EVENT1_OUT             = IOMUX_PAD(0x033C, 0x00B0, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__GPIO1_IO27                        = IOMUX_PAD(0x033C, 0x00B0, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__WDOG1_WDOG_B                      = IOMUX_PAD(0x033C, 0x00B0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART4_TX_DATA__UART4_DCE_TX                    = IOMUX_PAD(0x0340, 0x00B4, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART4_TX_DATA__UART4_DTE_RX                    = IOMUX_PAD(0x0340, 0x00B4, 0, 0x063C, 0, 0),
+	MX6_PAD_UART4_TX_DATA__ENET2_TDATA02                   = IOMUX_PAD(0x0340, 0x00B4, 1, 0x0000, 0, 0),
+	MX6_PAD_UART4_TX_DATA__I2C1_SCL                        = IOMUX_PAD(0x0340, 0x00B4, IOMUX_CONFIG_SION | 2, 0x05A4, 1, 0),
+	MX6_PAD_UART4_TX_DATA__CSI_DATA12                      = IOMUX_PAD(0x0340, 0x00B4, 3, 0x04F4, 0, 0),
+	MX6_PAD_UART4_TX_DATA__CSU_CSU_ALARM_AUT02             = IOMUX_PAD(0x0340, 0x00B4, 4, 0x0000, 0, 0),
+	MX6_PAD_UART4_TX_DATA__GPIO1_IO28                      = IOMUX_PAD(0x0340, 0x00B4, 5, 0x0000, 0, 0),
+	MX6_PAD_UART4_TX_DATA__ECSPI2_SCLK                     = IOMUX_PAD(0x0340, 0x00B4, 8, 0x0544, 1, 0),
+
+	MX6_PAD_UART4_RX_DATA__UART4_DCE_RX                    = IOMUX_PAD(0x0344, 0x00B8, 0, 0x063C, 1, 0),
+
+	MX6_PAD_UART4_RX_DATA__UART4_DTE_TX                    = IOMUX_PAD(0x0344, 0x00B8, 0, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__ENET2_TDATA03                   = IOMUX_PAD(0x0344, 0x00B8, 1, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__I2C1_SDA                        = IOMUX_PAD(0x0344, 0x00B8, IOMUX_CONFIG_SION | 2, 0x05A8, 2, 0),
+	MX6_PAD_UART4_RX_DATA__CSI_DATA13                      = IOMUX_PAD(0x0344, 0x00B8, 3, 0x04F8, 0, 0),
+	MX6_PAD_UART4_RX_DATA__CSU_CSU_ALARM_AUT01             = IOMUX_PAD(0x0344, 0x00B8, 4, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__GPIO1_IO29                      = IOMUX_PAD(0x0344, 0x00B8, 5, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__ECSPI2_SS0                      = IOMUX_PAD(0x0344, 0x00B8, 8, 0x0550, 1, 0),
+	MX6_PAD_UART5_TX_DATA__GPIO1_IO30                      = IOMUX_PAD(0x0348, 0x00BC, 5, 0x0000, 0, 0),
+	MX6_PAD_UART5_TX_DATA__ECSPI2_MOSI                     = IOMUX_PAD(0x0348, 0x00BC, 8, 0x054C, 0, 0),
+
+	MX6_PAD_UART5_TX_DATA__UART5_DCE_TX                    = IOMUX_PAD(0x0348, 0x00BC, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART5_TX_DATA__UART5_DTE_RX                    = IOMUX_PAD(0x0348, 0x00BC, 0, 0x0644, 4, 0),
+	MX6_PAD_UART5_TX_DATA__ENET2_CRS                       = IOMUX_PAD(0x0348, 0x00BC, 1, 0x0000, 0, 0),
+	MX6_PAD_UART5_TX_DATA__I2C2_SCL                        = IOMUX_PAD(0x0348, 0x00BC, IOMUX_CONFIG_SION | 2, 0x05AC, 2, 0),
+	MX6_PAD_UART5_TX_DATA__CSI_DATA14                      = IOMUX_PAD(0x0348, 0x00BC, 3, 0x04FC, 0, 0),
+	MX6_PAD_UART5_TX_DATA__CSU_CSU_ALARM_AUT00             = IOMUX_PAD(0x0348, 0x00BC, 4, 0x0000, 0, 0),
+
+	MX6_PAD_UART5_RX_DATA__UART5_DCE_RX                    = IOMUX_PAD(0x034C, 0x00C0, 0, 0x0644, 5, 0),
+
+	MX6_PAD_UART5_RX_DATA__UART5_DTE_TX                    = IOMUX_PAD(0x034C, 0x00C0, 0, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__ENET2_COL                       = IOMUX_PAD(0x034C, 0x00C0, 1, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__I2C2_SDA                        = IOMUX_PAD(0x034C, 0x00C0, IOMUX_CONFIG_SION | 2, 0x05B0, 2, 0),
+	MX6_PAD_UART5_RX_DATA__CSI_DATA15                      = IOMUX_PAD(0x034C, 0x00C0, 3, 0x0500, 0, 0),
+	MX6_PAD_UART5_RX_DATA__CSU_CSU_INT_DEB                 = IOMUX_PAD(0x034C, 0x00C0, 4, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__GPIO1_IO31                      = IOMUX_PAD(0x034C, 0x00C0, 5, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__ECSPI2_MISO                     = IOMUX_PAD(0x034C, 0x00C0, 8, 0x0548, 1, 0),
+
+	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00                  = IOMUX_PAD(0x0350, 0x00C4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__UART4_DCE_RTS                  = IOMUX_PAD(0x0350, 0x00C4, 1, 0x0638, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__UART4_DTE_CTS                  = IOMUX_PAD(0x0350, 0x00C4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__PWM1_OUT                       = IOMUX_PAD(0x0350, 0x00C4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__CSI_DATA16                     = IOMUX_PAD(0x0350, 0x00C4, 3, 0x0504, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__FLEXCAN1_TX                    = IOMUX_PAD(0x0350, 0x00C4, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__GPIO2_IO00                     = IOMUX_PAD(0x0350, 0x00C4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__KPP_ROW00                      = IOMUX_PAD(0x0350, 0x00C4, 6, 0x05D0, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__USDHC1_LCTL                    = IOMUX_PAD(0x0350, 0x00C4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01                  = IOMUX_PAD(0x0354, 0x00C8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__UART4_DCE_CTS                  = IOMUX_PAD(0x0354, 0x00C8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__UART4_DTE_RTS                  = IOMUX_PAD(0x0354, 0x00C8, 1, 0x0638, 1, 0),
+	MX6_PAD_ENET1_RX_DATA1__PWM2_OUT                       = IOMUX_PAD(0x0354, 0x00C8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__CSI_DATA17                     = IOMUX_PAD(0x0354, 0x00C8, 3, 0x0508, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__FLEXCAN1_RX                    = IOMUX_PAD(0x0354, 0x00C8, 4, 0x0584, 1, 0),
+	MX6_PAD_ENET1_RX_DATA1__GPIO2_IO01                     = IOMUX_PAD(0x0354, 0x00C8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__KPP_COL00                      = IOMUX_PAD(0x0354, 0x00C8, 6, 0x05C4, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__USDHC2_LCTL                    = IOMUX_PAD(0x0354, 0x00C8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN                       = IOMUX_PAD(0x0358, 0x00CC, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__UART5_DCE_RTS                     = IOMUX_PAD(0x0358, 0x00CC, 1, 0x0640, 3, 0),
+	MX6_PAD_ENET1_RX_EN__UART5_DTE_CTS                     = IOMUX_PAD(0x0358, 0x00CC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__REF_CLK_32K                       = IOMUX_PAD(0x0358, 0x00CC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__CSI_DATA18                        = IOMUX_PAD(0x0358, 0x00CC, 3, 0x050C, 0, 0),
+	MX6_PAD_ENET1_RX_EN__FLEXCAN2_TX                       = IOMUX_PAD(0x0358, 0x00CC, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__GPIO2_IO02                        = IOMUX_PAD(0x0358, 0x00CC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__KPP_ROW01                         = IOMUX_PAD(0x0358, 0x00CC, 6, 0x05D4, 0, 0),
+	MX6_PAD_ENET1_RX_EN__USDHC1_VSELECT                    = IOMUX_PAD(0x0358, 0x00CC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00                  = IOMUX_PAD(0x035C, 0x00D0, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__UART5_DCE_CTS                  = IOMUX_PAD(0x035C, 0x00D0, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__UART5_DTE_RTS                  = IOMUX_PAD(0x035C, 0x00D0, 1, 0x0640, 4, 0),
+	MX6_PAD_ENET1_TX_DATA0__REF_CLK_24M                    = IOMUX_PAD(0x035C, 0x00D0, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__CSI_DATA19                     = IOMUX_PAD(0x035C, 0x00D0, 3, 0x0510, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__FLEXCAN2_RX                    = IOMUX_PAD(0x035C, 0x00D0, 4, 0x0588, 1, 0),
+	MX6_PAD_ENET1_TX_DATA0__GPIO2_IO03                     = IOMUX_PAD(0x035C, 0x00D0, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__KPP_COL01                      = IOMUX_PAD(0x035C, 0x00D0, 6, 0x05C8, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__USDHC2_VSELECT                 = IOMUX_PAD(0x035C, 0x00D0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01                  = IOMUX_PAD(0x0360, 0x00D4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__UART6_DCE_CTS                  = IOMUX_PAD(0x0360, 0x00D4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__UART6_DTE_RTS                  = IOMUX_PAD(0x0360, 0x00D4, 1, 0x0648, 2, 0),
+	MX6_PAD_ENET1_TX_DATA1__PWM5_OUT                       = IOMUX_PAD(0x0360, 0x00D4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__CSI_DATA20                     = IOMUX_PAD(0x0360, 0x00D4, 3, 0x0514, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__ENET2_MDIO                     = IOMUX_PAD(0x0360, 0x00D4, 4, 0x0580, 1, 0),
+	MX6_PAD_ENET1_TX_DATA1__GPIO2_IO04                     = IOMUX_PAD(0x0360, 0x00D4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__KPP_ROW02                      = IOMUX_PAD(0x0360, 0x00D4, 6, 0x05D8, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__WDOG1_WDOG_RST_B_DEB           = IOMUX_PAD(0x0360, 0x00D4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN                       = IOMUX_PAD(0x0364, 0x00D8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__UART6_DCE_RTS                     = IOMUX_PAD(0x0364, 0x00D8, 1, 0x0648, 3, 0),
+	MX6_PAD_ENET1_TX_EN__UART6_DTE_CTS                     = IOMUX_PAD(0x0364, 0x00D8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__PWM6_OUT                          = IOMUX_PAD(0x0364, 0x00D8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__CSI_DATA21                        = IOMUX_PAD(0x0364, 0x00D8, 3, 0x0518, 0, 0),
+	MX6_PAD_ENET1_TX_EN__ENET2_MDC                         = IOMUX_PAD(0x0364, 0x00D8, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__GPIO2_IO05                        = IOMUX_PAD(0x0364, 0x00D8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__KPP_COL02                         = IOMUX_PAD(0x0364, 0x00D8, 6, 0x05CC, 0, 0),
+	MX6_PAD_ENET1_TX_EN__WDOG2_WDOG_RST_B_DEB              = IOMUX_PAD(0x0364, 0x00D8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_CLK__ENET1_TX_CLK                     = IOMUX_PAD(0x0368, 0x00DC, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__UART7_DCE_CTS                    = IOMUX_PAD(0x0368, 0x00DC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__UART7_DTE_RTS                    = IOMUX_PAD(0x0368, 0x00DC, 1, 0x0650, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__PWM7_OUT                         = IOMUX_PAD(0x0368, 0x00DC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__CSI_DATA22                       = IOMUX_PAD(0x0368, 0x00DC, 3, 0x051C, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1                   = IOMUX_PAD(0x0368, 0x00DC, IOMUX_CONFIG_SION | 4, 0x0574, 2, 0),
+	MX6_PAD_ENET1_TX_CLK__GPIO2_IO06                       = IOMUX_PAD(0x0368, 0x00DC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__KPP_ROW03                        = IOMUX_PAD(0x0368, 0x00DC, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__GPT1_CLK                         = IOMUX_PAD(0x0368, 0x00DC, 8, 0x0594, 1, 0),
+
+	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER                       = IOMUX_PAD(0x036C, 0x00E0, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__UART7_DCE_RTS                     = IOMUX_PAD(0x036C, 0x00E0, 1, 0x0650, 1, 0),
+	MX6_PAD_ENET1_RX_ER__UART7_DTE_CTS                     = IOMUX_PAD(0x036C, 0x00E0, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__PWM8_OUT                          = IOMUX_PAD(0x036C, 0x00E0, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__CSI_DATA23                        = IOMUX_PAD(0x036C, 0x00E0, 3, 0x0520, 0, 0),
+	MX6_PAD_ENET1_RX_ER__EIM_CRE                           = IOMUX_PAD(0x036C, 0x00E0, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__GPIO2_IO07                        = IOMUX_PAD(0x036C, 0x00E0, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__KPP_COL03                         = IOMUX_PAD(0x036C, 0x00E0, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__GPT1_CAPTURE2                     = IOMUX_PAD(0x036C, 0x00E0, 8, 0x0590, 1, 0),
+
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00                  = IOMUX_PAD(0x0370, 0x00E4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__UART6_DCE_TX                   = IOMUX_PAD(0x0370, 0x00E4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__UART6_DTE_RX                   = IOMUX_PAD(0x0370, 0x00E4, 1, 0x064C, 1, 0),
+	MX6_PAD_ENET2_RX_DATA0__SIM1_PORT0_TRXD                = IOMUX_PAD(0x0370, 0x00E4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__I2C3_SCL                       = IOMUX_PAD(0x0370, 0x00E4, IOMUX_CONFIG_SION | 3, 0x05B4, 1, 0),
+	MX6_PAD_ENET2_RX_DATA0__ENET1_MDIO                     = IOMUX_PAD(0x0370, 0x00E4, 4, 0x0578, 1, 0),
+	MX6_PAD_ENET2_RX_DATA0__GPIO2_IO08                     = IOMUX_PAD(0x0370, 0x00E4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__KPP_ROW04                      = IOMUX_PAD(0x0370, 0x00E4, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__USB_OTG1_PWR                   = IOMUX_PAD(0x0370, 0x00E4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01                  = IOMUX_PAD(0x0374, 0x00E8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__UART6_DCE_RX                   = IOMUX_PAD(0x0374, 0x00E8, 1, 0x064C, 2, 0),
+	MX6_PAD_ENET2_RX_DATA1__UART6_DTE_TX                   = IOMUX_PAD(0x0374, 0x00E8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__SIM1_PORT0_CLK                 = IOMUX_PAD(0x0374, 0x00E8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__I2C3_SDA                       = IOMUX_PAD(0x0374, 0x00E8, IOMUX_CONFIG_SION | 3, 0x05B8, 1, 0),
+	MX6_PAD_ENET2_RX_DATA1__ENET1_MDC                      = IOMUX_PAD(0x0374, 0x00E8, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__GPIO2_IO09                     = IOMUX_PAD(0x0374, 0x00E8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__KPP_COL04                      = IOMUX_PAD(0x0374, 0x00E8, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__USB_OTG1_OC                    = IOMUX_PAD(0x0374, 0x00E8, 8, 0x0664, 1, 0),
+
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN                       = IOMUX_PAD(0x0378, 0x00EC, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__UART7_DCE_TX                      = IOMUX_PAD(0x0378, 0x00EC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__UART7_DTE_RX                      = IOMUX_PAD(0x0378, 0x00EC, 1, 0x0654, 0, 0),
+	MX6_PAD_ENET2_RX_EN__SIM1_PORT0_RST_B                  = IOMUX_PAD(0x0378, 0x00EC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__I2C4_SCL                          = IOMUX_PAD(0x0378, 0x00EC, IOMUX_CONFIG_SION | 3, 0x05BC, 1, 0),
+	MX6_PAD_ENET2_RX_EN__EIM_ADDR26                        = IOMUX_PAD(0x0378, 0x00EC, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__GPIO2_IO10                        = IOMUX_PAD(0x0378, 0x00EC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__KPP_ROW05                         = IOMUX_PAD(0x0378, 0x00EC, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__ENET1_REF_CLK_25M                 = IOMUX_PAD(0x0378, 0x00EC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00                  = IOMUX_PAD(0x037C, 0x00F0, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__UART7_DCE_RX                   = IOMUX_PAD(0x037C, 0x00F0, 1, 0x0654, 1, 0),
+	MX6_PAD_ENET2_TX_DATA0__UART7_DTE_TX                   = IOMUX_PAD(0x037C, 0x00F0, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__SIM1_PORT0_SVEN                = IOMUX_PAD(0x037C, 0x00F0, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__I2C4_SDA                       = IOMUX_PAD(0x037C, 0x00F0, IOMUX_CONFIG_SION | 3, 0x05C0, 1, 0),
+	MX6_PAD_ENET2_TX_DATA0__EIM_EB_B02                     = IOMUX_PAD(0x037C, 0x00F0, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__GPIO2_IO11                     = IOMUX_PAD(0x037C, 0x00F0, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__KPP_COL05                      = IOMUX_PAD(0x037C, 0x00F0, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__REF_CLK_24M                    = IOMUX_PAD(0x037C, 0x00F0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01                  = IOMUX_PAD(0x0380, 0x00F4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__UART8_DCE_TX                   = IOMUX_PAD(0x0380, 0x00F4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__UART8_DTE_RX                   = IOMUX_PAD(0x0380, 0x00F4, 1, 0x065C, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__SIM2_PORT0_TRXD                = IOMUX_PAD(0x0380, 0x00F4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__ECSPI4_SCLK                    = IOMUX_PAD(0x0380, 0x00F4, 3, 0x0564, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__EIM_EB_B03                     = IOMUX_PAD(0x0380, 0x00F4, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__GPIO2_IO12                     = IOMUX_PAD(0x0380, 0x00F4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__KPP_ROW06                      = IOMUX_PAD(0x0380, 0x00F4, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__USB_OTG2_PWR                   = IOMUX_PAD(0x0380, 0x00F4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN                       = IOMUX_PAD(0x0384, 0x00F8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__UART8_DCE_RX                      = IOMUX_PAD(0x0384, 0x00F8, 1, 0x065C, 1, 0),
+	MX6_PAD_ENET2_TX_EN__UART8_DTE_TX                      = IOMUX_PAD(0x0384, 0x00F8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__SIM2_PORT0_CLK                    = IOMUX_PAD(0x0384, 0x00F8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__ECSPI4_MOSI                       = IOMUX_PAD(0x0384, 0x00F8, 3, 0x056C, 0, 0),
+	MX6_PAD_ENET2_TX_EN__EIM_ACLK_FREERUN                  = IOMUX_PAD(0x0384, 0x00F8, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__GPIO2_IO13                        = IOMUX_PAD(0x0384, 0x00F8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__KPP_COL06                         = IOMUX_PAD(0x0384, 0x00F8, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__USB_OTG2_OC                       = IOMUX_PAD(0x0384, 0x00F8, 8, 0x0660, 1, 0),
+
+	MX6_PAD_ENET2_TX_CLK__ENET2_TX_CLK                     = IOMUX_PAD(0x0388, 0x00FC, IOMUX_CONFIG_SION | 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__UART8_DCE_CTS                    = IOMUX_PAD(0x0388, 0x00FC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__UART8_DTE_RTS                    = IOMUX_PAD(0x0388, 0x00FC, 1, 0x0658, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__SIM2_PORT0_RST_B                 = IOMUX_PAD(0x0388, 0x00FC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__ECSPI4_MISO                      = IOMUX_PAD(0x0388, 0x00FC, 3, 0x0568, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2                   = IOMUX_PAD(0x0388, 0x00FC, IOMUX_CONFIG_SION | 4, 0x057C, 2, 0),
+	MX6_PAD_ENET2_TX_CLK__GPIO2_IO14                       = IOMUX_PAD(0x0388, 0x00FC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__KPP_ROW07                        = IOMUX_PAD(0x0388, 0x00FC, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__ANATOP_OTG2_ID                   = IOMUX_PAD(0x0388, 0x00FC, 8, 0x04BC, 1, 0),
+
+	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER                       = IOMUX_PAD(0x038C, 0x0100, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__UART8_DCE_RTS                     = IOMUX_PAD(0x038C, 0x0100, 1, 0x0658, 1, 0),
+	MX6_PAD_ENET2_RX_ER__UART8_DTE_CTS                     = IOMUX_PAD(0x038C, 0x0100, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__SIM2_PORT0_SVEN                   = IOMUX_PAD(0x038C, 0x0100, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__ECSPI4_SS0                        = IOMUX_PAD(0x038C, 0x0100, 3, 0x0570, 0, 0),
+	MX6_PAD_ENET2_RX_ER__EIM_ADDR25                        = IOMUX_PAD(0x038C, 0x0100, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__GPIO2_IO15                        = IOMUX_PAD(0x038C, 0x0100, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__KPP_COL07                         = IOMUX_PAD(0x038C, 0x0100, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__WDOG1_WDOG_ANY                    = IOMUX_PAD(0x038C, 0x0100, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_CLK__LCDIF_CLK                             = IOMUX_PAD(0x0390, 0x0104, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__LCDIF_WR_RWN                          = IOMUX_PAD(0x0390, 0x0104, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__UART4_DCE_TX                          = IOMUX_PAD(0x0390, 0x0104, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__UART4_DTE_RX                          = IOMUX_PAD(0x0390, 0x0104, 2, 0x063C, 2, 0),
+	MX6_PAD_LCD_CLK__SAI3_MCLK                             = IOMUX_PAD(0x0390, 0x0104, 3, 0x0600, 0, 0),
+	MX6_PAD_LCD_CLK__EIM_CS2_B                             = IOMUX_PAD(0x0390, 0x0104, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__GPIO3_IO00                            = IOMUX_PAD(0x0390, 0x0104, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__WDOG1_WDOG_RST_B_DEB                  = IOMUX_PAD(0x0390, 0x0104, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE                       = IOMUX_PAD(0x0394, 0x0108, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__LCDIF_RD_E                         = IOMUX_PAD(0x0394, 0x0108, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__UART4_DCE_RX                       = IOMUX_PAD(0x0394, 0x0108, 2, 0x063C, 3, 0),
+	MX6_PAD_LCD_ENABLE__UART4_DTE_TX                       = IOMUX_PAD(0x0394, 0x0108, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__SAI3_TX_SYNC                       = IOMUX_PAD(0x0394, 0x0108, 3, 0x060C, 0, 0),
+	MX6_PAD_LCD_ENABLE__EIM_CS3_B                          = IOMUX_PAD(0x0394, 0x0108, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__GPIO3_IO01                         = IOMUX_PAD(0x0394, 0x0108, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__ECSPI2_RDY                         = IOMUX_PAD(0x0394, 0x0108, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC                         = IOMUX_PAD(0x0398, 0x010C, 0, 0x05DC, 0, 0),
+	MX6_PAD_LCD_HSYNC__LCDIF_RS                            = IOMUX_PAD(0x0398, 0x010C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__UART4_DCE_CTS                       = IOMUX_PAD(0x0398, 0x010C, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__UART4_DTE_RTS                       = IOMUX_PAD(0x0398, 0x010C, 2, 0x0638, 2, 0),
+	MX6_PAD_LCD_HSYNC__SAI3_TX_BCLK                        = IOMUX_PAD(0x0398, 0x010C, 3, 0x0608, 0, 0),
+	MX6_PAD_LCD_HSYNC__WDOG3_WDOG_RST_B_DEB                = IOMUX_PAD(0x0398, 0x010C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__GPIO3_IO02                          = IOMUX_PAD(0x0398, 0x010C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__ECSPI2_SS1                          = IOMUX_PAD(0x0398, 0x010C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC                         = IOMUX_PAD(0x039C, 0x0110, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__LCDIF_BUSY                          = IOMUX_PAD(0x039C, 0x0110, 1, 0x05DC, 1, 0),
+	MX6_PAD_LCD_VSYNC__UART4_DCE_RTS                       = IOMUX_PAD(0x039C, 0x0110, 2, 0x0638, 3, 0),
+	MX6_PAD_LCD_VSYNC__UART4_DTE_CTS                       = IOMUX_PAD(0x039C, 0x0110, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__SAI3_RX_DATA                        = IOMUX_PAD(0x039C, 0x0110, 3, 0x0604, 0, 0),
+	MX6_PAD_LCD_VSYNC__WDOG2_WDOG_B                        = IOMUX_PAD(0x039C, 0x0110, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__GPIO3_IO03                          = IOMUX_PAD(0x039C, 0x0110, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__ECSPI2_SS2                          = IOMUX_PAD(0x039C, 0x0110, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_RESET__LCDIF_RESET                         = IOMUX_PAD(0x03A0, 0x0114, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__LCDIF_CS                            = IOMUX_PAD(0x03A0, 0x0114, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__CA7_MX6UL_EVENTI                    = IOMUX_PAD(0x03A0, 0x0114, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__SAI3_TX_DATA                        = IOMUX_PAD(0x03A0, 0x0114, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__WDOG1_WDOG_ANY                      = IOMUX_PAD(0x03A0, 0x0114, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__GPIO3_IO04                          = IOMUX_PAD(0x03A0, 0x0114, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__ECSPI2_SS3                          = IOMUX_PAD(0x03A0, 0x0114, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00                       = IOMUX_PAD(0x03A4, 0x0118, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__PWM1_OUT                           = IOMUX_PAD(0x03A4, 0x0118, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__CA7_MX6UL_TRACE0                   = IOMUX_PAD(0x03A4, 0x0118, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__ENET1_1588_EVENT2_IN               = IOMUX_PAD(0x03A4, 0x0118, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__I2C3_SDA                           = IOMUX_PAD(0x03A4, 0x0118, IOMUX_CONFIG_SION | 4, 0x05B8, 2, 0),
+	MX6_PAD_LCD_DATA00__GPIO3_IO05                         = IOMUX_PAD(0x03A4, 0x0118, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__SRC_BT_CFG00                       = IOMUX_PAD(0x03A4, 0x0118, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__SAI1_MCLK                          = IOMUX_PAD(0x03A4, 0x0118, 8, 0x05E0, 1, 0),
+
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01                       = IOMUX_PAD(0x03A8, 0x011C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__PWM2_OUT                           = IOMUX_PAD(0x03A8, 0x011C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__CA7_MX6UL_TRACE1                   = IOMUX_PAD(0x03A8, 0x011C, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__ENET1_1588_EVENT2_OUT              = IOMUX_PAD(0x03A8, 0x011C, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__I2C3_SCL                           = IOMUX_PAD(0x03A8, 0x011C, IOMUX_CONFIG_SION | 4, 0x05B4, 2, 0),
+	MX6_PAD_LCD_DATA01__GPIO3_IO06                         = IOMUX_PAD(0x03A8, 0x011C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__SRC_BT_CFG01                       = IOMUX_PAD(0x03A8, 0x011C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__SAI1_TX_SYNC                       = IOMUX_PAD(0x03A8, 0x011C, 8, 0x05EC, 0, 0),
+
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02                       = IOMUX_PAD(0x03AC, 0x0120, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__PWM3_OUT                           = IOMUX_PAD(0x03AC, 0x0120, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__CA7_MX6UL_TRACE2                   = IOMUX_PAD(0x03AC, 0x0120, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__ENET1_1588_EVENT3_IN               = IOMUX_PAD(0x03AC, 0x0120, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__I2C4_SDA                           = IOMUX_PAD(0x03AC, 0x0120, IOMUX_CONFIG_SION | 4, 0x05C0, 2, 0),
+	MX6_PAD_LCD_DATA02__GPIO3_IO07                         = IOMUX_PAD(0x03AC, 0x0120, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__SRC_BT_CFG02                       = IOMUX_PAD(0x03AC, 0x0120, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__SAI1_TX_BCLK                       = IOMUX_PAD(0x03AC, 0x0120, 8, 0x05E8, 0, 0),
+
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03                       = IOMUX_PAD(0x03B0, 0x0124, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__PWM4_OUT                           = IOMUX_PAD(0x03B0, 0x0124, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__CA7_MX6UL_TRACE3                   = IOMUX_PAD(0x03B0, 0x0124, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__ENET1_1588_EVENT3_OUT              = IOMUX_PAD(0x03B0, 0x0124, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__I2C4_SCL                           = IOMUX_PAD(0x03B0, 0x0124, IOMUX_CONFIG_SION | 4, 0x05BC, 2, 0),
+	MX6_PAD_LCD_DATA03__GPIO3_IO08                         = IOMUX_PAD(0x03B0, 0x0124, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__SRC_BT_CFG03                       = IOMUX_PAD(0x03B0, 0x0124, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__SAI1_RX_DATA                       = IOMUX_PAD(0x03B0, 0x0124, 8, 0x05E4, 0, 0),
+
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04                       = IOMUX_PAD(0x03B4, 0x0128, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__UART8_DCE_CTS                      = IOMUX_PAD(0x03B4, 0x0128, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__UART8_DTE_RTS                      = IOMUX_PAD(0x03B4, 0x0128, 1, 0x0658, 2, 0),
+	MX6_PAD_LCD_DATA04__CA7_MX6UL_TRACE4                   = IOMUX_PAD(0x03B4, 0x0128, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__ENET2_1588_EVENT2_IN               = IOMUX_PAD(0x03B4, 0x0128, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SPDIF_SR_CLK                       = IOMUX_PAD(0x03B4, 0x0128, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__GPIO3_IO09                         = IOMUX_PAD(0x03B4, 0x0128, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SRC_BT_CFG04                       = IOMUX_PAD(0x03B4, 0x0128, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SAI1_TX_DATA                       = IOMUX_PAD(0x03B4, 0x0128, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05                       = IOMUX_PAD(0x03B8, 0x012C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__UART8_DCE_RTS                      = IOMUX_PAD(0x03B8, 0x012C, 1, 0x0658, 3, 0),
+	MX6_PAD_LCD_DATA05__UART8_DTE_CTS                      = IOMUX_PAD(0x03B8, 0x012C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__CA7_MX6UL_TRACE5                   = IOMUX_PAD(0x03B8, 0x012C, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__ENET2_1588_EVENT2_OUT              = IOMUX_PAD(0x03B8, 0x012C, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__SPDIF_OUT                          = IOMUX_PAD(0x03B8, 0x012C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__GPIO3_IO10                         = IOMUX_PAD(0x03B8, 0x012C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__SRC_BT_CFG05                       = IOMUX_PAD(0x03B8, 0x012C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__ECSPI1_SS1                         = IOMUX_PAD(0x03B8, 0x012C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06                       = IOMUX_PAD(0x03BC, 0x0130, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__UART7_DCE_CTS                      = IOMUX_PAD(0x03BC, 0x0130, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__UART7_DTE_RTS                      = IOMUX_PAD(0x03BC, 0x0130, 1, 0x0650, 2, 0),
+	MX6_PAD_LCD_DATA06__CA7_MX6UL_TRACE6                   = IOMUX_PAD(0x03BC, 0x0130, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__ENET2_1588_EVENT3_IN               = IOMUX_PAD(0x03BC, 0x0130, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__SPDIF_LOCK                         = IOMUX_PAD(0x03BC, 0x0130, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__GPIO3_IO11                         = IOMUX_PAD(0x03BC, 0x0130, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__SRC_BT_CFG06                       = IOMUX_PAD(0x03BC, 0x0130, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__ECSPI1_SS2                         = IOMUX_PAD(0x03BC, 0x0130, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07                       = IOMUX_PAD(0x03C0, 0x0134, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__UART7_DCE_RTS                      = IOMUX_PAD(0x03C0, 0x0134, 1, 0x0650, 3, 0),
+	MX6_PAD_LCD_DATA07__UART7_DTE_CTS                      = IOMUX_PAD(0x03C0, 0x0134, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__CA7_MX6UL_TRACE7                   = IOMUX_PAD(0x03C0, 0x0134, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__ENET2_1588_EVENT3_OUT              = IOMUX_PAD(0x03C0, 0x0134, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__SPDIF_EXT_CLK                      = IOMUX_PAD(0x03C0, 0x0134, 4, 0x061C, 0, 0),
+	MX6_PAD_LCD_DATA07__GPIO3_IO12                         = IOMUX_PAD(0x03C0, 0x0134, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__SRC_BT_CFG07                       = IOMUX_PAD(0x03C0, 0x0134, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__ECSPI1_SS3                         = IOMUX_PAD(0x03C0, 0x0134, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08                       = IOMUX_PAD(0x03C4, 0x0138, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__SPDIF_IN                           = IOMUX_PAD(0x03C4, 0x0138, 1, 0x0618, 2, 0),
+	MX6_PAD_LCD_DATA08__CA7_MX6UL_TRACE8                   = IOMUX_PAD(0x03C4, 0x0138, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__CSI_DATA16                         = IOMUX_PAD(0x03C4, 0x0138, 3, 0x0504, 1, 0),
+	MX6_PAD_LCD_DATA08__EIM_DATA00                         = IOMUX_PAD(0x03C4, 0x0138, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__GPIO3_IO13                         = IOMUX_PAD(0x03C4, 0x0138, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__SRC_BT_CFG08                       = IOMUX_PAD(0x03C4, 0x0138, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__FLEXCAN1_TX                        = IOMUX_PAD(0x03C4, 0x0138, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09                       = IOMUX_PAD(0x03C8, 0x013C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__SAI3_MCLK                          = IOMUX_PAD(0x03C8, 0x013C, 1, 0x0600, 1, 0),
+	MX6_PAD_LCD_DATA09__CA7_MX6UL_TRACE9                   = IOMUX_PAD(0x03C8, 0x013C, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__CSI_DATA17                         = IOMUX_PAD(0x03C8, 0x013C, 3, 0x0508, 1, 0),
+	MX6_PAD_LCD_DATA09__EIM_DATA01                         = IOMUX_PAD(0x03C8, 0x013C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__GPIO3_IO14                         = IOMUX_PAD(0x03C8, 0x013C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__SRC_BT_CFG09                       = IOMUX_PAD(0x03C8, 0x013C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__FLEXCAN1_RX                        = IOMUX_PAD(0x03C8, 0x013C, 8, 0x0584, 2, 0),
+
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10                       = IOMUX_PAD(0x03CC, 0x0140, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__SAI3_RX_SYNC                       = IOMUX_PAD(0x03CC, 0x0140, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__CA7_MX6UL_TRACE10                  = IOMUX_PAD(0x03CC, 0x0140, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__CSI_DATA18                         = IOMUX_PAD(0x03CC, 0x0140, 3, 0x050C, 1, 0),
+	MX6_PAD_LCD_DATA10__EIM_DATA02                         = IOMUX_PAD(0x03CC, 0x0140, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__GPIO3_IO15                         = IOMUX_PAD(0x03CC, 0x0140, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__SRC_BT_CFG10                       = IOMUX_PAD(0x03CC, 0x0140, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__FLEXCAN2_TX                        = IOMUX_PAD(0x03CC, 0x0140, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11                       = IOMUX_PAD(0x03D0, 0x0144, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__SAI3_RX_BCLK                       = IOMUX_PAD(0x03D0, 0x0144, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__CA7_MX6UL_TRACE11                  = IOMUX_PAD(0x03D0, 0x0144, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__CSI_DATA19                         = IOMUX_PAD(0x03D0, 0x0144, 3, 0x0510, 1, 0),
+	MX6_PAD_LCD_DATA11__EIM_DATA03                         = IOMUX_PAD(0x03D0, 0x0144, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__GPIO3_IO16                         = IOMUX_PAD(0x03D0, 0x0144, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__SRC_BT_CFG11                       = IOMUX_PAD(0x03D0, 0x0144, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__FLEXCAN2_RX                        = IOMUX_PAD(0x03D0, 0x0144, 8, 0x0588, 2, 0),
+
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12                       = IOMUX_PAD(0x03D4, 0x0148, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__SAI3_TX_SYNC                       = IOMUX_PAD(0x03D4, 0x0148, 1, 0x060C, 1, 0),
+	MX6_PAD_LCD_DATA12__CA7_MX6UL_TRACE12                  = IOMUX_PAD(0x03D4, 0x0148, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__CSI_DATA20                         = IOMUX_PAD(0x03D4, 0x0148, 3, 0x0514, 1, 0),
+	MX6_PAD_LCD_DATA12__EIM_DATA04                         = IOMUX_PAD(0x03D4, 0x0148, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__GPIO3_IO17                         = IOMUX_PAD(0x03D4, 0x0148, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__SRC_BT_CFG12                       = IOMUX_PAD(0x03D4, 0x0148, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__ECSPI1_RDY                         = IOMUX_PAD(0x03D4, 0x0148, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13                       = IOMUX_PAD(0x03D8, 0x014C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__SAI3_TX_BCLK                       = IOMUX_PAD(0x03D8, 0x014C, 1, 0x0608, 1, 0),
+	MX6_PAD_LCD_DATA13__CA7_MX6UL_TRACE13                  = IOMUX_PAD(0x03D8, 0x014C, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__CSI_DATA21                         = IOMUX_PAD(0x03D8, 0x014C, 3, 0x0518, 1, 0),
+	MX6_PAD_LCD_DATA13__EIM_DATA05                         = IOMUX_PAD(0x03D8, 0x014C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__GPIO3_IO18                         = IOMUX_PAD(0x03D8, 0x014C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__SRC_BT_CFG13                       = IOMUX_PAD(0x03D8, 0x014C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__USDHC2_RESET_B                     = IOMUX_PAD(0x03D8, 0x014C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14                       = IOMUX_PAD(0x03DC, 0x0150, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__SAI3_RX_DATA                       = IOMUX_PAD(0x03DC, 0x0150, 1, 0x0604, 1, 0),
+	MX6_PAD_LCD_DATA14__CA7_MX6UL_TRACE14                  = IOMUX_PAD(0x03DC, 0x0150, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__CSI_DATA22                         = IOMUX_PAD(0x03DC, 0x0150, 3, 0x051C, 1, 0),
+	MX6_PAD_LCD_DATA14__EIM_DATA06                         = IOMUX_PAD(0x03DC, 0x0150, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__GPIO3_IO19                         = IOMUX_PAD(0x03DC, 0x0150, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__SRC_BT_CFG14                       = IOMUX_PAD(0x03DC, 0x0150, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__USDHC2_DATA4                       = IOMUX_PAD(0x03DC, 0x0150, 8, 0x068C, 0, 0),
+
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15                       = IOMUX_PAD(0x03E0, 0x0154, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__SAI3_TX_DATA                       = IOMUX_PAD(0x03E0, 0x0154, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__CA7_MX6UL_TRACE15                  = IOMUX_PAD(0x03E0, 0x0154, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__CSI_DATA23                         = IOMUX_PAD(0x03E0, 0x0154, 3, 0x0520, 1, 0),
+	MX6_PAD_LCD_DATA15__EIM_DATA07                         = IOMUX_PAD(0x03E0, 0x0154, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__GPIO3_IO20                         = IOMUX_PAD(0x03E0, 0x0154, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__SRC_BT_CFG15                       = IOMUX_PAD(0x03E0, 0x0154, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__USDHC2_DATA5                       = IOMUX_PAD(0x03E0, 0x0154, 8, 0x0690, 0, 0),
+
+	MX6_PAD_LCD_DATA16__LCDIF_DATA16                       = IOMUX_PAD(0x03E4, 0x0158, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__UART7_DCE_TX                       = IOMUX_PAD(0x03E4, 0x0158, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__UART7_DTE_RX                       = IOMUX_PAD(0x03E4, 0x0158, 1, 0x0654, 2, 0),
+	MX6_PAD_LCD_DATA16__CA7_MX6UL_TRACE_CLK                = IOMUX_PAD(0x03E4, 0x0158, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__CSI_DATA01                         = IOMUX_PAD(0x03E4, 0x0158, 3, 0x04D4, 1, 0),
+	MX6_PAD_LCD_DATA16__EIM_DATA08                         = IOMUX_PAD(0x03E4, 0x0158, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__GPIO3_IO21                         = IOMUX_PAD(0x03E4, 0x0158, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__SRC_BT_CFG24                       = IOMUX_PAD(0x03E4, 0x0158, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__USDHC2_DATA6                       = IOMUX_PAD(0x03E4, 0x0158, 8, 0x0694, 0, 0),
+
+	MX6_PAD_LCD_DATA17__LCDIF_DATA17                       = IOMUX_PAD(0x03E8, 0x015C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__UART7_DCE_RX                       = IOMUX_PAD(0x03E8, 0x015C, 1, 0x0654, 3, 0),
+	MX6_PAD_LCD_DATA17__UART7_DTE_TX                       = IOMUX_PAD(0x03E8, 0x015C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__CA7_MX6UL_TRACE_CTL                = IOMUX_PAD(0x03E8, 0x015C, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__CSI_DATA00                         = IOMUX_PAD(0x03E8, 0x015C, 3, 0x04D0, 1, 0),
+	MX6_PAD_LCD_DATA17__EIM_DATA09                         = IOMUX_PAD(0x03E8, 0x015C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__GPIO3_IO22                         = IOMUX_PAD(0x03E8, 0x015C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__SRC_BT_CFG25                       = IOMUX_PAD(0x03E8, 0x015C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__USDHC2_DATA7                       = IOMUX_PAD(0x03E8, 0x015C, 8, 0x0698, 0, 0),
+
+	MX6_PAD_LCD_DATA18__LCDIF_DATA18                       = IOMUX_PAD(0x03EC, 0x0160, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__PWM5_OUT                           = IOMUX_PAD(0x03EC, 0x0160, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__CA7_MX6UL_EVENTO                   = IOMUX_PAD(0x03EC, 0x0160, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__CSI_DATA10                         = IOMUX_PAD(0x03EC, 0x0160, 3, 0x04EC, 1, 0),
+	MX6_PAD_LCD_DATA18__EIM_DATA10                         = IOMUX_PAD(0x03EC, 0x0160, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__GPIO3_IO23                         = IOMUX_PAD(0x03EC, 0x0160, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__SRC_BT_CFG26                       = IOMUX_PAD(0x03EC, 0x0160, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__USDHC2_CMD                         = IOMUX_PAD(0x03EC, 0x0160, 8, 0x0678, 1, 0),
+	MX6_PAD_LCD_DATA19__EIM_DATA11                         = IOMUX_PAD(0x03F0, 0x0164, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__GPIO3_IO24                         = IOMUX_PAD(0x03F0, 0x0164, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__SRC_BT_CFG27                       = IOMUX_PAD(0x03F0, 0x0164, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__USDHC2_CLK                         = IOMUX_PAD(0x03F0, 0x0164, 8, 0x0670, 1, 0),
+
+	MX6_PAD_LCD_DATA19__LCDIF_DATA19                       = IOMUX_PAD(0x03F0, 0x0164, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__PWM6_OUT                           = IOMUX_PAD(0x03F0, 0x0164, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__WDOG1_WDOG_ANY                     = IOMUX_PAD(0x03F0, 0x0164, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__CSI_DATA11                         = IOMUX_PAD(0x03F0, 0x0164, 3, 0x04F0, 1, 0),
+	MX6_PAD_LCD_DATA20__EIM_DATA12                         = IOMUX_PAD(0x03F4, 0x0168, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__GPIO3_IO25                         = IOMUX_PAD(0x03F4, 0x0168, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__SRC_BT_CFG28                       = IOMUX_PAD(0x03F4, 0x0168, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__USDHC2_DATA0                       = IOMUX_PAD(0x03F4, 0x0168, 8, 0x067C, 1, 0),
+
+	MX6_PAD_LCD_DATA20__LCDIF_DATA20                       = IOMUX_PAD(0x03F4, 0x0168, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__UART8_DCE_TX                       = IOMUX_PAD(0x03F4, 0x0168, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__UART8_DTE_RX                       = IOMUX_PAD(0x03F4, 0x0168, 1, 0x065C, 2, 0),
+	MX6_PAD_LCD_DATA20__ECSPI1_SCLK                        = IOMUX_PAD(0x03F4, 0x0168, 2, 0x0534, 0, 0),
+	MX6_PAD_LCD_DATA20__CSI_DATA12                         = IOMUX_PAD(0x03F4, 0x0168, 3, 0x04F4, 1, 0),
+
+	MX6_PAD_LCD_DATA21__LCDIF_DATA21                       = IOMUX_PAD(0x03F8, 0x016C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__UART8_DCE_RX                       = IOMUX_PAD(0x03F8, 0x016C, 1, 0x065C, 3, 0),
+	MX6_PAD_LCD_DATA21__UART8_DTE_TX                       = IOMUX_PAD(0x03F8, 0x016C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__ECSPI1_SS0                         = IOMUX_PAD(0x03F8, 0x016C, 2, 0x0540, 0, 0),
+	MX6_PAD_LCD_DATA21__CSI_DATA13                         = IOMUX_PAD(0x03F8, 0x016C, 3, 0x04F8, 1, 0),
+	MX6_PAD_LCD_DATA21__EIM_DATA13                         = IOMUX_PAD(0x03F8, 0x016C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__GPIO3_IO26                         = IOMUX_PAD(0x03F8, 0x016C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__SRC_BT_CFG29                       = IOMUX_PAD(0x03F8, 0x016C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__USDHC2_DATA1                       = IOMUX_PAD(0x03F8, 0x016C, 8, 0x0680, 1, 0),
+
+	MX6_PAD_LCD_DATA22__LCDIF_DATA22                       = IOMUX_PAD(0x03FC, 0x0170, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__MQS_RIGHT                          = IOMUX_PAD(0x03FC, 0x0170, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__ECSPI1_MOSI                        = IOMUX_PAD(0x03FC, 0x0170, 2, 0x053C, 0, 0),
+	MX6_PAD_LCD_DATA22__CSI_DATA14                         = IOMUX_PAD(0x03FC, 0x0170, 3, 0x04FC, 1, 0),
+	MX6_PAD_LCD_DATA22__EIM_DATA14                         = IOMUX_PAD(0x03FC, 0x0170, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__GPIO3_IO27                         = IOMUX_PAD(0x03FC, 0x0170, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__SRC_BT_CFG30                       = IOMUX_PAD(0x03FC, 0x0170, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__USDHC2_DATA2                       = IOMUX_PAD(0x03FC, 0x0170, 8, 0x0684, 0, 0),
+
+	MX6_PAD_LCD_DATA23__LCDIF_DATA23                       = IOMUX_PAD(0x0400, 0x0174, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__MQS_LEFT                           = IOMUX_PAD(0x0400, 0x0174, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__ECSPI1_MISO                        = IOMUX_PAD(0x0400, 0x0174, 2, 0x0538, 0, 0),
+	MX6_PAD_LCD_DATA23__CSI_DATA15                         = IOMUX_PAD(0x0400, 0x0174, 3, 0x0500, 1, 0),
+	MX6_PAD_LCD_DATA23__EIM_DATA15                         = IOMUX_PAD(0x0400, 0x0174, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__GPIO3_IO28                         = IOMUX_PAD(0x0400, 0x0174, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__SRC_BT_CFG31                       = IOMUX_PAD(0x0400, 0x0174, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__USDHC2_DATA3                       = IOMUX_PAD(0x0400, 0x0174, 8, 0x0688, 1, 0),
+
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B                        = IOMUX_PAD(0x0404, 0x0178, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__USDHC2_CLK                          = IOMUX_PAD(0x0404, 0x0178, 1, 0x0670, 2, 0),
+	MX6_PAD_NAND_RE_B__QSPI_B_SCLK                         = IOMUX_PAD(0x0404, 0x0178, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__KPP_ROW00                           = IOMUX_PAD(0x0404, 0x0178, 3, 0x05D0, 1, 0),
+	MX6_PAD_NAND_RE_B__EIM_EB_B00                          = IOMUX_PAD(0x0404, 0x0178, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__GPIO4_IO00                          = IOMUX_PAD(0x0404, 0x0178, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__ECSPI3_SS2                          = IOMUX_PAD(0x0404, 0x0178, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B                        = IOMUX_PAD(0x0408, 0x017C, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__USDHC2_CMD                          = IOMUX_PAD(0x0408, 0x017C, 1, 0x0678, 2, 0),
+	MX6_PAD_NAND_WE_B__QSPI_B_SS0_B                        = IOMUX_PAD(0x0408, 0x017C, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__KPP_COL00                           = IOMUX_PAD(0x0408, 0x017C, 3, 0x05C4, 1, 0),
+	MX6_PAD_NAND_WE_B__EIM_EB_B01                          = IOMUX_PAD(0x0408, 0x017C, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__GPIO4_IO01                          = IOMUX_PAD(0x0408, 0x017C, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__ECSPI3_SS3                          = IOMUX_PAD(0x0408, 0x017C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00                    = IOMUX_PAD(0x040C, 0x0180, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0                      = IOMUX_PAD(0x040C, 0x0180, 1, 0x067C, 2, 0),
+	MX6_PAD_NAND_DATA00__QSPI_B_SS1_B                      = IOMUX_PAD(0x040C, 0x0180, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__KPP_ROW01                         = IOMUX_PAD(0x040C, 0x0180, 3, 0x05D4, 1, 0),
+	MX6_PAD_NAND_DATA00__EIM_AD08                          = IOMUX_PAD(0x040C, 0x0180, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__GPIO4_IO02                        = IOMUX_PAD(0x040C, 0x0180, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__ECSPI4_RDY                        = IOMUX_PAD(0x040C, 0x0180, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01                    = IOMUX_PAD(0x0410, 0x0184, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1                      = IOMUX_PAD(0x0410, 0x0184, 1, 0x0680, 2, 0),
+	MX6_PAD_NAND_DATA01__QSPI_B_DQS                        = IOMUX_PAD(0x0410, 0x0184, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__KPP_COL01                         = IOMUX_PAD(0x0410, 0x0184, 3, 0x05C8, 1, 0),
+	MX6_PAD_NAND_DATA01__EIM_AD09                          = IOMUX_PAD(0x0410, 0x0184, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__GPIO4_IO03                        = IOMUX_PAD(0x0410, 0x0184, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__ECSPI4_SS1                        = IOMUX_PAD(0x0410, 0x0184, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02                    = IOMUX_PAD(0x0414, 0x0188, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2                      = IOMUX_PAD(0x0414, 0x0188, 1, 0x0684, 1, 0),
+	MX6_PAD_NAND_DATA02__QSPI_B_DATA00                     = IOMUX_PAD(0x0414, 0x0188, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__KPP_ROW02                         = IOMUX_PAD(0x0414, 0x0188, 3, 0x05D8, 1, 0),
+	MX6_PAD_NAND_DATA02__EIM_AD10                          = IOMUX_PAD(0x0414, 0x0188, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__GPIO4_IO04                        = IOMUX_PAD(0x0414, 0x0188, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__ECSPI4_SS2                        = IOMUX_PAD(0x0414, 0x0188, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03                    = IOMUX_PAD(0x0418, 0x018C, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3                      = IOMUX_PAD(0x0418, 0x018C, 1, 0x0688, 2, 0),
+	MX6_PAD_NAND_DATA03__QSPI_B_DATA01                     = IOMUX_PAD(0x0418, 0x018C, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__KPP_COL02                         = IOMUX_PAD(0x0418, 0x018C, 3, 0x05CC, 1, 0),
+	MX6_PAD_NAND_DATA03__EIM_AD11                          = IOMUX_PAD(0x0418, 0x018C, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__GPIO4_IO05                        = IOMUX_PAD(0x0418, 0x018C, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__ECSPI4_SS3                        = IOMUX_PAD(0x0418, 0x018C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04                    = IOMUX_PAD(0x041C, 0x0190, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__USDHC2_DATA4                      = IOMUX_PAD(0x041C, 0x0190, 1, 0x068C, 1, 0),
+	MX6_PAD_NAND_DATA04__QSPI_B_DATA02                     = IOMUX_PAD(0x041C, 0x0190, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__ECSPI4_SCLK                       = IOMUX_PAD(0x041C, 0x0190, 3, 0x0564, 1, 0),
+	MX6_PAD_NAND_DATA04__EIM_AD12                          = IOMUX_PAD(0x041C, 0x0190, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__GPIO4_IO06                        = IOMUX_PAD(0x041C, 0x0190, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__UART2_DCE_TX                      = IOMUX_PAD(0x041C, 0x0190, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__UART2_DTE_RX                      = IOMUX_PAD(0x041C, 0x0190, 8, 0x062C, 2, 0),
+
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05                    = IOMUX_PAD(0x0420, 0x0194, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__USDHC2_DATA5                      = IOMUX_PAD(0x0420, 0x0194, 1, 0x0690, 1, 0),
+	MX6_PAD_NAND_DATA05__QSPI_B_DATA03                     = IOMUX_PAD(0x0420, 0x0194, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__ECSPI4_MOSI                       = IOMUX_PAD(0x0420, 0x0194, 3, 0x056C, 1, 0),
+	MX6_PAD_NAND_DATA05__EIM_AD13                          = IOMUX_PAD(0x0420, 0x0194, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__GPIO4_IO07                        = IOMUX_PAD(0x0420, 0x0194, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__UART2_DCE_RX                      = IOMUX_PAD(0x0420, 0x0194, 8, 0x062C, 3, 0),
+	MX6_PAD_NAND_DATA05__UART2_DTE_TX                      = IOMUX_PAD(0x0420, 0x0194, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06                    = IOMUX_PAD(0x0424, 0x0198, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__USDHC2_DATA6                      = IOMUX_PAD(0x0424, 0x0198, 1, 0x0694, 1, 0),
+	MX6_PAD_NAND_DATA06__SAI2_RX_BCLK                      = IOMUX_PAD(0x0424, 0x0198, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__ECSPI4_MISO                       = IOMUX_PAD(0x0424, 0x0198, 3, 0x0568, 1, 0),
+	MX6_PAD_NAND_DATA06__EIM_AD14                          = IOMUX_PAD(0x0424, 0x0198, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__GPIO4_IO08                        = IOMUX_PAD(0x0424, 0x0198, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__UART2_DCE_CTS                     = IOMUX_PAD(0x0424, 0x0198, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__UART2_DTE_RTS                     = IOMUX_PAD(0x0424, 0x0198, 8, 0x0628, 4, 0),
+
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07                    = IOMUX_PAD(0x0428, 0x019C, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__USDHC2_DATA7                      = IOMUX_PAD(0x0428, 0x019C, 1, 0x0698, 1, 0),
+	MX6_PAD_NAND_DATA07__QSPI_A_SS1_B                      = IOMUX_PAD(0x0428, 0x019C, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__ECSPI4_SS0                        = IOMUX_PAD(0x0428, 0x019C, 3, 0x0570, 1, 0),
+	MX6_PAD_NAND_DATA07__EIM_AD15                          = IOMUX_PAD(0x0428, 0x019C, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__GPIO4_IO09                        = IOMUX_PAD(0x0428, 0x019C, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__UART2_DCE_RTS                     = IOMUX_PAD(0x0428, 0x019C, 8, 0x0628, 5, 0),
+	MX6_PAD_NAND_DATA07__UART2_DTE_CTS                     = IOMUX_PAD(0x0428, 0x019C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_ALE__RAWNAND_ALE                          = IOMUX_PAD(0x042C, 0x01A0, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__USDHC2_RESET_B                       = IOMUX_PAD(0x042C, 0x01A0, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__QSPI_A_DQS                           = IOMUX_PAD(0x042C, 0x01A0, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__PWM3_OUT                             = IOMUX_PAD(0x042C, 0x01A0, 3, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__EIM_ADDR17                           = IOMUX_PAD(0x042C, 0x01A0, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__GPIO4_IO10                           = IOMUX_PAD(0x042C, 0x01A0, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__ECSPI3_SS1                           = IOMUX_PAD(0x042C, 0x01A0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B                        = IOMUX_PAD(0x0430, 0x01A4, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__USDHC1_RESET_B                      = IOMUX_PAD(0x0430, 0x01A4, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__QSPI_A_SCLK                         = IOMUX_PAD(0x0430, 0x01A4, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__PWM4_OUT                            = IOMUX_PAD(0x0430, 0x01A4, 3, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__EIM_BCLK                            = IOMUX_PAD(0x0430, 0x01A4, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__GPIO4_IO11                          = IOMUX_PAD(0x0430, 0x01A4, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__ECSPI3_RDY                          = IOMUX_PAD(0x0430, 0x01A4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B                  = IOMUX_PAD(0x0434, 0x01A8, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__USDHC1_DATA4                     = IOMUX_PAD(0x0434, 0x01A8, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__QSPI_A_DATA00                    = IOMUX_PAD(0x0434, 0x01A8, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__ECSPI3_SS0                       = IOMUX_PAD(0x0434, 0x01A8, 3, 0x0560, 1, 0),
+	MX6_PAD_NAND_READY_B__EIM_CS1_B                        = IOMUX_PAD(0x0434, 0x01A8, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__GPIO4_IO12                       = IOMUX_PAD(0x0434, 0x01A8, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__UART3_DCE_TX                     = IOMUX_PAD(0x0434, 0x01A8, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__UART3_DTE_RX                     = IOMUX_PAD(0x0434, 0x01A8, 8, 0x0634, 2, 0),
+
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B                      = IOMUX_PAD(0x0438, 0x01AC, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__USDHC1_DATA5                       = IOMUX_PAD(0x0438, 0x01AC, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01                      = IOMUX_PAD(0x0438, 0x01AC, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__ECSPI3_SCLK                        = IOMUX_PAD(0x0438, 0x01AC, 3, 0x0554, 1, 0),
+	MX6_PAD_NAND_CE0_B__EIM_DTACK_B                        = IOMUX_PAD(0x0438, 0x01AC, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__GPIO4_IO13                         = IOMUX_PAD(0x0438, 0x01AC, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__UART3_DCE_RX                       = IOMUX_PAD(0x0438, 0x01AC, 8, 0x0634, 3, 0),
+	MX6_PAD_NAND_CE0_B__UART3_DTE_TX                       = IOMUX_PAD(0x0438, 0x01AC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B                      = IOMUX_PAD(0x043C, 0x01B0, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__USDHC1_DATA6                       = IOMUX_PAD(0x043C, 0x01B0, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02                      = IOMUX_PAD(0x043C, 0x01B0, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__ECSPI3_MOSI                        = IOMUX_PAD(0x043C, 0x01B0, 3, 0x055C, 1, 0),
+	MX6_PAD_NAND_CE1_B__EIM_ADDR18                         = IOMUX_PAD(0x043C, 0x01B0, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__GPIO4_IO14                         = IOMUX_PAD(0x043C, 0x01B0, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__UART3_DCE_CTS                      = IOMUX_PAD(0x043C, 0x01B0, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__UART3_DTE_RTS                      = IOMUX_PAD(0x043C, 0x01B0, 8, 0x0630, 2, 0),
+
+	MX6_PAD_NAND_CLE__RAWNAND_CLE                          = IOMUX_PAD(0x0440, 0x01B4, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__USDHC1_DATA7                         = IOMUX_PAD(0x0440, 0x01B4, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__QSPI_A_DATA03                        = IOMUX_PAD(0x0440, 0x01B4, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__ECSPI3_MISO                          = IOMUX_PAD(0x0440, 0x01B4, 3, 0x0558, 1, 0),
+	MX6_PAD_NAND_CLE__EIM_ADDR16                           = IOMUX_PAD(0x0440, 0x01B4, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__GPIO4_IO15                           = IOMUX_PAD(0x0440, 0x01B4, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__UART3_DCE_RTS                        = IOMUX_PAD(0x0440, 0x01B4, 8, 0x0630, 3, 0),
+	MX6_PAD_NAND_CLE__UART3_DTE_CTS                        = IOMUX_PAD(0x0440, 0x01B4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DQS__RAWNAND_DQS                          = IOMUX_PAD(0x0444, 0x01B8, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__CSI_FIELD                            = IOMUX_PAD(0x0444, 0x01B8, 1, 0x0530, 1, 0),
+	MX6_PAD_NAND_DQS__QSPI_A_SS0_B                         = IOMUX_PAD(0x0444, 0x01B8, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__PWM5_OUT                             = IOMUX_PAD(0x0444, 0x01B8, 3, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__EIM_WAIT                             = IOMUX_PAD(0x0444, 0x01B8, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__GPIO4_IO16                           = IOMUX_PAD(0x0444, 0x01B8, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__SDMA_EXT_EVENT01                     = IOMUX_PAD(0x0444, 0x01B8, 6, 0x0614, 1, 0),
+	MX6_PAD_NAND_DQS__SPDIF_EXT_CLK                        = IOMUX_PAD(0x0444, 0x01B8, 8, 0x061C, 1, 0),
+
+	MX6_PAD_SD1_CMD__USDHC1_CMD                            = IOMUX_PAD(0x0448, 0x01BC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__GPT2_COMPARE1                         = IOMUX_PAD(0x0448, 0x01BC, 1, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__SAI2_RX_SYNC                          = IOMUX_PAD(0x0448, 0x01BC, 2, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__SPDIF_OUT                             = IOMUX_PAD(0x0448, 0x01BC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__EIM_ADDR19                            = IOMUX_PAD(0x0448, 0x01BC, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__GPIO2_IO16                            = IOMUX_PAD(0x0448, 0x01BC, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__SDMA_EXT_EVENT00                      = IOMUX_PAD(0x0448, 0x01BC, 6, 0x0610, 2, 0),
+	MX6_PAD_SD1_CMD__USB_OTG1_PWR                          = IOMUX_PAD(0x0448, 0x01BC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_CLK__USDHC1_CLK                            = IOMUX_PAD(0x044C, 0x01C0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__GPT2_COMPARE2                         = IOMUX_PAD(0x044C, 0x01C0, 1, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__SAI2_MCLK                             = IOMUX_PAD(0x044C, 0x01C0, 2, 0x05F0, 1, 0),
+	MX6_PAD_SD1_CLK__SPDIF_IN                              = IOMUX_PAD(0x044C, 0x01C0, 3, 0x0618, 3, 0),
+	MX6_PAD_SD1_CLK__EIM_ADDR20                            = IOMUX_PAD(0x044C, 0x01C0, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__GPIO2_IO17                            = IOMUX_PAD(0x044C, 0x01C0, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__USB_OTG1_OC                           = IOMUX_PAD(0x044C, 0x01C0, 8, 0x0664, 2, 0),
+
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0                        = IOMUX_PAD(0x0450, 0x01C4, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__GPT2_COMPARE3                       = IOMUX_PAD(0x0450, 0x01C4, 1, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__SAI2_TX_SYNC                        = IOMUX_PAD(0x0450, 0x01C4, 2, 0x05FC, 1, 0),
+	MX6_PAD_SD1_DATA0__FLEXCAN1_TX                         = IOMUX_PAD(0x0450, 0x01C4, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__EIM_ADDR21                          = IOMUX_PAD(0x0450, 0x01C4, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__GPIO2_IO18                          = IOMUX_PAD(0x0450, 0x01C4, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__ANATOP_OTG1_ID                      = IOMUX_PAD(0x0450, 0x01C4, 8, 0x04B8, 2, 0),
+
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1                        = IOMUX_PAD(0x0454, 0x01C8, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__GPT2_CLK                            = IOMUX_PAD(0x0454, 0x01C8, 1, 0x05A0, 1, 0),
+	MX6_PAD_SD1_DATA1__SAI2_TX_BCLK                        = IOMUX_PAD(0x0454, 0x01C8, 2, 0x05F8, 1, 0),
+	MX6_PAD_SD1_DATA1__FLEXCAN1_RX                         = IOMUX_PAD(0x0454, 0x01C8, 3, 0x0584, 3, 0),
+	MX6_PAD_SD1_DATA1__EIM_ADDR22                          = IOMUX_PAD(0x0454, 0x01C8, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__GPIO2_IO19                          = IOMUX_PAD(0x0454, 0x01C8, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__USB_OTG2_PWR                        = IOMUX_PAD(0x0454, 0x01C8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2                        = IOMUX_PAD(0x0458, 0x01CC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__GPT2_CAPTURE1                       = IOMUX_PAD(0x0458, 0x01CC, 1, 0x0598, 1, 0),
+	MX6_PAD_SD1_DATA2__SAI2_RX_DATA                        = IOMUX_PAD(0x0458, 0x01CC, 2, 0x05F4, 1, 0),
+	MX6_PAD_SD1_DATA2__FLEXCAN2_TX                         = IOMUX_PAD(0x0458, 0x01CC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__EIM_ADDR23                          = IOMUX_PAD(0x0458, 0x01CC, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__GPIO2_IO20                          = IOMUX_PAD(0x0458, 0x01CC, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__CCM_CLKO1                           = IOMUX_PAD(0x0458, 0x01CC, 6, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__USB_OTG2_OC                         = IOMUX_PAD(0x0458, 0x01CC, 8, 0x0660, 2, 0),
+
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3                        = IOMUX_PAD(0x045C, 0x01D0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__GPT2_CAPTURE2                       = IOMUX_PAD(0x045C, 0x01D0, 1, 0x059C, 1, 0),
+	MX6_PAD_SD1_DATA3__SAI2_TX_DATA                        = IOMUX_PAD(0x045C, 0x01D0, 2, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__FLEXCAN2_RX                         = IOMUX_PAD(0x045C, 0x01D0, 3, 0x0588, 3, 0),
+	MX6_PAD_SD1_DATA3__EIM_ADDR24                          = IOMUX_PAD(0x045C, 0x01D0, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__GPIO2_IO21                          = IOMUX_PAD(0x045C, 0x01D0, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__CCM_CLKO2                           = IOMUX_PAD(0x045C, 0x01D0, 6, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__ANATOP_OTG2_ID                      = IOMUX_PAD(0x045C, 0x01D0, 8, 0x04BC, 2, 0),
+
+	MX6_PAD_CSI_MCLK__CSI_MCLK                             = IOMUX_PAD(0x0460, 0x01D4, 0, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__USDHC2_CD_B                          = IOMUX_PAD(0x0460, 0x01D4, 1, 0x0674, 0, 0),
+	MX6_PAD_CSI_MCLK__RAWNAND_CE2_B                        = IOMUX_PAD(0x0460, 0x01D4, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__I2C1_SDA                             = IOMUX_PAD(0x0460, 0x01D4, IOMUX_CONFIG_SION | 3, 0x05A8, 0, 0),
+	MX6_PAD_CSI_MCLK__EIM_CS0_B                            = IOMUX_PAD(0x0460, 0x01D4, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__GPIO4_IO17                           = IOMUX_PAD(0x0460, 0x01D4, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__SNVS_HP_VIO_5_CTL                    = IOMUX_PAD(0x0460, 0x01D4, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__UART6_DCE_TX                         = IOMUX_PAD(0x0460, 0x01D4, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__UART6_DTE_RX                         = IOMUX_PAD(0x0460, 0x01D4, 8, 0x064C, 0, 0),
+
+	MX6_PAD_CSI_PIXCLK__CSI_PIXCLK                         = IOMUX_PAD(0x0464, 0x01D8, 0, 0x0528, 1, 0),
+	MX6_PAD_CSI_PIXCLK__USDHC2_WP                          = IOMUX_PAD(0x0464, 0x01D8, 1, 0x069C, 2, 0),
+	MX6_PAD_CSI_PIXCLK__RAWNAND_CE3_B                      = IOMUX_PAD(0x0464, 0x01D8, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__I2C1_SCL                           = IOMUX_PAD(0x0464, 0x01D8, IOMUX_CONFIG_SION | 3, 0x05A4, 2, 0),
+	MX6_PAD_CSI_PIXCLK__EIM_OE                             = IOMUX_PAD(0x0464, 0x01D8, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__GPIO4_IO18                         = IOMUX_PAD(0x0464, 0x01D8, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__SNVS_HP_VIO_5                      = IOMUX_PAD(0x0464, 0x01D8, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__UART6_DCE_RX                       = IOMUX_PAD(0x0464, 0x01D8, 8, 0x064C, 3, 0),
+	MX6_PAD_CSI_PIXCLK__UART6_DTE_TX                       = IOMUX_PAD(0x0464, 0x01D8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_VSYNC__CSI_VSYNC                           = IOMUX_PAD(0x0468, 0x01DC, 0, 0x052C, 0, 0),
+	MX6_PAD_CSI_VSYNC__USDHC2_CLK                          = IOMUX_PAD(0x0468, 0x01DC, 1, 0x0670, 0, 0),
+	MX6_PAD_CSI_VSYNC__SIM1_PORT1_CLK                      = IOMUX_PAD(0x0468, 0x01DC, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__I2C2_SDA                            = IOMUX_PAD(0x0468, 0x01DC, IOMUX_CONFIG_SION | 3, 0x05B0, 0, 0),
+	MX6_PAD_CSI_VSYNC__EIM_RW                              = IOMUX_PAD(0x0468, 0x01DC, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__GPIO4_IO19                          = IOMUX_PAD(0x0468, 0x01DC, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__PWM7_OUT                            = IOMUX_PAD(0x0468, 0x01DC, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__UART6_DCE_RTS                       = IOMUX_PAD(0x0468, 0x01DC, 8, 0x0648, 0, 0),
+	MX6_PAD_CSI_VSYNC__UART6_DTE_CTS                       = IOMUX_PAD(0x0468, 0x01DC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_HSYNC__CSI_HSYNC                           = IOMUX_PAD(0x046C, 0x01E0, 0, 0x0524, 0, 0),
+	MX6_PAD_CSI_HSYNC__USDHC2_CMD                          = IOMUX_PAD(0x046C, 0x01E0, 1, 0x0678, 0, 0),
+	MX6_PAD_CSI_HSYNC__SIM1_PORT1_PD                       = IOMUX_PAD(0x046C, 0x01E0, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__I2C2_SCL                            = IOMUX_PAD(0x046C, 0x01E0, IOMUX_CONFIG_SION | 3, 0x05AC, 0, 0),
+	MX6_PAD_CSI_HSYNC__EIM_LBA_B                           = IOMUX_PAD(0x046C, 0x01E0, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__GPIO4_IO20                          = IOMUX_PAD(0x046C, 0x01E0, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__PWM8_OUT                            = IOMUX_PAD(0x046C, 0x01E0, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__UART6_DCE_CTS                       = IOMUX_PAD(0x046C, 0x01E0, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__UART6_DTE_RTS                       = IOMUX_PAD(0x046C, 0x01E0, 8, 0x0648, 1, 0),
+
+	MX6_PAD_CSI_DATA00__CSI_DATA02                         = IOMUX_PAD(0x0470, 0x01E4, 0, 0x04C4, 0, 0),
+	MX6_PAD_CSI_DATA00__USDHC2_DATA0                       = IOMUX_PAD(0x0470, 0x01E4, 1, 0x067C, 0, 0),
+	MX6_PAD_CSI_DATA00__SIM1_PORT1_RST_B                   = IOMUX_PAD(0x0470, 0x01E4, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__ECSPI2_SCLK                        = IOMUX_PAD(0x0470, 0x01E4, 3, 0x0544, 0, 0),
+	MX6_PAD_CSI_DATA00__EIM_AD00                           = IOMUX_PAD(0x0470, 0x01E4, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__GPIO4_IO21                         = IOMUX_PAD(0x0470, 0x01E4, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__SRC_INT_BOOT                       = IOMUX_PAD(0x0470, 0x01E4, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__UART5_DCE_TX                       = IOMUX_PAD(0x0470, 0x01E4, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__UART5_DTE_RX                       = IOMUX_PAD(0x0470, 0x01E4, 8, 0x0644, 0, 0),
+
+	MX6_PAD_CSI_DATA01__CSI_DATA03                         = IOMUX_PAD(0x0474, 0x01E8, 0, 0x04C8, 0, 0),
+	MX6_PAD_CSI_DATA01__USDHC2_DATA1                       = IOMUX_PAD(0x0474, 0x01E8, 1, 0x0680, 0, 0),
+	MX6_PAD_CSI_DATA01__SIM1_PORT1_SVEN                    = IOMUX_PAD(0x0474, 0x01E8, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA01__ECSPI2_SS0                         = IOMUX_PAD(0x0474, 0x01E8, 3, 0x0550, 0, 0),
+	MX6_PAD_CSI_DATA01__EIM_AD01                           = IOMUX_PAD(0x0474, 0x01E8, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA01__GPIO4_IO22                         = IOMUX_PAD(0x0474, 0x01E8, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA01__SAI1_MCLK                          = IOMUX_PAD(0x0474, 0x01E8, 6, 0x05E0, 0, 0),
+	MX6_PAD_CSI_DATA01__UART5_DCE_RX                       = IOMUX_PAD(0x0474, 0x01E8, 8, 0x0644, 1, 0),
+	MX6_PAD_CSI_DATA01__UART5_DTE_TX                       = IOMUX_PAD(0x0474, 0x01E8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_DATA02__CSI_DATA04                         = IOMUX_PAD(0x0478, 0x01EC, 0, 0x04D8, 1, 0),
+	MX6_PAD_CSI_DATA02__USDHC2_DATA2                       = IOMUX_PAD(0x0478, 0x01EC, 1, 0x0684, 2, 0),
+	MX6_PAD_CSI_DATA02__SIM1_PORT1_TRXD                    = IOMUX_PAD(0x0478, 0x01EC, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__ECSPI2_MOSI                        = IOMUX_PAD(0x0478, 0x01EC, 3, 0x054C, 1, 0),
+	MX6_PAD_CSI_DATA02__EIM_AD02                           = IOMUX_PAD(0x0478, 0x01EC, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__GPIO4_IO23                         = IOMUX_PAD(0x0478, 0x01EC, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__SAI1_RX_SYNC                       = IOMUX_PAD(0x0478, 0x01EC, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__UART5_DCE_RTS                      = IOMUX_PAD(0x0478, 0x01EC, 8, 0x0640, 5, 0),
+	MX6_PAD_CSI_DATA02__UART5_DTE_CTS                      = IOMUX_PAD(0x0478, 0x01EC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_DATA03__CSI_DATA05                         = IOMUX_PAD(0x047C, 0x01F0, 0, 0x04CC, 0, 0),
+	MX6_PAD_CSI_DATA03__USDHC2_DATA3                       = IOMUX_PAD(0x047C, 0x01F0, 1, 0x0688, 0, 0),
+	MX6_PAD_CSI_DATA03__SIM2_PORT1_PD                      = IOMUX_PAD(0x047C, 0x01F0, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__ECSPI2_MISO                        = IOMUX_PAD(0x047C, 0x01F0, 3, 0x0548, 0, 0),
+	MX6_PAD_CSI_DATA03__EIM_AD03                           = IOMUX_PAD(0x047C, 0x01F0, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__GPIO4_IO24                         = IOMUX_PAD(0x047C, 0x01F0, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__SAI1_RX_BCLK                       = IOMUX_PAD(0x047C, 0x01F0, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__UART5_DCE_CTS                      = IOMUX_PAD(0x047C, 0x01F0, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__UART5_DTE_RTS                      = IOMUX_PAD(0x047C, 0x01F0, 8, 0x0640, 0, 0),
+
+	MX6_PAD_CSI_DATA04__CSI_DATA06                         = IOMUX_PAD(0x0480, 0x01F4, 0, 0x04DC, 1, 0),
+	MX6_PAD_CSI_DATA04__USDHC2_DATA4                       = IOMUX_PAD(0x0480, 0x01F4, 1, 0x068C, 2, 0),
+	MX6_PAD_CSI_DATA04__SIM2_PORT1_CLK                     = IOMUX_PAD(0x0480, 0x01F4, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA04__ECSPI1_SCLK                        = IOMUX_PAD(0x0480, 0x01F4, 3, 0x0534, 1, 0),
+	MX6_PAD_CSI_DATA04__EIM_AD04                           = IOMUX_PAD(0x0480, 0x01F4, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA04__GPIO4_IO25                         = IOMUX_PAD(0x0480, 0x01F4, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA04__SAI1_TX_SYNC                       = IOMUX_PAD(0x0480, 0x01F4, 6, 0x05EC, 1, 0),
+	MX6_PAD_CSI_DATA04__USDHC1_WP                          = IOMUX_PAD(0x0480, 0x01F4, 8, 0x066C, 2, 0),
+
+	MX6_PAD_CSI_DATA05__CSI_DATA07                         = IOMUX_PAD(0x0484, 0x01F8, 0, 0x04E0, 1, 0),
+	MX6_PAD_CSI_DATA05__USDHC2_DATA5                       = IOMUX_PAD(0x0484, 0x01F8, 1, 0x0690, 2, 0),
+	MX6_PAD_CSI_DATA05__SIM2_PORT1_RST_B                   = IOMUX_PAD(0x0484, 0x01F8, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA05__ECSPI1_SS0                         = IOMUX_PAD(0x0484, 0x01F8, 3, 0x0540, 1, 0),
+	MX6_PAD_CSI_DATA05__EIM_AD05                           = IOMUX_PAD(0x0484, 0x01F8, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA05__GPIO4_IO26                         = IOMUX_PAD(0x0484, 0x01F8, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA05__SAI1_TX_BCLK                       = IOMUX_PAD(0x0484, 0x01F8, 6, 0x05E8, 1, 0),
+	MX6_PAD_CSI_DATA05__USDHC1_CD_B                        = IOMUX_PAD(0x0484, 0x01F8, 8, 0x0668, 2, 0),
+
+	MX6_PAD_CSI_DATA06__CSI_DATA08                         = IOMUX_PAD(0x0488, 0x01FC, 0, 0x04E4, 1, 0),
+	MX6_PAD_CSI_DATA06__USDHC2_DATA6                       = IOMUX_PAD(0x0488, 0x01FC, 1, 0x0694, 2, 0),
+	MX6_PAD_CSI_DATA06__SIM2_PORT1_SVEN                    = IOMUX_PAD(0x0488, 0x01FC, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA06__ECSPI1_MOSI                        = IOMUX_PAD(0x0488, 0x01FC, 3, 0x053C, 1, 0),
+	MX6_PAD_CSI_DATA06__EIM_AD06                           = IOMUX_PAD(0x0488, 0x01FC, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA06__GPIO4_IO27                         = IOMUX_PAD(0x0488, 0x01FC, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA06__SAI1_RX_DATA                       = IOMUX_PAD(0x0488, 0x01FC, 6, 0x05E4, 1, 0),
+	MX6_PAD_CSI_DATA06__USDHC1_RESET_B                     = IOMUX_PAD(0x0488, 0x01FC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_DATA07__CSI_DATA09                         = IOMUX_PAD(0x048C, 0x0200, 0, 0x04E8, 1, 0),
+	MX6_PAD_CSI_DATA07__USDHC2_DATA7                       = IOMUX_PAD(0x048C, 0x0200, 1, 0x0698, 2, 0),
+	MX6_PAD_CSI_DATA07__SIM2_PORT1_TRXD                    = IOMUX_PAD(0x048C, 0x0200, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__ECSPI1_MISO                        = IOMUX_PAD(0x048C, 0x0200, 3, 0x0538, 1, 0),
+	MX6_PAD_CSI_DATA07__EIM_AD07                           = IOMUX_PAD(0x048C, 0x0200, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__GPIO4_IO28                         = IOMUX_PAD(0x048C, 0x0200, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__SAI1_TX_DATA                       = IOMUX_PAD(0x048C, 0x0200, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__USDHC1_VSELECT                     = IOMUX_PAD(0x048C, 0x0200, 8, 0x0000, 0, 0),
+};
+#endif  /* __ASM_ARCH_IMX6UL_PINS_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/mxc_hdmi.h ebf_6ull_uboot/arch/arm/include/asm/arch/mxc_hdmi.h
--- u-boot-2016.03/arch/arm/include/asm/arch/mxc_hdmi.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/mxc_hdmi.h	2021-04-16 14:42:14.692580786 +0800
@@ -0,0 +1,1060 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MXC_HDMI_H__
+#define __MXC_HDMI_H__
+
+#ifdef CONFIG_IMX_HDMI
+void imx_enable_hdmi_phy(void);
+void imx_setup_hdmi(void);
+#endif
+
+/*
+ * Hdmi controller registers
+ */
+struct hdmi_regs {
+	/*Identification Registers */
+	u8 design_id;			/* 0x000 */
+	u8 revision_id;			/* 0x001 */
+	u8 product_id0;			/* 0x002 */
+	u8 product_id1;			/* 0x003 */
+	u8 config0_id;			/* 0x004 */
+	u8 config1_id;			/* 0x005 */
+	u8 config2_id;			/* 0x006 */
+	u8 config3_id;			/* 0x007 */
+	u8 reserved1[0xf8];
+	/* Interrupt Registers */
+	u8 ih_fc_stat0;			/* 0x100 */
+	u8 ih_fc_stat1;			/* 0x101 */
+	u8 ih_fc_stat2;			/* 0x102 */
+	u8 ih_as_stat0;			/* 0x103 */
+	u8 ih_phy_stat0;		/* 0x104 */
+	u8 ih_i2cm_stat0;		/* 0x105 */
+	u8 ih_cec_stat0;		/* 0x106 */
+	u8 ih_vp_stat0;			/* 0x107 */
+	u8 ih_i2cmphy_stat0;		/* 0x108 */
+	u8 ih_ahbdmaaud_stat0;		/* 0x109 */
+	u8 reserved2[0x76];
+	u8 ih_mute_fc_stat0;		/* 0x180 */
+	u8 ih_mute_fc_stat1;		/* 0x181 */
+	u8 ih_mute_fc_stat2;		/* 0x182 */
+	u8 ih_mute_as_stat0;		/* 0x183 */
+	u8 ih_mute_phy_stat0;		/* 0x184 */
+	u8 ih_mute_i2cm_stat0;		/* 0x185 */
+	u8 ih_mute_cec_stat0;		/* 0x186 */
+	u8 ih_mute_vp_stat0;		/* 0x187 */
+	u8 ih_mute_i2cmphy_stat0;	/* 0x188 */
+	u8 ih_mute_ahbdmaaud_stat0;	/* 0x189 */
+	u8 reserved3[0x75];
+	u8 ih_mute;			/* 0x1ff */
+	/* Video Sample Registers */
+	u8 tx_invid0;			/* 0x200 */
+	u8 tx_instuffing;		/* 0x201 */
+	u8 tx_gydata0;			/* 0x202 */
+	u8 tx_gydata1;			/* 0x203 */
+	u8 tx_rcrdata0;			/* 0x204 */
+	u8 tx_rcrdata1;			/* 0x205 */
+	u8 tx_bcbdata0;			/* 0x206 */
+	u8 tx_bcbdata1;			/* 0x207 */
+	u8 reserved4[0x5f8];
+	/* Video Packetizer Registers */
+	u8 vp_status;			/* 0x800 */
+	u8 vp_pr_cd;			/* 0x801 */
+	u8 vp_stuff;			/* 0x802 */
+	u8 vp_remap;			/* 0x803 */
+	u8 vp_conf;			/* 0x804 */
+	u8 vp_stat;			/* 0x805 */
+	u8 vp_int;			/* 0x806 */
+	u8 vp_mask;			/* 0x807 */
+	u8 vp_pol;			/* 0x808 */
+	u8 reserved5[0x7f7];
+	/* Frame Composer Registers */
+	u8 fc_invidconf;		/* 0x1000 */
+	u8 fc_inhactv0;			/* 0x1001 */
+	u8 fc_inhactv1;			/* 0x1002 */
+	u8 fc_inhblank0;		/* 0x1003 */
+	u8 fc_inhblank1;		/* 0x1004 */
+	u8 fc_invactv0;			/* 0x1005 */
+	u8 fc_invactv1;			/* 0x1006 */
+	u8 fc_invblank;			/* 0x1007 */
+	u8 fc_hsyncindelay0;		/* 0x1008 */
+	u8 fc_hsyncindelay1;		/* 0x1009 */
+	u8 fc_hsyncinwidth0;		/* 0x100a */
+	u8 fc_hsyncinwidth1;		/* 0x100b */
+	u8 fc_vsyncindelay;		/* 0x100c */
+	u8 fc_vsyncinwidth;		/* 0x100d */
+	u8 fc_infreq0;			/* 0x100e */
+	u8 fc_infreq1;			/* 0x100f */
+	u8 fc_infreq2;			/* 0x1010 */
+	u8 fc_ctrldur;			/* 0x1011 */
+	u8 fc_exctrldur;		/* 0x1012 */
+	u8 fc_exctrlspac;		/* 0x1013 */
+	u8 fc_ch0pream;			/* 0x1014 */
+	u8 fc_ch1pream;			/* 0x1015 */
+	u8 fc_ch2pream;			/* 0x1016 */
+	u8 fc_aviconf3;			/* 0x1017 */
+	u8 fc_gcp;			/* 0x1018 */
+	u8 fc_aviconf0;			/* 0x1019 */
+	u8 fc_aviconf1;			/* 0x101a */
+	u8 fc_aviconf2;			/* 0x101b */
+	u8 fc_avivid;			/* 0x101c */
+	u8 fc_avietb0;			/* 0x101d */
+	u8 fc_avietb1;			/* 0x101e */
+	u8 fc_avisbb0;			/* 0x101f */
+	u8 fc_avisbb1;			/* 0x1020 */
+	u8 fc_avielb0;			/* 0x1021 */
+	u8 fc_avielb1;			/* 0x1022 */
+	u8 fc_avisrb0;			/* 0x1023 */
+	u8 fc_avisrb1;			/* 0x1024 */
+	u8 fc_audiconf0;		/* 0x1025 */
+	u8 fc_audiconf1;		/* 0x1026 */
+	u8 fc_audiconf2;		/* 0x1027 */
+	u8 fc_audiconf3;		/* 0x1028 */
+	u8 fc_vsdieeeid0;		/* 0x1029 */
+	u8 fc_vsdsize;			/* 0x102a */
+	u8 reserved6[5];
+	u8 fc_vsdieeeid1;		/* 0x1030 */
+	u8 fc_vsdieeeid2;		/* 0x1031 */
+	u8 fc_vsdpayload0;		/* 0x1032 */
+	u8 fc_vsdpayload1;		/* 0x1033 */
+	u8 fc_vsdpayload2;		/* 0x1034 */
+	u8 fc_vsdpayload3;		/* 0x1035 */
+	u8 fc_vsdpayload4;		/* 0x1036 */
+	u8 fc_vsdpayload5;		/* 0x1037 */
+	u8 fc_vsdpayload6;		/* 0x1038 */
+	u8 fc_vsdpayload7;		/* 0x1039 */
+	u8 fc_vsdpayload8;		/* 0x103a */
+	u8 fc_vsdpayload9;		/* 0x103b */
+	u8 fc_vsdpayload10;		/* 0x103c */
+	u8 fc_vsdpayload11;		/* 0x103d */
+	u8 fc_vsdpayload12;		/* 0x103e */
+	u8 fc_vsdpayload13;		/* 0x103f */
+	u8 fc_vsdpayload14;		/* 0x1040 */
+	u8 fc_vsdpayload15;		/* 0x1041 */
+	u8 fc_vsdpayload16;		/* 0x1042 */
+	u8 fc_vsdpayload17;		/* 0x1043 */
+	u8 fc_vsdpayload18;		/* 0x1044 */
+	u8 fc_vsdpayload19;		/* 0x1045 */
+	u8 fc_vsdpayload20;		/* 0x1046 */
+	u8 fc_vsdpayload21;		/* 0x1047 */
+	u8 fc_vsdpayload22;		/* 0x1048 */
+	u8 fc_vsdpayload23;		/* 0x1049 */
+	u8 fc_spdvendorname0;		/* 0x104a */
+	u8 fc_spdvendorname1;		/* 0x104b */
+	u8 fc_spdvendorname2;		/* 0x104c */
+	u8 fc_spdvendorname3;		/* 0x104d */
+	u8 fc_spdvendorname4;		/* 0x104e */
+	u8 fc_spdvendorname5;		/* 0x104f */
+	u8 fc_spdvendorname6;		/* 0x1050 */
+	u8 fc_spdvendorname7;		/* 0x1051 */
+	u8 fc_sdpproductname0;		/* 0x1052 */
+	u8 fc_sdpproductname1;		/* 0x1053 */
+	u8 fc_sdpproductname2;		/* 0x1054 */
+	u8 fc_sdpproductname3;		/* 0x1055 */
+	u8 fc_sdpproductname4;		/* 0x1056 */
+	u8 fc_sdpproductname5;		/* 0x1057 */
+	u8 fc_sdpproductname6;		/* 0x1058 */
+	u8 fc_sdpproductname7;		/* 0x1059 */
+	u8 fc_sdpproductname8;		/* 0x105a */
+	u8 fc_sdpproductname9;		/* 0x105b */
+	u8 fc_sdpproductname10;		/* 0x105c */
+	u8 fc_sdpproductname11;		/* 0x105d */
+	u8 fc_sdpproductname12;		/* 0x105e */
+	u8 fc_sdpproductname13;		/* 0x105f */
+	u8 fc_sdpproductname14;		/* 0x1060 */
+	u8 fc_spdproductname15;		/* 0x1061 */
+	u8 fc_spddeviceinf;		/* 0x1062 */
+	u8 fc_audsconf;			/* 0x1063 */
+	u8 fc_audsstat;			/* 0x1064 */
+	u8 reserved7[0xb];
+	u8 fc_datach0fill;		/* 0x1070 */
+	u8 fc_datach1fill;		/* 0x1071 */
+	u8 fc_datach2fill;		/* 0x1072 */
+	u8 fc_ctrlqhigh;		/* 0x1073 */
+	u8 fc_ctrlqlow;			/* 0x1074 */
+	u8 fc_acp0;			/* 0x1075 */
+	u8 fc_acp28;			/* 0x1076 */
+	u8 fc_acp27;			/* 0x1077 */
+	u8 fc_acp26;			/* 0x1078 */
+	u8 fc_acp25;			/* 0x1079 */
+	u8 fc_acp24;			/* 0x107a */
+	u8 fc_acp23;			/* 0x107b */
+	u8 fc_acp22;			/* 0x107c */
+	u8 fc_acp21;			/* 0x107d */
+	u8 fc_acp20;			/* 0x107e */
+	u8 fc_acp19;			/* 0x107f */
+	u8 fc_acp18;			/* 0x1080 */
+	u8 fc_acp17;			/* 0x1081 */
+	u8 fc_acp16;			/* 0x1082 */
+	u8 fc_acp15;			/* 0x1083 */
+	u8 fc_acp14;			/* 0x1084 */
+	u8 fc_acp13;			/* 0x1085 */
+	u8 fc_acp12;			/* 0x1086 */
+	u8 fc_acp11;			/* 0x1087 */
+	u8 fc_acp10;			/* 0x1088 */
+	u8 fc_acp9;			/* 0x1089 */
+	u8 fc_acp8;			/* 0x108a */
+	u8 fc_acp7;			/* 0x108b */
+	u8 fc_acp6;			/* 0x108c */
+	u8 fc_acp5;			/* 0x108d */
+	u8 fc_acp4;			/* 0x108e */
+	u8 fc_acp3;			/* 0x108f */
+	u8 fc_acp2;			/* 0x1090 */
+	u8 fc_acp1;			/* 0x1091 */
+	u8 fc_iscr1_0;			/* 0x1092 */
+	u8 fc_iscr1_16;			/* 0x1093 */
+	u8 fc_iscr1_15;			/* 0x1094 */
+	u8 fc_iscr1_14;			/* 0x1095 */
+	u8 fc_iscr1_13;			/* 0x1096 */
+	u8 fc_iscr1_12;			/* 0x1097 */
+	u8 fc_iscr1_11;			/* 0x1098 */
+	u8 fc_iscr1_10;			/* 0x1099 */
+	u8 fc_iscr1_9;			/* 0x109a */
+	u8 fc_iscr1_8;			/* 0x109b */
+	u8 fc_iscr1_7;			/* 0x109c */
+	u8 fc_iscr1_6;			/* 0x109d */
+	u8 fc_iscr1_5;			/* 0x109e */
+	u8 fc_iscr1_4;			/* 0x109f */
+	u8 fc_iscr1_3;			/* 0x10a0 */
+	u8 fc_iscr1_2;			/* 0x10a1 */
+	u8 fc_iscr1_1;			/* 0x10a2 */
+	u8 fc_iscr2_15;			/* 0x10a3 */
+	u8 fc_iscr2_14;			/* 0x10a4 */
+	u8 fc_iscr2_13;			/* 0x10a5 */
+	u8 fc_iscr2_12;			/* 0x10a6 */
+	u8 fc_iscr2_11;			/* 0x10a7 */
+	u8 fc_iscr2_10;			/* 0x10a8 */
+	u8 fc_iscr2_9;			/* 0x10a9 */
+	u8 fc_iscr2_8;			/* 0x10aa */
+	u8 fc_iscr2_7;			/* 0x10ab */
+	u8 fc_iscr2_6;			/* 0x10ac */
+	u8 fc_iscr2_5;			/* 0x10ad */
+	u8 fc_iscr2_4;			/* 0x10ae */
+	u8 fc_iscr2_3;			/* 0x10af */
+	u8 fc_iscr2_2;			/* 0x10b0 */
+	u8 fc_iscr2_1;			/* 0x10b1 */
+	u8 fc_iscr2_0;			/* 0x10b2 */
+	u8 fc_datauto0;			/* 0x10b3 */
+	u8 fc_datauto1;			/* 0x10b4 */
+	u8 fc_datauto2;			/* 0x10b5 */
+	u8 fc_datman;			/* 0x10b6 */
+	u8 fc_datauto3;			/* 0x10b7 */
+	u8 fc_rdrb0;			/* 0x10b8 */
+	u8 fc_rdrb1;			/* 0x10b9 */
+	u8 fc_rdrb2;			/* 0x10ba */
+	u8 fc_rdrb3;			/* 0x10bb */
+	u8 fc_rdrb4;			/* 0x10bc */
+	u8 fc_rdrb5;			/* 0x10bd */
+	u8 fc_rdrb6;			/* 0x10be */
+	u8 fc_rdrb7;			/* 0x10bf */
+	u8 reserved8[0x10];
+	u8 fc_stat0;			/* 0x10d0 */
+	u8 fc_int0;			/* 0x10d1 */
+	u8 fc_mask0;			/* 0x10d2 */
+	u8 fc_pol0;			/* 0x10d3 */
+	u8 fc_stat1;			/* 0x10d4 */
+	u8 fc_int1;			/* 0x10d5 */
+	u8 fc_mask1;			/* 0x10d6 */
+	u8 fc_pol1;			/* 0x10d7 */
+	u8 fc_stat2;			/* 0x10d8 */
+	u8 fc_int2;			/* 0x10d9 */
+	u8 fc_mask2;			/* 0x10da */
+	u8 fc_pol2;			/* 0x10db */
+	u8 reserved9[0x4];
+	u8 fc_prconf;			/* 0x10e0 */
+	u8 reserved10[0x1f];
+	u8 fc_gmd_stat;			/* 0x1100 */
+	u8 fc_gmd_en;			/* 0x1101 */
+	u8 fc_gmd_up;			/* 0x1102 */
+	u8 fc_gmd_conf;			/* 0x1103 */
+	u8 fc_gmd_hb;			/* 0x1104 */
+	u8 fc_gmd_pb0;			/* 0x1105 */
+	u8 fc_gmd_pb1;			/* 0x1106 */
+	u8 fc_gmd_pb2;			/* 0x1107 */
+	u8 fc_gmd_pb3;			/* 0x1108 */
+	u8 fc_gmd_pb4;			/* 0x1109 */
+	u8 fc_gmd_pb5;			/* 0x110a */
+	u8 fc_gmd_pb6;			/* 0x110b */
+	u8 fc_gmd_pb7;			/* 0x110c */
+	u8 fc_gmd_pb8;			/* 0x110d */
+	u8 fc_gmd_pb9;			/* 0x110e */
+	u8 fc_gmd_pb10;			/* 0x110f */
+	u8 fc_gmd_pb11;			/* 0x1110 */
+	u8 fc_gmd_pb12;			/* 0x1111 */
+	u8 fc_gmd_pb13;			/* 0x1112 */
+	u8 fc_gmd_pb14;			/* 0x1113 */
+	u8 fc_gmd_pb15;			/* 0x1114 */
+	u8 fc_gmd_pb16;			/* 0x1115 */
+	u8 fc_gmd_pb17;			/* 0x1116 */
+	u8 fc_gmd_pb18;			/* 0x1117 */
+	u8 fc_gmd_pb19;			/* 0x1118 */
+	u8 fc_gmd_pb20;			/* 0x1119 */
+	u8 fc_gmd_pb21;			/* 0x111a */
+	u8 fc_gmd_pb22;			/* 0x111b */
+	u8 fc_gmd_pb23;			/* 0x111c */
+	u8 fc_gmd_pb24;			/* 0x111d */
+	u8 fc_gmd_pb25;			/* 0x111e */
+	u8 fc_gmd_pb26;			/* 0x111f */
+	u8 fc_gmd_pb27;			/* 0x1120 */
+	u8 reserved11[0xdf];
+	u8 fc_dbgforce;			/* 0x1200 */
+	u8 fc_dbgaud0ch0;		/* 0x1201 */
+	u8 fc_dbgaud1ch0;		/* 0x1202 */
+	u8 fc_dbgaud2ch0;		/* 0x1203 */
+	u8 fc_dbgaud0ch1;		/* 0x1204 */
+	u8 fc_dbgaud1ch1;		/* 0x1205 */
+	u8 fc_dbgaud2ch1;		/* 0x1206 */
+	u8 fc_dbgaud0ch2;		/* 0x1207 */
+	u8 fc_dbgaud1ch2;		/* 0x1208 */
+	u8 fc_dbgaud2ch2;		/* 0x1209 */
+	u8 fc_dbgaud0ch3;		/* 0x120a */
+	u8 fc_dbgaud1ch3;		/* 0x120b */
+	u8 fc_dbgaud2ch3;		/* 0x120c */
+	u8 fc_dbgaud0ch4;		/* 0x120d */
+	u8 fc_dbgaud1ch4;		/* 0x120e */
+	u8 fc_dbgaud2ch4;		/* 0x120f */
+	u8 fc_dbgaud0ch5;		/* 0x1210 */
+	u8 fc_dbgaud1ch5;		/* 0x1211 */
+	u8 fc_dbgaud2ch5;		/* 0x1212 */
+	u8 fc_dbgaud0ch6;		/* 0x1213 */
+	u8 fc_dbgaud1ch6;		/* 0x1214 */
+	u8 fc_dbgaud2ch6;		/* 0x1215 */
+	u8 fc_dbgaud0ch7;		/* 0x1216 */
+	u8 fc_dbgaud1ch7;		/* 0x1217 */
+	u8 fc_dbgaud2ch7;		/* 0x1218 */
+	u8 fc_dbgtmds0;			/* 0x1219 */
+	u8 fc_dbgtmds1;			/* 0x121a */
+	u8 fc_dbgtmds2;			/* 0x121b */
+	u8 reserved12[0x1de4];
+	/* Hdmi Source Phy Registers */
+	u8 phy_conf0;			/* 0x3000 */
+	u8 phy_tst0;			/* 0x3001 */
+	u8 phy_tst1;			/* 0x3002 */
+	u8 phy_tst2;			/* 0x3003 */
+	u8 phy_stat0;			/* 0x3004 */
+	u8 phy_int0;			/* 0x3005 */
+	u8 phy_mask0;			/* 0x3006 */
+	u8 phy_pol0;			/* 0x3007 */
+	u8 reserved13[0x18];
+	/* Hdmi Master Phy Registers */
+	u8 phy_i2cm_slave_addr;		/* 0x3020 */
+	u8 phy_i2cm_address_addr;	/* 0x3021 */
+	u8 phy_i2cm_datao_1_addr;	/* 0x3022 */
+	u8 phy_i2cm_datao_0_addr;	/* 0x3023 */
+	u8 phy_i2cm_datai_1_addr;	/* 0x3024 */
+	u8 phy_i2cm_datai_0_addr;	/* 0x3025 */
+	u8 phy_i2cm_operation_addr;	/* 0x3026 */
+	u8 phy_i2cm_int_addr;		/* 0x3027 */
+	u8 phy_i2cm_ctlint_addr;	/* 0x3028 */
+	u8 phy_i2cm_div_addr;		/* 0x3029 */
+	u8 phy_i2cm_softrstz_addr;	/* 0x302a */
+	u8 phy_i2cm_ss_scl_hcnt_1_addr;	/* 0x302b */
+	u8 phy_i2cm_ss_scl_hcnt_0_addr;	/* 0x302c */
+	u8 phy_i2cm_ss_scl_lcnt_1_addr;	/* 0x302d */
+	u8 phy_i2cm_ss_scl_lcnt_0_addr;	/* 0x302e */
+	u8 phy_i2cm_fs_scl_hcnt_1_addr;	/* 0x302f */
+	u8 phy_i2cm_fs_scl_hcnt_0_addr;	/* 0x3030 */
+	u8 phy_i2cm_fs_scl_lcnt_1_addr;	/* 0x3031 */
+	u8 phy_i2cm_fs_scl_lcnt_0_addr;	/* 0x3032 */
+	u8 reserved14[0xcd];
+	/* Audio Sampler Registers */
+	u8 aud_conf0;			/* 0x3100 */
+	u8 aud_conf1;			/* 0x3101 */
+	u8 aud_int;			/* 0x3102 */
+	u8 aud_conf2;			/* 0x3103 */
+	u8 reserved15[0xfc];
+	u8 aud_n1;			/* 0x3200 */
+	u8 aud_n2;			/* 0x3201 */
+	u8 aud_n3;			/* 0x3202 */
+	u8 aud_cts1;			/* 0x3203 */
+	u8 aud_cts2;			/* 0x3204 */
+	u8 aud_cts3;			/* 0x3205 */
+	u8 aud_inputclkfs;		/* 0x3206 */
+	u8 reserved16[0xfb];
+	u8 aud_spdifint;		/* 0x3302 */
+	u8 reserved17[0xfd];
+	u8 aud_conf0_hbr;		/* 0x3400 */
+	u8 aud_hbr_status;		/* 0x3401 */
+	u8 aud_hbr_int;			/* 0x3402 */
+	u8 aud_hbr_pol;			/* 0x3403 */
+	u8 aud_hbr_mask;		/* 0x3404 */
+	u8 reserved18[0xfb];
+	/*
+	 * Generic Parallel Audio Interface Registers
+	 * Not used as GPAUD interface is not enabled in hw
+	 */
+	u8 gp_conf0;			/* 0x3500 */
+	u8 gp_conf1;			/* 0x3501 */
+	u8 gp_conf2;			/* 0x3502 */
+	u8 gp_stat;			/* 0x3503 */
+	u8 gp_int;			/* 0x3504 */
+	u8 gp_mask;			/* 0x3505 */
+	u8 gp_pol;			/* 0x3506 */
+	u8 reserved19[0xf9];
+	/* Audio DMA Registers */
+	u8 ahb_dma_conf0;		/* 0x3600 */
+	u8 ahb_dma_start;		/* 0x3601 */
+	u8 ahb_dma_stop;		/* 0x3602 */
+	u8 ahb_dma_thrsld;		/* 0x3603 */
+	u8 ahb_dma_straddr0;		/* 0x3604 */
+	u8 ahb_dma_straddr1;		/* 0x3605 */
+	u8 ahb_dma_straddr2;		/* 0x3606 */
+	u8 ahb_dma_straddr3;		/* 0x3607 */
+	u8 ahb_dma_stpaddr0;		/* 0x3608 */
+	u8 ahb_dma_stpaddr1;		/* 0x3609 */
+	u8 ahb_dma_stpaddr2;		/* 0x360a */
+	u8 ahb_dma_stpaddr3;		/* 0x360b */
+	u8 ahb_dma_bstaddr0;		/* 0x360c */
+	u8 ahb_dma_bstaddr1;		/* 0x360d */
+	u8 ahb_dma_bstaddr2;		/* 0x360e */
+	u8 ahb_dma_bstaddr3;		/* 0x360f */
+	u8 ahb_dma_mblength0;		/* 0x3610 */
+	u8 ahb_dma_mblength1;		/* 0x3611 */
+	u8 ahb_dma_stat;		/* 0x3612 */
+	u8 ahb_dma_int;			/* 0x3613 */
+	u8 ahb_dma_mask;		/* 0x3614 */
+	u8 ahb_dma_pol;			/* 0x3615 */
+	u8 ahb_dma_conf1;		/* 0x3616 */
+	u8 ahb_dma_buffstat;		/* 0x3617 */
+	u8 ahb_dma_buffint;		/* 0x3618 */
+	u8 ahb_dma_buffmask;		/* 0x3619 */
+	u8 ahb_dma_buffpol;		/* 0x361a */
+	u8 reserved20[0x9e5];
+	/* Main Controller Registers */
+	u8 mc_sfrdiv;			/* 0x4000 */
+	u8 mc_clkdis;			/* 0x4001 */
+	u8 mc_swrstz;			/* 0x4002 */
+	u8 mc_opctrl;			/* 0x4003 */
+	u8 mc_flowctrl;			/* 0x4004 */
+	u8 mc_phyrstz;			/* 0x4005 */
+	u8 mc_lockonclock;		/* 0x4006 */
+	u8 mc_heacphy_rst;		/* 0x4007 */
+	u8 reserved21[0xf8];
+	/* Colorspace Converter Registers */
+	u8 csc_cfg;			/* 0x4100 */
+	u8 csc_scale;			/* 0x4101 */
+	u8 csc_coef_a1_msb;		/* 0x4102 */
+	u8 csc_coef_a1_lsb;		/* 0x4103 */
+	u8 csc_coef_a2_msb;		/* 0x4104 */
+	u8 csc_coef_a2_lsb;		/* 0x4105 */
+	u8 csc_coef_a3_msb;		/* 0x4106 */
+	u8 csc_coef_a3_lsb;		/* 0x4107 */
+	u8 csc_coef_a4_msb;		/* 0x4108 */
+	u8 csc_coef_a4_lsb;		/* 0x4109 */
+	u8 csc_coef_b1_msb;		/* 0x410a */
+	u8 csc_coef_b1_lsb;		/* 0x410b */
+	u8 csc_coef_b2_msb;		/* 0x410c */
+	u8 csc_coef_b2_lsb;		/* 0x410d */
+	u8 csc_coef_b3_msb;		/* 0x410e */
+	u8 csc_coef_b3_lsb;		/* 0x410f */
+	u8 csc_coef_b4_msb;		/* 0x4110 */
+	u8 csc_coef_b4_lsb;		/* 0x4111 */
+	u8 csc_coef_c1_msb;		/* 0x4112 */
+	u8 csc_coef_c1_lsb;		/* 0x4113 */
+	u8 csc_coef_c2_msb;		/* 0x4114 */
+	u8 csc_coef_c2_lsb;		/* 0x4115 */
+	u8 csc_coef_c3_msb;		/* 0x4116 */
+	u8 csc_coef_c3_lsb;		/* 0x4117 */
+	u8 csc_coef_c4_msb;		/* 0x4118 */
+	u8 csc_coef_c4_lsb;		/* 0x4119 */
+	u8 reserved22[0xee6];
+	/* HDCP Encryption Engine Registers */
+	u8 a_hdcpcfg0;			/* 0x5000 */
+	u8 a_hdcpcfg1;			/* 0x5001 */
+	u8 a_hdcpobs0;			/* 0x5002 */
+	u8 a_hdcpobs1;			/* 0x5003 */
+	u8 a_hdcpobs2;			/* 0x5004 */
+	u8 a_hdcpobs3;			/* 0x5005 */
+	u8 a_apiintclr;			/* 0x5006 */
+	u8 a_apiintstat;		/* 0x5007 */
+	u8 a_apiintmsk;			/* 0x5008 */
+	u8 a_vidpolcfg;			/* 0x5009 */
+	u8 a_oesswcfg;			/* 0x500a */
+	u8 a_timer1setup0;		/* 0x500b */
+	u8 a_timer1setup1;		/* 0x500c */
+	u8 a_timer2setup0;		/* 0x500d */
+	u8 a_timer2setup1;		/* 0x500e */
+	u8 a_100mscfg;			/* 0x500f */
+	u8 a_2scfg0;			/* 0x5010 */
+	u8 a_2scfg1;			/* 0x5011 */
+	u8 a_5scfg0;			/* 0x5012 */
+	u8 a_5scfg1;			/* 0x5013 */
+	u8 a_srmverlsb;			/* 0x5014 */
+	u8 a_srmvermsb;			/* 0x5015 */
+	u8 a_srmctrl;			/* 0x5016 */
+	u8 a_sfrsetup;			/* 0x5017 */
+	u8 a_i2chsetup;			/* 0x5018 */
+	u8 a_intsetup;			/* 0x5019 */
+	u8 a_presetup;			/* 0x501a */
+	u8 reserved23[0x5];
+	u8 a_srm_base;			/* 0x5020 */
+	u8 reserved24[0x2cdf];
+	/* CEC Engine Registers */
+	u8 cec_ctrl;			/* 0x7d00 */
+	u8 cec_stat;			/* 0x7d01 */
+	u8 cec_mask;			/* 0x7d02 */
+	u8 cec_polarity;		/* 0x7d03 */
+	u8 cec_int;			/* 0x7d04 */
+	u8 cec_addr_l;			/* 0x7d05 */
+	u8 cec_addr_h;			/* 0x7d06 */
+	u8 cec_tx_cnt;			/* 0x7d07 */
+	u8 cec_rx_cnt;			/* 0x7d08 */
+	u8 reserved25[0x7];
+	u8 cec_tx_data0;		/* 0x7d10 */
+	u8 cec_tx_data1;		/* 0x7d11 */
+	u8 cec_tx_data2;		/* 0x7d12 */
+	u8 cec_tx_data3;		/* 0x7d13 */
+	u8 cec_tx_data4;		/* 0x7d14 */
+	u8 cec_tx_data5;		/* 0x7d15 */
+	u8 cec_tx_data6;		/* 0x7d16 */
+	u8 cec_tx_data7;		/* 0x7d17 */
+	u8 cec_tx_data8;		/* 0x7d18 */
+	u8 cec_tx_data9;		/* 0x7d19 */
+	u8 cec_tx_data10;		/* 0x7d1a */
+	u8 cec_tx_data11;		/* 0x7d1b */
+	u8 cec_tx_data12;		/* 0x7d1c */
+	u8 cec_tx_data13;		/* 0x7d1d */
+	u8 cec_tx_data14;		/* 0x7d1e */
+	u8 cec_tx_data15;		/* 0x7d1f */
+	u8 cec_rx_data0;		/* 0x7d20 */
+	u8 cec_rx_data1;		/* 0x7d21 */
+	u8 cec_rx_data2;		/* 0x7d22 */
+	u8 cec_rx_data3;		/* 0x7d23 */
+	u8 cec_rx_data4;		/* 0x7d24 */
+	u8 cec_rx_data5;		/* 0x7d25 */
+	u8 cec_rx_data6;		/* 0x7d26 */
+	u8 cec_rx_data7;		/* 0x7d27 */
+	u8 cec_rx_data8;		/* 0x7d28 */
+	u8 cec_rx_data9;		/* 0x7d29 */
+	u8 cec_rx_data10;		/* 0x7d2a */
+	u8 cec_rx_data11;		/* 0x7d2b */
+	u8 cec_rx_data12;		/* 0x7d2c */
+	u8 cec_rx_data13;		/* 0x7d2d */
+	u8 cec_rx_data14;		/* 0x7d2e */
+	u8 cec_rx_data15;		/* 0x7d2f */
+	u8 cec_lock;			/* 0x7d30 */
+	u8 cec_wkupctrl;		/* 0x7d31 */
+	u8 reserved26[0xce];
+	/* I2C Master Registers (E-DDC) */
+	u8 i2cm_slave;			/* 0x7e00 */
+	u8 i2cmess;			/* 0x7e01 */
+	u8 i2cm_datao;			/* 0x7e02 */
+	u8 i2cm_datai;			/* 0x7e03 */
+	u8 i2cm_operation;		/* 0x7e04 */
+	u8 i2cm_int;			/* 0x7e05 */
+	u8 i2cm_ctlint;			/* 0x7e06 */
+	u8 i2cm_div;			/* 0x7e07 */
+	u8 i2cm_segaddr;		/* 0x7e08 */
+	u8 i2cm_softrstz;		/* 0x7e09 */
+	u8 i2cm_segptr;			/* 0x7e0a */
+	u8 i2cm_ss_scl_hcnt_1_addr;	/* 0x7e0b */
+	u8 i2cm_ss_scl_hcnt_0_addr;	/* 0x7e0c */
+	u8 i2cm_ss_scl_lcnt_1_addr;	/* 0x7e0d */
+	u8 i2cm_ss_scl_lcnt_0_addr;	/* 0x7e0e */
+	u8 i2cm_fs_scl_hcnt_1_addr;	/* 0x7e0f */
+	u8 i2cm_fs_scl_hcnt_0_addr;	/* 0x7e10 */
+	u8 i2cm_fs_scl_lcnt_1_addr;	/* 0x7e11 */
+	u8 i2cm_fs_scl_lcnt_0_addr;	/* 0x7e12 */
+	u8 reserved27[0x1ed];
+	/* Random Number Generator Registers (RNG) */
+	u8 rng_base;			/* 0x8000 */
+};
+
+/*
+ * Register field definitions
+ */
+enum {
+/* IH_FC_INT2 field values */
+	HDMI_IH_FC_INT2_OVERFLOW_MASK = 0x03,
+	HDMI_IH_FC_INT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_IH_FC_INT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* IH_FC_STAT2 field values */
+	HDMI_IH_FC_STAT2_OVERFLOW_MASK = 0x03,
+	HDMI_IH_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_IH_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* IH_PHY_STAT0 field values */
+	HDMI_IH_PHY_STAT0_RX_SENSE3 = 0x20,
+	HDMI_IH_PHY_STAT0_RX_SENSE2 = 0x10,
+	HDMI_IH_PHY_STAT0_RX_SENSE1 = 0x8,
+	HDMI_IH_PHY_STAT0_RX_SENSE0 = 0x4,
+	HDMI_IH_PHY_STAT0_TX_PHY_LOCK = 0x2,
+	HDMI_IH_PHY_STAT0_HPD = 0x1,
+
+/* IH_MUTE_I2CMPHY_STAT0 field values */
+	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYDONE = 0x2,
+	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYERROR = 0x1,
+
+/* IH_AHBDMAAUD_STAT0 field values */
+	HDMI_IH_AHBDMAAUD_STAT0_ERROR = 0x20,
+	HDMI_IH_AHBDMAAUD_STAT0_LOST = 0x10,
+	HDMI_IH_AHBDMAAUD_STAT0_RETRY = 0x08,
+	HDMI_IH_AHBDMAAUD_STAT0_DONE = 0x04,
+	HDMI_IH_AHBDMAAUD_STAT0_BUFFFULL = 0x02,
+	HDMI_IH_AHBDMAAUD_STAT0_BUFFEMPTY = 0x01,
+
+/* IH_MUTE_FC_STAT2 field values */
+	HDMI_IH_MUTE_FC_STAT2_OVERFLOW_MASK = 0x03,
+	HDMI_IH_MUTE_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_IH_MUTE_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* IH_MUTE_AHBDMAAUD_STAT0 field values */
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_ERROR = 0x20,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_LOST = 0x10,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_RETRY = 0x08,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_DONE = 0x04,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFFULL = 0x02,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFEMPTY = 0x01,
+
+/* IH_MUTE field values */
+	HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT = 0x2,
+	HDMI_IH_MUTE_MUTE_ALL_INTERRUPT = 0x1,
+
+/* TX_INVID0 field values */
+	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_MASK = 0x80,
+	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_ENABLE = 0x80,
+	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_DISABLE = 0x00,
+	HDMI_TX_INVID0_VIDEO_MAPPING_MASK = 0x1F,
+	HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET = 0,
+
+/* TX_INSTUFFING field values */
+	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_MASK = 0x4,
+	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_ENABLE = 0x4,
+	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_DISABLE = 0x0,
+	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_MASK = 0x2,
+	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE = 0x2,
+	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_DISABLE = 0x0,
+	HDMI_TX_INSTUFFING_GYDATA_STUFFING_MASK = 0x1,
+	HDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE = 0x1,
+	HDMI_TX_INSTUFFING_GYDATA_STUFFING_DISABLE = 0x0,
+
+/* VP_PR_CD field values */
+	HDMI_VP_PR_CD_COLOR_DEPTH_MASK = 0xF0,
+	HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET = 4,
+	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK = 0x0F,
+	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET = 0,
+
+/* VP_STUFF field values */
+	HDMI_VP_STUFF_IDEFAULT_PHASE_MASK = 0x20,
+	HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET = 5,
+	HDMI_VP_STUFF_IFIX_PP_TO_LAST_MASK = 0x10,
+	HDMI_VP_STUFF_IFIX_PP_TO_LAST_OFFSET = 4,
+	HDMI_VP_STUFF_ICX_GOTO_P0_ST_MASK = 0x8,
+	HDMI_VP_STUFF_ICX_GOTO_P0_ST_OFFSET = 3,
+	HDMI_VP_STUFF_YCC422_STUFFING_MASK = 0x4,
+	HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE = 0x4,
+	HDMI_VP_STUFF_YCC422_STUFFING_DIRECT_MODE = 0x0,
+	HDMI_VP_STUFF_PP_STUFFING_MASK = 0x2,
+	HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE = 0x2,
+	HDMI_VP_STUFF_PP_STUFFING_DIRECT_MODE = 0x0,
+	HDMI_VP_STUFF_PR_STUFFING_MASK = 0x1,
+	HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE = 0x1,
+	HDMI_VP_STUFF_PR_STUFFING_DIRECT_MODE = 0x0,
+
+/* VP_CONF field values */
+	HDMI_VP_CONF_BYPASS_EN_MASK = 0x40,
+	HDMI_VP_CONF_BYPASS_EN_ENABLE = 0x40,
+	HDMI_VP_CONF_BYPASS_EN_DISABLE = 0x00,
+	HDMI_VP_CONF_PP_EN_ENMASK = 0x20,
+	HDMI_VP_CONF_PP_EN_ENABLE = 0x20,
+	HDMI_VP_CONF_PP_EN_DISABLE = 0x00,
+	HDMI_VP_CONF_PR_EN_MASK = 0x10,
+	HDMI_VP_CONF_PR_EN_ENABLE = 0x10,
+	HDMI_VP_CONF_PR_EN_DISABLE = 0x00,
+	HDMI_VP_CONF_YCC422_EN_MASK = 0x8,
+	HDMI_VP_CONF_YCC422_EN_ENABLE = 0x8,
+	HDMI_VP_CONF_YCC422_EN_DISABLE = 0x0,
+	HDMI_VP_CONF_BYPASS_SELECT_MASK = 0x4,
+	HDMI_VP_CONF_BYPASS_SELECT_VID_PACKETIZER = 0x4,
+	HDMI_VP_CONF_BYPASS_SELECT_PIX_REPEATER = 0x0,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_MASK = 0x3,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS = 0x3,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422 = 0x1,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_PP = 0x0,
+
+/* VP_REMAP field values */
+	HDMI_VP_REMAP_MASK = 0x3,
+	HDMI_VP_REMAP_YCC422_24bit = 0x2,
+	HDMI_VP_REMAP_YCC422_20bit = 0x1,
+	HDMI_VP_REMAP_YCC422_16bit = 0x0,
+
+/* FC_INVIDCONF field values */
+	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_MASK = 0x80,
+	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE = 0x80,
+	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_INACTIVE = 0x00,
+	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_MASK = 0x40,
+	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH = 0x40,
+	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW = 0x00,
+	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_MASK = 0x20,
+	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH = 0x20,
+	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW = 0x00,
+	HDMI_FC_INVIDCONF_DE_IN_POLARITY_MASK = 0x10,
+	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH = 0x10,
+	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW = 0x00,
+	HDMI_FC_INVIDCONF_DVI_MODEZ_MASK = 0x8,
+	HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE = 0x8,
+	HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE = 0x0,
+	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_MASK = 0x2,
+	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH = 0x2,
+	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW = 0x0,
+	HDMI_FC_INVIDCONF_IN_I_P_MASK = 0x1,
+	HDMI_FC_INVIDCONF_IN_I_P_INTERLACED = 0x1,
+	HDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE = 0x0,
+
+/* FC_AUDICONF0 field values */
+	HDMI_FC_AUDICONF0_CC_OFFSET = 4,
+	HDMI_FC_AUDICONF0_CC_MASK = 0x70,
+	HDMI_FC_AUDICONF0_CT_OFFSET = 0,
+	HDMI_FC_AUDICONF0_CT_MASK = 0xF,
+
+/* FC_AUDICONF1 field values */
+	HDMI_FC_AUDICONF1_SS_OFFSET = 3,
+	HDMI_FC_AUDICONF1_SS_MASK = 0x18,
+	HDMI_FC_AUDICONF1_SF_OFFSET = 0,
+	HDMI_FC_AUDICONF1_SF_MASK = 0x7,
+
+/* FC_AUDICONF3 field values */
+	HDMI_FC_AUDICONF3_LFEPBL_OFFSET = 5,
+	HDMI_FC_AUDICONF3_LFEPBL_MASK = 0x60,
+	HDMI_FC_AUDICONF3_DM_INH_OFFSET = 4,
+	HDMI_FC_AUDICONF3_DM_INH_MASK = 0x10,
+	HDMI_FC_AUDICONF3_LSV_OFFSET = 0,
+	HDMI_FC_AUDICONF3_LSV_MASK = 0xF,
+
+/* FC_AUDSCHNLS0 field values */
+	HDMI_FC_AUDSCHNLS0_CGMSA_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS0_CGMSA_MASK = 0x30,
+	HDMI_FC_AUDSCHNLS0_COPYRIGHT_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS0_COPYRIGHT_MASK = 0x01,
+
+/* FC_AUDSCHNLS3-6 field values */
+	HDMI_FC_AUDSCHNLS3_OIEC_CH0_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS3_OIEC_CH0_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS3_OIEC_CH1_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS3_OIEC_CH1_MASK = 0xf0,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH2_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH2_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH3_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH3_MASK = 0xf0,
+
+	HDMI_FC_AUDSCHNLS5_OIEC_CH0_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS5_OIEC_CH0_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS5_OIEC_CH1_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS5_OIEC_CH1_MASK = 0xf0,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH2_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH2_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH3_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH3_MASK = 0xf0,
+
+/* HDMI_FC_AUDSCHNLS7 field values */
+	HDMI_FC_AUDSCHNLS7_ACCURACY_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS7_ACCURACY_MASK = 0x30,
+
+/* HDMI_FC_AUDSCHNLS8 field values */
+	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_MASK = 0xf0,
+	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_OFFSET = 0,
+
+/* FC_AUDSCONF field values */
+	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_MASK = 0xF0,
+	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_OFFSET = 4,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_MASK = 0x1,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_OFFSET = 0,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT1 = 0x1,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT0 = 0x0,
+
+/* FC_STAT2 field values */
+	HDMI_FC_STAT2_OVERFLOW_MASK = 0x03,
+	HDMI_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* FC_INT2 field values */
+	HDMI_FC_INT2_OVERFLOW_MASK = 0x03,
+	HDMI_FC_INT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_FC_INT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* FC_MASK2 field values */
+	HDMI_FC_MASK2_OVERFLOW_MASK = 0x03,
+	HDMI_FC_MASK2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_FC_MASK2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* FC_PRCONF field values */
+	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_MASK = 0xF0,
+	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_OFFSET = 4,
+	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_MASK = 0x0F,
+	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_OFFSET = 0,
+
+/* FC_AVICONF0-FC_AVICONF3 field values */
+	HDMI_FC_AVICONF0_PIX_FMT_MASK = 0x03,
+	HDMI_FC_AVICONF0_PIX_FMT_RGB = 0x00,
+	HDMI_FC_AVICONF0_PIX_FMT_YCBCR422 = 0x01,
+	HDMI_FC_AVICONF0_PIX_FMT_YCBCR444 = 0x02,
+	HDMI_FC_AVICONF0_ACTIVE_FMT_MASK = 0x40,
+	HDMI_FC_AVICONF0_ACTIVE_FMT_INFO_PRESENT = 0x40,
+	HDMI_FC_AVICONF0_ACTIVE_FMT_NO_INFO = 0x00,
+	HDMI_FC_AVICONF0_BAR_DATA_MASK = 0x0C,
+	HDMI_FC_AVICONF0_BAR_DATA_NO_DATA = 0x00,
+	HDMI_FC_AVICONF0_BAR_DATA_VERT_BAR = 0x04,
+	HDMI_FC_AVICONF0_BAR_DATA_HORIZ_BAR = 0x08,
+	HDMI_FC_AVICONF0_BAR_DATA_VERT_HORIZ_BAR = 0x0C,
+	HDMI_FC_AVICONF0_SCAN_INFO_MASK = 0x30,
+	HDMI_FC_AVICONF0_SCAN_INFO_OVERSCAN = 0x10,
+	HDMI_FC_AVICONF0_SCAN_INFO_UNDERSCAN = 0x20,
+	HDMI_FC_AVICONF0_SCAN_INFO_NODATA = 0x00,
+
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_MASK = 0x0F,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_USE_CODED = 0x08,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_4_3 = 0x09,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_16_9 = 0x0A,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_14_9 = 0x0B,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_MASK = 0x30,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_NO_DATA = 0x00,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_4_3 = 0x10,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_16_9 = 0x20,
+	HDMI_FC_AVICONF1_COLORIMETRY_MASK = 0xC0,
+	HDMI_FC_AVICONF1_COLORIMETRY_NO_DATA = 0x00,
+	HDMI_FC_AVICONF1_COLORIMETRY_SMPTE = 0x40,
+	HDMI_FC_AVICONF1_COLORIMETRY_ITUR = 0x80,
+	HDMI_FC_AVICONF1_COLORIMETRY_EXTENDED_INFO = 0xC0,
+
+	HDMI_FC_AVICONF2_SCALING_MASK = 0x03,
+	HDMI_FC_AVICONF2_SCALING_NONE = 0x00,
+	HDMI_FC_AVICONF2_SCALING_HORIZ = 0x01,
+	HDMI_FC_AVICONF2_SCALING_VERT = 0x02,
+	HDMI_FC_AVICONF2_SCALING_HORIZ_VERT = 0x03,
+	HDMI_FC_AVICONF2_RGB_QUANT_MASK = 0x0C,
+	HDMI_FC_AVICONF2_RGB_QUANT_DEFAULT = 0x00,
+	HDMI_FC_AVICONF2_RGB_QUANT_LIMITED_RANGE = 0x04,
+	HDMI_FC_AVICONF2_RGB_QUANT_FULL_RANGE = 0x08,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_MASK = 0x70,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC601 = 0x00,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC709 = 0x10,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_SYCC601 = 0x20,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_YCC601 = 0x30,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_RGB = 0x40,
+	HDMI_FC_AVICONF2_IT_CONTENT_MASK = 0x80,
+	HDMI_FC_AVICONF2_IT_CONTENT_NO_DATA = 0x00,
+	HDMI_FC_AVICONF2_IT_CONTENT_VALID = 0x80,
+
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_MASK = 0x03,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GRAPHICS = 0x00,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_PHOTO = 0x01,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_CINEMA = 0x02,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GAME = 0x03,
+	HDMI_FC_AVICONF3_QUANT_RANGE_MASK = 0x0C,
+	HDMI_FC_AVICONF3_QUANT_RANGE_LIMITED = 0x00,
+	HDMI_FC_AVICONF3_QUANT_RANGE_FULL = 0x04,
+
+/* FC_DBGFORCE field values */
+	HDMI_FC_DBGFORCE_FORCEAUDIO = 0x10,
+	HDMI_FC_DBGFORCE_FORCEVIDEO = 0x1,
+
+/* PHY_CONF0 field values */
+	HDMI_PHY_CONF0_PDZ_MASK = 0x80,
+	HDMI_PHY_CONF0_PDZ_OFFSET = 7,
+	HDMI_PHY_CONF0_ENTMDS_MASK = 0x40,
+	HDMI_PHY_CONF0_ENTMDS_OFFSET = 6,
+	HDMI_PHY_CONF0_SPARECTRL = 0x20,
+	HDMI_PHY_CONF0_GEN2_PDDQ_MASK = 0x10,
+	HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET = 4,
+	HDMI_PHY_CONF0_GEN2_TXPWRON_MASK = 0x8,
+	HDMI_PHY_CONF0_GEN2_TXPWRON_OFFSET = 3,
+	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_MASK = 0x4,
+	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_OFFSET = 2,
+	HDMI_PHY_CONF0_SELDATAENPOL_MASK = 0x2,
+	HDMI_PHY_CONF0_SELDATAENPOL_OFFSET = 1,
+	HDMI_PHY_CONF0_SELDIPIF_MASK = 0x1,
+	HDMI_PHY_CONF0_SELDIPIF_OFFSET = 0,
+
+/* PHY_TST0 field values */
+	HDMI_PHY_TST0_TSTCLR_MASK = 0x20,
+	HDMI_PHY_TST0_TSTCLR_OFFSET = 5,
+	HDMI_PHY_TST0_TSTEN_MASK = 0x10,
+	HDMI_PHY_TST0_TSTEN_OFFSET = 4,
+	HDMI_PHY_TST0_TSTCLK_MASK = 0x1,
+	HDMI_PHY_TST0_TSTCLK_OFFSET = 0,
+
+/* PHY_STAT0 field values */
+	HDMI_PHY_RX_SENSE3 = 0x80,
+	HDMI_PHY_RX_SENSE2 = 0x40,
+	HDMI_PHY_RX_SENSE1 = 0x20,
+	HDMI_PHY_RX_SENSE0 = 0x10,
+	HDMI_PHY_HPD = 0x02,
+	HDMI_PHY_TX_PHY_LOCK = 0x01,
+
+/* Convenience macro RX_SENSE | HPD */
+	HDMI_DVI_STAT = 0xF2,
+
+/* PHY_I2CM_SLAVE_ADDR field values */
+	HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2 = 0x69,
+	HDMI_PHY_I2CM_SLAVE_ADDR_HEAC_PHY = 0x49,
+
+/* PHY_I2CM_OPERATION_ADDR field values */
+	HDMI_PHY_I2CM_OPERATION_ADDR_WRITE = 0x10,
+	HDMI_PHY_I2CM_OPERATION_ADDR_READ = 0x1,
+
+/* HDMI_PHY_I2CM_INT_ADDR */
+	HDMI_PHY_I2CM_INT_ADDR_DONE_POL = 0x08,
+	HDMI_PHY_I2CM_INT_ADDR_DONE_MASK = 0x04,
+
+/* HDMI_PHY_I2CM_CTLINT_ADDR */
+	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_POL = 0x80,
+	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_MASK = 0x40,
+	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_POL = 0x08,
+	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_MASK = 0x04,
+
+/* AUD_CTS3 field values */
+	HDMI_AUD_CTS3_N_SHIFT_OFFSET = 5,
+	HDMI_AUD_CTS3_N_SHIFT_MASK = 0xe0,
+	HDMI_AUD_CTS3_N_SHIFT_1 = 0,
+	HDMI_AUD_CTS3_N_SHIFT_16 = 0x20,
+	HDMI_AUD_CTS3_N_SHIFT_32 = 0x40,
+	HDMI_AUD_CTS3_N_SHIFT_64 = 0x60,
+	HDMI_AUD_CTS3_N_SHIFT_128 = 0x80,
+	HDMI_AUD_CTS3_N_SHIFT_256 = 0xa0,
+	/* note that the CTS3 MANUAL bit has been removed
+	   from our part. Can't set it, will read as 0. */
+	HDMI_AUD_CTS3_CTS_MANUAL = 0x10,
+	HDMI_AUD_CTS3_AUDCTS19_16_MASK = 0x0f,
+
+/* AHB_DMA_CONF0 field values */
+	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_OFFSET = 7,
+	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_MASK = 0x80,
+	HDMI_AHB_DMA_CONF0_HBR = 0x10,
+	HDMI_AHB_DMA_CONF0_EN_HLOCK_OFFSET = 3,
+	HDMI_AHB_DMA_CONF0_EN_HLOCK_MASK = 0x08,
+	HDMI_AHB_DMA_CONF0_INCR_TYPE_OFFSET = 1,
+	HDMI_AHB_DMA_CONF0_INCR_TYPE_MASK = 0x06,
+	HDMI_AHB_DMA_CONF0_INCR4 = 0x0,
+	HDMI_AHB_DMA_CONF0_INCR8 = 0x2,
+	HDMI_AHB_DMA_CONF0_INCR16 = 0x4,
+	HDMI_AHB_DMA_CONF0_BURST_MODE = 0x1,
+
+/* HDMI_AHB_DMA_START field values */
+	HDMI_AHB_DMA_START_START_OFFSET = 0,
+	HDMI_AHB_DMA_START_START_MASK = 0x01,
+
+/* HDMI_AHB_DMA_STOP field values */
+	HDMI_AHB_DMA_STOP_STOP_OFFSET = 0,
+	HDMI_AHB_DMA_STOP_STOP_MASK = 0x01,
+
+/* AHB_DMA_STAT, AHB_DMA_INT, AHB_DMA_MASK, AHB_DMA_POL field values */
+	HDMI_AHB_DMA_DONE = 0x80,
+	HDMI_AHB_DMA_RETRY_SPLIT = 0x40,
+	HDMI_AHB_DMA_LOSTOWNERSHIP = 0x20,
+	HDMI_AHB_DMA_ERROR = 0x10,
+	HDMI_AHB_DMA_FIFO_THREMPTY = 0x04,
+	HDMI_AHB_DMA_FIFO_FULL = 0x02,
+	HDMI_AHB_DMA_FIFO_EMPTY = 0x01,
+
+/* AHB_DMA_BUFFSTAT, AHB_DMA_BUFFINT, AHB_DMA_BUFFMASK, AHB_DMA_BUFFPOL field values */
+	HDMI_AHB_DMA_BUFFSTAT_FULL = 0x02,
+	HDMI_AHB_DMA_BUFFSTAT_EMPTY = 0x01,
+
+/* MC_CLKDIS field values */
+	HDMI_MC_CLKDIS_HDCPCLK_DISABLE = 0x40,
+	HDMI_MC_CLKDIS_CECCLK_DISABLE = 0x20,
+	HDMI_MC_CLKDIS_CSCCLK_DISABLE = 0x10,
+	HDMI_MC_CLKDIS_AUDCLK_DISABLE = 0x8,
+	HDMI_MC_CLKDIS_PREPCLK_DISABLE = 0x4,
+	HDMI_MC_CLKDIS_TMDSCLK_DISABLE = 0x2,
+	HDMI_MC_CLKDIS_PIXELCLK_DISABLE = 0x1,
+
+/* MC_SWRSTZ field values */
+	HDMI_MC_SWRSTZ_TMDSSWRST_REQ = 0x02,
+
+/* MC_FLOWCTRL field values */
+	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_MASK = 0x1,
+	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_IN_PATH = 0x1,
+	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_BYPASS = 0x0,
+
+/* MC_PHYRSTZ field values */
+	HDMI_MC_PHYRSTZ_ASSERT = 0x0,
+	HDMI_MC_PHYRSTZ_DEASSERT = 0x1,
+
+/* MC_HEACPHY_RST field values */
+	HDMI_MC_HEACPHY_RST_ASSERT = 0x1,
+	HDMI_MC_HEACPHY_RST_DEASSERT = 0x0,
+
+/* CSC_CFG field values */
+	HDMI_CSC_CFG_INTMODE_MASK = 0x30,
+	HDMI_CSC_CFG_INTMODE_OFFSET = 4,
+	HDMI_CSC_CFG_INTMODE_DISABLE = 0x00,
+	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA1 = 0x10,
+	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA2 = 0x20,
+	HDMI_CSC_CFG_DECMODE_MASK = 0x3,
+	HDMI_CSC_CFG_DECMODE_OFFSET = 0,
+	HDMI_CSC_CFG_DECMODE_DISABLE = 0x0,
+	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA1 = 0x1,
+	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA2 = 0x2,
+	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA3 = 0x3,
+
+/* CSC_SCALE field values */
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK = 0xF0,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_24BPP = 0x00,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_30BPP = 0x50,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_36BPP = 0x60,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_48BPP = 0x70,
+	HDMI_CSC_SCALE_CSCSCALE_MASK = 0x03,
+
+/* A_HDCPCFG0 field values */
+	HDMI_A_HDCPCFG0_ELVENA_MASK = 0x80,
+	HDMI_A_HDCPCFG0_ELVENA_ENABLE = 0x80,
+	HDMI_A_HDCPCFG0_ELVENA_DISABLE = 0x00,
+	HDMI_A_HDCPCFG0_I2CFASTMODE_MASK = 0x40,
+	HDMI_A_HDCPCFG0_I2CFASTMODE_ENABLE = 0x40,
+	HDMI_A_HDCPCFG0_I2CFASTMODE_DISABLE = 0x00,
+	HDMI_A_HDCPCFG0_BYPENCRYPTION_MASK = 0x20,
+	HDMI_A_HDCPCFG0_BYPENCRYPTION_ENABLE = 0x20,
+	HDMI_A_HDCPCFG0_BYPENCRYPTION_DISABLE = 0x00,
+	HDMI_A_HDCPCFG0_SYNCRICHECK_MASK = 0x10,
+	HDMI_A_HDCPCFG0_SYNCRICHECK_ENABLE = 0x10,
+	HDMI_A_HDCPCFG0_SYNCRICHECK_DISABLE = 0x00,
+	HDMI_A_HDCPCFG0_AVMUTE_MASK = 0x8,
+	HDMI_A_HDCPCFG0_AVMUTE_ENABLE = 0x8,
+	HDMI_A_HDCPCFG0_AVMUTE_DISABLE = 0x0,
+	HDMI_A_HDCPCFG0_RXDETECT_MASK = 0x4,
+	HDMI_A_HDCPCFG0_RXDETECT_ENABLE = 0x4,
+	HDMI_A_HDCPCFG0_RXDETECT_DISABLE = 0x0,
+	HDMI_A_HDCPCFG0_EN11FEATURE_MASK = 0x2,
+	HDMI_A_HDCPCFG0_EN11FEATURE_ENABLE = 0x2,
+	HDMI_A_HDCPCFG0_EN11FEATURE_DISABLE = 0x0,
+	HDMI_A_HDCPCFG0_HDMIDVI_MASK = 0x1,
+	HDMI_A_HDCPCFG0_HDMIDVI_HDMI = 0x1,
+	HDMI_A_HDCPCFG0_HDMIDVI_DVI = 0x0,
+
+/* A_HDCPCFG1 field values */
+	HDMI_A_HDCPCFG1_DISSHA1CHECK_MASK = 0x8,
+	HDMI_A_HDCPCFG1_DISSHA1CHECK_DISABLE = 0x8,
+	HDMI_A_HDCPCFG1_DISSHA1CHECK_ENABLE = 0x0,
+	HDMI_A_HDCPCFG1_PH2UPSHFTENC_MASK = 0x4,
+	HDMI_A_HDCPCFG1_PH2UPSHFTENC_ENABLE = 0x4,
+	HDMI_A_HDCPCFG1_PH2UPSHFTENC_DISABLE = 0x0,
+	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_MASK = 0x2,
+	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_DISABLE = 0x2,
+	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_ENABLE = 0x0,
+	HDMI_A_HDCPCFG1_SWRESET_MASK = 0x1,
+	HDMI_A_HDCPCFG1_SWRESET_ASSERT = 0x0,
+
+/* A_VIDPOLCFG field values */
+	HDMI_A_VIDPOLCFG_UNENCRYPTCONF_MASK = 0x60,
+	HDMI_A_VIDPOLCFG_UNENCRYPTCONF_OFFSET = 5,
+	HDMI_A_VIDPOLCFG_DATAENPOL_MASK = 0x10,
+	HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH = 0x10,
+	HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_LOW = 0x0,
+	HDMI_A_VIDPOLCFG_VSYNCPOL_MASK = 0x8,
+	HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_HIGH = 0x8,
+	HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_LOW = 0x0,
+	HDMI_A_VIDPOLCFG_HSYNCPOL_MASK = 0x2,
+	HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_HIGH = 0x2,
+	HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_LOW = 0x0,
+};
+
+#endif /* __MXC_HDMI_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch/sys_proto.h ebf_6ull_uboot/arch/arm/include/asm/arch/sys_proto.h
--- u-boot-2016.03/arch/arm/include/asm/arch/sys_proto.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch/sys_proto.h	2021-04-16 14:42:14.692580786 +0800
@@ -0,0 +1,21 @@
+/*
+ * (C) Copyright 2009
+ * Stefano Babic, DENX Software Engineering, sbabic@denx.de.
+ *
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/imx-common/sys_proto.h>
+#include <asm/arch/module_fuse.h>
+
+void set_wdog_reset(struct wdog_regs *wdog);
+#ifdef CONFIG_LDO_BYPASS_CHECK
+int check_ldo_bypass(void);
+int check_1_2G(void);
+int set_anatop_bypass(int wdog_reset_pin);
+void ldo_mode_set(int ldo_bypass);
+void prep_anatop_bypass(void);
+void finish_anatop_bypass(void);
+#endif
diff -urN u-boot-2016.03/arch/arm/include/asm/arch-imx/cpu.h ebf_6ull_uboot/arch/arm/include/asm/arch-imx/cpu.h
--- u-boot-2016.03/arch/arm/include/asm/arch-imx/cpu.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch-imx/cpu.h	2021-04-16 14:42:14.688580767 +0800
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2014 Freescale Semiconductor, Inc.
+ * (C) Copyright 2014-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -17,8 +17,10 @@
 #define MXC_CPU_MX6SX		0x62
 #define MXC_CPU_MX6Q		0x63
 #define MXC_CPU_MX6UL		0x64
-#define MXC_CPU_MX6SOLO		0x65 /* dummy ID */
-#define MXC_CPU_MX6D		0x67
+#define MXC_CPU_MX6ULL		0x65
+#define MXC_CPU_MX6SOLO		0x66 /* dummy */
+#define MXC_CPU_MX6SLL		0x67
+#define MXC_CPU_MX6D		0x6A
 #define MXC_CPU_MX6DP		0x68
 #define MXC_CPU_MX6QP		0x69
 #define MXC_CPU_MX7D		0x72
diff -urN u-boot-2016.03/arch/arm/include/asm/arch-mx6/clock.h ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/clock.h
--- u-boot-2016.03/arch/arm/include/asm/arch-mx6/clock.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/clock.h	2021-04-16 14:42:14.688580767 +0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2009
  * Stefano Babic, DENX Software Engineering, sbabic@denx.de.
  *
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -67,7 +69,10 @@
 int enable_fec_anatop_clock(int fec_id, enum enet_freq freq);
 void enable_enet_clk(unsigned char enable);
 int enable_lcdif_clock(u32 base_addr);
+int enable_lvds_bridge(u32 lcd_base_addr);
 void enable_qspi_clk(int qspi_num);
 void enable_thermal_clk(void);
+void enable_epdc_clock(void);
 void mxs_set_lcdclk(u32 base_addr, u32 freq);
+void mxs_set_vadcclk(void);
 #endif /* __ASM_ARCH_CLOCK_H */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch-mx6/crm_regs.h ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/crm_regs.h
--- u-boot-2016.03/arch/arm/include/asm/arch-mx6/crm_regs.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/crm_regs.h	2021-04-16 14:42:14.688580767 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2011-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -265,11 +265,20 @@
 #define MXC_CCM_CBCMR_GPU3D_SHADER_PODF_OFFSET		29
 #define MXC_CCM_CBCMR_GPU3D_CORE_PODF_MASK		(0x7 << 26)
 #define MXC_CCM_CBCMR_GPU3D_CORE_PODF_OFFSET		26
-/* LCDIF on i.MX6SX/UL */
+/* LCDIF on i.MX6SX/UL/SLL */
 #define MXC_CCM_CBCMR_LCDIF1_PODF_MASK                  (0x7 << 23)
 #define MXC_CCM_CBCMR_LCDIF1_PODF_OFFSET                23
-#define MXC_CCM_CBCMR_GPU2D_CORE_PODF_MASK		(0x7 << 23)
-#define MXC_CCM_CBCMR_GPU2D_CORE_PODF_OFFSET		23
+#define MXC_CCM_CBCMR_GPU2D_CORE_CLK_PODF_MASK		(0x7 << 23)
+#define MXC_CCM_CBCMR_GPU2D_CORE_CLK_PODF_OFFSET		23
+
+/* For i.MX6SL */
+#define MXC_CCM_CBCMR_GPU2D_CORE_PODF_MASK		(0x7 << 29)
+#define MXC_CCM_CBCMR_GPU2D_CORE_PODF_OFFSET		29
+#define MXC_CCM_CBCMR_GPU2D_OVG_CORE_PODF_MASK		(0x7 << 26)
+#define MXC_CCM_CBCMR_GPU2D_OVG_CORE_PODF_OFFSET		26
+#define MXC_CCM_CBCMR_EPDC_PIX_PODF_MASK		(0x7 << 23)
+#define MXC_CCM_CBCMR_EPDC_PIX_PODF_OFFSET		23
+
 #define MXC_CCM_CBCMR_PRE_PERIPH2_CLK_SEL_MASK		(0x3 << 21)
 #define MXC_CCM_CBCMR_PRE_PERIPH2_CLK_SEL_OFFSET	21
 #define MXC_CCM_CBCMR_PERIPH2_CLK2_SEL			(1 << 20)
@@ -291,6 +300,14 @@
 #define MXC_CCM_CBCMR_GPU3D_SHADER_CLK_SEL_OFFSET	8
 #define MXC_CCM_CBCMR_GPU3D_CORE_CLK_SEL_MASK		(0x3 << 4)
 #define MXC_CCM_CBCMR_GPU3D_CORE_CLK_SEL_OFFSET		4
+
+/* For i.MX6SL */
+#define MXC_CCM_CBCMR_GPU2D_CORE_CLK_SEL_MASK		(0x3 << 8)
+#define MXC_CCM_CBCMR_GPU2D_CORE_CLK_SEL_OFFSET	8
+#define MXC_CCM_CBCMR_GPU2D_OVG_CORE_CLK_SEL_MASK		(0x3 << 4)
+#define MXC_CCM_CBCMR_GPU2D_OVG_CORE_CLK_SEL_OFFSET		4
+
+
 /* Exists on i.MX6QP */
 #define MXC_CCM_CBCMR_PRE_CLK_SEL			(1 << 1)
 
@@ -307,6 +324,9 @@
 /* LCFIF2_PODF on i.MX6SX */
 #define MXC_CCM_CSCMR1_LCDIF2_PODF_MASK			(0x7 << 20)
 #define MXC_CCM_CSCMR1_LCDIF2_PODF_OFFSET               20
+/* LCDIF_PIX_PODF on i.MX6SL */
+#define MXC_CCM_CSCMR1_LCDIF_PIX_PODF_MASK			(0x7 << 20)
+#define MXC_CCM_CSCMR1_LCDIF_PIX_PODF_OFFSET               20
 /* ACLK_EMI on i.MX6DQ/SDL/DQP */
 #define MXC_CCM_CSCMR1_ACLK_EMI_PODF_MASK		(0x7 << 20)
 #define MXC_CCM_CSCMR1_ACLK_EMI_PODF_OFFSET		20
@@ -379,6 +399,16 @@
 #define MXC_CCM_CSCDR1_UART_CLK_SEL			(1 << 6)
 
 /* Define the bits in register CS1CDR */
+/* MX6UL, !MX6ULL */
+#define MXC_CCM_CS1CDR_SAI3_CLK_PRED_MASK		(0x7 << 22)
+#define MXC_CCM_CS1CDR_SAI3_CLK_PRED_OFFSET		22
+#define MXC_CCM_CS1CDR_SAI3_CLK_PODF_MASK		(0x3F << 16)
+#define MXC_CCM_CS1CDR_SAI3_CLK_PODF_OFFSET		16
+#define MXC_CCM_CS1CDR_SAI1_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CS1CDR_SAI1_CLK_PRED_OFFSET		6
+#define MXC_CCM_CS1CDR_SAI1_CLK_PODF_MASK		0x3F
+#define MXC_CCM_CS1CDR_SAI1_CLK_PODF_OFFSET		0
+
 #define MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK		(0x3F << 25)
 #define MXC_CCM_CS1CDR_ESAI_CLK_PODF_OFFSET		25
 #define MXC_CCM_CS1CDR_SSI3_CLK_PRED_MASK		(0x7 << 22)
@@ -419,15 +449,15 @@
 #define MXC_CCM_CS2CDR_ENFC_CLK_SEL_DQ(v)		(((v) & 0x3) << 16)
 
 #define MXC_CCM_CS2CDR_ENFC_CLK_SEL_MASK		\
-	((is_mx6dqp() || is_cpu_type(MXC_CPU_MX6UL)) ?	\
+	((is_mx6dqp() || is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL)) ? \
 	 MXC_CCM_CS2CDR_ENFC_CLK_SEL_MASK_DQP :		\
 	 MXC_CCM_CS2CDR_ENFC_CLK_SEL_MASK_DQ)
 #define MXC_CCM_CS2CDR_ENFC_CLK_SEL_OFFSET		\
-	((is_mx6dqp() || is_cpu_type(MXC_CPU_MX6UL)) ?	\
+	((is_mx6dqp() || is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL)) ? \
 	 MXC_CCM_CS2CDR_ENFC_CLK_SEL_OFFSET_DQP :	\
 	 MXC_CCM_CS2CDR_ENFC_CLK_SEL_OFFSET_DQ)
 #define MXC_CCM_CS2CDR_ENFC_CLK_SEL(v)			\
-	((is_mx6dqp() || is_cpu_type(MXC_CPU_MX6UL)) ?	\
+	((is_mx6dqp() || is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL)) ? \
 	 MXC_CCM_CS2CDR_ENFC_CLK_SEL_DQP(v) :		\
 	 MXC_CCM_CS2CDR_ENFC_CLK_SEL_DQ(v))
 
@@ -460,7 +490,7 @@
 #define MXC_CCM_CDCDR_SPDIF1_CLK_SEL_OFFSET		7
 
 /* Define the bits in register CHSCCDR */
-#ifdef CONFIG_MX6SX
+/* i.MX 6SX */
 #define MXC_CCM_CHSCCDR_ENET_PRE_CLK_SEL_MASK		(0x7 << 15)
 #define MXC_CCM_CHSCCDR_ENET_PRE_CLK_SEL_OFFSET		15
 #define MXC_CCM_CHSCCDR_ENET_PODF_MASK			(0x7 << 12)
@@ -473,7 +503,7 @@
 #define MXC_CCM_CHSCCDR_M4_PODF_OFFSET			3
 #define MXC_CCM_CHSCCDR_M4_CLK_SEL_MASK			(0x7)
 #define MXC_CCM_CHSCCDR_M4_CLK_SEL_OFFSET		0
-#else
+
 #define MXC_CCM_CHSCCDR_IPU1_DI1_PRE_CLK_SEL_MASK	(0x7 << 15)
 #define MXC_CCM_CHSCCDR_IPU1_DI1_PRE_CLK_SEL_OFFSET	15
 #define MXC_CCM_CHSCCDR_IPU1_DI1_PODF_MASK		(0x7 << 12)
@@ -486,7 +516,14 @@
 #define MXC_CCM_CHSCCDR_IPU1_DI0_PODF_OFFSET		3
 #define MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_MASK		(0x7)
 #define MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET		0
-#endif
+
+/* i.MX6ULL/SLL */
+#define MXC_CCM_CHSCCDR_EPDC_PRE_CLK_SEL_MASK		(0x7 << 15)
+#define MXC_CCM_CHSCCDR_EPDC_PRE_CLK_SEL_OFFSET		15
+#define MXC_CCM_CHSCCDR_EPDC_PODF_MASK			(0x7 << 12)
+#define MXC_CCM_CHSCCDR_EPDC_PODF_OFFSET			12
+#define MXC_CCM_CHSCCDR_EPDC_CLK_SEL_MASK		(0x7 << 9)
+#define MXC_CCM_CHSCCDR_EPDC_CLK_SEL_OFFSET		9
 
 #define CHSCCDR_CLK_SEL_LDB_DI0				3
 #define CHSCCDR_PODF_DIVIDE_BY_3			2
@@ -497,13 +534,20 @@
 #define MXC_CCM_CSCDR2_ECSPI_CLK_PODF_OFFSET		19
 /* ECSPI_CLK_SEL exists on i.MX6SX/SL/QP */
 #define MXC_CCM_CSCDR2_ECSPI_CLK_SEL_MASK		(0x1 << 18)
-/* LCDIF1 on i.MX6SX/UL */
+/* LCDIF1 on i.MX6SX/UL/SLL */
 #define MXC_CCM_CSCDR2_LCDIF1_PRED_SEL_MASK             (0x7 << 15)
 #define MXC_CCM_CSCDR2_LCDIF1_PRED_SEL_OFFSET           15
 #define MXC_CCM_CSCDR2_LCDIF1_PRE_DIV_MASK              (0x7 << 12)
 #define MXC_CCM_CSCDR2_LCDIF1_PRE_DIV_OFFSET            12
 #define MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_MASK              (0x7 << 9)
 #define MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_OFFSET            9
+
+/* EPDC on i.MX6SL */
+#define MXC_CCM_CSCDR2_EPDC_PIX_CLK_SEL_MASK             (0x7 << 15)
+#define MXC_CCM_CSCDR2_EPDC_PIX_CLK_SEL_OFFSET           15
+#define MXC_CCM_CSCDR2_EPDC_PIX_PRE_DIV_MASK              (0x7 << 12)
+#define MXC_CCM_CSCDR2_EPDC_PIX_PRE_DIV_OFFSET            12
+
 /* LCDIF2 on i.MX6SX */
 #define MXC_CCM_CSCDR2_LCDIF2_PRED_SEL_MASK             (0x7 << 6)
 #define MXC_CCM_CSCDR2_LCDIF2_PRED_SEL_OFFSET           6
@@ -512,6 +556,13 @@
 #define MXC_CCM_CSCDR2_LCDIF2_CLK_SEL_MASK              (0x7 << 0)
 #define MXC_CCM_CSCDR2_LCDIF2_CLK_SEL_OFFSET             0
 
+/*LCD on i.MX6SL */
+#define MXC_CCM_CSCDR2_LCDIF_PIX_CLK_SEL_MASK             (0x7 << 6)
+#define MXC_CCM_CSCDR2_LCDIF_PIX_CLK_SEL_OFFSET           6
+#define MXC_CCM_CSCDR2_LCDIF_PIX_PRE_DIV_MASK              (0x7 << 3)
+#define MXC_CCM_CSCDR2_LCDIF_PIX_PRE_DIV_OFFSET            3
+
+
 /* All IPU2_DI1 are LCDIF1 on MX6SX */
 #define MXC_CCM_CHSCCDR_IPU2_DI1_PRE_CLK_SEL_MASK	(0x7 << 15)
 #define MXC_CCM_CHSCCDR_IPU2_DI1_PRE_CLK_SEL_OFFSET	15
@@ -537,6 +588,23 @@
 #define MXC_CCM_CSCDR3_IPU1_HSP_CLK_SEL_MASK		(0x3 << 9)
 #define MXC_CCM_CSCDR3_IPU1_HSP_CLK_SEL_OFFSET		9
 
+/* For i.MX6SL */
+#define MXC_CCM_CSCDR3_LCDIF_AXI_PODF_MASK		(0x7 << 16)
+#define MXC_CCM_CSCDR3_LCDIF_AXI_PODF_OFFSET		16
+#define MXC_CCM_CSCDR3_LCDIF_AXI_CLK_SEL_MASK		(0x3 << 14)
+#define MXC_CCM_CSCDR3_LCDIF_AXI_CLK_SEL_OFFSET		14
+#define MXC_CCM_CSCDR3_CSI_CORE_PODF_MASK		(0x7 << 11)
+#define MXC_CCM_CSCDR3_CSI_CORE_PODF_OFFSET		11
+#define MXC_CCM_CSCDR3_CSI_CORE_CLK_SEL_MASK		(0x3 << 9)
+#define MXC_CCM_CSCDR3_CSI_CORE_CLK_SEL_OFFSET		9
+
+/* For i.MX6SLL */
+#define MXC_CCM_CSCDR3_PXP_PODF_MASK		(0x7 << 16)
+#define MXC_CCM_CSCDR3_PXP_PODF_OFFSET		16
+#define MXC_CCM_CSCDR3_PXP_CLK_SEL_MASK		(0x3 << 14)
+#define MXC_CCM_CSCDR3_PXP_CLK_SEL_OFFSET		14
+
+
 /* Define the bits in register CDHIPR */
 #define MXC_CCM_CDHIPR_ARM_PODF_BUSY			(1 << 16)
 #define MXC_CCM_CDHIPR_PERIPH_CLK_SEL_BUSY		(1 << 5)
@@ -626,6 +694,12 @@
 /* Define the bits in registers CCGRx */
 #define MXC_CCM_CCGR_CG_MASK				3
 
+/* i.MX 6ULL */
+#define MXC_CCM_CCGR0_DCP_CLK_OFFSET		10
+#define MXC_CCM_CCGR0_DCP_CLK_MASK		(3 << MXC_CCM_CCGR0_DCP_CLK_OFFSET)
+#define MXC_CCM_CCGR0_ENET_CLK_ENABLE_OFFSET	12
+#define MXC_CCM_CCGR0_ENET_CLK_ENABLE_MASK	(3 << MXC_CCM_CCGR0_ENET_CLK_ENABLE_OFFSET)
+
 #define MXC_CCM_CCGR0_AIPS_TZ1_OFFSET			0
 #define MXC_CCM_CCGR0_AIPS_TZ1_MASK			(3 << MXC_CCM_CCGR0_AIPS_TZ1_OFFSET)
 #define MXC_CCM_CCGR0_AIPS_TZ2_OFFSET			2
@@ -702,13 +776,13 @@
 #define MXC_CCM_CCGR1_CANFD_MASK			(3 << MXC_CCM_CCGR1_CANFD_OFFSET)
 #endif
 
-#ifndef CONFIG_MX6SX
 #define MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_OFFSET		0
 #define MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_MASK		(3 << MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_OFFSET)
-#else
+
+/* i.MX6SX/UL */
 #define MXC_CCM_CCGR2_CSI_OFFSET			2
 #define MXC_CCM_CCGR2_CSI_MASK				(3 << MXC_CCM_CCGR2_CSI_OFFSET)
-#endif
+
 #ifndef CONFIG_MX6SX
 #define MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_OFFSET		4
 #define MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_MASK		(3 << MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_OFFSET)
@@ -733,7 +807,7 @@
 #define MXC_CCM_CCGR2_IPMUX3_MASK			(3 << MXC_CCM_CCGR2_IPMUX3_OFFSET)
 #define MXC_CCM_CCGR2_IPSYNC_IP2APB_TZASC1_IPGS_OFFSET	22
 #define MXC_CCM_CCGR2_IPSYNC_IP2APB_TZASC1_IPGS_MASK	(3 << MXC_CCM_CCGR2_IPSYNC_IP2APB_TZASC1_IPGS_OFFSET)
-/* i.MX6SX/UL LCD and PXP */
+/* i.MX6SX/UL/SLL LCD and PXP */
 #define MXC_CCM_CCGR2_LCD_OFFSET			28
 #define MXC_CCM_CCGR2_LCD_MASK				(3 << MXC_CCM_CCGR2_LCD_OFFSET)
 #define MXC_CCM_CCGR2_PXP_OFFSET			30
@@ -744,14 +818,37 @@
 #define MXC_CCM_CCGR2_IPSYNC_VDOA_IPG_MASTER_CLK_OFFSET	26
 #define MXC_CCM_CCGR2_IPSYNC_VDOA_IPG_MASTER_CLK_MASK	(3 << MXC_CCM_CCGR2_IPSYNC_VDOA_IPG_MASTER_CLK_OFFSET)
 
+/* i.MX6ULL */
+#define MXC_CCM_CCGR2_ESAI_CLK_OFFSET		0
+#define MXC_CCM_CCGR2_ESAI_CLK_MASK		(3 << MXC_CCM_CCGR2_ESAI_CLK_OFFSET)
+#define MXC_CCM_CCGR2_IOMUXC_SNVS_CLK_OFFSET		4
+#define MXC_CCM_CCGR2_IOMUXC_SNVS_CLK_MASK		(3 << MXC_CCM_CCGR2_IOMUXC_SNVS_CLK_OFFSET)
+
 /* Exist on i.MX6SX */
 #define MXC_CCM_CCGR3_M4_OFFSET					2
 #define MXC_CCM_CCGR3_M4_MASK					(3 << MXC_CCM_CCGR3_M4_OFFSET)
+/* i.MX6ULL */
+#define MXC_CCM_CCGR3_EPDC_CLK_ENABLE_OFFSET			4
+#define MXC_CCM_CCGR3_EPDC_CLK_ENABLE_MASK			(3 << MXC_CCM_CCGR3_EPDC_CLK_ENABLE_OFFSET)
 #define MXC_CCM_CCGR3_ENET_OFFSET				4
 #define MXC_CCM_CCGR3_ENET_MASK					(3 << MXC_CCM_CCGR3_ENET_OFFSET)
 #define MXC_CCM_CCGR3_QSPI_OFFSET				14
 #define MXC_CCM_CCGR3_QSPI_MASK					(3 << MXC_CCM_CCGR3_QSPI_OFFSET)
 
+/* i.MX6SL */
+#define MXC_CCM_CCGR3_CSI_CORE_OFFSET			0
+#define MXC_CCM_CCGR3_CSI_CORE_MASK				(3 << MXC_CCM_CCGR3_CSI_CORE_OFFSET)
+#define MXC_CCM_CCGR3_PXP_AXI_OFFSET			2
+#define MXC_CCM_CCGR3_PXP_AXI_MASK				(3 << MXC_CCM_CCGR3_PXP_AXI_OFFSET)
+#define MXC_CCM_CCGR3_EPDC_AXI_OFFSET			4
+#define MXC_CCM_CCGR3_EPDC_AXI_MASK				(3 << MXC_CCM_CCGR3_EPDC_AXI_OFFSET)
+#define MXC_CCM_CCGR3_LCDIF_AXI_OFFSET			6
+#define MXC_CCM_CCGR3_LCDIF_AXI_MASK			(3 << MXC_CCM_CCGR3_LCDIF_AXI_OFFSET)
+#define MXC_CCM_CCGR3_LCDIF_PIX_OFFSET			8
+#define MXC_CCM_CCGR3_LCDIF_PIX_MASK			(3 << MXC_CCM_CCGR3_LCDIF_PIX_OFFSET)
+#define MXC_CCM_CCGR3_EPDC_PIX_OFFSET			10
+#define MXC_CCM_CCGR3_EPDC_PIX_MASK				(3 << MXC_CCM_CCGR3_EPDC_PIX_OFFSET)
+
 #define MXC_CCM_CCGR3_IPU1_IPU_OFFSET				0
 #define MXC_CCM_CCGR3_IPU1_IPU_MASK				(3 << MXC_CCM_CCGR3_IPU1_IPU_OFFSET)
 #define MXC_CCM_CCGR3_IPU1_IPU_DI0_OFFSET			2
@@ -808,7 +905,7 @@
 #define MXC_CCM_CCGR3_OCRAM_OFFSET				28
 #define MXC_CCM_CCGR3_OCRAM_MASK				(3 << MXC_CCM_CCGR3_OCRAM_OFFSET)
 
-/* GPIO4 on i.MX6UL */
+/* GPIO4 on i.MX6UL/ULL */
 #define MXC_CCM_CCGR3_GPIO4_CLK_OFFSET				30
 #define MXC_CCM_CCGR3_GPIO4_CLK_MASK				(3 << MXC_CCM_CCGR3_GPIO4_CLK_OFFSET)
 
@@ -817,6 +914,10 @@
 #define MXC_CCM_CCGR3_OPENVGAXICLK_MASK				(3 << MXC_CCM_CCGR3_OPENVGAXICLK_OFFSET)
 #endif
 
+/* i.MX6ULL */
+#define MXC_CCM_CCGR3_IOMUXC_SNVS_GPR_CLK_OFFSET		30
+#define MXC_CCM_CCGR3_IOMUXC_SNVS_GPR_CLK_MASK			(3 << MXC_CCM_CCGR3_IOMUXC_SNVS_GPR_CLK_OFFSET)
+
 #define MXC_CCM_CCGR4_PCIE_OFFSET				0
 #define MXC_CCM_CCGR4_PCIE_MASK					(3 << MXC_CCM_CCGR4_PCIE_OFFSET)
 /* QSPI2 on i.MX6SX */
@@ -883,6 +984,13 @@
 #define MXC_CCM_CCGR6_USDHC1_MASK		(3 << MXC_CCM_CCGR6_USDHC1_OFFSET)
 #define MXC_CCM_CCGR6_USDHC2_OFFSET		4
 #define MXC_CCM_CCGR6_USDHC2_MASK		(3 << MXC_CCM_CCGR6_USDHC2_OFFSET)
+#define MXC_CCM_CCGR6_SIM1_CLK_OFFSET		6
+#define MXC_CCM_CCGR6_SIM1_CLK_MASK		(3 << MXC_CCM_CCGR6_SIM1_CLK_OFFSET)
+#define MXC_CCM_CCGR6_SIM2_CLK_OFFSET		8
+#define MXC_CCM_CCGR6_SIM2_CLK_MASK		(3 << MXC_CCM_CCGR6_SIM2_CLK_OFFSET)
+/* i.MX6ULL */
+#define MXC_CCM_CCGR6_IPMUX4_CLK_OFFSET		8
+#define MXC_CCM_CCGR6_IPMUX4_CLK_MASK		(3 << MXC_CCM_CCGR6_IPMUX4_CLK_OFFSET)
 /* GPMI/BCH on i.MX6UL */
 #define MXC_CCM_CCGR6_BCH_OFFSET		6
 #define MXC_CCM_CCGR6_BCH_MASK			(3 << MXC_CCM_CCGR6_BCH_OFFSET)
@@ -895,6 +1003,9 @@
 #define MXC_CCM_CCGR6_USDHC4_MASK		(3 << MXC_CCM_CCGR6_USDHC4_OFFSET)
 #define MXC_CCM_CCGR6_EMI_SLOW_OFFSET		10
 #define MXC_CCM_CCGR6_EMI_SLOW_MASK		(3 << MXC_CCM_CCGR6_EMI_SLOW_OFFSET)
+/* i.MX6ULL */
+#define MXC_CCM_CCGR6_AIPS_TZ3_CLK_OFFSET	18
+#define MXC_CCM_CCGR6_AIPS_TZ3_CLK_MASK		(3 << MXC_CCM_CCGR6_AIPS_TZ3_CLK_OFFSET)
 /* The following *CCGR6* exist only i.MX6SX */
 #define MXC_CCM_CCGR6_PWM8_OFFSET		16
 #define MXC_CCM_CCGR6_PWM8_MASK			(3 << MXC_CCM_CCGR6_PWM8_OFFSET)
@@ -1226,6 +1337,7 @@
 	(((v) << 0) & BM_ANADIG_PFD_528_PFD0_FRAC)
 
 #define BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF 0x00000008
+#define BM_ANADIG_ANA_MISC0_REFTOP_VBGADJ_SHIFT 4
 
 #define BM_PMU_MISC2_AUDIO_DIV_MSB (1 << 23)
 #define BP_PMU_MISC2_AUDIO_DIV_MSB 23
diff -urN u-boot-2016.03/arch/arm/include/asm/arch-mx6/imx-regs.h ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/imx-regs.h
--- u-boot-2016.03/arch/arm/include/asm/arch-mx6/imx-regs.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/imx-regs.h	2021-04-16 14:42:14.688580767 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -32,7 +32,7 @@
 #define APBH_DMA_ARB_END_ADDR           0x0180BFFF
 #define M4_BOOTROM_BASE_ADDR			0x007F8000
 
-#else
+#elif !defined(CONFIG_MX6SLL)
 #define CAAM_ARB_BASE_ADDR              0x00100000
 #define CAAM_ARB_END_ADDR               0x00103FFF
 #define APBH_DMA_ARB_BASE_ADDR          0x00110000
@@ -52,21 +52,16 @@
 #define MXS_BCH_BASE			(APBH_DMA_ARB_BASE_ADDR + 0x04000)
 
 /* GPV - PL301 configuration ports */
-#if (defined(CONFIG_MX6SL) || defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL))
-#define GPV2_BASE_ADDR                  0x00D00000
-#else
-#define GPV2_BASE_ADDR			0x00200000
-#endif
-
-#if (defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL))
+#if (defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || defined(CONFIG_MX6SL) || defined(CONFIG_MX6SLL))
+#define GPV2_BASE_ADDR          0x00D00000
 #define GPV3_BASE_ADDR			0x00E00000
 #define GPV4_BASE_ADDR			0x00F00000
 #define GPV5_BASE_ADDR			0x01000000
 #define GPV6_BASE_ADDR			0x01100000
 #define PCIE_ARB_BASE_ADDR              0x08000000
 #define PCIE_ARB_END_ADDR               0x08FFFFFF
-
 #else
+#define GPV2_BASE_ADDR			0x00200000
 #define GPV3_BASE_ADDR			0x00300000
 #define GPV4_BASE_ADDR			0x00800000
 #define PCIE_ARB_BASE_ADDR              0x01000000
@@ -102,7 +97,7 @@
 #define WEIM_ARB_END_ADDR               0x57FFFFFF
 #define QSPI0_AMBA_BASE                 0x60000000
 #define QSPI0_AMBA_END                  0x6FFFFFFF
-#else
+#elif !defined(CONFIG_MX6SLL)
 #define SATA_ARB_BASE_ADDR              0x02200000
 #define SATA_ARB_END_ADDR               0x02203FFF
 #define OPENVG_ARB_BASE_ADDR            0x02204000
@@ -117,7 +112,7 @@
 #define WEIM_ARB_END_ADDR               0x0FFFFFFF
 #endif
 
-#if (defined(CONFIG_MX6SL) || defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL))
+#if (defined(CONFIG_MX6SLL) || defined(CONFIG_MX6SL) || defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL))
 #define MMDC0_ARB_BASE_ADDR             0x80000000
 #define MMDC0_ARB_END_ADDR              0xFFFFFFFF
 #define MMDC1_ARB_BASE_ADDR             0xC0000000
@@ -129,7 +124,12 @@
 #define MMDC1_ARB_END_ADDR              0xFFFFFFFF
 #endif
 
-#ifndef CONFIG_MX6SX
+#define QSPI1_ARB_BASE_ADDR             0x60000000
+#define QSPI1_ARB_END_ADDR              0x6FFFFFFF
+#define QSPI2_ARB_BASE_ADDR             0x70000000
+#define QSPI2_ARB_END_ADDR              0x7FFFFFFF
+
+#if (!(defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || defined(CONFIG_MX6SLL)))
 #define IPU_SOC_BASE_ADDR		IPU1_ARB_BASE_ADDR
 #define IPU_SOC_OFFSET			0x00200000
 #endif
@@ -147,28 +147,40 @@
 #define ECSPI2_BASE_ADDR            (ATZ1_BASE_ADDR + 0x0C000)
 #define ECSPI3_BASE_ADDR            (ATZ1_BASE_ADDR + 0x10000)
 #define ECSPI4_BASE_ADDR            (ATZ1_BASE_ADDR + 0x14000)
-#ifdef CONFIG_MX6SL
-#define UART5_IPS_BASE_ADDR         (ATZ1_BASE_ADDR + 0x18000)
-#define UART1_IPS_BASE_ADDR         (ATZ1_BASE_ADDR + 0x20000)
-#define UART2_IPS_BASE_ADDR         (ATZ1_BASE_ADDR + 0x24000)
-#define SSI1_IPS_BASE_ADDR          (ATZ1_BASE_ADDR + 0x28000)
-#define SSI2_IPS_BASE_ADDR          (ATZ1_BASE_ADDR + 0x2C000)
-#define SSI3_IPS_BASE_ADDR          (ATZ1_BASE_ADDR + 0x30000)
-#define UART3_IPS_BASE_ADDR         (ATZ1_BASE_ADDR + 0x34000)
-#define UART4_IPS_BASE_ADDR         (ATZ1_BASE_ADDR + 0x38000)
-#else
-#ifndef CONFIG_MX6SX
+
+#define MX6SL_UART5_BASE_ADDR       (ATZ1_BASE_ADDR + 0x18000)
+#define MX6SLL_UART4_BASE_ADDR      (ATZ1_BASE_ADDR + 0x18000)
+#define MX6UL_UART7_BASE_ADDR       (ATZ1_BASE_ADDR + 0x18000)
 #define ECSPI5_BASE_ADDR            (ATZ1_BASE_ADDR + 0x18000)
-#endif
+
 #define UART1_BASE                  (ATZ1_BASE_ADDR + 0x20000)
+
+#define MX6SL_UART2_BASE_ADDR       (ATZ1_BASE_ADDR + 0x24000)
+#define MX6SLL_UART2_BASE_ADDR      (ATZ1_BASE_ADDR + 0x24000)
+#define MX6UL_UART8_BASE_ADDR       (ATZ1_BASE_ADDR + 0x24000)
 #define ESAI1_BASE_ADDR             (ATZ1_BASE_ADDR + 0x24000)
+
+#if defined(CONFIG_MX6UL)
+#define SAI1_BASE_ADDR              (ATZ1_BASE_ADDR + 0x28000)
+#define SAI2_BASE_ADDR              (ATZ1_BASE_ADDR + 0x2C000)
+#define SAI3_BASE_ADDR              (ATZ1_BASE_ADDR + 0x30000)
+#else
 #define SSI1_BASE_ADDR              (ATZ1_BASE_ADDR + 0x28000)
 #define SSI2_BASE_ADDR              (ATZ1_BASE_ADDR + 0x2C000)
 #define SSI3_BASE_ADDR              (ATZ1_BASE_ADDR + 0x30000)
-#define ASRC_BASE_ADDR              (ATZ1_BASE_ADDR + 0x34000)
 #endif
 
-#ifndef CONFIG_MX6SX
+#define MX6SL_UART3_BASE_ADDR       (ATZ1_BASE_ADDR + 0x34000)
+#define MX6SLL_UART3_BASE_ADDR      (ATZ1_BASE_ADDR + 0x34000)
+#define ASRC_BASE_ADDR              (ATZ1_BASE_ADDR + 0x34000)
+
+#define MX6SL_UART4_BASE_ADDR       (ATZ1_BASE_ADDR + 0x38000)
+
+
+#if defined(CONFIG_MX6UL)
+#define TOUCH_CTRL_BASE_ADDR        (ATZ1_BASE_ADDR + 0x40000)
+#define BEE_BASE_ADDR               (ATZ1_BASE_ADDR + 0x44000)
+#elif !defined(CONFIG_MX6SX)
 #define SPBA_BASE_ADDR              (ATZ1_BASE_ADDR + 0x3C000)
 #define VPU_BASE_ADDR               (ATZ1_BASE_ADDR + 0x40000)
 #endif
@@ -179,16 +191,25 @@
 #define PWM2_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x4000)
 #define PWM3_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x8000)
 #define PWM4_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0xC000)
+/* No CAN on i.MX6SLL */
 #define CAN1_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x10000)
 #define CAN2_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x14000)
+/* QOSC on i.MX6SLL */
+#define QOSC_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x14000)
 #define GPT1_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x18000)
 #define GPIO1_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x1C000)
 #define GPIO2_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x20000)
 #define GPIO3_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x24000)
 #define GPIO4_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x28000)
 #define GPIO5_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x2C000)
+#define MX6UL_SNVS_LP_BASE_ADDR     (AIPS1_OFF_BASE_ADDR + 0x30000)
+#if defined(CONFIG_MX6UL)
+#define SNVS_LP_BASE_ADDR           (AIPS1_OFF_BASE_ADDR + 0x30000)
+#define ENET2_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x34000)
+#else
 #define GPIO6_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x30000)
 #define GPIO7_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x34000)
+#endif
 #define KPP_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x38000)
 #define WDOG1_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x3C000)
 #define WDOG2_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x40000)
@@ -202,29 +223,54 @@
 #define SRC_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x58000)
 #define GPC_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x5C000)
 #define IOMUXC_BASE_ADDR            (AIPS1_OFF_BASE_ADDR + 0x60000)
-#ifdef CONFIG_MX6SL
+#define IOMUXC_GPR_BASE_ADDR        (AIPS1_OFF_BASE_ADDR + 0x64000)
+#ifdef CONFIG_MX6SLL
+#define CSI_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x68000)
+#define SDMA_PORT_HOST_BASE_ADDR    (AIPS1_OFF_BASE_ADDR + 0x6C000)
+#define PXP_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x70000)
+#define EPDC_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x74000)
+#define DCP_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x7C000)
+#elif defined(CONFIG_MX6SL)
 #define CSI_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x64000)
 #define SIPIX_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x68000)
 #define SDMA_PORT_HOST_BASE_ADDR    (AIPS1_OFF_BASE_ADDR + 0x6C000)
-#elif CONFIG_MX6SX
+#define EPDC_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x74000)
+#elif defined(CONFIG_MX6SX)
 #define CANFD1_BASE_ADDR            (AIPS1_OFF_BASE_ADDR + 0x68000)
 #define SDMA_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x6C000)
 #define CANFD2_BASE_ADDR            (AIPS1_OFF_BASE_ADDR + 0x70000)
 #define SEMAPHORE1_BASE_ADDR        (AIPS1_OFF_BASE_ADDR + 0x74000)
 #define SEMAPHORE2_BASE_ADDR        (AIPS1_OFF_BASE_ADDR + 0x78000)
 #define RDC_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x7C000)
+
+#elif defined(CONFIG_MX6UL)
+#define GPT2_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x68000)
+#define SDMA_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x6C000)
+#define PWM5_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x70000)
+#define PWM6_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x74000)
+#define PWM7_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x78000)
+#define PWM8_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x7C000)
 #else
 #define DCIC1_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x64000)
 #define DCIC2_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x68000)
 #define DMA_REQ_PORT_HOST_BASE_ADDR (AIPS1_OFF_BASE_ADDR + 0x6C000)
+#define EPDC_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x74000)
 #endif
+#define MX6SL_LCDIF_BASE_ADDR      (AIPS1_OFF_BASE_ADDR + 0x78000)
+#define MX6SLL_LCDIF_BASE_ADDR      (AIPS1_OFF_BASE_ADDR + 0x78000)
 
 #define AIPS2_ON_BASE_ADDR          (ATZ2_BASE_ADDR + 0x7C000)
 #define AIPS2_OFF_BASE_ADDR         (ATZ2_BASE_ADDR + 0x80000)
 #define AIPS3_ON_BASE_ADDR          (ATZ3_BASE_ADDR + 0x7C000)
 #define AIPS3_OFF_BASE_ADDR         (ATZ3_BASE_ADDR + 0x80000)
+
+#if defined(CONFIG_MX6UL)
+#define CAAM_BASE_ADDR              (ATZ2_BASE_ADDR + 0x40000)
+#define ARM_BASE_ADDR               (ATZ2_BASE_ADDR)
+#else
 #define CAAM_BASE_ADDR              (ATZ2_BASE_ADDR)
-#define ARM_BASE_ADDR		    (ATZ2_BASE_ADDR + 0x40000)
+#define ARM_BASE_ADDR               (ATZ2_BASE_ADDR + 0x40000)
+#endif
 
 #define CONFIG_SYS_FSL_SEC_ADDR     CAAM_BASE_ADDR
 #define CONFIG_SYS_FSL_JR0_ADDR     (CAAM_BASE_ADDR + 0x1000)
@@ -235,6 +281,8 @@
 #define ENET_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x8000)
 #ifdef CONFIG_MX6SL
 #define MSHC_IPS_BASE_ADDR          (AIPS2_OFF_BASE_ADDR + 0xC000)
+#elif defined(CONFIG_MX6UL)
+#define SIM1_IPS_BASE_ADDR          (AIPS2_OFF_BASE_ADDR + 0xC000)
 #else
 #define MLB_BASE_ADDR               (AIPS2_OFF_BASE_ADDR + 0xC000)
 #endif
@@ -243,12 +291,15 @@
 #define USDHC2_BASE_ADDR            (AIPS2_OFF_BASE_ADDR + 0x14000)
 #define USDHC3_BASE_ADDR            (AIPS2_OFF_BASE_ADDR + 0x18000)
 #define USDHC4_BASE_ADDR            (AIPS2_OFF_BASE_ADDR + 0x1C000)
+
+#define MX6UL_ADC1_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x18000)
+#define MX6UL_ADC2_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x1C000)
 #define I2C1_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x20000)
 #define I2C2_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x24000)
 #define I2C3_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x28000)
 #define ROMCP_BASE_ADDR             (AIPS2_OFF_BASE_ADDR + 0x2C000)
 #define MMDC_P0_BASE_ADDR           (AIPS2_OFF_BASE_ADDR + 0x30000)
-/* i.MX6SL */
+/* i.MX6SL/SLL */
 #define RNGB_IPS_BASE_ADDR          (AIPS2_OFF_BASE_ADDR + 0x34000)
 #ifdef CONFIG_MX6UL
 #define ENET2_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x34000)
@@ -262,9 +313,18 @@
 #define WEIM_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x38000)
 #define OCOTP_BASE_ADDR             (AIPS2_OFF_BASE_ADDR + 0x3C000)
 #define CSU_BASE_ADDR               (AIPS2_OFF_BASE_ADDR + 0x40000)
+#if defined(CONFIG_MX6UL)
+#define CSI_BASE_ADDR               (AIPS2_OFF_BASE_ADDR + 0x44000)
+#define PXP_BASE_ADDR               (AIPS2_OFF_BASE_ADDR + 0x4C000)
+#elif defined(CONFIG_MX6SLL)
+#define IOMUXC_GPR_SNVS_BASE_ADDR    (AIPS2_OFF_BASE_ADDR + 0x44000)
+#define IOMUXC_SNVS_BASE_ADDR        (AIPS2_OFF_BASE_ADDR + 0x48000)
+#else
 #define IP2APB_PERFMON1_BASE_ADDR   (AIPS2_OFF_BASE_ADDR + 0x44000)
 #define IP2APB_PERFMON2_BASE_ADDR   (AIPS2_OFF_BASE_ADDR + 0x48000)
+#endif
 #define MX6UL_LCDIF1_BASE_ADDR      (AIPS2_OFF_BASE_ADDR + 0x48000)
+#define MX6ULL_LCDIF1_BASE_ADDR      (AIPS2_OFF_BASE_ADDR + 0x48000)
 #ifdef CONFIG_MX6SX
 #define DEBUG_MONITOR_BASE_ADDR     (AIPS2_OFF_BASE_ADDR + 0x4C000)
 #else
@@ -273,6 +333,9 @@
 #define IP2APB_TZASC1_BASE_ADDR     (AIPS2_OFF_BASE_ADDR + 0x50000)
 #ifdef CONFIG_MX6UL
 #define QSPI0_BASE_ADDR             (AIPS2_OFF_BASE_ADDR + 0x60000)
+#define SYSCNT_RD_IPS_BASE_ADDR     (AIPS2_OFF_BASE_ADDR + 0x54000)
+#define SYSCNT_CMP_IPS_BASE_ADDR    (AIPS2_OFF_BASE_ADDR + 0x58000)
+#define SYSCNT_CTRL_IPS_BASE_ADDR   (AIPS2_OFF_BASE_ADDR + 0x5C000)
 #elif defined(CONFIG_MX6SX)
 #define SAI1_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x54000)
 #define AUDMUX_BASE_ADDR            (AIPS2_OFF_BASE_ADDR + 0x58000)
@@ -290,10 +353,21 @@
 #define UART3_BASE                  (AIPS2_OFF_BASE_ADDR + 0x6C000)
 #define UART4_BASE                  (AIPS2_OFF_BASE_ADDR + 0x70000)
 #define UART5_BASE                  (AIPS2_OFF_BASE_ADDR + 0x74000)
+/* i.MX6SLL */
+#define MTR_MASTER_BASE_ADDR        (AIPS2_OFF_BASE_ADDR + 0x7C000)
+/* i.MX6SX/UL */
 #define I2C4_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x78000)
+/* i.MX6UL */
+#define MX6UL_UART6_BASE_ADDR             (AIPS2_OFF_BASE_ADDR + 0x7C000)
 #define IP2APB_USBPHY1_BASE_ADDR    (AIPS2_OFF_BASE_ADDR + 0x78000)
 #define IP2APB_USBPHY2_BASE_ADDR    (AIPS2_OFF_BASE_ADDR + 0x7C000)
 
+#define OTG_BASE_ADDR               USB_BASE_ADDR
+
+#if defined(CONFIG_MX6UL)
+#define SCTR_BASE_ADDR              SYSCNT_CTRL_IPS_BASE_ADDR
+#endif
+
 #ifdef CONFIG_MX6SX
 #define GIS_BASE_ADDR               (AIPS3_ARB_BASE_ADDR + 0x04000)
 #define DCIC1_BASE_ADDR             (AIPS3_ARB_BASE_ADDR + 0x0C000)
@@ -305,40 +379,60 @@
 #define VDEC_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x2C000)
 #define SPBA_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x3C000)
 #define AIPS3_CONFIG_BASE_ADDR      (AIPS3_ARB_BASE_ADDR + 0x7C000)
-#define ADC1_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x80000)
-#define ADC2_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x84000)
+#define MX6SX_ADC1_BASE_ADDR        (AIPS3_ARB_BASE_ADDR + 0x80000)
+#define MX6SX_ADC2_BASE_ADDR        (AIPS3_ARB_BASE_ADDR + 0x84000)
 #define ECSPI5_BASE_ADDR            (AIPS3_ARB_BASE_ADDR + 0x8C000)
 #define HS_BASE_ADDR                (AIPS3_ARB_BASE_ADDR + 0x90000)
 #define MU_MCU_BASE_ADDR            (AIPS3_ARB_BASE_ADDR + 0x94000)
 #define CANFD_BASE_ADDR             (AIPS3_ARB_BASE_ADDR + 0x98000)
 #define MU_DSP_BASE_ADDR            (AIPS3_ARB_BASE_ADDR + 0x9C000)
-#define UART6_BASE_ADDR             (AIPS3_ARB_BASE_ADDR + 0xA0000)
 #define PWM5_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xA4000)
 #define PWM6_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xA8000)
 #define PWM7_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xAC000)
 #define PWM8_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xB0000)
+#elif defined(CONFIG_MX6ULL)
+#define AIPS3_CONFIG_BASE_ADDR      (AIPS3_ARB_BASE_ADDR + 0x7C000)
+#define DCP_BASE_ADDR               (AIPS3_ARB_BASE_ADDR + 0x80000)
+#define RNGB_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x84000)
+#define UART8_IPS_BASE_ADDR         (AIPS3_ARB_BASE_ADDR + 0x88000)
+#define EPDC_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x8C000)
+#define IOMUXC_SNVS_BASE_ADDR       (AIPS3_ARB_BASE_ADDR + 0x90000)
+#define SNVS_GPR_BASE_ADDR          (AIPS3_ARB_BASE_ADDR + 0x94000)
 #endif
 /* Only for i.MX6SX */
 #define LCDIF2_BASE_ADDR            (AIPS3_ARB_BASE_ADDR + 0x24000)
 #define MX6SX_LCDIF1_BASE_ADDR      (AIPS3_ARB_BASE_ADDR + 0x20000)
 #define MX6SX_WDOG3_BASE_ADDR       (AIPS3_ARB_BASE_ADDR + 0x88000)
+#define MX6SX_UART6_BASE_ADDR             (AIPS3_ARB_BASE_ADDR + 0xA0000)
 
-#if !(defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL))
+#if !(defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || \
+	defined(CONFIG_MX6SLL) || defined(CONFIG_MX6SL))
 #define IRAM_SIZE                    0x00040000
 #else
 #define IRAM_SIZE                    0x00020000
 #endif
 #define FEC_QUIRK_ENET_MAC
+#define SNVS_LPGPR                   0x68
 
 #include <asm/imx-common/regs-lcdif.h>
 #if !(defined(__KERNEL_STRICT_NAMES) || defined(__ASSEMBLY__))
 #include <asm/types.h>
 
 /* only for i.MX6SX/UL */
-#define WDOG3_BASE_ADDR ((is_cpu_type(MXC_CPU_MX6UL) ?	\
+#define WDOG3_BASE_ADDR (((is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL)) ?	\
 			 MX6UL_WDOG3_BASE_ADDR :  MX6SX_WDOG3_BASE_ADDR))
-#define LCDIF1_BASE_ADDR ((is_cpu_type(MXC_CPU_MX6UL)) ?	\
-			  MX6UL_LCDIF1_BASE_ADDR : MX6SX_LCDIF1_BASE_ADDR)
+#define LCDIF1_BASE_ADDR ((is_cpu_type(MXC_CPU_MX6SLL)) ?	\
+			  MX6SLL_LCDIF_BASE_ADDR :		\
+			  (is_cpu_type(MXC_CPU_MX6SL)) ?	\
+			  MX6SL_LCDIF_BASE_ADDR :		\
+			  ((is_cpu_type(MXC_CPU_MX6UL)) ?	\
+			  MX6UL_LCDIF1_BASE_ADDR :		\
+			  ((is_cpu_type(MXC_CPU_MX6ULL)) ?	\
+			  MX6ULL_LCDIF1_BASE_ADDR : MX6SX_LCDIF1_BASE_ADDR)))
+#define UART6_BASE_ADDR (((is_cpu_type(MXC_CPU_MX6UL)) || is_cpu_type(MXC_CPU_MX6ULL)) ? \
+			  MX6UL_UART6_BASE_ADDR : MX6SX_UART6_BASE_ADDR)
+
+#define MXS_LCDIF_BASE LCDIF1_BASE_ADDR
 
 
 extern void imx_get_mac_from_fuse(int dev_id, unsigned char *mac);
@@ -536,7 +630,12 @@
 #if (defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL))
 	u8 reserved[0x4000];
 #endif
+
+#ifdef CONFIG_MX6UL
+	u32 gpr[15];
+#else
 	u32 gpr[14];
+#endif
 };
 
 struct gpc {
@@ -619,6 +718,12 @@
 #define IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0		(IOMUXC_GPR2_MODE_ENABLED_DI0<<IOMUXC_GPR2_LVDS_CH0_MODE_OFFSET)
 #define IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI1		(IOMUXC_GPR2_MODE_ENABLED_DI1<<IOMUXC_GPR2_LVDS_CH0_MODE_OFFSET)
 
+#define IMX6SX_GPR5_CSI1_MUX_CTRL_MASK			(0x3 << 4)
+#define IMX6SX_GPR5_CSI1_MUX_CTRL_EXT_PIN		(0x0 << 4)
+#define IMX6SX_GPR5_CSI1_MUX_CTRL_CVD			(0x1 << 4)
+#define IMX6SX_GPR5_CSI1_MUX_CTRL_VDAC_TO_CSI	(0x2 << 4)
+#define IMX6SX_GPR5_CSI1_MUX_CTRL_GND			(0x3 << 4)
+
 /* ECSPI registers */
 struct cspi_regs {
 	u32 rxdata;
@@ -649,7 +754,11 @@
 #define MXC_CSPICTRL_RXOVF	(1 << 6)
 #define MXC_CSPIPERIOD_32KHZ	(1 << 15)
 #define MAX_SPI_BYTES	32
+#if defined(CONFIG_MX6DL) || defined(CONFIG_MX6UL) || defined(CONFIG_MX6SLL) || defined(CONFIG_MX6SL)
+#define SPI_MAX_NUM	3
+#else
 #define SPI_MAX_NUM	4
+#endif
 
 /* Bit position inside CTRL register to be associated with SS */
 #define MXC_CSPICTRL_CHAN	18
@@ -659,7 +768,7 @@
 #define MXC_CSPICON_POL		4  /* SCLK polarity */
 #define MXC_CSPICON_SSPOL	12 /* SS polarity */
 #define MXC_CSPICON_CTL		20 /* inactive state of SCLK */
-#if defined(CONFIG_MX6SL) || defined(CONFIG_MX6DL) || defined(CONFIG_MX6UL)
+#if defined(CONFIG_MX6SLL) || defined(CONFIG_MX6SL) || defined(CONFIG_MX6DL) || defined(CONFIG_MX6UL)
 #define MXC_SPI_BASE_ADDRESSES \
 	ECSPI1_BASE_ADDR, \
 	ECSPI2_BASE_ADDR, \
@@ -674,6 +783,8 @@
 	ECSPI5_BASE_ADDR
 #endif
 
+#define ANATOP_PLL_VIDEO        0xA0
+
 struct ocotp_regs {
 	u32	ctrl;
 	u32	ctrl_set;
@@ -923,6 +1034,25 @@
 #define ANATOP_PFD_CLKGATE_SHIFT(n)	(7+((n)*8))
 #define ANATOP_PFD_CLKGATE_MASK(n)	(1<<ANATOP_PFD_CLKGATE_SHIFT(n))
 
+struct iomuxc_gpr_base_regs {
+#if defined(CONFIG_MX6UL)
+	u32     gpr[15];        /* 0x000 */
+#else
+	u32     gpr[14];        /* 0x000 */
+#endif
+};
+
+struct iomuxc_base_regs {
+#if !(defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL))
+	u32     gpr[14];        /* 0x000 */
+#endif
+	u32     obsrv[5];       /* 0x038 */
+	u32     swmux_ctl[197]; /* 0x04c */
+	u32     swpad_ctl[250]; /* 0x360 */
+	u32     swgrp[26];      /* 0x748 */
+	u32     daisy[104];     /* 0x7b0..94c */
+};
+
 struct wdog_regs {
 	u16	wcr;	/* Control */
 	u16	wsr;	/* Service */
@@ -947,5 +1077,26 @@
 	u32	pr;
 	u32	cnr;
 };
+
+struct dbg_monitor_regs {
+	u32	ctrl[4];		/* Control */
+	u32	master_en[4];		/* Master enable */
+	u32	irq[4];			/* IRQ */
+	u32	trap_addr_low[4];	/* Trap address low */
+	u32	trap_addr_high[4];	/* Trap address high */
+	u32	trap_id[4];		/* Trap ID */
+	u32	snvs_addr[4];		/* SNVS address */
+	u32	snvs_data[4];		/* SNVS data */
+	u32	snvs_info[4];		/* SNVS info */
+	u32	version[4];		/* Version */
+};
+
+/*
+ * If ROM fail back to USB recover mode, USBPH0_PWD will be clear to use USB
+ * If boot from the other mode, USB0_PWD will keep reset value
+ */
+#define	is_boot_from_usb(void) (!(readl(USB_PHY0_BASE_ADDR) & (1<<20)))
+#define	disconnect_from_pc(void) writel(0x0, OTG_BASE_ADDR + 0x140)
+
 #endif /* __ASSEMBLER__*/
 #endif /* __ASM_ARCH_MX6_IMX_REGS_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch-mx6/module_fuse.h ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/module_fuse.h
--- u-boot-2016.03/arch/arm/include/asm/arch-mx6/module_fuse.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/module_fuse.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MODULE_FUSE_H__
+#define __MODULE_FUSE_H__
+
+enum fuse_module_type{
+	MX6_MODULE_TSC,
+	MX6_MODULE_ADC1,
+	MX6_MODULE_ADC2,
+	MX6_MODULE_SIM1,
+	MX6_MODULE_SIM2,
+	MX6_MODULE_FLEXCAN1,
+	MX6_MODULE_FLEXCAN2,
+	MX6_MODULE_SPDIF,
+	MX6_MODULE_EIM,
+	MX6_MODULE_SD1,
+	MX6_MODULE_SD2,
+	MX6_MODULE_SD3,
+	MX6_MODULE_SD4,
+	MX6_MODULE_QSPI1,
+	MX6_MODULE_QSPI2,
+	MX6_MODULE_GPMI,
+	MX6_MODULE_APBHDMA,
+	MX6_MODULE_LCDIF,
+	MX6_MODULE_PXP,
+	MX6_MODULE_CSI,
+	MX6_MODULE_ENET1,
+	MX6_MODULE_ENET2,
+	MX6_MODULE_CAAM,
+	MX6_MODULE_USB_OTG1,
+	MX6_MODULE_USB_OTG2,
+	MX6_MODULE_SAI2,
+	MX6_MODULE_SAI3,
+	MX6_MODULE_BEE,
+	MX6_MODULE_UART1,
+	MX6_MODULE_UART2,
+	MX6_MODULE_UART3,
+	MX6_MODULE_UART4,
+	MX6_MODULE_UART5,
+	MX6_MODULE_UART6,
+	MX6_MODULE_UART7,
+	MX6_MODULE_UART8,
+	MX6_MODULE_PWM5,
+	MX6_MODULE_PWM6,
+	MX6_MODULE_PWM7,
+	MX6_MODULE_PWM8,
+	MX6_MODULE_ECSPI1,
+	MX6_MODULE_ECSPI2,
+	MX6_MODULE_ECSPI3,
+	MX6_MODULE_ECSPI4,
+	MX6_MODULE_ECSPI5,
+	MX6_MODULE_I2C1,
+	MX6_MODULE_I2C2,
+	MX6_MODULE_I2C3,
+	MX6_MODULE_I2C4,
+	MX6_MODULE_GPT1,
+	MX6_MODULE_GPT2,
+	MX6_MODULE_EPIT1,
+	MX6_MODULE_EPIT2,
+};
+
+#if !defined(CONFIG_MODULE_FUSE)
+static inline u32 check_module_fused(enum fuse_module_type module)
+{
+	return 0;
+};
+
+static inline u32 mx6_esdhc_fused(u32 base_addr)
+{
+	return 0;
+};
+
+static inline u32 mx6_ecspi_fused(u32 base_addr)
+{
+	return 0;
+};
+static inline u32 mx6_uart_fused(u32 base_addr)
+{
+	return 0;
+};
+static inline u32 mx6_usb_fused(u32 base_addr)
+{
+	return 0;
+};
+static inline u32 mx6_qspi_fused(u32 base_addr)
+{
+	return 0;
+};
+static inline u32 mx6_i2c_fused(u32 base_addr)
+{
+	return 0;
+};
+static inline u32 mx6_enet_fused(u32 base_addr)
+{
+	return 0;
+};
+
+#else
+u32 check_module_fused(enum fuse_module_type module);
+u32 mx6_esdhc_fused(u32 base_addr);
+u32 mx6_ecspi_fused(u32 base_addr);
+u32 mx6_uart_fused(u32 base_addr);
+u32 mx6_usb_fused(u32 base_addr);
+u32 mx6_qspi_fused(u32 base_addr);
+u32 mx6_i2c_fused(u32 base_addr);
+u32 mx6_enet_fused(u32 base_addr);
+#endif
+
+#ifdef DEBUG
+void print_fuse_status();
+void simulate_fuse();
+#endif
+
+#endif /* __MODULE_FUSE_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch-mx6/mx6_bee.h ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/mx6_bee.h
--- u-boot-2016.03/arch/arm/include/asm/arch-mx6/mx6_bee.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/mx6_bee.h	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+
+#define GPR0           0x0
+#define GPR1           0x4
+#define GPR2           0x8
+#define GPR3           0xC
+#define GPR4           0x10
+#define GPR5           0x14
+#define GPR6           0x18
+#define GPR7           0x1C
+#define GPR8           0x20
+#define GPR9           0x24
+#define GPR10          0x28
+#define GPR11          0x2C
+
+#define GPR0_CTRL_CLK_EN_LOCK	(1 << 31)
+#define GPR0_CTRL_CLK_EN	(1 << 15)
+#define GPR0_CTRL_SFTRST_N_LOCK	(1 << 30)
+#define GPR0_CTRL_SFTRST	(0 << 14)
+#define GPR0_CTRL_SFTRST_N	(1 << 14)
+#define GPR0_CTRL_AES_MODE_LOCK	(1 << 29)
+#define GPR0_CTRL_AES_MODE_ECB	(0 << 13)
+#define GPR0_CTRL_AES_MODE_CTR	(1 << 13)
+#define GPR0_SEC_LEVEL_LOCK	(3 << 24)
+#define GPR0_SEC_LEVEL		(3 << 8)
+#define GPR0_AES_KEY_SEL_LOCK	(1 << 20)
+#define GPR0_AES_KEY_SEL_SNVS	(0 << 4)
+#define GPR0_AES_KEY_SEL_SOFT	(1 << 4)
+#define GPR0_BEE_ENABLE_LOCK	(1 << 16)
+#define GPR0_BEE_ENABLE		(1 << 0)
+
+/*
+ * SECURITY LEVEL
+ *        Non-Secure User |  Non-Secure Spvr | Secure User | Secure Spvr
+ * Level
+ * (0)00      RD + WR           RD + WR          RD + WR       RD + WR
+ * (1)01      None              RD + WR          RD + WR       RD + WR
+ * (2)10      None              None             RD + WR       RD + WR
+ * (3)11      None              None             None          RD + WR
+ */
+#define GPR0_SEC_LEVEL_0	(0 << 8)
+#define GPR0_SEC_LEVEL_1	(1 << 8)
+#define GPR0_SEC_LEVEL_2	(2 << 8)
+#define GPR0_SEC_LEVEL_3	(3 << 8)
diff -urN u-boot-2016.03/arch/arm/include/asm/arch-mx6/mx6-pins.h ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/mx6-pins.h
--- u-boot-2016.03/arch/arm/include/asm/arch-mx6/mx6-pins.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/mx6-pins.h	2021-04-16 14:42:14.688580767 +0800
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2013 Boundary Devices Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -33,10 +34,14 @@
 	MX6_PAD_DECLARE(MX6_PAD_,name, pco, mc, mm, sio, si, pc),
 #include "mx6dl_pins.h"
 };
+#elif defined(CONFIG_MX6SLL)
+#include "mx6sll_pins.h"
 #elif defined(CONFIG_MX6SL)
 #include "mx6sl_pins.h"
 #elif defined(CONFIG_MX6SX)
 #include "mx6sx_pins.h"
+#elif defined(CONFIG_MX6ULL)
+#include "mx6ull_pins.h"
 #elif defined(CONFIG_MX6UL)
 #include "mx6ul_pins.h"
 #else
diff -urN u-boot-2016.03/arch/arm/include/asm/arch-mx6/mx6_plugin.S ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/mx6_plugin.S
--- u-boot-2016.03/arch/arm/include/asm/arch-mx6/mx6_plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/mx6_plugin.S	2021-04-16 14:42:14.688580767 +0800
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <config.h>
+
+#ifdef CONFIG_ROM_UNIFIED_SECTIONS
+#define ROM_API_TABLE_BASE_ADDR_LEGACY		0x180
+#define ROM_VERSION_OFFSET               	0x80
+#else
+#define ROM_API_TABLE_BASE_ADDR_LEGACY		0xC0
+#define ROM_VERSION_OFFSET               	0x48
+#endif
+#define ROM_API_TABLE_BASE_ADDR_MX6DQ_TO15	0xC4
+#define ROM_API_TABLE_BASE_ADDR_MX6DL_TO12	0xC4
+#define ROM_API_HWCNFG_SETUP_OFFSET		0x08
+#define ROM_VERSION_TO10			0x10
+#define ROM_VERSION_TO12			0x12
+#define ROM_VERSION_TO15			0x15
+
+plugin_start:
+
+	push    {r0-r4, lr}
+
+	imx6_ddr_setting
+	imx6_clock_gating
+	imx6_qos_setting
+
+/*
+ * The following is to fill in those arguments for this ROM function
+ * pu_irom_hwcnfg_setup(void **start, size_t *bytes, const void *boot_data)
+ * This function is used to copy data from the storage media into DDR.
+ * start - Initial (possibly partial) image load address on entry.
+ *         Final image load address on exit.
+ * bytes - Initial (possibly partial) image size on entry.
+ *         Final image size on exit.
+ * boot_data - Initial @ref ivt Boot Data load address.
+ */
+	adr r0, boot_data2
+	adr r1, image_len2
+	adr r2, boot_data2
+
+#ifdef CONFIG_SYS_BOOT_EIMNOR
+#ifdef CONFIG_MX6SX
+	ldr r3, =ROM_VERSION_OFFSET
+	ldr r4, [r3]
+	cmp r4, #ROM_VERSION_TO10
+	bgt before_calling_rom___pu_irom_hwcnfg_setup
+	ldr r3, =0x00900b00
+	ldr r4, =0x50000000
+	str r4, [r3, #0x5c]
+#else
+	ldr r3, =0x00900800
+	ldr r4, =0x08000000
+	str r4, [r3, #0xc0]
+#endif
+#endif
+
+/*
+ * check the _pu_irom_api_table for the address
+ */
+before_calling_rom___pu_irom_hwcnfg_setup:
+	ldr r3, =ROM_VERSION_OFFSET
+	ldr r4, [r3]
+#if defined(CONFIG_MX6SOLO) || defined(CONFIG_MX6DL)
+	ldr r3, =ROM_VERSION_TO12
+	cmp r4, r3
+	ldrge r3, =ROM_API_TABLE_BASE_ADDR_MX6DL_TO12
+	ldrlt r3, =ROM_API_TABLE_BASE_ADDR_LEGACY
+#elif defined(CONFIG_MX6Q)
+	ldr r3, =ROM_VERSION_TO15
+	cmp r4, r3
+	ldrge r3, =ROM_API_TABLE_BASE_ADDR_MX6DQ_TO15
+	ldrlt r3, =ROM_API_TABLE_BASE_ADDR_LEGACY
+#else
+	ldr r3, =ROM_API_TABLE_BASE_ADDR_LEGACY
+#endif
+	ldr r4, [r3, #ROM_API_HWCNFG_SETUP_OFFSET]
+	blx r4
+after_calling_rom___pu_irom_hwcnfg_setup:
+
+/*
+ * ROM_API_HWCNFG_SETUP function enables MMU & Caches.
+ * Thus disable MMU & Caches.
+ */
+
+#define ENABLE_CACHE 0x01
+
+    MRC     p15, 0, r0, c1, c0, 0   /* read CP15 register 1 into r0 */
+    ANDS    r0, r0, #0x1            /* check if MMU is enabled         */
+    BEQ     mmu_disable_notreq      /* exit if MMU is already disabled */
+
+/* Disable caches, MMU    */
+    MRC     p15, 0, r0, c1, c0, 0           /* read CP15 register 1 into r0 */
+    BIC     r0, r0, #(ENABLE_CACHE << 2)    /* disable D Cache */
+    BIC     r0, r0, #0x1                    /* clear bit 0 ; MMU off */
+
+    BIC     r0, r0, #(0x1 << 11)            /* disable Z, branch prediction */
+    BIC     r0, r0, #(0x1 << 1)             /* disable A, Strict alignment */
+					    /*		check enabled. */
+
+    MCR     p15, 0, r0, c1, c0, 0           /* write CP15 register 1 */
+    MOV     r0, r0
+    MOV     r0, r0
+    MOV     r0, r0
+    MOV     r0, r0
+
+mmu_disable_notreq:
+    NOP
+
+/* To return to ROM from plugin, we need to fill in these argument.
+ * Here is what need to do:
+ * Need to construct the paramters for this function before return to ROM:
+ * plugin_download(void **start, size_t *bytes, UINT32 *ivt_offset)
+ */
+	pop {r0-r4, lr}
+	push {r5}
+	ldr r5, boot_data2
+	str r5, [r0]
+	ldr r5, image_len2
+	str r5, [r1]
+	ldr r5, second_ivt_offset
+	str r5, [r2]
+	mov r0, #1
+	pop {r5}
+
+	/* return back to ROM code */
+	bx lr
+
+/* make the following data right in the end of the output*/
+.ltorg
+
+#if (defined(CONFIG_SYS_BOOT_EIMNOR) || defined(CONFIG_SYS_BOOT_QSPI))
+#define FLASH_OFFSET 0x1000
+#else
+#define FLASH_OFFSET 0x400
+#endif
+
+/*
+ * second_ivt_offset is the offset from the "second_ivt_header" to
+ * "image_copy_start", which involves FLASH_OFFSET, plus the first
+ * ivt_header, the plugin code size itself recorded by "ivt2_header"
+ */
+
+second_ivt_offset:      .long (ivt2_header + 0x2C + FLASH_OFFSET)
+
+/*
+ * The following is the second IVT header plus the second boot data
+ */
+ivt2_header:            .long 0x0
+app2_code_jump_v:       .long 0x0
+reserv3:                .long 0x0
+dcd2_ptr:               .long 0x0
+boot_data2_ptr:         .long 0x0
+self_ptr2:              .long 0x0
+app_code_csf2:          .long 0x0
+reserv4:                .long 0x0
+boot_data2:             .long 0x0
+image_len2:             .long 0x0
+plugin2:                .long 0x0
diff -urN u-boot-2016.03/arch/arm/include/asm/arch-mx6/mx6sll_pins.h ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/mx6sll_pins.h
--- u-boot-2016.03/arch/arm/include/asm/arch-mx6/mx6sll_pins.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/mx6sll_pins.h	2021-04-16 14:42:14.692580786 +0800
@@ -0,0 +1,1019 @@
+/*
+ * Copyright (C) 2014 - 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_IMX6SLL_PINS_H__
+#define __ASM_ARCH_IMX6SLL_PINS_H__
+
+#include <asm/imx-common/iomux-v3.h>
+
+enum {
+	MX6_PAD_WDOG_B__WDOG1_B                               = IOMUX_PAD(0x02DC, 0x0014, 0, 0x0000, 0, 0),
+	MX6_PAD_WDOG_B__WDOG1_RESET_B_DEB                     = IOMUX_PAD(0x02DC, 0x0014, 1, 0x0000, 0, 0),
+	MX6_PAD_WDOG_B__UART5_RI_B                            = IOMUX_PAD(0x02DC, 0x0014, 2, 0x0000, 0, 0),
+	MX6_PAD_WDOG_B__GPIO3_IO18                            = IOMUX_PAD(0x02DC, 0x0014, 5, 0x0000, 0, 0),
+
+	MX6_PAD_REF_CLK_24M__XTALOSC_REF_CLK_24M              = IOMUX_PAD(0x02E0, 0x0018, 0, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_24M__I2C3_SCL                         = IOMUX_PAD(0x02E0, 0x0018, IOMUX_CONFIG_SION | 1, 0x068C, 0, 0),
+	MX6_PAD_REF_CLK_24M__PWM3_OUT                         = IOMUX_PAD(0x02E0, 0x0018, 2, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_24M__USB_OTG2_ID                      = IOMUX_PAD(0x02E0, 0x0018, 3, 0x0560, 0, 0),
+	MX6_PAD_REF_CLK_24M__CCM_PMIC_READY                   = IOMUX_PAD(0x02E0, 0x0018, 4, 0x05AC, 0, 0),
+	MX6_PAD_REF_CLK_24M__GPIO3_IO21                       = IOMUX_PAD(0x02E0, 0x0018, 5, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_24M__SD3_WP                           = IOMUX_PAD(0x02E0, 0x0018, 6, 0x0794, 0, 0),
+
+	MX6_PAD_REF_CLK_32K__XTALOSC_REF_CLK_32K              = IOMUX_PAD(0x02E4, 0x001C, 0, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_32K__I2C3_SDA                         = IOMUX_PAD(0x02E4, 0x001C, IOMUX_CONFIG_SION | 1, 0x0690, 0, 0),
+	MX6_PAD_REF_CLK_32K__PWM4_OUT                         = IOMUX_PAD(0x02E4, 0x001C, 2, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_32K__USB_OTG1_ID                      = IOMUX_PAD(0x02E4, 0x001C, 3, 0x055C, 0, 0),
+	MX6_PAD_REF_CLK_32K__SD1_LCTL                         = IOMUX_PAD(0x02E4, 0x001C, 4, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_32K__GPIO3_IO22                       = IOMUX_PAD(0x02E4, 0x001C, 5, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_32K__SD3_CD_B                         = IOMUX_PAD(0x02E4, 0x001C, 6, 0x0780, 0, 0),
+
+	MX6_PAD_PWM1__PWM1_OUT                                = IOMUX_PAD(0x02E8, 0x0020, 0, 0x0000, 0, 0),
+	MX6_PAD_PWM1__CCM_CLKO                                = IOMUX_PAD(0x02E8, 0x0020, 1, 0x0000, 0, 0),
+	MX6_PAD_PWM1__AUDIO_CLK_OUT                           = IOMUX_PAD(0x02E8, 0x0020, 2, 0x0000, 0, 0),
+	MX6_PAD_PWM1__CSI_MCLK                                = IOMUX_PAD(0x02E8, 0x0020, 4, 0x0000, 0, 0),
+	MX6_PAD_PWM1__GPIO3_IO23                              = IOMUX_PAD(0x02E8, 0x0020, 5, 0x0000, 0, 0),
+	MX6_PAD_PWM1__EPIT1_OUT                               = IOMUX_PAD(0x02E8, 0x0020, 6, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_COL0__KEY_COL0                            = IOMUX_PAD(0x02EC, 0x0024, 0, 0x06A0, 0, 0),
+	MX6_PAD_KEY_COL0__I2C2_SCL                            = IOMUX_PAD(0x02EC, 0x0024, IOMUX_CONFIG_SION | 1, 0x0684, 0, 0),
+	MX6_PAD_KEY_COL0__LCD_DATA00                          = IOMUX_PAD(0x02EC, 0x0024, 2, 0x06D8, 0, 0),
+	MX6_PAD_KEY_COL0__SD1_CD_B                            = IOMUX_PAD(0x02EC, 0x0024, 4, 0x0770, 1, 0),
+	MX6_PAD_KEY_COL0__GPIO3_IO24                          = IOMUX_PAD(0x02EC, 0x0024, 5, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_ROW0__KEY_ROW0                            = IOMUX_PAD(0x02F0, 0x0028, 0, 0x06C0, 0, 0),
+	MX6_PAD_KEY_ROW0__I2C2_SDA                            = IOMUX_PAD(0x02F0, 0x0028, IOMUX_CONFIG_SION | 1, 0x0688, 0, 0),
+	MX6_PAD_KEY_ROW0__LCD_DATA01                          = IOMUX_PAD(0x02F0, 0x0028, 2, 0x06DC, 0, 0),
+	MX6_PAD_KEY_ROW0__SD1_WP                              = IOMUX_PAD(0x02F0, 0x0028, 4, 0x0774, 1, 0),
+	MX6_PAD_KEY_ROW0__GPIO3_IO25                          = IOMUX_PAD(0x02F0, 0x0028, 5, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_COL1__KEY_COL1                            = IOMUX_PAD(0x02F4, 0x002C, 0, 0x06A4, 0, 0),
+	MX6_PAD_KEY_COL1__ECSPI4_MOSI                         = IOMUX_PAD(0x02F4, 0x002C, 1, 0x0658, 1, 0),
+	MX6_PAD_KEY_COL1__LCD_DATA02                          = IOMUX_PAD(0x02F4, 0x002C, 2, 0x06E0, 0, 0),
+	MX6_PAD_KEY_COL1__SD3_DATA4                           = IOMUX_PAD(0x02F4, 0x002C, 4, 0x0784, 0, 0),
+	MX6_PAD_KEY_COL1__GPIO3_IO26                          = IOMUX_PAD(0x02F4, 0x002C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_ROW1__KEY_ROW1                            = IOMUX_PAD(0x02F8, 0x0030, 0, 0x06C4, 0, 0),
+	MX6_PAD_KEY_ROW1__ECSPI4_MISO                         = IOMUX_PAD(0x02F8, 0x0030, 1, 0x0654, 1, 0),
+	MX6_PAD_KEY_ROW1__LCD_DATA03                          = IOMUX_PAD(0x02F8, 0x0030, 2, 0x06E4, 0, 0),
+	MX6_PAD_KEY_ROW1__CSI_FIELD                           = IOMUX_PAD(0x02F8, 0x0030, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW1__SD3_DATA5                           = IOMUX_PAD(0x02F8, 0x0030, 4, 0x0788, 0, 0),
+	MX6_PAD_KEY_ROW1__GPIO3_IO27                          = IOMUX_PAD(0x02F8, 0x0030, 5, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_COL2__KEY_COL2                            = IOMUX_PAD(0x02FC, 0x0034, 0, 0x06A8, 0, 0),
+	MX6_PAD_KEY_COL2__ECSPI4_SS0                          = IOMUX_PAD(0x02FC, 0x0034, 1, 0x065C, 1, 0),
+	MX6_PAD_KEY_COL2__LCD_DATA04                          = IOMUX_PAD(0x02FC, 0x0034, 2, 0x06E8, 0, 0),
+	MX6_PAD_KEY_COL2__CSI_DATA12                          = IOMUX_PAD(0x02FC, 0x0034, 3, 0x05B8, 1, 0),
+	MX6_PAD_KEY_COL2__SD3_DATA6                           = IOMUX_PAD(0x02FC, 0x0034, 4, 0x078C, 0, 0),
+	MX6_PAD_KEY_COL2__GPIO3_IO28                          = IOMUX_PAD(0x02FC, 0x0034, 5, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_ROW2__KEY_ROW2                            = IOMUX_PAD(0x0300, 0x0038, 0, 0x06C8, 0, 0),
+	MX6_PAD_KEY_ROW2__ECSPI4_SCLK                         = IOMUX_PAD(0x0300, 0x0038, 1, 0x0650, 1, 0),
+	MX6_PAD_KEY_ROW2__LCD_DATA05                          = IOMUX_PAD(0x0300, 0x0038, 2, 0x06EC, 0, 0),
+	MX6_PAD_KEY_ROW2__CSI_DATA13                          = IOMUX_PAD(0x0300, 0x0038, 3, 0x05BC, 1, 0),
+	MX6_PAD_KEY_ROW2__SD3_DATA7                           = IOMUX_PAD(0x0300, 0x0038, 4, 0x0790, 0, 0),
+	MX6_PAD_KEY_ROW2__GPIO3_IO29                          = IOMUX_PAD(0x0300, 0x0038, 5, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_COL3__KEY_COL3                            = IOMUX_PAD(0x0304, 0x003C, 0, 0x06AC, 0, 0),
+	MX6_PAD_KEY_COL3__AUD6_RXFS                           = IOMUX_PAD(0x0304, 0x003C, 1, 0x05A0, 1, 0),
+	MX6_PAD_KEY_COL3__LCD_DATA06                          = IOMUX_PAD(0x0304, 0x003C, 2, 0x06F0, 0, 0),
+	MX6_PAD_KEY_COL3__CSI_DATA14                          = IOMUX_PAD(0x0304, 0x003C, 3, 0x05C0, 1, 0),
+	MX6_PAD_KEY_COL3__GPIO3_IO30                          = IOMUX_PAD(0x0304, 0x003C, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL3__SD1_RESET                           = IOMUX_PAD(0x0304, 0x003C, 6, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_ROW3__KEY_ROW3                            = IOMUX_PAD(0x0308, 0x0040, 0, 0x06CC, 1, 0),
+	MX6_PAD_KEY_ROW3__AUD6_RXC                            = IOMUX_PAD(0x0308, 0x0040, 1, 0x059C, 1, 0),
+	MX6_PAD_KEY_ROW3__LCD_DATA07                          = IOMUX_PAD(0x0308, 0x0040, 2, 0x06F4, 1, 0),
+	MX6_PAD_KEY_ROW3__CSI_DATA15                          = IOMUX_PAD(0x0308, 0x0040, 3, 0x05C4, 2, 0),
+	MX6_PAD_KEY_ROW3__GPIO3_IO31                          = IOMUX_PAD(0x0308, 0x0040, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW3__SD1_VSELECT                         = IOMUX_PAD(0x0308, 0x0040, 6, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_COL4__KEY_COL4                            = IOMUX_PAD(0x030C, 0x0044, 0, 0x06B0, 1, 0),
+	MX6_PAD_KEY_COL4__AUD6_RXD                            = IOMUX_PAD(0x030C, 0x0044, 1, 0x0594, 1, 0),
+	MX6_PAD_KEY_COL4__LCD_DATA08                          = IOMUX_PAD(0x030C, 0x0044, 2, 0x06F8, 1, 0),
+	MX6_PAD_KEY_COL4__CSI_DATA16                          = IOMUX_PAD(0x030C, 0x0044, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL4__GPIO4_IO00                          = IOMUX_PAD(0x030C, 0x0044, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL4__USB_OTG1_PWR                        = IOMUX_PAD(0x030C, 0x0044, 6, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_ROW4__KEY_ROW4                            = IOMUX_PAD(0x0310, 0x0048, 0, 0x06D0, 1, 0),
+	MX6_PAD_KEY_ROW4__AUD6_TXC                            = IOMUX_PAD(0x0310, 0x0048, 1, 0x05A4, 1, 0),
+	MX6_PAD_KEY_ROW4__LCD_DATA09                          = IOMUX_PAD(0x0310, 0x0048, 2, 0x06FC, 1, 0),
+	MX6_PAD_KEY_ROW4__CSI_DATA17                          = IOMUX_PAD(0x0310, 0x0048, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW4__GPIO4_IO01                          = IOMUX_PAD(0x0310, 0x0048, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW4__USB_OTG1_OC                         = IOMUX_PAD(0x0310, 0x0048, 6, 0x076C, 2, 0),
+
+	MX6_PAD_KEY_COL5__KEY_COL5                            = IOMUX_PAD(0x0314, 0x004C, 0, 0x0694, 1, 0),
+	MX6_PAD_KEY_COL5__AUD6_TXFS                           = IOMUX_PAD(0x0314, 0x004C, 1, 0x05A8, 1, 0),
+	MX6_PAD_KEY_COL5__LCD_DATA10                          = IOMUX_PAD(0x0314, 0x004C, 2, 0x0700, 0, 0),
+	MX6_PAD_KEY_COL5__CSI_DATA18                          = IOMUX_PAD(0x0314, 0x004C, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL5__GPIO4_IO02                          = IOMUX_PAD(0x0314, 0x004C, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL5__USB_OTG2_PWR                        = IOMUX_PAD(0x0314, 0x004C, 6, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_ROW5__KEY_ROW5                            = IOMUX_PAD(0x0318, 0x0050, 0, 0x06B4, 2, 0),
+	MX6_PAD_KEY_ROW5__AUD6_TXD                            = IOMUX_PAD(0x0318, 0x0050, 1, 0x0598, 1, 0),
+	MX6_PAD_KEY_ROW5__LCD_DATA11                          = IOMUX_PAD(0x0318, 0x0050, 2, 0x0704, 1, 0),
+	MX6_PAD_KEY_ROW5__CSI_DATA19                          = IOMUX_PAD(0x0318, 0x0050, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW5__GPIO4_IO03                          = IOMUX_PAD(0x0318, 0x0050, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW5__USB_OTG2_OC                         = IOMUX_PAD(0x0318, 0x0050, 6, 0x0768, 3, 0),
+
+	MX6_PAD_KEY_COL6__KEY_COL6                            = IOMUX_PAD(0x031C, 0x0054, 0, 0x0698, 2, 0),
+	MX6_PAD_KEY_COL6__UART4_DCE_RX                        = IOMUX_PAD(0x031C, 0x0054, 1, 0x075C, 2, 0),
+	MX6_PAD_KEY_COL6__UART4_DTE_TX                        = IOMUX_PAD(0x031C, 0x0054, 1, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL6__LCD_DATA12                          = IOMUX_PAD(0x031C, 0x0054, 2, 0x0708, 1, 0),
+	MX6_PAD_KEY_COL6__CSI_DATA20                          = IOMUX_PAD(0x031C, 0x0054, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL6__GPIO4_IO04                          = IOMUX_PAD(0x031C, 0x0054, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL6__SD3_RESET                           = IOMUX_PAD(0x031C, 0x0054, 6, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_ROW6__KEY_ROW6                            = IOMUX_PAD(0x0320, 0x0058, 0, 0x06B8, 2, 0),
+	MX6_PAD_KEY_ROW6__UART4_DCE_TX                        = IOMUX_PAD(0x0320, 0x0058, 1, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW6__UART4_DTE_RX                        = IOMUX_PAD(0x0320, 0x0058, 1, 0x075C, 3, 0),
+	MX6_PAD_KEY_ROW6__LCD_DATA13                          = IOMUX_PAD(0x0320, 0x0058, 2, 0x070C, 1, 0),
+	MX6_PAD_KEY_ROW6__CSI_DATA21                          = IOMUX_PAD(0x0320, 0x0058, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW6__GPIO4_IO05                          = IOMUX_PAD(0x0320, 0x0058, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW6__SD3_VSELECT                         = IOMUX_PAD(0x0320, 0x0058, 6, 0x0000, 0, 0),
+
+	MX6_PAD_KEY_COL7__KEY_COL7                            = IOMUX_PAD(0x0324, 0x005C, 0, 0x069C, 2, 0),
+	MX6_PAD_KEY_COL7__UART4_DCE_RTS                       = IOMUX_PAD(0x0324, 0x005C, 1, 0x0758, 2, 0),
+	MX6_PAD_KEY_COL7__UART4_DTE_CTS                       = IOMUX_PAD(0x0324, 0x005C, 1, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL7__LCD_DATA14                          = IOMUX_PAD(0x0324, 0x005C, 2, 0x0710, 1, 0),
+	MX6_PAD_KEY_COL7__CSI_DATA22                          = IOMUX_PAD(0x0324, 0x005C, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL7__GPIO4_IO06                          = IOMUX_PAD(0x0324, 0x005C, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL7__SD1_WP                              = IOMUX_PAD(0x0324, 0x005C, 6, 0x0774, 3, 0),
+
+	MX6_PAD_KEY_ROW7__KEY_ROW7                            = IOMUX_PAD(0x0328, 0x0060, 0, 0x06BC, 2, 0),
+	MX6_PAD_KEY_ROW7__UART4_DCE_CTS                       = IOMUX_PAD(0x0328, 0x0060, 1, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW7__UART4_DTE_RTS                       = IOMUX_PAD(0x0328, 0x0060, 1, 0x0758, 3, 0),
+	MX6_PAD_KEY_ROW7__LCD_DATA15                          = IOMUX_PAD(0x0328, 0x0060, 2, 0x0714, 1, 0),
+	MX6_PAD_KEY_ROW7__CSI_DATA23                          = IOMUX_PAD(0x0328, 0x0060, 3, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW7__GPIO4_IO07                          = IOMUX_PAD(0x0328, 0x0060, 5, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW7__SD1_CD_B                            = IOMUX_PAD(0x0328, 0x0060, 6, 0x0770, 3, 0),
+
+	MX6_PAD_EPDC_DATA00__EPDC_DATA00                      = IOMUX_PAD(0x032C, 0x0064, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA00__ECSPI4_MOSI                      = IOMUX_PAD(0x032C, 0x0064, 1, 0x0658, 2, 0),
+	MX6_PAD_EPDC_DATA00__LCD_DATA24                       = IOMUX_PAD(0x032C, 0x0064, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA00__CSI_DATA00                       = IOMUX_PAD(0x032C, 0x0064, 3, 0x05C8, 2, 0),
+	MX6_PAD_EPDC_DATA00__GPIO1_IO07                       = IOMUX_PAD(0x032C, 0x0064, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA01__EPDC_DATA01                      = IOMUX_PAD(0x0330, 0x0068, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA01__ECSPI4_MISO                      = IOMUX_PAD(0x0330, 0x0068, 1, 0x0654, 2, 0),
+	MX6_PAD_EPDC_DATA01__LCD_DATA25                       = IOMUX_PAD(0x0330, 0x0068, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA01__CSI_DATA01                       = IOMUX_PAD(0x0330, 0x0068, 3, 0x05CC, 2, 0),
+	MX6_PAD_EPDC_DATA01__GPIO1_IO08                       = IOMUX_PAD(0x0330, 0x0068, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA02__EPDC_DATA02                      = IOMUX_PAD(0x0334, 0x006C, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA02__ECSPI4_SS0                       = IOMUX_PAD(0x0334, 0x006C, 1, 0x065C, 2, 0),
+	MX6_PAD_EPDC_DATA02__LCD_DATA26                       = IOMUX_PAD(0x0334, 0x006C, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA02__CSI_DATA02                       = IOMUX_PAD(0x0334, 0x006C, 3, 0x05D0, 2, 0),
+	MX6_PAD_EPDC_DATA02__GPIO1_IO09                       = IOMUX_PAD(0x0334, 0x006C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA03__EPDC_DATA03                      = IOMUX_PAD(0x0338, 0x0070, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA03__ECSPI4_SCLK                      = IOMUX_PAD(0x0338, 0x0070, 1, 0x0650, 2, 0),
+	MX6_PAD_EPDC_DATA03__LCD_DATA27                       = IOMUX_PAD(0x0338, 0x0070, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA03__CSI_DATA03                       = IOMUX_PAD(0x0338, 0x0070, 3, 0x05D4, 2, 0),
+	MX6_PAD_EPDC_DATA03__GPIO1_IO10                       = IOMUX_PAD(0x0338, 0x0070, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA04__EPDC_DATA04                      = IOMUX_PAD(0x033C, 0x0074, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA04__ECSPI4_SS1                       = IOMUX_PAD(0x033C, 0x0074, 1, 0x0660, 1, 0),
+	MX6_PAD_EPDC_DATA04__LCD_DATA28                       = IOMUX_PAD(0x033C, 0x0074, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA04__CSI_DATA04                       = IOMUX_PAD(0x033C, 0x0074, 3, 0x05D8, 2, 0),
+	MX6_PAD_EPDC_DATA04__GPIO1_IO11                       = IOMUX_PAD(0x033C, 0x0074, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA05__EPDC_DATA05                      = IOMUX_PAD(0x0340, 0x0078, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA05__ECSPI4_SS2                       = IOMUX_PAD(0x0340, 0x0078, 1, 0x0664, 1, 0),
+	MX6_PAD_EPDC_DATA05__LCD_DATA29                       = IOMUX_PAD(0x0340, 0x0078, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA05__CSI_DATA05                       = IOMUX_PAD(0x0340, 0x0078, 3, 0x05DC, 2, 0),
+	MX6_PAD_EPDC_DATA05__GPIO1_IO12                       = IOMUX_PAD(0x0340, 0x0078, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA06__EPDC_DATA06                      = IOMUX_PAD(0x0344, 0x007C, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA06__ECSPI4_SS3                       = IOMUX_PAD(0x0344, 0x007C, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA06__LCD_DATA30                       = IOMUX_PAD(0x0344, 0x007C, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA06__CSI_DATA06                       = IOMUX_PAD(0x0344, 0x007C, 3, 0x05E0, 2, 0),
+	MX6_PAD_EPDC_DATA06__GPIO1_IO13                       = IOMUX_PAD(0x0344, 0x007C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA07__EPDC_DATA07                      = IOMUX_PAD(0x0348, 0x0080, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA07__ECSPI4_RDY                       = IOMUX_PAD(0x0348, 0x0080, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA07__LCD_DATA31                       = IOMUX_PAD(0x0348, 0x0080, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA07__CSI_DATA07                       = IOMUX_PAD(0x0348, 0x0080, 3, 0x05E4, 2, 0),
+	MX6_PAD_EPDC_DATA07__GPIO1_IO14                       = IOMUX_PAD(0x0348, 0x0080, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA08__EPDC_DATA08                      = IOMUX_PAD(0x034C, 0x0084, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA08__ECSPI3_MOSI                      = IOMUX_PAD(0x034C, 0x0084, 1, 0x063C, 2, 0),
+	MX6_PAD_EPDC_DATA08__EPDC_PWR_CTRL0                   = IOMUX_PAD(0x034C, 0x0084, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA08__GPIO1_IO15                       = IOMUX_PAD(0x034C, 0x0084, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA09__EPDC_DATA09                      = IOMUX_PAD(0x0350, 0x0088, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA09__ECSPI3_MISO                      = IOMUX_PAD(0x0350, 0x0088, 1, 0x0638, 2, 0),
+	MX6_PAD_EPDC_DATA09__EPDC_PWR_CTRL1                   = IOMUX_PAD(0x0350, 0x0088, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA09__GPIO1_IO16                       = IOMUX_PAD(0x0350, 0x0088, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA10__EPDC_DATA10                      = IOMUX_PAD(0x0354, 0x008C, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA10__ECSPI3_SS0                       = IOMUX_PAD(0x0354, 0x008C, 1, 0x0648, 2, 0),
+	MX6_PAD_EPDC_DATA10__EPDC_PWR_CTRL2                   = IOMUX_PAD(0x0354, 0x008C, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA10__GPIO1_IO17                       = IOMUX_PAD(0x0354, 0x008C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA11__EPDC_DATA11                      = IOMUX_PAD(0x0358, 0x0090, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA11__ECSPI3_SCLK                      = IOMUX_PAD(0x0358, 0x0090, 1, 0x0630, 2, 0),
+	MX6_PAD_EPDC_DATA11__EPDC_PWR_CTRL3                   = IOMUX_PAD(0x0358, 0x0090, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA11__GPIO1_IO18                       = IOMUX_PAD(0x0358, 0x0090, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_DATA12__EPDC_DATA12                      = IOMUX_PAD(0x035C, 0x0094, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA12__UART2_DCE_RX                     = IOMUX_PAD(0x035C, 0x0094, 1, 0x074C, 4, 0),
+	MX6_PAD_EPDC_DATA12__UART2_DTE_TX                     = IOMUX_PAD(0x035C, 0x0094, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA12__EPDC_PWR_COM                     = IOMUX_PAD(0x035C, 0x0094, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA12__GPIO1_IO19                       = IOMUX_PAD(0x035C, 0x0094, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA12__ECSPI3_SS1                       = IOMUX_PAD(0x035C, 0x0094, 6, 0x064C, 1, 0),
+
+	MX6_PAD_EPDC_DATA13__EPDC_DATA13                      = IOMUX_PAD(0x0360, 0x0098, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA13__UART2_DCE_TX                     = IOMUX_PAD(0x0360, 0x0098, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA13__UART2_DTE_RX                     = IOMUX_PAD(0x0360, 0x0098, 1, 0x074C, 5, 0),
+	MX6_PAD_EPDC_DATA13__EPDC_PWR_IRQ                     = IOMUX_PAD(0x0360, 0x0098, 2, 0x0668, 0, 0),
+	MX6_PAD_EPDC_DATA13__GPIO1_IO20                       = IOMUX_PAD(0x0360, 0x0098, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA13__ECSPI3_SS2                       = IOMUX_PAD(0x0360, 0x0098, 6, 0x0640, 1, 0),
+
+	MX6_PAD_EPDC_DATA14__EPDC_DATA14                      = IOMUX_PAD(0x0364, 0x009C, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA14__UART2_DCE_RTS                    = IOMUX_PAD(0x0364, 0x009C, 1, 0x0748, 4, 0),
+	MX6_PAD_EPDC_DATA14__UART2_DTE_CTS                    = IOMUX_PAD(0x0364, 0x009C, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA14__EPDC_PWR_STAT                    = IOMUX_PAD(0x0364, 0x009C, 2, 0x066C, 0, 0),
+	MX6_PAD_EPDC_DATA14__GPIO1_IO21                       = IOMUX_PAD(0x0364, 0x009C, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA14__ECSPI3_SS3                       = IOMUX_PAD(0x0364, 0x009C, 6, 0x0644, 1, 0),
+
+	MX6_PAD_EPDC_DATA15__EPDC_DATA15                      = IOMUX_PAD(0x0368, 0x00A0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA15__UART2_DCE_CTS                    = IOMUX_PAD(0x0368, 0x00A0, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA15__UART2_DTE_RTS                    = IOMUX_PAD(0x0368, 0x00A0, 1, 0x0748, 5, 0),
+	MX6_PAD_EPDC_DATA15__EPDC_PWR_WAKE                    = IOMUX_PAD(0x0368, 0x00A0, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA15__GPIO1_IO22                       = IOMUX_PAD(0x0368, 0x00A0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_DATA15__ECSPI3_RDY                       = IOMUX_PAD(0x0368, 0x00A0, 6, 0x0634, 1, 0),
+
+	MX6_PAD_EPDC_SDCLK__EPDC_SDCLK_P                      = IOMUX_PAD(0x036C, 0x00A4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCLK__ECSPI2_MOSI                       = IOMUX_PAD(0x036C, 0x00A4, 1, 0x0624, 2, 0),
+	MX6_PAD_EPDC_SDCLK__I2C2_SCL                          = IOMUX_PAD(0x036C, 0x00A4, IOMUX_CONFIG_SION | 2, 0x0684, 2, 0),
+	MX6_PAD_EPDC_SDCLK__CSI_DATA08                        = IOMUX_PAD(0x036C, 0x00A4, 3, 0x05E8, 2, 0),
+	MX6_PAD_EPDC_SDCLK__GPIO1_IO23                        = IOMUX_PAD(0x036C, 0x00A4, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_SDLE__EPDC_SDLE                          = IOMUX_PAD(0x0370, 0x00A8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDLE__ECSPI2_MISO                        = IOMUX_PAD(0x0370, 0x00A8, 1, 0x0620, 2, 0),
+	MX6_PAD_EPDC_SDLE__I2C2_SDA                           = IOMUX_PAD(0x0370, 0x00A8, IOMUX_CONFIG_SION | 2, 0x0688, 2, 0),
+	MX6_PAD_EPDC_SDLE__CSI_DATA09                         = IOMUX_PAD(0x0370, 0x00A8, 3, 0x05EC, 2, 0),
+	MX6_PAD_EPDC_SDLE__GPIO1_IO24                         = IOMUX_PAD(0x0370, 0x00A8, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_SDOE__EPDC_SDOE                          = IOMUX_PAD(0x0374, 0x00AC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDOE__ECSPI2_SS0                         = IOMUX_PAD(0x0374, 0x00AC, 1, 0x0628, 1, 0),
+	MX6_PAD_EPDC_SDOE__CSI_DATA10                         = IOMUX_PAD(0x0374, 0x00AC, 3, 0x05B0, 2, 0),
+	MX6_PAD_EPDC_SDOE__GPIO1_IO25                         = IOMUX_PAD(0x0374, 0x00AC, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_SDSHR__EPDC_SDSHR                        = IOMUX_PAD(0x0378, 0x00B0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDSHR__ECSPI2_SCLK                       = IOMUX_PAD(0x0378, 0x00B0, 1, 0x061C, 2, 0),
+	MX6_PAD_EPDC_SDSHR__EPDC_SDCE4                        = IOMUX_PAD(0x0378, 0x00B0, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDSHR__CSI_DATA11                        = IOMUX_PAD(0x0378, 0x00B0, 3, 0x05B4, 2, 0),
+	MX6_PAD_EPDC_SDSHR__GPIO1_IO26                        = IOMUX_PAD(0x0378, 0x00B0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_SDCE0__EPDC_SDCE0                        = IOMUX_PAD(0x037C, 0x00B4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE0__ECSPI2_SS1                        = IOMUX_PAD(0x037C, 0x00B4, 1, 0x062C, 1, 0),
+	MX6_PAD_EPDC_SDCE0__PWM3_OUT                          = IOMUX_PAD(0x037C, 0x00B4, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE0__GPIO1_IO27                        = IOMUX_PAD(0x037C, 0x00B4, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_SDCE1__EPDC_SDCE1                        = IOMUX_PAD(0x0380, 0x00B8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE1__WDOG2_B                           = IOMUX_PAD(0x0380, 0x00B8, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE1__PWM4_OUT                          = IOMUX_PAD(0x0380, 0x00B8, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE1__GPIO1_IO28                        = IOMUX_PAD(0x0380, 0x00B8, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_SDCE2__EPDC_SDCE2                        = IOMUX_PAD(0x0384, 0x00BC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE2__I2C3_SCL                          = IOMUX_PAD(0x0384, 0x00BC, IOMUX_CONFIG_SION | 1, 0x068C, 2, 0),
+	MX6_PAD_EPDC_SDCE2__PWM1_OUT                          = IOMUX_PAD(0x0384, 0x00BC, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE2__GPIO1_IO29                        = IOMUX_PAD(0x0384, 0x00BC, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_SDCE3__EPDC_SDCE3                        = IOMUX_PAD(0x0388, 0x00C0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE3__I2C3_SDA                          = IOMUX_PAD(0x0388, 0x00C0, IOMUX_CONFIG_SION | 1, 0x0690, 2, 0),
+	MX6_PAD_EPDC_SDCE3__PWM2_OUT                          = IOMUX_PAD(0x0388, 0x00C0, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE3__GPIO1_IO30                        = IOMUX_PAD(0x0388, 0x00C0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_GDCLK__EPDC_GDCLK                        = IOMUX_PAD(0x038C, 0x00C4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDCLK__ECSPI2_SS2                        = IOMUX_PAD(0x038C, 0x00C4, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDCLK__CSI_PIXCLK                        = IOMUX_PAD(0x038C, 0x00C4, 3, 0x05F4, 2, 0),
+	MX6_PAD_EPDC_GDCLK__GPIO1_IO31                        = IOMUX_PAD(0x038C, 0x00C4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDCLK__SD2_RESET                         = IOMUX_PAD(0x038C, 0x00C4, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_GDOE__EPDC_GDOE                          = IOMUX_PAD(0x0390, 0x00C8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDOE__ECSPI2_SS3                         = IOMUX_PAD(0x0390, 0x00C8, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDOE__CSI_HSYNC                          = IOMUX_PAD(0x0390, 0x00C8, 3, 0x05F0, 2, 0),
+	MX6_PAD_EPDC_GDOE__GPIO2_IO00                         = IOMUX_PAD(0x0390, 0x00C8, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDOE__SD2_VSELECT                        = IOMUX_PAD(0x0390, 0x00C8, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_GDRL__EPDC_GDRL                          = IOMUX_PAD(0x0394, 0x00CC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDRL__ECSPI2_RDY                         = IOMUX_PAD(0x0394, 0x00CC, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDRL__CSI_MCLK                           = IOMUX_PAD(0x0394, 0x00CC, 3, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDRL__GPIO2_IO01                         = IOMUX_PAD(0x0394, 0x00CC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDRL__SD2_WP                             = IOMUX_PAD(0x0394, 0x00CC, 6, 0x077C, 2, 0),
+
+	MX6_PAD_EPDC_GDSP__EPDC_GDSP                          = IOMUX_PAD(0x0398, 0x00D0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDSP__PWM4_OUT                           = IOMUX_PAD(0x0398, 0x00D0, 1, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDSP__CSI_VSYNC                          = IOMUX_PAD(0x0398, 0x00D0, 3, 0x05F8, 2, 0),
+	MX6_PAD_EPDC_GDSP__GPIO2_IO02                         = IOMUX_PAD(0x0398, 0x00D0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDSP__SD2_CD_B                           = IOMUX_PAD(0x0398, 0x00D0, 6, 0x0778, 2, 0),
+
+	MX6_PAD_EPDC_VCOM0__EPDC_VCOM0                        = IOMUX_PAD(0x039C, 0x00D4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_VCOM0__AUD5_RXFS                         = IOMUX_PAD(0x039C, 0x00D4, 1, 0x0588, 1, 0),
+	MX6_PAD_EPDC_VCOM0__UART3_DCE_RX                      = IOMUX_PAD(0x039C, 0x00D4, 2, 0x0754, 4, 0),
+	MX6_PAD_EPDC_VCOM0__UART3_DTE_TX                      = IOMUX_PAD(0x039C, 0x00D4, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_VCOM0__GPIO2_IO03                        = IOMUX_PAD(0x039C, 0x00D4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_VCOM0__EPDC_SDCE5                        = IOMUX_PAD(0x039C, 0x00D4, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_VCOM1__EPDC_VCOM1                        = IOMUX_PAD(0x03A0, 0x00D8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_VCOM1__AUD5_RXD                          = IOMUX_PAD(0x03A0, 0x00D8, 1, 0x057C, 1, 0),
+	MX6_PAD_EPDC_VCOM1__UART3_DCE_TX                      = IOMUX_PAD(0x03A0, 0x00D8, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_VCOM1__UART3_DTE_RX                      = IOMUX_PAD(0x03A0, 0x00D8, 2, 0x0754, 5, 0),
+	MX6_PAD_EPDC_VCOM1__GPIO2_IO04                        = IOMUX_PAD(0x03A0, 0x00D8, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_VCOM1__EPDC_SDCE6                        = IOMUX_PAD(0x03A0, 0x00D8, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_BDR0__EPDC_BDR0                          = IOMUX_PAD(0x03A4, 0x00DC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR0__UART3_DCE_RTS                      = IOMUX_PAD(0x03A4, 0x00DC, 2, 0x0750, 2, 0),
+	MX6_PAD_EPDC_BDR0__UART3_DTE_CTS                      = IOMUX_PAD(0x03A4, 0x00DC, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR0__GPIO2_IO05                         = IOMUX_PAD(0x03A4, 0x00DC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR0__EPDC_SDCE7                         = IOMUX_PAD(0x03A4, 0x00DC, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_BDR1__EPDC_BDR1                          = IOMUX_PAD(0x03A8, 0x00E0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR1__UART3_DCE_CTS                      = IOMUX_PAD(0x03A8, 0x00E0, 2, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR1__UART3_DTE_RTS                      = IOMUX_PAD(0x03A8, 0x00E0, 2, 0x0750, 3, 0),
+	MX6_PAD_EPDC_BDR1__GPIO2_IO06                         = IOMUX_PAD(0x03A8, 0x00E0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR1__EPDC_SDCE8                         = IOMUX_PAD(0x03A8, 0x00E0, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWR_CTRL0__EPDC_PWR_CTRL0                = IOMUX_PAD(0x03AC, 0x00E4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_CTRL0__AUD5_RXC                      = IOMUX_PAD(0x03AC, 0x00E4, 1, 0x0584, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL0__LCD_DATA16                    = IOMUX_PAD(0x03AC, 0x00E4, 2, 0x0718, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL0__GPIO2_IO07                    = IOMUX_PAD(0x03AC, 0x00E4, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWR_CTRL1__EPDC_PWR_CTRL1                = IOMUX_PAD(0x03B0, 0x00E8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_CTRL1__AUD5_TXFS                     = IOMUX_PAD(0x03B0, 0x00E8, 1, 0x0590, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL1__LCD_DATA17                    = IOMUX_PAD(0x03B0, 0x00E8, 2, 0x071C, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL1__GPIO2_IO08                    = IOMUX_PAD(0x03B0, 0x00E8, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWR_CTRL2__EPDC_PWR_CTRL2                = IOMUX_PAD(0x03B4, 0x00EC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_CTRL2__AUD5_TXD                      = IOMUX_PAD(0x03B4, 0x00EC, 1, 0x0580, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL2__LCD_DATA18                    = IOMUX_PAD(0x03B4, 0x00EC, 2, 0x0720, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL2__GPIO2_IO09                    = IOMUX_PAD(0x03B4, 0x00EC, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWR_CTRL3__EPDC_PWR_CTRL3                = IOMUX_PAD(0x03B8, 0x00F0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_CTRL3__AUD5_TXC                      = IOMUX_PAD(0x03B8, 0x00F0, 1, 0x058C, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL3__LCD_DATA19                    = IOMUX_PAD(0x03B8, 0x00F0, 2, 0x0724, 1, 0),
+	MX6_PAD_EPDC_PWR_CTRL3__GPIO2_IO10                    = IOMUX_PAD(0x03B8, 0x00F0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWR_COM__EPDC_PWR_COM                    = IOMUX_PAD(0x03BC, 0x00F4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_COM__LCD_DATA20                      = IOMUX_PAD(0x03BC, 0x00F4, 2, 0x0728, 1, 0),
+	MX6_PAD_EPDC_PWR_COM__USB_OTG1_ID                     = IOMUX_PAD(0x03BC, 0x00F4, 4, 0x055C, 4, 0),
+	MX6_PAD_EPDC_PWR_COM__GPIO2_IO11                      = IOMUX_PAD(0x03BC, 0x00F4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_COM__SD3_RESET                       = IOMUX_PAD(0x03BC, 0x00F4, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWR_IRQ__EPDC_PWR_IRQ                    = IOMUX_PAD(0x03C0, 0x00F8, 0, 0x0668, 1, 0),
+	MX6_PAD_EPDC_PWR_IRQ__LCD_DATA21                      = IOMUX_PAD(0x03C0, 0x00F8, 2, 0x072C, 1, 0),
+	MX6_PAD_EPDC_PWR_IRQ__USB_OTG2_ID                     = IOMUX_PAD(0x03C0, 0x00F8, 4, 0x0560, 3, 0),
+	MX6_PAD_EPDC_PWR_IRQ__GPIO2_IO12                      = IOMUX_PAD(0x03C0, 0x00F8, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_IRQ__SD3_VSELECT                     = IOMUX_PAD(0x03C0, 0x00F8, 6, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWR_STAT__EPDC_PWR_STAT                  = IOMUX_PAD(0x03C4, 0x00FC, 0, 0x066C, 1, 0),
+	MX6_PAD_EPDC_PWR_STAT__LCD_DATA22                     = IOMUX_PAD(0x03C4, 0x00FC, 2, 0x0730, 1, 0),
+	MX6_PAD_EPDC_PWR_STAT__ARM_EVENTI                     = IOMUX_PAD(0x03C4, 0x00FC, 4, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_STAT__GPIO2_IO13                     = IOMUX_PAD(0x03C4, 0x00FC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_STAT__SD3_WP                         = IOMUX_PAD(0x03C4, 0x00FC, 6, 0x0794, 2, 0),
+
+	MX6_PAD_EPDC_PWR_WAKE__EPDC_PWR_WAKE                  = IOMUX_PAD(0x03C8, 0x0100, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_WAKE__LCD_DATA23                     = IOMUX_PAD(0x03C8, 0x0100, 2, 0x0734, 1, 0),
+	MX6_PAD_EPDC_PWR_WAKE__ARM_EVENTO                     = IOMUX_PAD(0x03C8, 0x0100, 4, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_WAKE__GPIO2_IO14                     = IOMUX_PAD(0x03C8, 0x0100, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWR_WAKE__SD3_CD_B                       = IOMUX_PAD(0x03C8, 0x0100, 6, 0x0780, 2, 0),
+
+	MX6_PAD_LCD_CLK__LCD_CLK                              = IOMUX_PAD(0x03CC, 0x0104, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__LCD_WR_RWN                           = IOMUX_PAD(0x03CC, 0x0104, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__PWM4_OUT                             = IOMUX_PAD(0x03CC, 0x0104, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__GPIO2_IO15                           = IOMUX_PAD(0x03CC, 0x0104, 5, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_ENABLE__LCD_ENABLE                        = IOMUX_PAD(0x03D0, 0x0108, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__LCD_RD_E                          = IOMUX_PAD(0x03D0, 0x0108, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__UART2_DCE_RX                      = IOMUX_PAD(0x03D0, 0x0108, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__UART2_DTE_TX                      = IOMUX_PAD(0x03D0, 0x0108, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__GPIO2_IO16                        = IOMUX_PAD(0x03D0, 0x0108, 5, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_HSYNC__LCD_HSYNC                          = IOMUX_PAD(0x03D4, 0x010C, 0, 0x06D4, 0, 0),
+	MX6_PAD_LCD_HSYNC__LCD_CS                             = IOMUX_PAD(0x03D4, 0x010C, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__UART2_DCE_TX                       = IOMUX_PAD(0x03D4, 0x010C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__UART2_DTE_RX                       = IOMUX_PAD(0x03D4, 0x010C, 4, 0x074C, 1, 0),
+	MX6_PAD_LCD_HSYNC__GPIO2_IO17                         = IOMUX_PAD(0x03D4, 0x010C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__ARM_TRACE_CLK                      = IOMUX_PAD(0x03D4, 0x010C, 6, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_VSYNC__LCD_VSYNC                          = IOMUX_PAD(0x03D8, 0x0110, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__LCD_RS                             = IOMUX_PAD(0x03D8, 0x0110, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__UART2_DCE_RTS                      = IOMUX_PAD(0x03D8, 0x0110, 4, 0x0748, 0, 0),
+	MX6_PAD_LCD_VSYNC__UART2_DTE_CTS                      = IOMUX_PAD(0x03D8, 0x0110, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__GPIO2_IO18                         = IOMUX_PAD(0x03D8, 0x0110, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__ARM_TRACE_CTL                      = IOMUX_PAD(0x03D8, 0x0110, 6, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_RESET__LCD_RESET                          = IOMUX_PAD(0x03DC, 0x0114, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__LCD_BUSY                           = IOMUX_PAD(0x03DC, 0x0114, 2, 0x06D4, 1, 0),
+	MX6_PAD_LCD_RESET__UART2_DCE_CTS                      = IOMUX_PAD(0x03DC, 0x0114, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__UART2_DTE_RTS                      = IOMUX_PAD(0x03DC, 0x0114, 4, 0x0748, 1, 0),
+	MX6_PAD_LCD_RESET__GPIO2_IO19                         = IOMUX_PAD(0x03DC, 0x0114, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__CCM_PMIC_READY                     = IOMUX_PAD(0x03DC, 0x0114, 6, 0x05AC, 2, 0),
+
+	MX6_PAD_LCD_DATA00__LCD_DATA00                        = IOMUX_PAD(0x03E0, 0x0118, 0, 0x06D8, 1, 0),
+	MX6_PAD_LCD_DATA00__ECSPI1_MOSI                       = IOMUX_PAD(0x03E0, 0x0118, 1, 0x0608, 0, 0),
+	MX6_PAD_LCD_DATA00__USB_OTG2_ID                       = IOMUX_PAD(0x03E0, 0x0118, 2, 0x0560, 2, 0),
+	MX6_PAD_LCD_DATA00__PWM1_OUT                          = IOMUX_PAD(0x03E0, 0x0118, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__UART5_DTR_B                       = IOMUX_PAD(0x03E0, 0x0118, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__GPIO2_IO20                        = IOMUX_PAD(0x03E0, 0x0118, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__ARM_TRACE00                       = IOMUX_PAD(0x03E0, 0x0118, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__SRC_BOOT_CFG00                    = IOMUX_PAD(0x03E0, 0x0118, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA01__LCD_DATA01                        = IOMUX_PAD(0x03E4, 0x011C, 0, 0x06DC, 1, 0),
+	MX6_PAD_LCD_DATA01__ECSPI1_MISO                       = IOMUX_PAD(0x03E4, 0x011C, 1, 0x0604, 0, 0),
+	MX6_PAD_LCD_DATA01__USB_OTG1_ID                       = IOMUX_PAD(0x03E4, 0x011C, 2, 0x055C, 3, 0),
+	MX6_PAD_LCD_DATA01__PWM2_OUT                          = IOMUX_PAD(0x03E4, 0x011C, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__AUD4_RXFS                         = IOMUX_PAD(0x03E4, 0x011C, 4, 0x0570, 0, 0),
+	MX6_PAD_LCD_DATA01__GPIO2_IO21                        = IOMUX_PAD(0x03E4, 0x011C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__ARM_TRACE01                       = IOMUX_PAD(0x03E4, 0x011C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__SRC_BOOT_CFG01                    = IOMUX_PAD(0x03E4, 0x011C, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA02__LCD_DATA02                        = IOMUX_PAD(0x03E8, 0x0120, 0, 0x06E0, 1, 0),
+	MX6_PAD_LCD_DATA02__ECSPI1_SS0                        = IOMUX_PAD(0x03E8, 0x0120, 1, 0x0614, 0, 0),
+	MX6_PAD_LCD_DATA02__EPIT2_OUT                         = IOMUX_PAD(0x03E8, 0x0120, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__PWM3_OUT                          = IOMUX_PAD(0x03E8, 0x0120, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__AUD4_RXC                          = IOMUX_PAD(0x03E8, 0x0120, 4, 0x056C, 0, 0),
+	MX6_PAD_LCD_DATA02__GPIO2_IO22                        = IOMUX_PAD(0x03E8, 0x0120, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__ARM_TRACE02                       = IOMUX_PAD(0x03E8, 0x0120, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__SRC_BOOT_CFG02                    = IOMUX_PAD(0x03E8, 0x0120, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA03__LCD_DATA03                        = IOMUX_PAD(0x03EC, 0x0124, 0, 0x06E4, 1, 0),
+	MX6_PAD_LCD_DATA03__ECSPI1_SCLK                       = IOMUX_PAD(0x03EC, 0x0124, 1, 0x05FC, 0, 0),
+	MX6_PAD_LCD_DATA03__UART5_DSR_B                       = IOMUX_PAD(0x03EC, 0x0124, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__PWM4_OUT                          = IOMUX_PAD(0x03EC, 0x0124, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__AUD4_RXD                          = IOMUX_PAD(0x03EC, 0x0124, 4, 0x0564, 0, 0),
+	MX6_PAD_LCD_DATA03__GPIO2_IO23                        = IOMUX_PAD(0x03EC, 0x0124, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__ARM_TRACE03                       = IOMUX_PAD(0x03EC, 0x0124, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__SRC_BOOT_CFG03                    = IOMUX_PAD(0x03EC, 0x0124, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA04__LCD_DATA04                        = IOMUX_PAD(0x03F0, 0x0128, 0, 0x06E8, 1, 0),
+	MX6_PAD_LCD_DATA04__ECSPI1_SS1                        = IOMUX_PAD(0x03F0, 0x0128, 1, 0x060C, 1, 0),
+	MX6_PAD_LCD_DATA04__CSI_VSYNC                         = IOMUX_PAD(0x03F0, 0x0128, 2, 0x05F8, 0, 0),
+	MX6_PAD_LCD_DATA04__WDOG2_RESET_B_DEB                 = IOMUX_PAD(0x03F0, 0x0128, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__AUD4_TXC                          = IOMUX_PAD(0x03F0, 0x0128, 4, 0x0574, 0, 0),
+	MX6_PAD_LCD_DATA04__GPIO2_IO24                        = IOMUX_PAD(0x03F0, 0x0128, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__ARM_TRACE04                       = IOMUX_PAD(0x03F0, 0x0128, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SRC_BOOT_CFG04                    = IOMUX_PAD(0x03F0, 0x0128, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA05__LCD_DATA05                        = IOMUX_PAD(0x03F4, 0x012C, 0, 0x06EC, 1, 0),
+	MX6_PAD_LCD_DATA05__ECSPI1_SS2                        = IOMUX_PAD(0x03F4, 0x012C, 1, 0x0610, 1, 0),
+	MX6_PAD_LCD_DATA05__CSI_HSYNC                         = IOMUX_PAD(0x03F4, 0x012C, 2, 0x05F0, 0, 0),
+	MX6_PAD_LCD_DATA05__AUD4_TXFS                         = IOMUX_PAD(0x03F4, 0x012C, 4, 0x0578, 0, 0),
+	MX6_PAD_LCD_DATA05__GPIO2_IO25                        = IOMUX_PAD(0x03F4, 0x012C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__ARM_TRACE05                       = IOMUX_PAD(0x03F4, 0x012C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__SRC_BOOT_CFG05                    = IOMUX_PAD(0x03F4, 0x012C, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA06__LCD_DATA06                        = IOMUX_PAD(0x03F8, 0x0130, 0, 0x06F0, 1, 0),
+	MX6_PAD_LCD_DATA06__ECSPI1_SS3                        = IOMUX_PAD(0x03F8, 0x0130, 1, 0x0618, 0, 0),
+	MX6_PAD_LCD_DATA06__CSI_PIXCLK                        = IOMUX_PAD(0x03F8, 0x0130, 2, 0x05F4, 0, 0),
+	MX6_PAD_LCD_DATA06__AUD4_TXD                          = IOMUX_PAD(0x03F8, 0x0130, 4, 0x0568, 0, 0),
+	MX6_PAD_LCD_DATA06__GPIO2_IO26                        = IOMUX_PAD(0x03F8, 0x0130, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__ARM_TRACE06                       = IOMUX_PAD(0x03F8, 0x0130, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__SRC_BOOT_CFG06                    = IOMUX_PAD(0x03F8, 0x0130, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA07__LCD_DATA07                        = IOMUX_PAD(0x03FC, 0x0134, 0, 0x06F4, 0, 0),
+	MX6_PAD_LCD_DATA07__ECSPI1_RDY                        = IOMUX_PAD(0x03FC, 0x0134, 1, 0x0600, 0, 0),
+	MX6_PAD_LCD_DATA07__CSI_MCLK                          = IOMUX_PAD(0x03FC, 0x0134, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__AUDIO_CLK_OUT                     = IOMUX_PAD(0x03FC, 0x0134, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__GPIO2_IO27                        = IOMUX_PAD(0x03FC, 0x0134, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__ARM_TRACE07                       = IOMUX_PAD(0x03FC, 0x0134, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__SRC_BOOT_CFG07                    = IOMUX_PAD(0x03FC, 0x0134, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA08__LCD_DATA08                        = IOMUX_PAD(0x0400, 0x0138, 0, 0x06F8, 0, 0),
+	MX6_PAD_LCD_DATA08__KEY_COL0                          = IOMUX_PAD(0x0400, 0x0138, 1, 0x06A0, 1, 0),
+	MX6_PAD_LCD_DATA08__CSI_DATA09                        = IOMUX_PAD(0x0400, 0x0138, 2, 0x05EC, 0, 0),
+	MX6_PAD_LCD_DATA08__ECSPI2_SCLK                       = IOMUX_PAD(0x0400, 0x0138, 4, 0x061C, 0, 0),
+	MX6_PAD_LCD_DATA08__GPIO2_IO28                        = IOMUX_PAD(0x0400, 0x0138, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__ARM_TRACE08                       = IOMUX_PAD(0x0400, 0x0138, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__SRC_BOOT_CFG08                    = IOMUX_PAD(0x0400, 0x0138, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA09__LCD_DATA09                        = IOMUX_PAD(0x0404, 0x013C, 0, 0x06FC, 0, 0),
+	MX6_PAD_LCD_DATA09__KEY_ROW0                          = IOMUX_PAD(0x0404, 0x013C, 1, 0x06C0, 1, 0),
+	MX6_PAD_LCD_DATA09__CSI_DATA08                        = IOMUX_PAD(0x0404, 0x013C, 2, 0x05E8, 0, 0),
+	MX6_PAD_LCD_DATA09__ECSPI2_MOSI                       = IOMUX_PAD(0x0404, 0x013C, 4, 0x0624, 0, 0),
+	MX6_PAD_LCD_DATA09__GPIO2_IO29                        = IOMUX_PAD(0x0404, 0x013C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__ARM_TRACE09                       = IOMUX_PAD(0x0404, 0x013C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__SRC_BOOT_CFG09                    = IOMUX_PAD(0x0404, 0x013C, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA10__LCD_DATA10                        = IOMUX_PAD(0x0408, 0x0140, 0, 0x0700, 1, 0),
+	MX6_PAD_LCD_DATA10__KEY_COL1                          = IOMUX_PAD(0x0408, 0x0140, 1, 0x06A4, 1, 0),
+	MX6_PAD_LCD_DATA10__CSI_DATA07                        = IOMUX_PAD(0x0408, 0x0140, 2, 0x05E4, 0, 0),
+	MX6_PAD_LCD_DATA10__ECSPI2_MISO                       = IOMUX_PAD(0x0408, 0x0140, 4, 0x0620, 0, 0),
+	MX6_PAD_LCD_DATA10__GPIO2_IO30                        = IOMUX_PAD(0x0408, 0x0140, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__ARM_TRACE10                       = IOMUX_PAD(0x0408, 0x0140, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__SRC_BOOT_CFG10                    = IOMUX_PAD(0x0408, 0x0140, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA11__LCD_DATA11                        = IOMUX_PAD(0x040C, 0x0144, 0, 0x0704, 0, 0),
+	MX6_PAD_LCD_DATA11__KEY_ROW1                          = IOMUX_PAD(0x040C, 0x0144, 1, 0x06C4, 1, 0),
+	MX6_PAD_LCD_DATA11__CSI_DATA06                        = IOMUX_PAD(0x040C, 0x0144, 2, 0x05E0, 0, 0),
+	MX6_PAD_LCD_DATA11__ECSPI2_SS1                        = IOMUX_PAD(0x040C, 0x0144, 4, 0x062C, 0, 0),
+	MX6_PAD_LCD_DATA11__GPIO2_IO31                        = IOMUX_PAD(0x040C, 0x0144, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__ARM_TRACE11                       = IOMUX_PAD(0x040C, 0x0144, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__SRC_BOOT_CFG11                    = IOMUX_PAD(0x040C, 0x0144, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA12__LCD_DATA12                        = IOMUX_PAD(0x0410, 0x0148, 0, 0x0708, 0, 0),
+	MX6_PAD_LCD_DATA12__KEY_COL2                          = IOMUX_PAD(0x0410, 0x0148, 1, 0x06A8, 1, 0),
+	MX6_PAD_LCD_DATA12__CSI_DATA05                        = IOMUX_PAD(0x0410, 0x0148, 2, 0x05DC, 0, 0),
+	MX6_PAD_LCD_DATA12__UART5_DCE_RTS                     = IOMUX_PAD(0x0410, 0x0148, 4, 0x0760, 0, 0),
+	MX6_PAD_LCD_DATA12__UART5_DTE_CTS                     = IOMUX_PAD(0x0410, 0x0148, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__GPIO3_IO00                        = IOMUX_PAD(0x0410, 0x0148, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__ARM_TRACE12                       = IOMUX_PAD(0x0410, 0x0148, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__SRC_BOOT_CFG12                    = IOMUX_PAD(0x0410, 0x0148, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA13__LCD_DATA13                        = IOMUX_PAD(0x0414, 0x014C, 0, 0x070C, 0, 0),
+	MX6_PAD_LCD_DATA13__KEY_ROW2                          = IOMUX_PAD(0x0414, 0x014C, 1, 0x06C8, 1, 0),
+	MX6_PAD_LCD_DATA13__CSI_DATA04                        = IOMUX_PAD(0x0414, 0x014C, 2, 0x05D8, 0, 0),
+	MX6_PAD_LCD_DATA13__UART5_DCE_CTS                     = IOMUX_PAD(0x0414, 0x014C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__UART5_DTE_RTS                     = IOMUX_PAD(0x0414, 0x014C, 4, 0x0760, 1, 0),
+	MX6_PAD_LCD_DATA13__GPIO3_IO01                        = IOMUX_PAD(0x0414, 0x014C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__ARM_TRACE13                       = IOMUX_PAD(0x0414, 0x014C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__SRC_BOOT_CFG13                    = IOMUX_PAD(0x0414, 0x014C, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA14__LCD_DATA14                        = IOMUX_PAD(0x0418, 0x0150, 0, 0x0710, 0, 0),
+	MX6_PAD_LCD_DATA14__KEY_COL3                          = IOMUX_PAD(0x0418, 0x0150, 1, 0x06AC, 1, 0),
+	MX6_PAD_LCD_DATA14__CSI_DATA03                        = IOMUX_PAD(0x0418, 0x0150, 2, 0x05D4, 0, 0),
+	MX6_PAD_LCD_DATA14__UART5_DCE_RX                      = IOMUX_PAD(0x0418, 0x0150, 4, 0x0764, 0, 0),
+	MX6_PAD_LCD_DATA14__UART5_DTE_TX                      = IOMUX_PAD(0x0418, 0x0150, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__GPIO3_IO02                        = IOMUX_PAD(0x0418, 0x0150, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__ARM_TRACE14                       = IOMUX_PAD(0x0418, 0x0150, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__SRC_BOOT_CFG14                    = IOMUX_PAD(0x0418, 0x0150, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA15__LCD_DATA15                        = IOMUX_PAD(0x041C, 0x0154, 0, 0x0714, 0, 0),
+	MX6_PAD_LCD_DATA15__KEY_ROW3                          = IOMUX_PAD(0x041C, 0x0154, 1, 0x06CC, 0, 0),
+	MX6_PAD_LCD_DATA15__CSI_DATA02                        = IOMUX_PAD(0x041C, 0x0154, 2, 0x05D0, 0, 0),
+	MX6_PAD_LCD_DATA15__UART5_DCE_TX                      = IOMUX_PAD(0x041C, 0x0154, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__UART5_DTE_RX                      = IOMUX_PAD(0x041C, 0x0154, 4, 0x0764, 1, 0),
+	MX6_PAD_LCD_DATA15__GPIO3_IO03                        = IOMUX_PAD(0x041C, 0x0154, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__ARM_TRACE15                       = IOMUX_PAD(0x041C, 0x0154, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__SRC_BOOT_CFG15                    = IOMUX_PAD(0x041C, 0x0154, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA16__LCD_DATA16                        = IOMUX_PAD(0x0420, 0x0158, 0, 0x0718, 0, 0),
+	MX6_PAD_LCD_DATA16__KEY_COL4                          = IOMUX_PAD(0x0420, 0x0158, 1, 0x06B0, 0, 0),
+	MX6_PAD_LCD_DATA16__CSI_DATA01                        = IOMUX_PAD(0x0420, 0x0158, 2, 0x05CC, 0, 0),
+	MX6_PAD_LCD_DATA16__I2C2_SCL                          = IOMUX_PAD(0x0420, 0x0158, IOMUX_CONFIG_SION | 4, 0x0684, 1, 0),
+	MX6_PAD_LCD_DATA16__GPIO3_IO04                        = IOMUX_PAD(0x0420, 0x0158, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__SRC_BOOT_CFG24                    = IOMUX_PAD(0x0420, 0x0158, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA17__LCD_DATA17                        = IOMUX_PAD(0x0424, 0x015C, 0, 0x071C, 0, 0),
+	MX6_PAD_LCD_DATA17__KEY_ROW4                          = IOMUX_PAD(0x0424, 0x015C, 1, 0x06D0, 0, 0),
+	MX6_PAD_LCD_DATA17__CSI_DATA00                        = IOMUX_PAD(0x0424, 0x015C, 2, 0x05C8, 0, 0),
+	MX6_PAD_LCD_DATA17__I2C2_SDA                          = IOMUX_PAD(0x0424, 0x015C, IOMUX_CONFIG_SION | 4, 0x0688, 1, 0),
+	MX6_PAD_LCD_DATA17__GPIO3_IO05                        = IOMUX_PAD(0x0424, 0x015C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__SRC_BOOT_CFG25                    = IOMUX_PAD(0x0424, 0x015C, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA18__LCD_DATA18                        = IOMUX_PAD(0x0428, 0x0160, 0, 0x0720, 0, 0),
+	MX6_PAD_LCD_DATA18__KEY_COL5                          = IOMUX_PAD(0x0428, 0x0160, 1, 0x0694, 2, 0),
+	MX6_PAD_LCD_DATA18__CSI_DATA15                        = IOMUX_PAD(0x0428, 0x0160, 2, 0x05C4, 1, 0),
+	MX6_PAD_LCD_DATA18__GPT_CAPTURE1                      = IOMUX_PAD(0x0428, 0x0160, 4, 0x0670, 1, 0),
+	MX6_PAD_LCD_DATA18__GPIO3_IO06                        = IOMUX_PAD(0x0428, 0x0160, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__SRC_BOOT_CFG26                    = IOMUX_PAD(0x0428, 0x0160, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA19__LCD_DATA19                        = IOMUX_PAD(0x042C, 0x0164, 0, 0x0724, 0, 0),
+	MX6_PAD_LCD_DATA19__KEY_ROW5                          = IOMUX_PAD(0x042C, 0x0164, 1, 0x06B4, 1, 0),
+	MX6_PAD_LCD_DATA19__CSI_DATA14                        = IOMUX_PAD(0x042C, 0x0164, 2, 0x05C0, 2, 0),
+	MX6_PAD_LCD_DATA19__GPT_CAPTURE2                      = IOMUX_PAD(0x042C, 0x0164, 4, 0x0674, 1, 0),
+	MX6_PAD_LCD_DATA19__GPIO3_IO07                        = IOMUX_PAD(0x042C, 0x0164, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__SRC_BOOT_CFG27                    = IOMUX_PAD(0x042C, 0x0164, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA20__LCD_DATA20                        = IOMUX_PAD(0x0430, 0x0168, 0, 0x0728, 0, 0),
+	MX6_PAD_LCD_DATA20__KEY_COL6                          = IOMUX_PAD(0x0430, 0x0168, 1, 0x0698, 1, 0),
+	MX6_PAD_LCD_DATA20__CSI_DATA13                        = IOMUX_PAD(0x0430, 0x0168, 2, 0x05BC, 2, 0),
+	MX6_PAD_LCD_DATA20__GPT_COMPARE1                      = IOMUX_PAD(0x0430, 0x0168, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__GPIO3_IO08                        = IOMUX_PAD(0x0430, 0x0168, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__SRC_BOOT_CFG28                    = IOMUX_PAD(0x0430, 0x0168, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA21__LCD_DATA21                        = IOMUX_PAD(0x0434, 0x016C, 0, 0x072C, 0, 0),
+	MX6_PAD_LCD_DATA21__KEY_ROW6                          = IOMUX_PAD(0x0434, 0x016C, 1, 0x06B8, 1, 0),
+	MX6_PAD_LCD_DATA21__CSI_DATA12                        = IOMUX_PAD(0x0434, 0x016C, 2, 0x05B8, 2, 0),
+	MX6_PAD_LCD_DATA21__GPT_COMPARE2                      = IOMUX_PAD(0x0434, 0x016C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__GPIO3_IO09                        = IOMUX_PAD(0x0434, 0x016C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__SRC_BOOT_CFG29                    = IOMUX_PAD(0x0434, 0x016C, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA22__LCD_DATA22                        = IOMUX_PAD(0x0438, 0x0170, 0, 0x0730, 0, 0),
+	MX6_PAD_LCD_DATA22__KEY_COL7                          = IOMUX_PAD(0x0438, 0x0170, 1, 0x069C, 1, 0),
+	MX6_PAD_LCD_DATA22__CSI_DATA11                        = IOMUX_PAD(0x0438, 0x0170, 2, 0x05B4, 1, 0),
+	MX6_PAD_LCD_DATA22__GPT_COMPARE3                      = IOMUX_PAD(0x0438, 0x0170, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__GPIO3_IO10                        = IOMUX_PAD(0x0438, 0x0170, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__SRC_BOOT_CFG30                    = IOMUX_PAD(0x0438, 0x0170, 7, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA23__LCD_DATA23                        = IOMUX_PAD(0x043C, 0x0174, 0, 0x0734, 0, 0),
+	MX6_PAD_LCD_DATA23__KEY_ROW7                          = IOMUX_PAD(0x043C, 0x0174, 1, 0x06BC, 1, 0),
+	MX6_PAD_LCD_DATA23__CSI_DATA10                        = IOMUX_PAD(0x043C, 0x0174, 2, 0x05B0, 1, 0),
+	MX6_PAD_LCD_DATA23__GPT_CLKIN                         = IOMUX_PAD(0x043C, 0x0174, 4, 0x0678, 1, 0),
+	MX6_PAD_LCD_DATA23__GPIO3_IO11                        = IOMUX_PAD(0x043C, 0x0174, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__SRC_BOOT_CFG31                    = IOMUX_PAD(0x043C, 0x0174, 7, 0x0000, 0, 0),
+
+	MX6_PAD_AUD_RXFS__AUD3_RXFS                           = IOMUX_PAD(0x0440, 0x0178, 0, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXFS__I2C1_SCL                            = IOMUX_PAD(0x0440, 0x0178, IOMUX_CONFIG_SION | 1, 0x067C, 1, 0),
+	MX6_PAD_AUD_RXFS__UART3_DCE_RX                        = IOMUX_PAD(0x0440, 0x0178, 2, 0x0754, 0, 0),
+	MX6_PAD_AUD_RXFS__UART3_DTE_TX                        = IOMUX_PAD(0x0440, 0x0178, 2, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXFS__I2C3_SCL                            = IOMUX_PAD(0x0440, 0x0178, IOMUX_CONFIG_SION | 4, 0x068C, 1, 0),
+	MX6_PAD_AUD_RXFS__GPIO1_IO00                          = IOMUX_PAD(0x0440, 0x0178, 5, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXFS__ECSPI3_SS0                          = IOMUX_PAD(0x0440, 0x0178, 6, 0x0648, 0, 0),
+	MX6_PAD_AUD_RXFS__MBIST_BEND                          = IOMUX_PAD(0x0440, 0x0178, 7, 0x0000, 0, 0),
+
+	MX6_PAD_AUD_RXC__AUD3_RXC                             = IOMUX_PAD(0x0444, 0x017C, 0, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXC__I2C1_SDA                             = IOMUX_PAD(0x0444, 0x017C, IOMUX_CONFIG_SION | 1, 0x0680, 1, 0),
+	MX6_PAD_AUD_RXC__UART3_DCE_TX                         = IOMUX_PAD(0x0444, 0x017C, 2, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXC__UART3_DTE_RX                         = IOMUX_PAD(0x0444, 0x017C, 2, 0x0754, 1, 0),
+	MX6_PAD_AUD_RXC__I2C3_SDA                             = IOMUX_PAD(0x0444, 0x017C, IOMUX_CONFIG_SION | 4, 0x0690, 1, 0),
+	MX6_PAD_AUD_RXC__GPIO1_IO01                           = IOMUX_PAD(0x0444, 0x017C, 5, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXC__ECSPI3_SS1                           = IOMUX_PAD(0x0444, 0x017C, 6, 0x064C, 0, 0),
+
+	MX6_PAD_AUD_RXD__AUD3_RXD                             = IOMUX_PAD(0x0448, 0x0180, 0, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXD__ECSPI3_MOSI                          = IOMUX_PAD(0x0448, 0x0180, 1, 0x063C, 0, 0),
+	MX6_PAD_AUD_RXD__UART4_DCE_RX                         = IOMUX_PAD(0x0448, 0x0180, 2, 0x075C, 0, 0),
+	MX6_PAD_AUD_RXD__UART4_DTE_TX                         = IOMUX_PAD(0x0448, 0x0180, 2, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXD__SD1_LCTL                             = IOMUX_PAD(0x0448, 0x0180, 4, 0x0000, 0, 0),
+	MX6_PAD_AUD_RXD__GPIO1_IO02                           = IOMUX_PAD(0x0448, 0x0180, 5, 0x0000, 0, 0),
+
+	MX6_PAD_AUD_TXC__AUD3_TXC                             = IOMUX_PAD(0x044C, 0x0184, 0, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXC__ECSPI3_MISO                          = IOMUX_PAD(0x044C, 0x0184, 1, 0x0638, 0, 0),
+	MX6_PAD_AUD_TXC__UART4_DCE_TX                         = IOMUX_PAD(0x044C, 0x0184, 2, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXC__UART4_DTE_RX                         = IOMUX_PAD(0x044C, 0x0184, 2, 0x075C, 1, 0),
+	MX6_PAD_AUD_TXC__SD2_LCTL                             = IOMUX_PAD(0x044C, 0x0184, 4, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXC__GPIO1_IO03                           = IOMUX_PAD(0x044C, 0x0184, 5, 0x0000, 0, 0),
+
+	MX6_PAD_AUD_TXFS__AUD3_TXFS                           = IOMUX_PAD(0x0450, 0x0188, 0, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXFS__PWM3_OUT                            = IOMUX_PAD(0x0450, 0x0188, 1, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXFS__UART4_DCE_RTS                       = IOMUX_PAD(0x0450, 0x0188, 2, 0x0758, 0, 0),
+	MX6_PAD_AUD_TXFS__UART4_DTE_CTS                       = IOMUX_PAD(0x0450, 0x0188, 2, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXFS__SD3_LCTL                            = IOMUX_PAD(0x0450, 0x0188, 4, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXFS__GPIO1_IO04                          = IOMUX_PAD(0x0450, 0x0188, 5, 0x0000, 0, 0),
+
+	MX6_PAD_AUD_TXD__AUD3_TXD                             = IOMUX_PAD(0x0454, 0x018C, 0, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXD__ECSPI3_SCLK                          = IOMUX_PAD(0x0454, 0x018C, 1, 0x0630, 0, 0),
+	MX6_PAD_AUD_TXD__UART4_DCE_CTS                        = IOMUX_PAD(0x0454, 0x018C, 2, 0x0000, 0, 0),
+	MX6_PAD_AUD_TXD__UART4_DTE_RTS                        = IOMUX_PAD(0x0454, 0x018C, 2, 0x0758, 1, 0),
+	MX6_PAD_AUD_TXD__GPIO1_IO05                           = IOMUX_PAD(0x0454, 0x018C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_AUD_MCLK__AUDIO_CLK_OUT                       = IOMUX_PAD(0x0458, 0x0190, 0, 0x0000, 0, 0),
+	MX6_PAD_AUD_MCLK__PWM4_OUT                            = IOMUX_PAD(0x0458, 0x0190, 1, 0x0000, 0, 0),
+	MX6_PAD_AUD_MCLK__ECSPI3_RDY                          = IOMUX_PAD(0x0458, 0x0190, 2, 0x0634, 0, 0),
+	MX6_PAD_AUD_MCLK__WDOG2_RESET_B_DEB                   = IOMUX_PAD(0x0458, 0x0190, 4, 0x0000, 0, 0),
+	MX6_PAD_AUD_MCLK__GPIO1_IO06                          = IOMUX_PAD(0x0458, 0x0190, 5, 0x0000, 0, 0),
+	MX6_PAD_AUD_MCLK__SPDIF_EXT_CLK                       = IOMUX_PAD(0x0458, 0x0190, 6, 0x073C, 1, 0),
+
+	MX6_PAD_UART1_RXD__UART1_DCE_RX                       = IOMUX_PAD(0x045C, 0x0194, 0, 0x0744, 0, 0),
+
+	MX6_PAD_UART1_RXD__UART1_DTE_TX                       = IOMUX_PAD(0x045C, 0x0194, 0, 0x0000, 0, 0),
+	MX6_PAD_UART1_RXD__PWM1_OUT                           = IOMUX_PAD(0x045C, 0x0194, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_RXD__UART4_DCE_RX                       = IOMUX_PAD(0x045C, 0x0194, 2, 0x075C, 4, 0),
+	MX6_PAD_UART1_RXD__UART4_DTE_TX                       = IOMUX_PAD(0x045C, 0x0194, 2, 0x0000, 0, 0),
+	MX6_PAD_UART1_RXD__UART5_DCE_RX                       = IOMUX_PAD(0x045C, 0x0194, 4, 0x0764, 6, 0),
+	MX6_PAD_UART1_RXD__UART5_DTE_TX                       = IOMUX_PAD(0x045C, 0x0194, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_RXD__GPIO3_IO16                         = IOMUX_PAD(0x045C, 0x0194, 5, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_TXD__UART1_DCE_TX                       = IOMUX_PAD(0x0460, 0x0198, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_TXD__UART1_DTE_RX                       = IOMUX_PAD(0x0460, 0x0198, 0, 0x0744, 1, 0),
+	MX6_PAD_UART1_TXD__PWM2_OUT                           = IOMUX_PAD(0x0460, 0x0198, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_TXD__UART4_DCE_TX                       = IOMUX_PAD(0x0460, 0x0198, 2, 0x0000, 0, 0),
+	MX6_PAD_UART1_TXD__UART4_DTE_RX                       = IOMUX_PAD(0x0460, 0x0198, 2, 0x075C, 5, 0),
+	MX6_PAD_UART1_TXD__UART5_DCE_TX                       = IOMUX_PAD(0x0460, 0x0198, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_TXD__UART5_DTE_RX                       = IOMUX_PAD(0x0460, 0x0198, 4, 0x0764, 7, 0),
+	MX6_PAD_UART1_TXD__GPIO3_IO17                         = IOMUX_PAD(0x0460, 0x0198, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_TXD__UART5_DCD_B                        = IOMUX_PAD(0x0460, 0x0198, 7, 0x0000, 0, 0),
+
+	MX6_PAD_I2C1_SCL__I2C1_SCL                            = IOMUX_PAD(0x0464, 0x019C, IOMUX_CONFIG_SION | 0, 0x067C, 0, 0),
+	MX6_PAD_I2C1_SCL__UART1_DCE_RTS                       = IOMUX_PAD(0x0464, 0x019C, 1, 0x0740, 0, 0),
+	MX6_PAD_I2C1_SCL__UART1_DTE_CTS                       = IOMUX_PAD(0x0464, 0x019C, 1, 0x0000, 0, 0),
+	MX6_PAD_I2C1_SCL__ECSPI3_SS2                          = IOMUX_PAD(0x0464, 0x019C, 2, 0x0640, 0, 0),
+	MX6_PAD_I2C1_SCL__SD3_RESET                           = IOMUX_PAD(0x0464, 0x019C, 4, 0x0000, 0, 0),
+	MX6_PAD_I2C1_SCL__GPIO3_IO12                          = IOMUX_PAD(0x0464, 0x019C, 5, 0x0000, 0, 0),
+	MX6_PAD_I2C1_SCL__ECSPI1_SS1                          = IOMUX_PAD(0x0464, 0x019C, 6, 0x060C, 0, 0),
+
+	MX6_PAD_I2C1_SDA__I2C1_SDA                            = IOMUX_PAD(0x0468, 0x01A0, IOMUX_CONFIG_SION | 0, 0x0680, 0, 0),
+	MX6_PAD_I2C1_SDA__UART1_DCE_CTS                       = IOMUX_PAD(0x0468, 0x01A0, 1, 0x0000, 0, 0),
+	MX6_PAD_I2C1_SDA__UART1_DTE_RTS                       = IOMUX_PAD(0x0468, 0x01A0, 1, 0x0740, 1, 0),
+	MX6_PAD_I2C1_SDA__ECSPI3_SS3                          = IOMUX_PAD(0x0468, 0x01A0, 2, 0x0644, 0, 0),
+	MX6_PAD_I2C1_SDA__SD3_VSELECT                         = IOMUX_PAD(0x0468, 0x01A0, 4, 0x0000, 0, 0),
+	MX6_PAD_I2C1_SDA__GPIO3_IO13                          = IOMUX_PAD(0x0468, 0x01A0, 5, 0x0000, 0, 0),
+	MX6_PAD_I2C1_SDA__ECSPI1_SS2                          = IOMUX_PAD(0x0468, 0x01A0, 6, 0x0610, 0, 0),
+
+	MX6_PAD_I2C2_SCL__I2C2_SCL                            = IOMUX_PAD(0x046C, 0x01A4, IOMUX_CONFIG_SION | 0, 0x0684, 3, 0),
+	MX6_PAD_I2C2_SCL__AUD4_RXFS                           = IOMUX_PAD(0x046C, 0x01A4, 1, 0x0570, 2, 0),
+	MX6_PAD_I2C2_SCL__SPDIF_IN                            = IOMUX_PAD(0x046C, 0x01A4, 2, 0x0738, 2, 0),
+	MX6_PAD_I2C2_SCL__SD3_WP                              = IOMUX_PAD(0x046C, 0x01A4, 4, 0x0794, 3, 0),
+	MX6_PAD_I2C2_SCL__GPIO3_IO14                          = IOMUX_PAD(0x046C, 0x01A4, 5, 0x0000, 0, 0),
+	MX6_PAD_I2C2_SCL__ECSPI1_RDY                          = IOMUX_PAD(0x046C, 0x01A4, 6, 0x0600, 1, 0),
+
+	MX6_PAD_I2C2_SDA__I2C2_SDA                            = IOMUX_PAD(0x0470, 0x01A8, IOMUX_CONFIG_SION | 0, 0x0688, 3, 0),
+	MX6_PAD_I2C2_SDA__AUD4_RXC                            = IOMUX_PAD(0x0470, 0x01A8, 1, 0x056C, 2, 0),
+	MX6_PAD_I2C2_SDA__SPDIF_OUT                           = IOMUX_PAD(0x0470, 0x01A8, 2, 0x0000, 0, 0),
+	MX6_PAD_I2C2_SDA__SD3_CD_B                            = IOMUX_PAD(0x0470, 0x01A8, 4, 0x0780, 3, 0),
+	MX6_PAD_I2C2_SDA__GPIO3_IO15                          = IOMUX_PAD(0x0470, 0x01A8, 5, 0x0000, 0, 0),
+
+	MX6_PAD_ECSPI1_SCLK__ECSPI1_SCLK                      = IOMUX_PAD(0x0474, 0x01AC, 0, 0x05FC, 1, 0),
+	MX6_PAD_ECSPI1_SCLK__AUD4_TXD                         = IOMUX_PAD(0x0474, 0x01AC, 1, 0x0568, 1, 0),
+	MX6_PAD_ECSPI1_SCLK__UART5_DCE_RX                     = IOMUX_PAD(0x0474, 0x01AC, 2, 0x0764, 2, 0),
+	MX6_PAD_ECSPI1_SCLK__UART5_DTE_TX                     = IOMUX_PAD(0x0474, 0x01AC, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_SCLK__EPDC_VCOM0                       = IOMUX_PAD(0x0474, 0x01AC, 3, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_SCLK__SD2_RESET                        = IOMUX_PAD(0x0474, 0x01AC, 4, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_SCLK__GPIO4_IO08                       = IOMUX_PAD(0x0474, 0x01AC, 5, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_SCLK__USB_OTG2_OC                      = IOMUX_PAD(0x0474, 0x01AC, 6, 0x0768, 1, 0),
+
+	MX6_PAD_ECSPI1_MOSI__ECSPI1_MOSI                      = IOMUX_PAD(0x0478, 0x01B0, 0, 0x0608, 1, 0),
+	MX6_PAD_ECSPI1_MOSI__AUD4_TXC                         = IOMUX_PAD(0x0478, 0x01B0, 1, 0x0574, 1, 0),
+	MX6_PAD_ECSPI1_MOSI__UART5_DCE_TX                     = IOMUX_PAD(0x0478, 0x01B0, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_MOSI__UART5_DTE_RX                     = IOMUX_PAD(0x0478, 0x01B0, 2, 0x0764, 3, 0),
+	MX6_PAD_ECSPI1_MOSI__EPDC_VCOM1                       = IOMUX_PAD(0x0478, 0x01B0, 3, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_MOSI__SD2_VSELECT                      = IOMUX_PAD(0x0478, 0x01B0, 4, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_MOSI__GPIO4_IO09                       = IOMUX_PAD(0x0478, 0x01B0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_ECSPI1_MISO__ECSPI1_MISO                      = IOMUX_PAD(0x047C, 0x01B4, 0, 0x0604, 1, 0),
+	MX6_PAD_ECSPI1_MISO__AUD4_TXFS                        = IOMUX_PAD(0x047C, 0x01B4, 1, 0x0578, 1, 0),
+	MX6_PAD_ECSPI1_MISO__UART5_DCE_RTS                    = IOMUX_PAD(0x047C, 0x01B4, 2, 0x0760, 2, 0),
+	MX6_PAD_ECSPI1_MISO__UART5_DTE_CTS                    = IOMUX_PAD(0x047C, 0x01B4, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_MISO__EPDC_BDR0                        = IOMUX_PAD(0x047C, 0x01B4, 3, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_MISO__SD2_WP                           = IOMUX_PAD(0x047C, 0x01B4, 4, 0x077C, 0, 0),
+	MX6_PAD_ECSPI1_MISO__GPIO4_IO10                       = IOMUX_PAD(0x047C, 0x01B4, 5, 0x0000, 0, 0),
+
+	MX6_PAD_ECSPI1_SS0__ECSPI1_SS0                        = IOMUX_PAD(0x0480, 0x01B8, 0, 0x0614, 1, 0),
+	MX6_PAD_ECSPI1_SS0__AUD4_RXD                          = IOMUX_PAD(0x0480, 0x01B8, 1, 0x0564, 1, 0),
+	MX6_PAD_ECSPI1_SS0__UART5_DCE_CTS                     = IOMUX_PAD(0x0480, 0x01B8, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_SS0__UART5_DTE_RTS                     = IOMUX_PAD(0x0480, 0x01B8, 2, 0x0760, 3, 0),
+	MX6_PAD_ECSPI1_SS0__EPDC_BDR1                         = IOMUX_PAD(0x0480, 0x01B8, 3, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_SS0__SD2_CD_B                          = IOMUX_PAD(0x0480, 0x01B8, 4, 0x0778, 0, 0),
+	MX6_PAD_ECSPI1_SS0__GPIO4_IO11                        = IOMUX_PAD(0x0480, 0x01B8, 5, 0x0000, 0, 0),
+	MX6_PAD_ECSPI1_SS0__USB_OTG2_PWR                      = IOMUX_PAD(0x0480, 0x01B8, 6, 0x0000, 0, 0),
+
+	MX6_PAD_ECSPI2_SCLK__ECSPI2_SCLK                      = IOMUX_PAD(0x0484, 0x01BC, 0, 0x061C, 1, 0),
+	MX6_PAD_ECSPI2_SCLK__SPDIF_EXT_CLK                    = IOMUX_PAD(0x0484, 0x01BC, 1, 0x073C, 2, 0),
+	MX6_PAD_ECSPI2_SCLK__UART3_DCE_RX                     = IOMUX_PAD(0x0484, 0x01BC, 2, 0x0754, 2, 0),
+	MX6_PAD_ECSPI2_SCLK__UART3_DTE_TX                     = IOMUX_PAD(0x0484, 0x01BC, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_SCLK__CSI_PIXCLK                       = IOMUX_PAD(0x0484, 0x01BC, 3, 0x05F4, 1, 0),
+	MX6_PAD_ECSPI2_SCLK__SD1_RESET                        = IOMUX_PAD(0x0484, 0x01BC, 4, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_SCLK__GPIO4_IO12                       = IOMUX_PAD(0x0484, 0x01BC, 5, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_SCLK__USB_OTG2_OC                      = IOMUX_PAD(0x0484, 0x01BC, 6, 0x0768, 2, 0),
+
+	MX6_PAD_ECSPI2_MOSI__ECSPI2_MOSI                      = IOMUX_PAD(0x0488, 0x01C0, 0, 0x0624, 1, 0),
+	MX6_PAD_ECSPI2_MOSI__SDMA_EXT_EVENT1                  = IOMUX_PAD(0x0488, 0x01C0, 1, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_MOSI__UART3_DCE_TX                     = IOMUX_PAD(0x0488, 0x01C0, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_MOSI__UART3_DTE_RX                     = IOMUX_PAD(0x0488, 0x01C0, 2, 0x0754, 3, 0),
+	MX6_PAD_ECSPI2_MOSI__CSI_HSYNC                        = IOMUX_PAD(0x0488, 0x01C0, 3, 0x05F0, 1, 0),
+	MX6_PAD_ECSPI2_MOSI__SD1_VSELECT                      = IOMUX_PAD(0x0488, 0x01C0, 4, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_MOSI__GPIO4_IO13                       = IOMUX_PAD(0x0488, 0x01C0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_ECSPI2_MISO__ECSPI2_MISO                      = IOMUX_PAD(0x048C, 0x01C4, 0, 0x0620, 1, 0),
+	MX6_PAD_ECSPI2_MISO__SDMA_EXT_EVENT0                  = IOMUX_PAD(0x048C, 0x01C4, 1, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_MISO__UART3_DCE_RTS                    = IOMUX_PAD(0x048C, 0x01C4, 2, 0x0750, 0, 0),
+	MX6_PAD_ECSPI2_MISO__UART3_DTE_CTS                    = IOMUX_PAD(0x048C, 0x01C4, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_MISO__CSI_MCLK                         = IOMUX_PAD(0x048C, 0x01C4, 3, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_MISO__SD1_WP                           = IOMUX_PAD(0x048C, 0x01C4, 4, 0x0774, 2, 0),
+	MX6_PAD_ECSPI2_MISO__GPIO4_IO14                       = IOMUX_PAD(0x048C, 0x01C4, 5, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_MISO__USB_OTG1_OC                      = IOMUX_PAD(0x048C, 0x01C4, 6, 0x076C, 1, 0),
+
+	MX6_PAD_ECSPI2_SS0__ECSPI2_SS0                        = IOMUX_PAD(0x0490, 0x01C8, 0, 0x0628, 0, 0),
+	MX6_PAD_ECSPI2_SS0__ECSPI1_SS3                        = IOMUX_PAD(0x0490, 0x01C8, 1, 0x0618, 1, 0),
+	MX6_PAD_ECSPI2_SS0__UART3_DCE_CTS                     = IOMUX_PAD(0x0490, 0x01C8, 2, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_SS0__UART3_DTE_RTS                     = IOMUX_PAD(0x0490, 0x01C8, 2, 0x0750, 1, 0),
+	MX6_PAD_ECSPI2_SS0__CSI_VSYNC                         = IOMUX_PAD(0x0490, 0x01C8, 3, 0x05F8, 1, 0),
+	MX6_PAD_ECSPI2_SS0__SD1_CD_B                          = IOMUX_PAD(0x0490, 0x01C8, 4, 0x0770, 2, 0),
+	MX6_PAD_ECSPI2_SS0__GPIO4_IO15                        = IOMUX_PAD(0x0490, 0x01C8, 5, 0x0000, 0, 0),
+	MX6_PAD_ECSPI2_SS0__USB_OTG1_PWR                      = IOMUX_PAD(0x0490, 0x01C8, 6, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_CLK__SD1_CLK                              = IOMUX_PAD(0x0494, 0x01CC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__KEY_COL0                             = IOMUX_PAD(0x0494, 0x01CC, 2, 0x06A0, 2, 0),
+	MX6_PAD_SD1_CLK__EPDC_SDCE4                           = IOMUX_PAD(0x0494, 0x01CC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__GPIO5_IO15                           = IOMUX_PAD(0x0494, 0x01CC, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_CMD__SD1_CMD                              = IOMUX_PAD(0x0498, 0x01D0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__KEY_ROW0                             = IOMUX_PAD(0x0498, 0x01D0, 2, 0x06C0, 2, 0),
+	MX6_PAD_SD1_CMD__EPDC_SDCE5                           = IOMUX_PAD(0x0498, 0x01D0, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__GPIO5_IO14                           = IOMUX_PAD(0x0498, 0x01D0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA0__SD1_DATA0                          = IOMUX_PAD(0x049C, 0x01D4, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__KEY_COL1                           = IOMUX_PAD(0x049C, 0x01D4, 2, 0x06A4, 2, 0),
+	MX6_PAD_SD1_DATA0__EPDC_SDCE6                         = IOMUX_PAD(0x049C, 0x01D4, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__GPIO5_IO11                         = IOMUX_PAD(0x049C, 0x01D4, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA1__SD1_DATA1                          = IOMUX_PAD(0x04A0, 0x01D8, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__KEY_ROW1                           = IOMUX_PAD(0x04A0, 0x01D8, 2, 0x06C4, 2, 0),
+	MX6_PAD_SD1_DATA1__EPDC_SDCE7                         = IOMUX_PAD(0x04A0, 0x01D8, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__GPIO5_IO08                         = IOMUX_PAD(0x04A0, 0x01D8, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA2__SD1_DATA2                          = IOMUX_PAD(0x04A4, 0x01DC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__KEY_COL2                           = IOMUX_PAD(0x04A4, 0x01DC, 2, 0x06A8, 2, 0),
+	MX6_PAD_SD1_DATA2__EPDC_SDCE8                         = IOMUX_PAD(0x04A4, 0x01DC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__GPIO5_IO13                         = IOMUX_PAD(0x04A4, 0x01DC, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA3__SD1_DATA3                          = IOMUX_PAD(0x04A8, 0x01E0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__KEY_ROW2                           = IOMUX_PAD(0x04A8, 0x01E0, 2, 0x06C8, 2, 0),
+	MX6_PAD_SD1_DATA3__EPDC_SDCE9                         = IOMUX_PAD(0x04A8, 0x01E0, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__GPIO5_IO06                         = IOMUX_PAD(0x04A8, 0x01E0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA4__SD1_DATA4                          = IOMUX_PAD(0x04AC, 0x01E4, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA4__KEY_COL3                           = IOMUX_PAD(0x04AC, 0x01E4, 2, 0x06AC, 2, 0),
+	MX6_PAD_SD1_DATA4__EPDC_SDCLK_N                       = IOMUX_PAD(0x04AC, 0x01E4, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA4__UART4_DCE_RX                       = IOMUX_PAD(0x04AC, 0x01E4, 4, 0x075C, 6, 0),
+	MX6_PAD_SD1_DATA4__UART4_DTE_TX                       = IOMUX_PAD(0x04AC, 0x01E4, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA4__GPIO5_IO12                         = IOMUX_PAD(0x04AC, 0x01E4, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA5__SD1_DATA5                          = IOMUX_PAD(0x04B0, 0x01E8, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA5__KEY_ROW3                           = IOMUX_PAD(0x04B0, 0x01E8, 2, 0x06CC, 2, 0),
+	MX6_PAD_SD1_DATA5__EPDC_SDOED                         = IOMUX_PAD(0x04B0, 0x01E8, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA5__UART4_DCE_TX                       = IOMUX_PAD(0x04B0, 0x01E8, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA5__UART4_DTE_RX                       = IOMUX_PAD(0x04B0, 0x01E8, 4, 0x075C, 7, 0),
+	MX6_PAD_SD1_DATA5__GPIO5_IO09                         = IOMUX_PAD(0x04B0, 0x01E8, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA6__SD1_DATA6                          = IOMUX_PAD(0x04B4, 0x01EC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA6__KEY_COL4                           = IOMUX_PAD(0x04B4, 0x01EC, 2, 0x06B0, 2, 0),
+	MX6_PAD_SD1_DATA6__EPDC_SDOEZ                         = IOMUX_PAD(0x04B4, 0x01EC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA6__UART4_DCE_RTS                      = IOMUX_PAD(0x04B4, 0x01EC, 4, 0x0758, 4, 0),
+	MX6_PAD_SD1_DATA6__UART4_DTE_CTS                      = IOMUX_PAD(0x04B4, 0x01EC, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA6__GPIO5_IO07                         = IOMUX_PAD(0x04B4, 0x01EC, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA7__SD1_DATA7                          = IOMUX_PAD(0x04B8, 0x01F0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA7__KEY_ROW4                           = IOMUX_PAD(0x04B8, 0x01F0, 2, 0x06D0, 2, 0),
+	MX6_PAD_SD1_DATA7__CCM_PMIC_READY                     = IOMUX_PAD(0x04B8, 0x01F0, 3, 0x05AC, 3, 0),
+	MX6_PAD_SD1_DATA7__UART4_DCE_CTS                      = IOMUX_PAD(0x04B8, 0x01F0, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA7__UART4_DTE_RTS                      = IOMUX_PAD(0x04B8, 0x01F0, 4, 0x0758, 5, 0),
+	MX6_PAD_SD1_DATA7__GPIO5_IO10                         = IOMUX_PAD(0x04B8, 0x01F0, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_RESET__SD2_RESET                          = IOMUX_PAD(0x04BC, 0x01F4, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_RESET__WDOG2_B                            = IOMUX_PAD(0x04BC, 0x01F4, 2, 0x0000, 0, 0),
+	MX6_PAD_SD2_RESET__SPDIF_OUT                          = IOMUX_PAD(0x04BC, 0x01F4, 3, 0x0000, 0, 0),
+	MX6_PAD_SD2_RESET__CSI_MCLK                           = IOMUX_PAD(0x04BC, 0x01F4, 4, 0x0000, 0, 0),
+	MX6_PAD_SD2_RESET__GPIO4_IO27                         = IOMUX_PAD(0x04BC, 0x01F4, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_CLK__SD2_CLK                              = IOMUX_PAD(0x04C0, 0x01F8, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_CLK__AUD4_RXFS                            = IOMUX_PAD(0x04C0, 0x01F8, 1, 0x0570, 1, 0),
+	MX6_PAD_SD2_CLK__ECSPI3_SCLK                          = IOMUX_PAD(0x04C0, 0x01F8, 2, 0x0630, 1, 0),
+	MX6_PAD_SD2_CLK__CSI_DATA00                           = IOMUX_PAD(0x04C0, 0x01F8, 3, 0x05C8, 1, 0),
+	MX6_PAD_SD2_CLK__GPIO5_IO05                           = IOMUX_PAD(0x04C0, 0x01F8, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_CMD__SD2_CMD                              = IOMUX_PAD(0x04C4, 0x01FC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_CMD__AUD4_RXC                             = IOMUX_PAD(0x04C4, 0x01FC, 1, 0x056C, 1, 0),
+	MX6_PAD_SD2_CMD__ECSPI3_SS0                           = IOMUX_PAD(0x04C4, 0x01FC, 2, 0x0648, 1, 0),
+	MX6_PAD_SD2_CMD__CSI_DATA01                           = IOMUX_PAD(0x04C4, 0x01FC, 3, 0x05CC, 1, 0),
+	MX6_PAD_SD2_CMD__EPIT1_OUT                            = IOMUX_PAD(0x04C4, 0x01FC, 4, 0x0000, 0, 0),
+	MX6_PAD_SD2_CMD__GPIO5_IO04                           = IOMUX_PAD(0x04C4, 0x01FC, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA0__SD2_DATA0                          = IOMUX_PAD(0x04C8, 0x0200, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA0__AUD4_RXD                           = IOMUX_PAD(0x04C8, 0x0200, 1, 0x0564, 2, 0),
+	MX6_PAD_SD2_DATA0__ECSPI3_MOSI                        = IOMUX_PAD(0x04C8, 0x0200, 2, 0x063C, 1, 0),
+	MX6_PAD_SD2_DATA0__CSI_DATA02                         = IOMUX_PAD(0x04C8, 0x0200, 3, 0x05D0, 1, 0),
+	MX6_PAD_SD2_DATA0__UART5_DCE_RTS                      = IOMUX_PAD(0x04C8, 0x0200, 4, 0x0760, 4, 0),
+	MX6_PAD_SD2_DATA0__UART5_DTE_CTS                      = IOMUX_PAD(0x04C8, 0x0200, 4, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA0__GPIO5_IO01                         = IOMUX_PAD(0x04C8, 0x0200, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA1__SD2_DATA1                          = IOMUX_PAD(0x04CC, 0x0204, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA1__AUD4_TXC                           = IOMUX_PAD(0x04CC, 0x0204, 1, 0x0574, 2, 0),
+	MX6_PAD_SD2_DATA1__ECSPI3_MISO                        = IOMUX_PAD(0x04CC, 0x0204, 2, 0x0638, 1, 0),
+	MX6_PAD_SD2_DATA1__CSI_DATA03                         = IOMUX_PAD(0x04CC, 0x0204, 3, 0x05D4, 1, 0),
+	MX6_PAD_SD2_DATA1__UART5_DCE_CTS                      = IOMUX_PAD(0x04CC, 0x0204, 4, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA1__UART5_DTE_RTS                      = IOMUX_PAD(0x04CC, 0x0204, 4, 0x0760, 5, 0),
+	MX6_PAD_SD2_DATA1__GPIO4_IO30                         = IOMUX_PAD(0x04CC, 0x0204, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA2__SD2_DATA2                          = IOMUX_PAD(0x04D0, 0x0208, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA2__AUD4_TXFS                          = IOMUX_PAD(0x04D0, 0x0208, 1, 0x0578, 2, 0),
+	MX6_PAD_SD2_DATA2__CSI_DATA04                         = IOMUX_PAD(0x04D0, 0x0208, 3, 0x05D8, 1, 0),
+	MX6_PAD_SD2_DATA2__UART5_DCE_RX                       = IOMUX_PAD(0x04D0, 0x0208, 4, 0x0764, 4, 0),
+	MX6_PAD_SD2_DATA2__UART5_DTE_TX                       = IOMUX_PAD(0x04D0, 0x0208, 4, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA2__GPIO5_IO03                         = IOMUX_PAD(0x04D0, 0x0208, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA3__SD2_DATA3                          = IOMUX_PAD(0x04D4, 0x020C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA3__AUD4_TXD                           = IOMUX_PAD(0x04D4, 0x020C, 1, 0x0568, 2, 0),
+	MX6_PAD_SD2_DATA3__CSI_DATA05                         = IOMUX_PAD(0x04D4, 0x020C, 3, 0x05DC, 1, 0),
+	MX6_PAD_SD2_DATA3__UART5_DCE_TX                       = IOMUX_PAD(0x04D4, 0x020C, 4, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA3__UART5_DTE_RX                       = IOMUX_PAD(0x04D4, 0x020C, 4, 0x0764, 5, 0),
+	MX6_PAD_SD2_DATA3__GPIO4_IO28                         = IOMUX_PAD(0x04D4, 0x020C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA4__SD2_DATA4                          = IOMUX_PAD(0x04D8, 0x0210, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA4__SD3_DATA4                          = IOMUX_PAD(0x04D8, 0x0210, 1, 0x0784, 1, 0),
+	MX6_PAD_SD2_DATA4__UART2_DCE_RX                       = IOMUX_PAD(0x04D8, 0x0210, 2, 0x074C, 2, 0),
+	MX6_PAD_SD2_DATA4__UART2_DTE_TX                       = IOMUX_PAD(0x04D8, 0x0210, 2, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA4__CSI_DATA06                         = IOMUX_PAD(0x04D8, 0x0210, 3, 0x05E0, 1, 0),
+	MX6_PAD_SD2_DATA4__SPDIF_OUT                          = IOMUX_PAD(0x04D8, 0x0210, 4, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA4__GPIO5_IO02                         = IOMUX_PAD(0x04D8, 0x0210, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA5__SD2_DATA5                          = IOMUX_PAD(0x04DC, 0x0214, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA5__SD3_DATA5                          = IOMUX_PAD(0x04DC, 0x0214, 1, 0x0788, 1, 0),
+	MX6_PAD_SD2_DATA5__UART2_DCE_TX                       = IOMUX_PAD(0x04DC, 0x0214, 2, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA5__UART2_DTE_RX                       = IOMUX_PAD(0x04DC, 0x0214, 2, 0x074C, 3, 0),
+	MX6_PAD_SD2_DATA5__CSI_DATA07                         = IOMUX_PAD(0x04DC, 0x0214, 3, 0x05E4, 1, 0),
+	MX6_PAD_SD2_DATA5__SPDIF_IN                           = IOMUX_PAD(0x04DC, 0x0214, 4, 0x0738, 1, 0),
+	MX6_PAD_SD2_DATA5__GPIO4_IO31                         = IOMUX_PAD(0x04DC, 0x0214, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA6__SD2_DATA6                          = IOMUX_PAD(0x04E0, 0x0218, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA6__SD3_DATA6                          = IOMUX_PAD(0x04E0, 0x0218, 1, 0x078C, 1, 0),
+	MX6_PAD_SD2_DATA6__UART2_DCE_RTS                      = IOMUX_PAD(0x04E0, 0x0218, 2, 0x0748, 2, 0),
+	MX6_PAD_SD2_DATA6__UART2_DTE_CTS                      = IOMUX_PAD(0x04E0, 0x0218, 2, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA6__CSI_DATA08                         = IOMUX_PAD(0x04E0, 0x0218, 3, 0x05E8, 1, 0),
+	MX6_PAD_SD2_DATA6__SD2_WP                             = IOMUX_PAD(0x04E0, 0x0218, 4, 0x077C, 1, 0),
+	MX6_PAD_SD2_DATA6__GPIO4_IO29                         = IOMUX_PAD(0x04E0, 0x0218, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD2_DATA7__SD2_DATA7                          = IOMUX_PAD(0x04E4, 0x021C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA7__SD3_DATA7                          = IOMUX_PAD(0x04E4, 0x021C, 1, 0x0790, 1, 0),
+	MX6_PAD_SD2_DATA7__UART2_DCE_CTS                      = IOMUX_PAD(0x04E4, 0x021C, 2, 0x0000, 0, 0),
+	MX6_PAD_SD2_DATA7__UART2_DTE_RTS                      = IOMUX_PAD(0x04E4, 0x021C, 2, 0x0748, 3, 0),
+	MX6_PAD_SD2_DATA7__CSI_DATA09                         = IOMUX_PAD(0x04E4, 0x021C, 3, 0x05EC, 1, 0),
+	MX6_PAD_SD2_DATA7__SD2_CD_B                           = IOMUX_PAD(0x04E4, 0x021C, 4, 0x0778, 1, 0),
+	MX6_PAD_SD2_DATA7__GPIO5_IO00                         = IOMUX_PAD(0x04E4, 0x021C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD3_CLK__SD3_CLK                              = IOMUX_PAD(0x04E8, 0x0220, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_CLK__AUD5_RXFS                            = IOMUX_PAD(0x04E8, 0x0220, 1, 0x0588, 0, 0),
+	MX6_PAD_SD3_CLK__KEY_COL5                             = IOMUX_PAD(0x04E8, 0x0220, 2, 0x0694, 0, 0),
+	MX6_PAD_SD3_CLK__CSI_DATA10                           = IOMUX_PAD(0x04E8, 0x0220, 3, 0x05B0, 0, 0),
+	MX6_PAD_SD3_CLK__WDOG1_RESET_B_DEB                    = IOMUX_PAD(0x04E8, 0x0220, 4, 0x0000, 0, 0),
+	MX6_PAD_SD3_CLK__GPIO5_IO18                           = IOMUX_PAD(0x04E8, 0x0220, 5, 0x0000, 0, 0),
+	MX6_PAD_SD3_CLK__USB_OTG1_PWR                         = IOMUX_PAD(0x04E8, 0x0220, 6, 0x0000, 0, 0),
+
+	MX6_PAD_SD3_CMD__SD3_CMD                              = IOMUX_PAD(0x04EC, 0x0224, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_CMD__AUD5_RXC                             = IOMUX_PAD(0x04EC, 0x0224, 1, 0x0584, 0, 0),
+	MX6_PAD_SD3_CMD__KEY_ROW5                             = IOMUX_PAD(0x04EC, 0x0224, 2, 0x06B4, 0, 0),
+	MX6_PAD_SD3_CMD__CSI_DATA11                           = IOMUX_PAD(0x04EC, 0x0224, 3, 0x05B4, 0, 0),
+	MX6_PAD_SD3_CMD__USB_OTG2_ID                          = IOMUX_PAD(0x04EC, 0x0224, 4, 0x0560, 1, 0),
+	MX6_PAD_SD3_CMD__GPIO5_IO21                           = IOMUX_PAD(0x04EC, 0x0224, 5, 0x0000, 0, 0),
+	MX6_PAD_SD3_CMD__USB_OTG2_PWR                         = IOMUX_PAD(0x04EC, 0x0224, 6, 0x0000, 0, 0),
+
+	MX6_PAD_SD3_DATA0__SD3_DATA0                          = IOMUX_PAD(0x04F0, 0x0228, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA0__AUD5_RXD                           = IOMUX_PAD(0x04F0, 0x0228, 1, 0x057C, 0, 0),
+	MX6_PAD_SD3_DATA0__KEY_COL6                           = IOMUX_PAD(0x04F0, 0x0228, 2, 0x0698, 0, 0),
+	MX6_PAD_SD3_DATA0__CSI_DATA12                         = IOMUX_PAD(0x04F0, 0x0228, 3, 0x05B8, 0, 0),
+	MX6_PAD_SD3_DATA0__USB_OTG1_ID                        = IOMUX_PAD(0x04F0, 0x0228, 4, 0x055C, 1, 0),
+	MX6_PAD_SD3_DATA0__GPIO5_IO19                         = IOMUX_PAD(0x04F0, 0x0228, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD3_DATA1__SD3_DATA1                          = IOMUX_PAD(0x04F4, 0x022C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA1__AUD5_TXC                           = IOMUX_PAD(0x04F4, 0x022C, 1, 0x058C, 0, 0),
+	MX6_PAD_SD3_DATA1__KEY_ROW6                           = IOMUX_PAD(0x04F4, 0x022C, 2, 0x06B8, 0, 0),
+	MX6_PAD_SD3_DATA1__CSI_DATA13                         = IOMUX_PAD(0x04F4, 0x022C, 3, 0x05BC, 0, 0),
+	MX6_PAD_SD3_DATA1__SD1_VSELECT                        = IOMUX_PAD(0x04F4, 0x022C, 4, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA1__GPIO5_IO20                         = IOMUX_PAD(0x04F4, 0x022C, 5, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA1__JTAG_DE_B                          = IOMUX_PAD(0x04F4, 0x022C, 6, 0x0000, 0, 0),
+
+	MX6_PAD_SD3_DATA2__SD3_DATA2                          = IOMUX_PAD(0x04F8, 0x0230, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA2__AUD5_TXFS                          = IOMUX_PAD(0x04F8, 0x0230, 1, 0x0590, 0, 0),
+	MX6_PAD_SD3_DATA2__KEY_COL7                           = IOMUX_PAD(0x04F8, 0x0230, 2, 0x069C, 0, 0),
+	MX6_PAD_SD3_DATA2__CSI_DATA14                         = IOMUX_PAD(0x04F8, 0x0230, 3, 0x05C0, 0, 0),
+	MX6_PAD_SD3_DATA2__EPIT1_OUT                          = IOMUX_PAD(0x04F8, 0x0230, 4, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA2__GPIO5_IO16                         = IOMUX_PAD(0x04F8, 0x0230, 5, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA2__USB_OTG2_OC                        = IOMUX_PAD(0x04F8, 0x0230, 6, 0x0768, 0, 0),
+
+	MX6_PAD_SD3_DATA3__SD3_DATA3                          = IOMUX_PAD(0x04FC, 0x0234, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA3__AUD5_TXD                           = IOMUX_PAD(0x04FC, 0x0234, 1, 0x0580, 0, 0),
+	MX6_PAD_SD3_DATA3__KEY_ROW7                           = IOMUX_PAD(0x04FC, 0x0234, 2, 0x06BC, 0, 0),
+	MX6_PAD_SD3_DATA3__CSI_DATA15                         = IOMUX_PAD(0x04FC, 0x0234, 3, 0x05C4, 0, 0),
+	MX6_PAD_SD3_DATA3__EPIT2_OUT                          = IOMUX_PAD(0x04FC, 0x0234, 4, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA3__GPIO5_IO17                         = IOMUX_PAD(0x04FC, 0x0234, 5, 0x0000, 0, 0),
+	MX6_PAD_SD3_DATA3__USB_OTG1_OC                        = IOMUX_PAD(0x04FC, 0x0234, 6, 0x076C, 0, 0),
+
+	MX6_PAD_GPIO4_IO20__SD1_STROBE                        = IOMUX_PAD(0x0500, 0x0238, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO20__AUD6_RXFS                         = IOMUX_PAD(0x0500, 0x0238, 2, 0x05A0, 0, 0),
+	MX6_PAD_GPIO4_IO20__ECSPI4_SS0                        = IOMUX_PAD(0x0500, 0x0238, 3, 0x065C, 0, 0),
+	MX6_PAD_GPIO4_IO20__GPT_CAPTURE1                      = IOMUX_PAD(0x0500, 0x0238, 4, 0x0670, 0, 0),
+	MX6_PAD_GPIO4_IO20__GPIO4_IO20                        = IOMUX_PAD(0x0500, 0x0238, 5, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO4_IO21__SD2_STROBE                        = IOMUX_PAD(0x0504, 0x023C, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO21__AUD6_RXC                          = IOMUX_PAD(0x0504, 0x023C, 2, 0x059C, 0, 0),
+	MX6_PAD_GPIO4_IO21__ECSPI4_SCLK                       = IOMUX_PAD(0x0504, 0x023C, 3, 0x0650, 0, 0),
+	MX6_PAD_GPIO4_IO21__GPT_CAPTURE2                      = IOMUX_PAD(0x0504, 0x023C, 4, 0x0674, 0, 0),
+	MX6_PAD_GPIO4_IO21__GPIO4_IO21                        = IOMUX_PAD(0x0504, 0x023C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO4_IO19__SD3_STROBE                        = IOMUX_PAD(0x0508, 0x0240, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO19__AUD6_RXD                          = IOMUX_PAD(0x0508, 0x0240, 2, 0x0594, 0, 0),
+	MX6_PAD_GPIO4_IO19__ECSPI4_MOSI                       = IOMUX_PAD(0x0508, 0x0240, 3, 0x0658, 0, 0),
+	MX6_PAD_GPIO4_IO19__GPT_COMPARE1                      = IOMUX_PAD(0x0508, 0x0240, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO19__GPIO4_IO19                        = IOMUX_PAD(0x0508, 0x0240, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO25__AUD6_TXC                          = IOMUX_PAD(0x050C, 0x0244, 2, 0x05A4, 0, 0),
+	MX6_PAD_GPIO4_IO25__ECSPI4_MISO                       = IOMUX_PAD(0x050C, 0x0244, 3, 0x0654, 0, 0),
+	MX6_PAD_GPIO4_IO25__GPT_COMPARE2                      = IOMUX_PAD(0x050C, 0x0244, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO25__GPIO4_IO25                        = IOMUX_PAD(0x050C, 0x0244, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO18__AUD6_TXFS                         = IOMUX_PAD(0x0510, 0x0248, 2, 0x05A8, 0, 0),
+	MX6_PAD_GPIO4_IO18__ECSPI4_SS1                        = IOMUX_PAD(0x0510, 0x0248, 3, 0x0660, 0, 0),
+	MX6_PAD_GPIO4_IO18__GPT_COMPARE3                      = IOMUX_PAD(0x0510, 0x0248, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO18__GPIO4_IO18                        = IOMUX_PAD(0x0510, 0x0248, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO24__AUD6_TXD                          = IOMUX_PAD(0x0514, 0x024C, 2, 0x0598, 0, 0),
+	MX6_PAD_GPIO4_IO24__ECSPI4_SS2                        = IOMUX_PAD(0x0514, 0x024C, 3, 0x0664, 0, 0),
+	MX6_PAD_GPIO4_IO24__GPT_CLKIN                         = IOMUX_PAD(0x0514, 0x024C, 4, 0x0678, 0, 0),
+	MX6_PAD_GPIO4_IO24__GPIO4_IO24                        = IOMUX_PAD(0x0514, 0x024C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO23__AUDIO_CLK_OUT                     = IOMUX_PAD(0x0518, 0x0250, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO23__SD1_RESET                         = IOMUX_PAD(0x0518, 0x0250, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO23__SD3_RESET                         = IOMUX_PAD(0x0518, 0x0250, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO23__GPIO4_IO23                        = IOMUX_PAD(0x0518, 0x0250, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO17__USB_OTG1_ID                       = IOMUX_PAD(0x051C, 0x0254, 2, 0x055C, 2, 0),
+	MX6_PAD_GPIO4_IO17__SD1_VSELECT                       = IOMUX_PAD(0x051C, 0x0254, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO17__SD3_VSELECT                       = IOMUX_PAD(0x051C, 0x0254, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO17__GPIO4_IO17                        = IOMUX_PAD(0x051C, 0x0254, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO22__SPDIF_IN                          = IOMUX_PAD(0x0520, 0x0258, 2, 0x0738, 0, 0),
+	MX6_PAD_GPIO4_IO22__SD1_WP                            = IOMUX_PAD(0x0520, 0x0258, 3, 0x0774, 0, 0),
+	MX6_PAD_GPIO4_IO22__SD3_WP                            = IOMUX_PAD(0x0520, 0x0258, 4, 0x0794, 1, 0),
+	MX6_PAD_GPIO4_IO22__GPIO4_IO22                        = IOMUX_PAD(0x0520, 0x0258, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO16__SPDIF_OUT                         = IOMUX_PAD(0x0524, 0x025C, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO16__SD1_CD_B                          = IOMUX_PAD(0x0524, 0x025C, 3, 0x0770, 0, 0),
+	MX6_PAD_GPIO4_IO16__SD3_CD_B                          = IOMUX_PAD(0x0524, 0x025C, 4, 0x0780, 1, 0),
+	MX6_PAD_GPIO4_IO16__GPIO4_IO16                        = IOMUX_PAD(0x0524, 0x025C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO26__WDOG1_B                           = IOMUX_PAD(0x0528, 0x0260, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO26__PWM4_OUT                          = IOMUX_PAD(0x0528, 0x0260, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO26__CCM_PMIC_READY                    = IOMUX_PAD(0x0528, 0x0260, 4, 0x05AC, 1, 0),
+	MX6_PAD_GPIO4_IO26__GPIO4_IO26                        = IOMUX_PAD(0x0528, 0x0260, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO4_IO26__SPDIF_EXT_CLK                     = IOMUX_PAD(0x0528, 0x0260, 6, 0x073C, 0, 0),
+};
+#endif  /* __ASM_ARCH_IMX6SLL_PINS_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch-mx6/mx6sl_pins.h ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/mx6sl_pins.h
--- u-boot-2016.03/arch/arm/include/asm/arch-mx6/mx6sl_pins.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/mx6sl_pins.h	2021-04-16 14:42:14.688580767 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2013 - 2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -59,14 +59,70 @@
 	MX6_PAD_FEC_RX_ER__GPIO_4_19				= IOMUX_PAD(0x0428, 0x0138, 5, 0x0000, 0, 0),
 	MX6_PAD_FEC_TX_CLK__GPIO_4_21				= IOMUX_PAD(0x0434, 0x0144, 5, 0x0000, 0, 0),
 
-	MX6_PAD_EPDC_PWRCOM__ANATOP_USBOTG1_ID			= IOMUX_PAD(0x03D0, 0x00E0, 4, 0x05DC, 0, 0),
+	MX6_PAD_KEY_COL0__KPP_COL_0				= IOMUX_PAD(0x0474, 0x016C, 0, 0x0734, 0, 0),
+	MX6_PAD_KEY_COL1__KPP_COL_1				= IOMUX_PAD(0x0478, 0x0170, 0, 0x0738, 0, 0),
+	MX6_PAD_KEY_COL2__KPP_COL_2				= IOMUX_PAD(0x047C, 0x0174, 0, 0x073C, 0, 0),
+	MX6_PAD_KEY_COL3__KPP_COL_3				= IOMUX_PAD(0x0480, 0x0178, 0, 0x0740, 0, 0),
+	MX6_PAD_KEY_ROW0__KPP_ROW_0				= IOMUX_PAD(0x0494, 0x018C, 0, 0x0754, 0, 0),
+	MX6_PAD_KEY_ROW1__KPP_ROW_1				= IOMUX_PAD(0x0498, 0x0190, 0, 0x0758, 0, 0),
+	MX6_PAD_KEY_ROW2__KPP_ROW_2				= IOMUX_PAD(0x049C, 0x0194, 0, 0x075C, 0, 0),
+	MX6_PAD_KEY_ROW3__KPP_ROW_3				= IOMUX_PAD(0x04A0, 0x0198, 0, 0x0760, 0, 0),
 
 	MX6_PAD_KEY_COL4__USB_USBOTG1_PWR			= IOMUX_PAD(0x0484, 0x017C, 6, 0x0000, 0, 0),
 	MX6_PAD_KEY_COL5__USB_USBOTG2_PWR			= IOMUX_PAD(0x0488, 0x0180, 6, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL6__GPIO_4_4				= IOMUX_PAD(0x048C, 0x0184, 5, 0x0000, 0, 0),
 
 	MX6_PAD_I2C1_SDA__I2C1_SDA				= IOMUX_PAD(0x0450, 0x0160, 0x10, 0x0720, 2, 0),
 	MX6_PAD_I2C1_SDA__GPIO_3_13				= IOMUX_PAD(0x0450, 0x0160, 5, 0x0000, 0, 0),
 	MX6_PAD_I2C1_SCL__I2C1_SCL				= IOMUX_PAD(0x044C, 0x015C, 0x10, 0x071C, 2, 0),
 	MX6_PAD_I2C1_SCL__GPIO_3_12				= IOMUX_PAD(0x044C, 0x015C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWRCOM__ANATOP_USBOTG1_ID			= IOMUX_PAD(0x03D0, 0x00E0, 4, 0x05DC, 0, 0),
+	MX6_PAD_EPDC_PWRCTRL2__GPIO_2_9				= IOMUX_PAD(0x03DC, 0x00EC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWRCTRL3__GPIO_2_10			= IOMUX_PAD(0x03E0, 0x00F0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWRSTAT__GPIO_2_13				= IOMUX_PAD(0x03E8, 0x00F8, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_VCOM0__GPIO_2_3				= IOMUX_PAD(0x0410, 0x0120, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWRWAKEUP__GPIO_2_14			= IOMUX_PAD(0x03EC, 0x00FC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWRCTRL0__GPIO_2_7				= IOMUX_PAD(0x03D4, 0x00E4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D0__EPDC_SDDO_0				= IOMUX_PAD(0x0380, 0x0090, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D1__EPDC_SDDO_1				= IOMUX_PAD(0x0384, 0x0094, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D2__EPDC_SDDO_2				= IOMUX_PAD(0x03A0, 0x00B0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D3__EPDC_SDDO_3				= IOMUX_PAD(0x03A4, 0x00B4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D4__EPDC_SDDO_4				= IOMUX_PAD(0x03A8, 0x00B8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D5__EPDC_SDDO_5				= IOMUX_PAD(0x03AC, 0x00BC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D6__EPDC_SDDO_6				= IOMUX_PAD(0x03B0, 0x00C0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D7__EPDC_SDDO_7				= IOMUX_PAD(0x03B4, 0x00C4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDCLK__EPDC_GDCLK				= IOMUX_PAD(0x03C0, 0x00D0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDSP__EPDC_GDSP				= IOMUX_PAD(0x03CC, 0x00DC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDOE__EPDC_GDOE				= IOMUX_PAD(0x03C4, 0x00D4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDRL__EPDC_GDRL				= IOMUX_PAD(0x03C8, 0x00D8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCLK__EPDC_SDCLK				= IOMUX_PAD(0x0400, 0x0110, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDOE__EPDC_SDOE				= IOMUX_PAD(0x0408, 0x0118, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDLE__EPDC_SDLE				= IOMUX_PAD(0x0404, 0x0114, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDSHR__EPDC_SDSHR				= IOMUX_PAD(0x040C, 0x011C, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR0__EPDC_BDR_0				= IOMUX_PAD(0x0378, 0x0088, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE0__EPDC_SDCE_0				= IOMUX_PAD(0x03F0, 0x0100, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE1__EPDC_SDCE_1				= IOMUX_PAD(0x03F4, 0x0104, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE2__EPDC_SDCE_2				= IOMUX_PAD(0x03F8, 0x0108, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D0__GPIO_1_7				= IOMUX_PAD(0x0380, 0x0090, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D1__GPIO_1_8				= IOMUX_PAD(0x0384, 0x0094, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D2__GPIO_1_9				= IOMUX_PAD(0x03A0, 0x00B0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D3__GPIO_1_10				= IOMUX_PAD(0x03A4, 0x00B4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D4__GPIO_1_11				= IOMUX_PAD(0x03A8, 0x00B8, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D5__GPIO_1_12				= IOMUX_PAD(0x03AC, 0x00BC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D6__GPIO_1_13				= IOMUX_PAD(0x03B0, 0x00C0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D7__GPIO_1_14				= IOMUX_PAD(0x03B4, 0x00C4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDCLK__GPIO_1_31				= IOMUX_PAD(0x03C0, 0x00D0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDSP__GPIO_2_2				= IOMUX_PAD(0x03CC, 0x00DC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDOE__GPIO_2_0				= IOMUX_PAD(0x03C4, 0x00D4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDRL__GPIO_2_1				= IOMUX_PAD(0x03C8, 0x00D8, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCLK__GPIO_1_23				= IOMUX_PAD(0x0400, 0x0110, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDOE__GPIO_1_25				= IOMUX_PAD(0x0408, 0x0118, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDLE__GPIO_1_24				= IOMUX_PAD(0x0404, 0x0114, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDSHR__GPIO_1_26				= IOMUX_PAD(0x040C, 0x011C, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR0__GPIO_2_5				= IOMUX_PAD(0x0378, 0x0088, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE0__GPIO_1_27				= IOMUX_PAD(0x03F0, 0x0100, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE1__GPIO_1_28				= IOMUX_PAD(0x03F4, 0x0104, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE2__GPIO_1_29				= IOMUX_PAD(0x03F8, 0x0108, 5, 0x0000, 0, 0),
 };
 #endif	/* __ASM_ARCH_MX6_MX6SL_PINS_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch-mx6/mx6ull_pins.h ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/mx6ull_pins.h
--- u-boot-2016.03/arch/arm/include/asm/arch-mx6/mx6ull_pins.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/mx6ull_pins.h	2021-04-16 14:42:14.692580786 +0800
@@ -0,0 +1,1091 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_IMX6ULL_PINS_H__
+#define __ASM_ARCH_IMX6ULL_PINS_H__
+
+#include <asm/imx-common/iomux-v3.h>
+
+enum {
+	MX6_PAD_BOOT_MODE0__GPIO5_IO10	                       = IOMUX_PAD(0x0044, 0x0000, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_BOOT_MODE1__GPIO5_IO11	                       = IOMUX_PAD(0x0048, 0x0004, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+
+	/*
+	 * The TAMPER Pin can be used for GPIO, which depends on
+	 * TAMPER_PIN_DISABLE[1:0] settings.
+	 */
+	MX6_PAD_SNVS_TAMPER0__GPIO5_IO00                       = IOMUX_PAD(0x004C, 0x0008, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER1__GPIO5_IO01                       = IOMUX_PAD(0x0050, 0x000C, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER2__GPIO5_IO02                       = IOMUX_PAD(0x0054, 0x0010, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER3__GPIO5_IO03                       = IOMUX_PAD(0x0058, 0x0014, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER4__GPIO5_IO04                       = IOMUX_PAD(0x005C, 0x0018, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER5__GPIO5_IO05                       = IOMUX_PAD(0x0060, 0x001C, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER6__GPIO5_IO06                       = IOMUX_PAD(0x0064, 0x0020, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER7__GPIO5_IO07                       = IOMUX_PAD(0x0068, 0x0024, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER8__GPIO5_IO08                       = IOMUX_PAD(0x006C, 0x0028, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER9__GPIO5_IO09                       = IOMUX_PAD(0x0070, 0x002C, IOMUX_CONFIG_LPSR | 5, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_MOD__SJC_MOD                             = IOMUX_PAD(0x02D0, 0x0044, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__GPT2_CLK                            = IOMUX_PAD(0x02D0, 0x0044, 1, 0x05A0, 0, 0),
+	MX6_PAD_JTAG_MOD__SPDIF_OUT                           = IOMUX_PAD(0x02D0, 0x0044, 2, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__ENET1_REF_CLK_25M                   = IOMUX_PAD(0x02D0, 0x0044, 3, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__CCM_PMIC_RDY                        = IOMUX_PAD(0x02D0, 0x0044, 4, 0x04C0, 0, 0),
+	MX6_PAD_JTAG_MOD__GPIO1_IO10                          = IOMUX_PAD(0x02D0, 0x0044, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__SDMA_EXT_EVENT00                    = IOMUX_PAD(0x02D0, 0x0044, 6, 0x0610, 0, 0),
+
+	MX6_PAD_JTAG_TMS__SJC_TMS                             = IOMUX_PAD(0x02D4, 0x0048, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__GPT2_CAPTURE1                       = IOMUX_PAD(0x02D4, 0x0048, 1, 0x0598, 0, 0),
+	MX6_PAD_JTAG_TMS__SAI2_MCLK                           = IOMUX_PAD(0x02D4, 0x0048, 2, 0x05F0, 0, 0),
+	MX6_PAD_JTAG_TMS__CCM_CLKO1                           = IOMUX_PAD(0x02D4, 0x0048, 3, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__CCM_WAIT                            = IOMUX_PAD(0x02D4, 0x0048, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__GPIO1_IO11                          = IOMUX_PAD(0x02D4, 0x0048, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__SDMA_EXT_EVENT01                    = IOMUX_PAD(0x02D4, 0x0048, 6, 0x0614, 0, 0),
+	MX6_PAD_JTAG_TMS__EPIT1_OUT                           = IOMUX_PAD(0x02D4, 0x0048, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TDO__SJC_TDO                             = IOMUX_PAD(0x02D8, 0x004C, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__GPT2_CAPTURE2                       = IOMUX_PAD(0x02D8, 0x004C, 1, 0x059C, 0, 0),
+	MX6_PAD_JTAG_TDO__SAI2_TX_SYNC                        = IOMUX_PAD(0x02D8, 0x004C, 2, 0x05FC, 0, 0),
+	MX6_PAD_JTAG_TDO__CCM_CLKO2                           = IOMUX_PAD(0x02D8, 0x004C, 3, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__CCM_STOP                            = IOMUX_PAD(0x02D8, 0x004C, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__GPIO1_IO12                          = IOMUX_PAD(0x02D8, 0x004C, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__MQS_RIGHT                           = IOMUX_PAD(0x02D8, 0x004C, 6, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__EPIT2_OUT                           = IOMUX_PAD(0x02D8, 0x004C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TDI__SJC_TDI                             = IOMUX_PAD(0x02DC, 0x0050, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__GPT2_COMPARE1                       = IOMUX_PAD(0x02DC, 0x0050, 1, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__SAI2_TX_BCLK                        = IOMUX_PAD(0x02DC, 0x0050, 2, 0x05F8, 0, 0),
+	MX6_PAD_JTAG_TDI__PWM6_OUT                            = IOMUX_PAD(0x02DC, 0x0050, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__GPIO1_IO13                          = IOMUX_PAD(0x02DC, 0x0050, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__MQS_LEFT                            = IOMUX_PAD(0x02DC, 0x0050, 6, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__SIM1_POWER_FAIL                     = IOMUX_PAD(0x02DC, 0x0050, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TCK__SJC_TCK                             = IOMUX_PAD(0x02E0, 0x0054, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__GPT2_COMPARE2                       = IOMUX_PAD(0x02E0, 0x0054, 1, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__SAI2_RX_DATA                        = IOMUX_PAD(0x02E0, 0x0054, 2, 0x05F4, 0, 0),
+	MX6_PAD_JTAG_TCK__PWM7_OUT                            = IOMUX_PAD(0x02E0, 0x0054, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__GPIO1_IO14                          = IOMUX_PAD(0x02E0, 0x0054, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__SIM2_POWER_FAIL                     = IOMUX_PAD(0x02E0, 0x0054, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TRST_B__SJC_TRSTB                        = IOMUX_PAD(0x02E4, 0x0058, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__GPT2_COMPARE3                    = IOMUX_PAD(0x02E4, 0x0058, 1, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__SAI2_TX_DATA                     = IOMUX_PAD(0x02E4, 0x0058, 2, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__PWM8_OUT                         = IOMUX_PAD(0x02E4, 0x0058, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__GPIO1_IO15                       = IOMUX_PAD(0x02E4, 0x0058, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__CAAM_RNG_OSC_OBS                 = IOMUX_PAD(0x02E4, 0x0058, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO00__I2C2_SCL                          = IOMUX_PAD(0x02E8, 0x005C, IOMUX_CONFIG_SION | 0, 0x05AC, 1, 0),
+	MX6_PAD_GPIO1_IO00__GPT1_CAPTURE1                     = IOMUX_PAD(0x02E8, 0x005C, 1, 0x058C, 0, 0),
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID                    = IOMUX_PAD(0x02E8, 0x005C, 2, 0x04B8, 0, 0),
+	MX6_PAD_GPIO1_IO00__ENET1_REF_CLK1                    = IOMUX_PAD(0x02E8, 0x005C, 3, 0x0574, 0, 0),
+	MX6_PAD_GPIO1_IO00__MQS_RIGHT                         = IOMUX_PAD(0x02E8, 0x005C, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__GPIO1_IO00                        = IOMUX_PAD(0x02E8, 0x005C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__ENET1_1588_EVENT0_IN              = IOMUX_PAD(0x02E8, 0x005C, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__SRC_SYSTEM_RESET                  = IOMUX_PAD(0x02E8, 0x005C, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__WDOG3_WDOG_B                      = IOMUX_PAD(0x02E8, 0x005C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO01__I2C2_SDA                          = IOMUX_PAD(0x02EC, 0x0060, IOMUX_CONFIG_SION | 0, 0x05B0, 1, 0),
+	MX6_PAD_GPIO1_IO01__GPT1_COMPARE1                     = IOMUX_PAD(0x02EC, 0x0060, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__USB_OTG1_OC                       = IOMUX_PAD(0x02EC, 0x0060, 2, 0x0664, 0, 0),
+	MX6_PAD_GPIO1_IO01__ENET2_REF_CLK2                    = IOMUX_PAD(0x02EC, 0x0060, 3, 0x057C, 0, 0),
+	MX6_PAD_GPIO1_IO01__MQS_LEFT                          = IOMUX_PAD(0x02EC, 0x0060, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__GPIO1_IO01                        = IOMUX_PAD(0x02EC, 0x0060, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__ENET1_1588_EVENT0_OUT             = IOMUX_PAD(0x02EC, 0x0060, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__SRC_EARLY_RESET                   = IOMUX_PAD(0x02EC, 0x0060, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__WDOG1_WDOG_B                      = IOMUX_PAD(0x02EC, 0x0060, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO02__I2C1_SCL                          = IOMUX_PAD(0x02F0, 0x0064, IOMUX_CONFIG_SION | 0, 0x05A4, 0, 0),
+	MX6_PAD_GPIO1_IO02__GPT1_COMPARE2                     = IOMUX_PAD(0x02F0, 0x0064, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__USB_OTG2_PWR                      = IOMUX_PAD(0x02F0, 0x0064, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__ENET1_REF_CLK_25M                 = IOMUX_PAD(0x02F0, 0x0064, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__USDHC1_WP                         = IOMUX_PAD(0x02F0, 0x0064, 4, 0x066C, 0, 0),
+	MX6_PAD_GPIO1_IO02__GPIO1_IO02                        = IOMUX_PAD(0x02F0, 0x0064, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__SDMA_EXT_EVENT00                  = IOMUX_PAD(0x02F0, 0x0064, 6, 0x0610, 1, 0),
+	MX6_PAD_GPIO1_IO02__SRC_ANY_PU_RESET                  = IOMUX_PAD(0x02F0, 0x0064, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__UART1_DCE_TX                      = IOMUX_PAD(0x02F0, 0x0064, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__UART1_DTE_RX                      = IOMUX_PAD(0x02F0, 0x0064, 8, 0x0624, 0, 0),
+
+	MX6_PAD_GPIO1_IO03__I2C1_SDA                          = IOMUX_PAD(0x02F4, 0x0068, IOMUX_CONFIG_SION | 0, 0x05A8, 1, 0),
+	MX6_PAD_GPIO1_IO03__GPT1_COMPARE3                     = IOMUX_PAD(0x02F4, 0x0068, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__USB_OTG2_OC                       = IOMUX_PAD(0x02F4, 0x0068, 2, 0x0660, 0, 0),
+	MX6_PAD_GPIO1_IO03__USDHC1_CD_B                       = IOMUX_PAD(0x02F4, 0x0068, 4, 0x0668, 0, 0),
+	MX6_PAD_GPIO1_IO03__GPIO1_IO03                        = IOMUX_PAD(0x02F4, 0x0068, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__CCM_DI0_EXT_CLK                   = IOMUX_PAD(0x02F4, 0x0068, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__SRC_TESTER_ACK                    = IOMUX_PAD(0x02F4, 0x0068, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__UART1_DCE_RX                      = IOMUX_PAD(0x02F4, 0x0068, 8, 0x0624, 1, 0),
+	MX6_PAD_GPIO1_IO03__UART1_DTE_TX                      = IOMUX_PAD(0x02F4, 0x0068, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO04__ENET1_REF_CLK1                    = IOMUX_PAD(0x02F8, 0x006C, 0, 0x0574, 1, 0),
+	MX6_PAD_GPIO1_IO04__PWM3_OUT                          = IOMUX_PAD(0x02F8, 0x006C, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__USB_OTG1_PWR                      = IOMUX_PAD(0x02F8, 0x006C, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__USDHC1_RESET_B                    = IOMUX_PAD(0x02F8, 0x006C, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__GPIO1_IO04                        = IOMUX_PAD(0x02F8, 0x006C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__ENET2_1588_EVENT0_IN              = IOMUX_PAD(0x02F8, 0x006C, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__UART5_DCE_TX                      = IOMUX_PAD(0x02F8, 0x006C, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__UART5_DTE_RX                      = IOMUX_PAD(0x02F8, 0x006C, 8, 0x0644, 2, 0),
+
+	MX6_PAD_GPIO1_IO05__ENET2_REF_CLK2                    = IOMUX_PAD(0x02FC, 0x0070, 0, 0x057C, 1, 0),
+	MX6_PAD_GPIO1_IO05__PWM4_OUT                          = IOMUX_PAD(0x02FC, 0x0070, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__ANATOP_OTG2_ID                    = IOMUX_PAD(0x02FC, 0x0070, 2, 0x04BC, 0, 0),
+	MX6_PAD_GPIO1_IO05__CSI_FIELD                         = IOMUX_PAD(0x02FC, 0x0070, 3, 0x0530, 0, 0),
+	MX6_PAD_GPIO1_IO05__USDHC1_VSELECT                    = IOMUX_PAD(0x02FC, 0x0070, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__GPIO1_IO05                        = IOMUX_PAD(0x02FC, 0x0070, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__ENET2_1588_EVENT0_OUT             = IOMUX_PAD(0x02FC, 0x0070, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__UART5_DCE_RX                      = IOMUX_PAD(0x02FC, 0x0070, 8, 0x0644, 3, 0),
+	MX6_PAD_GPIO1_IO05__UART5_DTE_TX                      = IOMUX_PAD(0x02FC, 0x0070, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO06__ENET1_MDIO                        = IOMUX_PAD(0x0300, 0x0074, 0, 0x0578, 0, 0),
+	MX6_PAD_GPIO1_IO06__ENET2_MDIO                        = IOMUX_PAD(0x0300, 0x0074, 1, 0x0580, 0, 0),
+	MX6_PAD_GPIO1_IO06__USB_OTG_PWR_WAKE                  = IOMUX_PAD(0x0300, 0x0074, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__CSI_MCLK                          = IOMUX_PAD(0x0300, 0x0074, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__USDHC2_WP                         = IOMUX_PAD(0x0300, 0x0074, 4, 0x069C, 0, 0),
+	MX6_PAD_GPIO1_IO06__GPIO1_IO06                        = IOMUX_PAD(0x0300, 0x0074, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__CCM_WAIT                          = IOMUX_PAD(0x0300, 0x0074, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__CCM_REF_EN_B                      = IOMUX_PAD(0x0300, 0x0074, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__UART1_DCE_CTS                     = IOMUX_PAD(0x0300, 0x0074, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__UART1_DTE_RTS                     = IOMUX_PAD(0x0300, 0x0074, 8, 0x0620, 0, 0),
+
+	MX6_PAD_GPIO1_IO07__ENET1_MDC                         = IOMUX_PAD(0x0304, 0x0078, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__ENET2_MDC                         = IOMUX_PAD(0x0304, 0x0078, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__USB_OTG_HOST_MODE                 = IOMUX_PAD(0x0304, 0x0078, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__CSI_PIXCLK                        = IOMUX_PAD(0x0304, 0x0078, 3, 0x0528, 0, 0),
+	MX6_PAD_GPIO1_IO07__USDHC2_CD_B                       = IOMUX_PAD(0x0304, 0x0078, 4, 0x0674, 1, 0),
+	MX6_PAD_GPIO1_IO07__GPIO1_IO07                        = IOMUX_PAD(0x0304, 0x0078, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__CCM_STOP                          = IOMUX_PAD(0x0304, 0x0078, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__UART1_DCE_RTS                     = IOMUX_PAD(0x0304, 0x0078, 8, 0x0620, 1, 0),
+	MX6_PAD_GPIO1_IO07__UART1_DTE_CTS                     = IOMUX_PAD(0x0304, 0x0078, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO08__PWM1_OUT                          = IOMUX_PAD(0x0308, 0x007C, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__WDOG1_WDOG_B                      = IOMUX_PAD(0x0308, 0x007C, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__SPDIF_OUT                         = IOMUX_PAD(0x0308, 0x007C, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__CSI_VSYNC                         = IOMUX_PAD(0x0308, 0x007C, 3, 0x052C, 1, 0),
+	MX6_PAD_GPIO1_IO08__USDHC2_VSELECT                    = IOMUX_PAD(0x0308, 0x007C, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__GPIO1_IO08                        = IOMUX_PAD(0x0308, 0x007C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__CCM_PMIC_RDY                      = IOMUX_PAD(0x0308, 0x007C, 6, 0x04C0, 1, 0),
+	MX6_PAD_GPIO1_IO08__UART5_DCE_RTS                     = IOMUX_PAD(0x0308, 0x007C, 8, 0x0640, 1, 0),
+	MX6_PAD_GPIO1_IO08__UART5_DTE_CTS                     = IOMUX_PAD(0x0308, 0x007C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO09__PWM2_OUT                          = IOMUX_PAD(0x030C, 0x0080, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__WDOG1_WDOG_ANY                    = IOMUX_PAD(0x030C, 0x0080, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__SPDIF_IN                          = IOMUX_PAD(0x030C, 0x0080, 2, 0x0618, 0, 0),
+	MX6_PAD_GPIO1_IO09__CSI_HSYNC                         = IOMUX_PAD(0x030C, 0x0080, 3, 0x0524, 1, 0),
+	MX6_PAD_GPIO1_IO09__USDHC2_RESET_B                    = IOMUX_PAD(0x030C, 0x0080, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09                        = IOMUX_PAD(0x030C, 0x0080, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__USDHC1_RESET_B                    = IOMUX_PAD(0x030C, 0x0080, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__UART5_DCE_CTS                     = IOMUX_PAD(0x030C, 0x0080, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__UART5_DTE_RTS                     = IOMUX_PAD(0x030C, 0x0080, 8, 0x0640, 2, 0),
+
+	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX                   = IOMUX_PAD(0x0310, 0x0084, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_TX_DATA__UART1_DTE_RX                   = IOMUX_PAD(0x0310, 0x0084, 0, 0x0624, 2, 0),
+	MX6_PAD_UART1_TX_DATA__ENET1_RDATA02                  = IOMUX_PAD(0x0310, 0x0084, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_TX_DATA__I2C3_SCL                       = IOMUX_PAD(0x0310, 0x0084, IOMUX_CONFIG_SION | 2, 0x05B4, 0, 0),
+	MX6_PAD_UART1_TX_DATA__CSI_DATA02                     = IOMUX_PAD(0x0310, 0x0084, 3, 0x04C4, 1, 0),
+	MX6_PAD_UART1_TX_DATA__GPT1_COMPARE1                  = IOMUX_PAD(0x0310, 0x0084, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_TX_DATA__GPIO1_IO16                     = IOMUX_PAD(0x0310, 0x0084, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_TX_DATA__SPDIF_OUT                      = IOMUX_PAD(0x0310, 0x0084, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX                   = IOMUX_PAD(0x0314, 0x0088, 0, 0x0624, 3, 0),
+
+	MX6_PAD_UART1_RX_DATA__UART1_DTE_TX                   = IOMUX_PAD(0x0314, 0x0088, 0, 0x0000, 0, 0),
+	MX6_PAD_UART1_RX_DATA__ENET1_RDATA03                  = IOMUX_PAD(0x0314, 0x0088, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_RX_DATA__I2C3_SDA                       = IOMUX_PAD(0x0314, 0x0088, IOMUX_CONFIG_SION | 2, 0x05B8, 0, 0),
+	MX6_PAD_UART1_RX_DATA__CSI_DATA03                     = IOMUX_PAD(0x0314, 0x0088, 3, 0x04C8, 1, 0),
+	MX6_PAD_UART1_RX_DATA__GPT1_CLK                       = IOMUX_PAD(0x0314, 0x0088, 4, 0x0594, 0, 0),
+	MX6_PAD_UART1_RX_DATA__GPIO1_IO17                     = IOMUX_PAD(0x0314, 0x0088, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_RX_DATA__SPDIF_IN                       = IOMUX_PAD(0x0314, 0x0088, 8, 0x0618, 1, 0),
+
+	MX6_PAD_UART1_CTS_B__UART1_DCE_CTS                    = IOMUX_PAD(0x0318, 0x008C, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_CTS_B__UART1_DTE_RTS                    = IOMUX_PAD(0x0318, 0x008C, 0, 0x0620, 2, 0),
+	MX6_PAD_UART1_CTS_B__ENET1_RX_CLK                     = IOMUX_PAD(0x0318, 0x008C, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_CTS_B__USDHC1_WP                        = IOMUX_PAD(0x0318, 0x008C, 2, 0x066C, 1, 0),
+	MX6_PAD_UART1_CTS_B__CSI_DATA04                       = IOMUX_PAD(0x0318, 0x008C, 3, 0x04D8, 0, 0),
+	MX6_PAD_UART1_CTS_B__ENET2_1588_EVENT1_IN             = IOMUX_PAD(0x0318, 0x008C, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_CTS_B__GPIO1_IO18                       = IOMUX_PAD(0x0318, 0x008C, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_CTS_B__USDHC2_WP                        = IOMUX_PAD(0x0318, 0x008C, 8, 0x069C, 1, 0),
+
+	MX6_PAD_UART1_RTS_B__UART1_DCE_RTS                    = IOMUX_PAD(0x031C, 0x0090, 0, 0x0620, 3, 0),
+
+	MX6_PAD_UART1_RTS_B__UART1_DTE_CTS                    = IOMUX_PAD(0x031C, 0x0090, 0, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__ENET1_TX_ER                      = IOMUX_PAD(0x031C, 0x0090, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__USDHC1_CD_B                      = IOMUX_PAD(0x031C, 0x0090, 2, 0x0668, 1, 0),
+	MX6_PAD_UART1_RTS_B__CSI_DATA05                       = IOMUX_PAD(0x031C, 0x0090, 3, 0x04CC, 1, 0),
+	MX6_PAD_UART1_RTS_B__ENET2_1588_EVENT1_OUT            = IOMUX_PAD(0x031C, 0x0090, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__GPIO1_IO19                       = IOMUX_PAD(0x031C, 0x0090, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__USDHC2_CD_B                      = IOMUX_PAD(0x031C, 0x0090, 8, 0x0674, 2, 0),
+
+	MX6_PAD_UART2_TX_DATA__UART2_DCE_TX                   = IOMUX_PAD(0x0320, 0x0094, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART2_TX_DATA__UART2_DTE_RX                   = IOMUX_PAD(0x0320, 0x0094, 0, 0x062C, 0, 0),
+	MX6_PAD_UART2_TX_DATA__ENET1_TDATA02                  = IOMUX_PAD(0x0320, 0x0094, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_TX_DATA__I2C4_SCL                       = IOMUX_PAD(0x0320, 0x0094, IOMUX_CONFIG_SION | 2, 0x05BC, 0, 0),
+	MX6_PAD_UART2_TX_DATA__CSI_DATA06                     = IOMUX_PAD(0x0320, 0x0094, 3, 0x04DC, 0, 0),
+	MX6_PAD_UART2_TX_DATA__GPT1_CAPTURE1                  = IOMUX_PAD(0x0320, 0x0094, 4, 0x058C, 1, 0),
+	MX6_PAD_UART2_TX_DATA__GPIO1_IO20                     = IOMUX_PAD(0x0320, 0x0094, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_TX_DATA__ECSPI3_SS0                     = IOMUX_PAD(0x0320, 0x0094, 8, 0x0560, 0, 0),
+
+	MX6_PAD_UART2_RX_DATA__UART2_DCE_RX                   = IOMUX_PAD(0x0324, 0x0098, 0, 0x062C, 1, 0),
+
+	MX6_PAD_UART2_RX_DATA__UART2_DTE_TX                   = IOMUX_PAD(0x0324, 0x0098, 0, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__ENET1_TDATA03                  = IOMUX_PAD(0x0324, 0x0098, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__I2C4_SDA                       = IOMUX_PAD(0x0324, 0x0098, IOMUX_CONFIG_SION | 2, 0x05C0, 0, 0),
+	MX6_PAD_UART2_RX_DATA__CSI_DATA07                     = IOMUX_PAD(0x0324, 0x0098, 3, 0x04E0, 0, 0),
+	MX6_PAD_UART2_RX_DATA__GPT1_CAPTURE2                  = IOMUX_PAD(0x0324, 0x0098, 4, 0x0590, 0, 0),
+	MX6_PAD_UART2_RX_DATA__GPIO1_IO21                     = IOMUX_PAD(0x0324, 0x0098, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__SJC_DONE                       = IOMUX_PAD(0x0324, 0x0098, 7, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__ECSPI3_SCLK                    = IOMUX_PAD(0x0324, 0x0098, 8, 0x0554, 0, 0),
+
+	MX6_PAD_UART2_CTS_B__UART2_DCE_CTS                    = IOMUX_PAD(0x0328, 0x009C, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART2_CTS_B__UART2_DTE_RTS                    = IOMUX_PAD(0x0328, 0x009C, 0, 0x0628, 0, 0),
+	MX6_PAD_UART2_CTS_B__ENET1_CRS                        = IOMUX_PAD(0x0328, 0x009C, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__FLEXCAN2_TX                      = IOMUX_PAD(0x0328, 0x009C, 2, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__CSI_DATA08                       = IOMUX_PAD(0x0328, 0x009C, 3, 0x04E4, 0, 0),
+	MX6_PAD_UART2_CTS_B__GPT1_COMPARE2                    = IOMUX_PAD(0x0328, 0x009C, 4, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__GPIO1_IO22                       = IOMUX_PAD(0x0328, 0x009C, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__SJC_DE_B                         = IOMUX_PAD(0x0328, 0x009C, 7, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__ECSPI3_MOSI                      = IOMUX_PAD(0x0328, 0x009C, 8, 0x055C, 0, 0),
+
+	MX6_PAD_UART2_RTS_B__UART2_DCE_RTS                    = IOMUX_PAD(0x032C, 0x00A0, 0, 0x0628, 1, 0),
+
+	MX6_PAD_UART2_RTS_B__UART2_DTE_CTS                    = IOMUX_PAD(0x032C, 0x00A0, 0, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__ENET1_COL                        = IOMUX_PAD(0x032C, 0x00A0, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__FLEXCAN2_RX                      = IOMUX_PAD(0x032C, 0x00A0, 2, 0x0588, 0, 0),
+	MX6_PAD_UART2_RTS_B__CSI_DATA09                       = IOMUX_PAD(0x032C, 0x00A0, 3, 0x04E8, 0, 0),
+	MX6_PAD_UART2_RTS_B__GPT1_COMPARE3                    = IOMUX_PAD(0x032C, 0x00A0, 4, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__GPIO1_IO23                       = IOMUX_PAD(0x032C, 0x00A0, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__SJC_FAIL                         = IOMUX_PAD(0x032C, 0x00A0, 7, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__ECSPI3_MISO                      = IOMUX_PAD(0x032C, 0x00A0, 8, 0x0558, 0, 0),
+
+	MX6_PAD_UART3_TX_DATA__UART3_DCE_TX                   = IOMUX_PAD(0x0330, 0x00A4, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_TX_DATA__UART3_DTE_RX                   = IOMUX_PAD(0x0330, 0x00A4, 0, 0x0634, 0, 0),
+	MX6_PAD_UART3_TX_DATA__ENET2_RDATA02                  = IOMUX_PAD(0x0330, 0x00A4, 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__SIM1_PORT0_PD                  = IOMUX_PAD(0x0330, 0x00A4, 2, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__CSI_DATA01                     = IOMUX_PAD(0x0330, 0x00A4, 3, 0x04D4, 0, 0),
+	MX6_PAD_UART3_TX_DATA__UART2_DCE_CTS                  = IOMUX_PAD(0x0330, 0x00A4, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__UART2_DTE_RTS                  = IOMUX_PAD(0x0330, 0x00A4, 4, 0x0628, 2, 0),
+	MX6_PAD_UART3_TX_DATA__GPIO1_IO24                     = IOMUX_PAD(0x0330, 0x00A4, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__SJC_JTAG_ACT                   = IOMUX_PAD(0x0330, 0x00A4, 7, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__ANATOP_OTG1_ID                 = IOMUX_PAD(0x0330, 0x00A4, 8, 0x04B8, 1, 0),
+
+	MX6_PAD_UART3_RX_DATA__UART3_DCE_RX                   = IOMUX_PAD(0x0334, 0x00A8, 0, 0x0634, 1, 0),
+
+	MX6_PAD_UART3_RX_DATA__UART3_DTE_TX                   = IOMUX_PAD(0x0334, 0x00A8, 0, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__ENET2_RDATA03                  = IOMUX_PAD(0x0334, 0x00A8, 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__SIM2_PORT0_PD                  = IOMUX_PAD(0x0334, 0x00A8, 2, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__CSI_DATA00                     = IOMUX_PAD(0x0334, 0x00A8, 3, 0x04D0, 0, 0),
+	MX6_PAD_UART3_RX_DATA__UART2_DCE_RTS                  = IOMUX_PAD(0x0334, 0x00A8, 4, 0x0628, 3, 0),
+	MX6_PAD_UART3_RX_DATA__UART2_DTE_CTS                  = IOMUX_PAD(0x0334, 0x00A8, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__GPIO1_IO25                     = IOMUX_PAD(0x0334, 0x00A8, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__EPIT1_OUT                      = IOMUX_PAD(0x0334, 0x00A8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_CTS_B__UART3_DCE_CTS                    = IOMUX_PAD(0x0338, 0x00AC, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_CTS_B__UART3_DTE_RTS                    = IOMUX_PAD(0x0338, 0x00AC, 0, 0x0630, 0, 0),
+	MX6_PAD_UART3_CTS_B__ENET2_RX_CLK                     = IOMUX_PAD(0x0338, 0x00AC, IOMUX_CONFIG_SION | 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__FLEXCAN1_TX                      = IOMUX_PAD(0x0338, 0x00AC, 2, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__CSI_DATA10                       = IOMUX_PAD(0x0338, 0x00AC, 3, 0x04EC, 0, 0),
+	MX6_PAD_UART3_CTS_B__ENET1_1588_EVENT1_IN             = IOMUX_PAD(0x0338, 0x00AC, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__GPIO1_IO26                       = IOMUX_PAD(0x0338, 0x00AC, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__EPIT2_OUT                        = IOMUX_PAD(0x0338, 0x00AC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_RTS_B__UART3_DCE_RTS                    = IOMUX_PAD(0x033C, 0x00B0, 0, 0x0630, 1, 0),
+
+	MX6_PAD_UART3_RTS_B__UART3_DTE_CTS                    = IOMUX_PAD(0x033C, 0x00B0, 0, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__ENET2_TX_ER                      = IOMUX_PAD(0x033C, 0x00B0, 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__FLEXCAN1_RX                      = IOMUX_PAD(0x033C, 0x00B0, 2, 0x0584, 0, 0),
+	MX6_PAD_UART3_RTS_B__CSI_DATA11                       = IOMUX_PAD(0x033C, 0x00B0, 3, 0x04F0, 0, 0),
+	MX6_PAD_UART3_RTS_B__ENET1_1588_EVENT1_OUT            = IOMUX_PAD(0x033C, 0x00B0, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__GPIO1_IO27                       = IOMUX_PAD(0x033C, 0x00B0, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__WDOG1_WDOG_B                     = IOMUX_PAD(0x033C, 0x00B0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART4_TX_DATA__UART4_DCE_TX                   = IOMUX_PAD(0x0340, 0x00B4, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART4_TX_DATA__UART4_DTE_RX                   = IOMUX_PAD(0x0340, 0x00B4, 0, 0x063C, 0, 0),
+	MX6_PAD_UART4_TX_DATA__ENET2_TDATA02                  = IOMUX_PAD(0x0340, 0x00B4, 1, 0x0000, 0, 0),
+	MX6_PAD_UART4_TX_DATA__I2C1_SCL                       = IOMUX_PAD(0x0340, 0x00B4, IOMUX_CONFIG_SION | 2, 0x05A4, 1, 0),
+	MX6_PAD_UART4_TX_DATA__CSI_DATA12                     = IOMUX_PAD(0x0340, 0x00B4, 3, 0x04F4, 0, 0),
+	MX6_PAD_UART4_TX_DATA__CSU_CSU_ALARM_AUT02            = IOMUX_PAD(0x0340, 0x00B4, 4, 0x0000, 0, 0),
+	MX6_PAD_UART4_TX_DATA__GPIO1_IO28                     = IOMUX_PAD(0x0340, 0x00B4, 5, 0x0000, 0, 0),
+	MX6_PAD_UART4_TX_DATA__ECSPI2_SCLK                    = IOMUX_PAD(0x0340, 0x00B4, 8, 0x0544, 1, 0),
+
+	MX6_PAD_UART4_RX_DATA__UART4_DCE_RX                   = IOMUX_PAD(0x0344, 0x00B8, 0, 0x063C, 1, 0),
+
+	MX6_PAD_UART4_RX_DATA__UART4_DTE_TX                   = IOMUX_PAD(0x0344, 0x00B8, 0, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__ENET2_TDATA03                  = IOMUX_PAD(0x0344, 0x00B8, 1, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__I2C1_SDA                       = IOMUX_PAD(0x0344, 0x00B8, IOMUX_CONFIG_SION | 2, 0x05A8, 2, 0),
+	MX6_PAD_UART4_RX_DATA__CSI_DATA13                     = IOMUX_PAD(0x0344, 0x00B8, 3, 0x04F8, 0, 0),
+	MX6_PAD_UART4_RX_DATA__CSU_CSU_ALARM_AUT01            = IOMUX_PAD(0x0344, 0x00B8, 4, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__GPIO1_IO29                     = IOMUX_PAD(0x0344, 0x00B8, 5, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__ECSPI2_SS0                     = IOMUX_PAD(0x0344, 0x00B8, 8, 0x0550, 1, 0),
+	MX6_PAD_UART5_TX_DATA__GPIO1_IO30                     = IOMUX_PAD(0x0348, 0x00BC, 5, 0x0000, 0, 0),
+	MX6_PAD_UART5_TX_DATA__ECSPI2_MOSI                    = IOMUX_PAD(0x0348, 0x00BC, 8, 0x054C, 0, 0),
+
+	MX6_PAD_UART5_TX_DATA__UART5_DCE_TX                   = IOMUX_PAD(0x0348, 0x00BC, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART5_TX_DATA__UART5_DTE_RX                   = IOMUX_PAD(0x0348, 0x00BC, 0, 0x0644, 4, 0),
+	MX6_PAD_UART5_TX_DATA__ENET2_CRS                      = IOMUX_PAD(0x0348, 0x00BC, 1, 0x0000, 0, 0),
+	MX6_PAD_UART5_TX_DATA__I2C2_SCL                       = IOMUX_PAD(0x0348, 0x00BC, IOMUX_CONFIG_SION | 2, 0x05AC, 2, 0),
+	MX6_PAD_UART5_TX_DATA__CSI_DATA14                     = IOMUX_PAD(0x0348, 0x00BC, 3, 0x04FC, 0, 0),
+	MX6_PAD_UART5_TX_DATA__CSU_CSU_ALARM_AUT00            = IOMUX_PAD(0x0348, 0x00BC, 4, 0x0000, 0, 0),
+
+	MX6_PAD_UART5_RX_DATA__UART5_DCE_RX                   = IOMUX_PAD(0x034C, 0x00C0, 0, 0x0644, 5, 0),
+
+	MX6_PAD_UART5_RX_DATA__UART5_DTE_TX                   = IOMUX_PAD(0x034C, 0x00C0, 0, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__ENET2_COL                      = IOMUX_PAD(0x034C, 0x00C0, 1, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__I2C2_SDA                       = IOMUX_PAD(0x034C, 0x00C0, IOMUX_CONFIG_SION | 2, 0x05B0, 2, 0),
+	MX6_PAD_UART5_RX_DATA__CSI_DATA15                     = IOMUX_PAD(0x034C, 0x00C0, 3, 0x0500, 0, 0),
+	MX6_PAD_UART5_RX_DATA__CSU_CSU_INT_DEB                = IOMUX_PAD(0x034C, 0x00C0, 4, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__GPIO1_IO31                     = IOMUX_PAD(0x034C, 0x00C0, 5, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__ECSPI2_MISO                    = IOMUX_PAD(0x034C, 0x00C0, 8, 0x0548, 1, 0),
+
+	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00                 = IOMUX_PAD(0x0350, 0x00C4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__UART4_DCE_RTS                 = IOMUX_PAD(0x0350, 0x00C4, 1, 0x0638, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__UART4_DTE_CTS                 = IOMUX_PAD(0x0350, 0x00C4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__PWM1_OUT                      = IOMUX_PAD(0x0350, 0x00C4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__CSI_DATA16                    = IOMUX_PAD(0x0350, 0x00C4, 3, 0x0504, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__FLEXCAN1_TX                   = IOMUX_PAD(0x0350, 0x00C4, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__GPIO2_IO00                    = IOMUX_PAD(0x0350, 0x00C4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__KPP_ROW00                     = IOMUX_PAD(0x0350, 0x00C4, 6, 0x05D0, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__USDHC1_LCTL                   = IOMUX_PAD(0x0350, 0x00C4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01                 = IOMUX_PAD(0x0354, 0x00C8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__UART4_DCE_CTS                 = IOMUX_PAD(0x0354, 0x00C8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__UART4_DTE_RTS                 = IOMUX_PAD(0x0354, 0x00C8, 1, 0x0638, 1, 0),
+	MX6_PAD_ENET1_RX_DATA1__PWM2_OUT                      = IOMUX_PAD(0x0354, 0x00C8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__CSI_DATA17                    = IOMUX_PAD(0x0354, 0x00C8, 3, 0x0508, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__FLEXCAN1_RX                   = IOMUX_PAD(0x0354, 0x00C8, 4, 0x0584, 1, 0),
+	MX6_PAD_ENET1_RX_DATA1__GPIO2_IO01                    = IOMUX_PAD(0x0354, 0x00C8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__KPP_COL00                     = IOMUX_PAD(0x0354, 0x00C8, 6, 0x05C4, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__USDHC2_LCTL                   = IOMUX_PAD(0x0354, 0x00C8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN                      = IOMUX_PAD(0x0358, 0x00CC, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__UART5_DCE_RTS                    = IOMUX_PAD(0x0358, 0x00CC, 1, 0x0640, 3, 0),
+	MX6_PAD_ENET1_RX_EN__UART5_DTE_CTS                    = IOMUX_PAD(0x0358, 0x00CC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__CSI_DATA18                       = IOMUX_PAD(0x0358, 0x00CC, 3, 0x050C, 0, 0),
+	MX6_PAD_ENET1_RX_EN__FLEXCAN2_TX                      = IOMUX_PAD(0x0358, 0x00CC, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__GPIO2_IO02                       = IOMUX_PAD(0x0358, 0x00CC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__KPP_ROW01                        = IOMUX_PAD(0x0358, 0x00CC, 6, 0x05D4, 0, 0),
+	MX6_PAD_ENET1_RX_EN__USDHC1_VSELECT                   = IOMUX_PAD(0x0358, 0x00CC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00                 = IOMUX_PAD(0x035C, 0x00D0, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__UART5_DCE_CTS                 = IOMUX_PAD(0x035C, 0x00D0, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__UART5_DTE_RTS                 = IOMUX_PAD(0x035C, 0x00D0, 1, 0x0640, 4, 0),
+	MX6_PAD_ENET1_TX_DATA0__CSI_DATA19                    = IOMUX_PAD(0x035C, 0x00D0, 3, 0x0510, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__FLEXCAN2_RX                   = IOMUX_PAD(0x035C, 0x00D0, 4, 0x0588, 1, 0),
+	MX6_PAD_ENET1_TX_DATA0__GPIO2_IO03                    = IOMUX_PAD(0x035C, 0x00D0, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__KPP_COL01                     = IOMUX_PAD(0x035C, 0x00D0, 6, 0x05C8, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__USDHC2_VSELECT                = IOMUX_PAD(0x035C, 0x00D0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01                 = IOMUX_PAD(0x0360, 0x00D4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__UART6_DCE_CTS                 = IOMUX_PAD(0x0360, 0x00D4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__UART6_DTE_RTS                 = IOMUX_PAD(0x0360, 0x00D4, 1, 0x0648, 2, 0),
+	MX6_PAD_ENET1_TX_DATA1__PWM5_OUT                      = IOMUX_PAD(0x0360, 0x00D4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__CSI_DATA20                    = IOMUX_PAD(0x0360, 0x00D4, 3, 0x0514, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__ENET2_MDIO                    = IOMUX_PAD(0x0360, 0x00D4, 4, 0x0580, 1, 0),
+	MX6_PAD_ENET1_TX_DATA1__GPIO2_IO04                    = IOMUX_PAD(0x0360, 0x00D4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__KPP_ROW02                     = IOMUX_PAD(0x0360, 0x00D4, 6, 0x05D8, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__WDOG1_WDOG_RST_B_DEB          = IOMUX_PAD(0x0360, 0x00D4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN                      = IOMUX_PAD(0x0364, 0x00D8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__UART6_DCE_RTS                    = IOMUX_PAD(0x0364, 0x00D8, 1, 0x0648, 3, 0),
+	MX6_PAD_ENET1_TX_EN__UART6_DTE_CTS                    = IOMUX_PAD(0x0364, 0x00D8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__PWM6_OUT                         = IOMUX_PAD(0x0364, 0x00D8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__CSI_DATA21                       = IOMUX_PAD(0x0364, 0x00D8, 3, 0x0518, 0, 0),
+	MX6_PAD_ENET1_TX_EN__ENET2_MDC                        = IOMUX_PAD(0x0364, 0x00D8, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__GPIO2_IO05                       = IOMUX_PAD(0x0364, 0x00D8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__KPP_COL02                        = IOMUX_PAD(0x0364, 0x00D8, 6, 0x05CC, 0, 0),
+	MX6_PAD_ENET1_TX_EN__WDOG2_WDOG_RST_B_DEB             = IOMUX_PAD(0x0364, 0x00D8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_CLK__ENET1_TX_CLK                    = IOMUX_PAD(0x0368, 0x00DC, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__UART7_DCE_CTS                   = IOMUX_PAD(0x0368, 0x00DC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__UART7_DTE_RTS                   = IOMUX_PAD(0x0368, 0x00DC, 1, 0x0650, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__PWM7_OUT                        = IOMUX_PAD(0x0368, 0x00DC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__CSI_DATA22                      = IOMUX_PAD(0x0368, 0x00DC, 3, 0x051C, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1                  = IOMUX_PAD(0x0368, 0x00DC, IOMUX_CONFIG_SION | 4, 0x0574, 2, 0),
+	MX6_PAD_ENET1_TX_CLK__GPIO2_IO06                      = IOMUX_PAD(0x0368, 0x00DC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__KPP_ROW03                       = IOMUX_PAD(0x0368, 0x00DC, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__GPT1_CLK                        = IOMUX_PAD(0x0368, 0x00DC, 8, 0x0594, 1, 0),
+
+	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER                      = IOMUX_PAD(0x036C, 0x00E0, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__UART7_DCE_RTS                    = IOMUX_PAD(0x036C, 0x00E0, 1, 0x0650, 1, 0),
+	MX6_PAD_ENET1_RX_ER__UART7_DTE_CTS                    = IOMUX_PAD(0x036C, 0x00E0, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__PWM8_OUT                         = IOMUX_PAD(0x036C, 0x00E0, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__CSI_DATA23                       = IOMUX_PAD(0x036C, 0x00E0, 3, 0x0520, 0, 0),
+	MX6_PAD_ENET1_RX_ER__EIM_CRE                          = IOMUX_PAD(0x036C, 0x00E0, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__GPIO2_IO07                       = IOMUX_PAD(0x036C, 0x00E0, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__KPP_COL03                        = IOMUX_PAD(0x036C, 0x00E0, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__GPT1_CAPTURE2                    = IOMUX_PAD(0x036C, 0x00E0, 8, 0x0590, 1, 0),
+
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00                 = IOMUX_PAD(0x0370, 0x00E4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__UART6_DCE_TX                  = IOMUX_PAD(0x0370, 0x00E4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__UART6_DTE_RX                  = IOMUX_PAD(0x0370, 0x00E4, 1, 0x064C, 1, 0),
+	MX6_PAD_ENET2_RX_DATA0__SIM1_PORT0_TRXD               = IOMUX_PAD(0x0370, 0x00E4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__I2C3_SCL                      = IOMUX_PAD(0x0370, 0x00E4, IOMUX_CONFIG_SION | 3, 0x05B4, 1, 0),
+	MX6_PAD_ENET2_RX_DATA0__ENET1_MDIO                    = IOMUX_PAD(0x0370, 0x00E4, 4, 0x0578, 1, 0),
+	MX6_PAD_ENET2_RX_DATA0__GPIO2_IO08                    = IOMUX_PAD(0x0370, 0x00E4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__KPP_ROW04                     = IOMUX_PAD(0x0370, 0x00E4, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__USB_OTG1_PWR                  = IOMUX_PAD(0x0370, 0x00E4, 8, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__EPDC_SDDO08                   = IOMUX_PAD(0x0370, 0x00E4, 9, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01                 = IOMUX_PAD(0x0374, 0x00E8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__UART6_DCE_RX                  = IOMUX_PAD(0x0374, 0x00E8, 1, 0x064C, 2, 0),
+	MX6_PAD_ENET2_RX_DATA1__UART6_DTE_TX                  = IOMUX_PAD(0x0374, 0x00E8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__SIM1_PORT0_CLK                = IOMUX_PAD(0x0374, 0x00E8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__I2C3_SDA                      = IOMUX_PAD(0x0374, 0x00E8, IOMUX_CONFIG_SION | 3, 0x05B8, 1, 0),
+	MX6_PAD_ENET2_RX_DATA1__ENET1_MDC                     = IOMUX_PAD(0x0374, 0x00E8, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__GPIO2_IO09                    = IOMUX_PAD(0x0374, 0x00E8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__KPP_COL04                     = IOMUX_PAD(0x0374, 0x00E8, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__USB_OTG1_OC                   = IOMUX_PAD(0x0374, 0x00E8, 8, 0x0664, 1, 0),
+	MX6_PAD_ENET2_RX_DATA1__EPDC_SDDO09                   = IOMUX_PAD(0x0374, 0x00E8, 9, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN                      = IOMUX_PAD(0x0378, 0x00EC, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__UART7_DCE_TX                     = IOMUX_PAD(0x0378, 0x00EC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__UART7_DTE_RX                     = IOMUX_PAD(0x0378, 0x00EC, 1, 0x0654, 0, 0),
+	MX6_PAD_ENET2_RX_EN__SIM1_PORT0_RST_B                 = IOMUX_PAD(0x0378, 0x00EC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__I2C4_SCL                         = IOMUX_PAD(0x0378, 0x00EC, IOMUX_CONFIG_SION | 3, 0x05BC, 1, 0),
+	MX6_PAD_ENET2_RX_EN__EIM_ADDR26                       = IOMUX_PAD(0x0378, 0x00EC, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__GPIO2_IO10                       = IOMUX_PAD(0x0378, 0x00EC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__KPP_ROW05                        = IOMUX_PAD(0x0378, 0x00EC, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__ENET1_REF_CLK_25M                = IOMUX_PAD(0x0378, 0x00EC, 8, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__EPDC_SDDO10                      = IOMUX_PAD(0x0378, 0x00EC, 9, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00                 = IOMUX_PAD(0x037C, 0x00F0, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__UART7_DCE_RX                  = IOMUX_PAD(0x037C, 0x00F0, 1, 0x0654, 1, 0),
+	MX6_PAD_ENET2_TX_DATA0__UART7_DTE_TX                  = IOMUX_PAD(0x037C, 0x00F0, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__SIM1_PORT0_SVEN               = IOMUX_PAD(0x037C, 0x00F0, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__I2C4_SDA                      = IOMUX_PAD(0x037C, 0x00F0, IOMUX_CONFIG_SION | 3, 0x05C0, 1, 0),
+	MX6_PAD_ENET2_TX_DATA0__EIM_EB_B02                    = IOMUX_PAD(0x037C, 0x00F0, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__GPIO2_IO11                    = IOMUX_PAD(0x037C, 0x00F0, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__KPP_COL05                     = IOMUX_PAD(0x037C, 0x00F0, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__EPDC_SDDO11                   = IOMUX_PAD(0x037C, 0x00F0, 9, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01                 = IOMUX_PAD(0x0380, 0x00F4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__UART8_DCE_TX                  = IOMUX_PAD(0x0380, 0x00F4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__UART8_DTE_RX                  = IOMUX_PAD(0x0380, 0x00F4, 1, 0x065C, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__SIM2_PORT0_TRXD               = IOMUX_PAD(0x0380, 0x00F4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__ECSPI4_SCLK                   = IOMUX_PAD(0x0380, 0x00F4, 3, 0x0564, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__EIM_EB_B03                    = IOMUX_PAD(0x0380, 0x00F4, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__GPIO2_IO12                    = IOMUX_PAD(0x0380, 0x00F4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__KPP_ROW06                     = IOMUX_PAD(0x0380, 0x00F4, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__USB_OTG2_PWR                  = IOMUX_PAD(0x0380, 0x00F4, 8, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__EPDC_SDDO12                   = IOMUX_PAD(0x0380, 0x00F4, 9, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN                      = IOMUX_PAD(0x0384, 0x00F8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__UART8_DCE_RX                     = IOMUX_PAD(0x0384, 0x00F8, 1, 0x065C, 1, 0),
+	MX6_PAD_ENET2_TX_EN__UART8_DTE_TX                     = IOMUX_PAD(0x0384, 0x00F8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__SIM2_PORT0_CLK                   = IOMUX_PAD(0x0384, 0x00F8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__ECSPI4_MOSI                      = IOMUX_PAD(0x0384, 0x00F8, 3, 0x056C, 0, 0),
+	MX6_PAD_ENET2_TX_EN__EIM_ACLK_FREERUN                 = IOMUX_PAD(0x0384, 0x00F8, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__GPIO2_IO13                       = IOMUX_PAD(0x0384, 0x00F8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__KPP_COL06                        = IOMUX_PAD(0x0384, 0x00F8, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__USB_OTG2_OC                      = IOMUX_PAD(0x0384, 0x00F8, 8, 0x0660, 1, 0),
+	MX6_PAD_ENET2_TX_EN__EPDC_SDDO13                      = IOMUX_PAD(0x0384, 0x00F8, 9, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_CLK__ENET2_TX_CLK                    = IOMUX_PAD(0x0388, 0x00FC, IOMUX_CONFIG_SION | 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__UART8_DCE_CTS                   = IOMUX_PAD(0x0388, 0x00FC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__UART8_DTE_RTS                   = IOMUX_PAD(0x0388, 0x00FC, 1, 0x0658, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__SIM2_PORT0_RST_B                = IOMUX_PAD(0x0388, 0x00FC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__ECSPI4_MISO                     = IOMUX_PAD(0x0388, 0x00FC, 3, 0x0568, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2                  = IOMUX_PAD(0x0388, 0x00FC, IOMUX_CONFIG_SION | 4, 0x057C, 2, 0),
+	MX6_PAD_ENET2_TX_CLK__GPIO2_IO14                      = IOMUX_PAD(0x0388, 0x00FC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__KPP_ROW07                       = IOMUX_PAD(0x0388, 0x00FC, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__ANATOP_OTG2_ID                  = IOMUX_PAD(0x0388, 0x00FC, 8, 0x04BC, 1, 0),
+	MX6_PAD_ENET2_TX_CLK__EPDC_SDDO14                     = IOMUX_PAD(0x0388, 0x00FC, 9, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER                      = IOMUX_PAD(0x038C, 0x0100, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__UART8_DCE_RTS                    = IOMUX_PAD(0x038C, 0x0100, 1, 0x0658, 1, 0),
+	MX6_PAD_ENET2_RX_ER__UART8_DTE_CTS                    = IOMUX_PAD(0x038C, 0x0100, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__SIM2_PORT0_SVEN                  = IOMUX_PAD(0x038C, 0x0100, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__ECSPI4_SS0                       = IOMUX_PAD(0x038C, 0x0100, 3, 0x0570, 0, 0),
+	MX6_PAD_ENET2_RX_ER__EIM_ADDR25                       = IOMUX_PAD(0x038C, 0x0100, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__GPIO2_IO15                       = IOMUX_PAD(0x038C, 0x0100, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__KPP_COL07                        = IOMUX_PAD(0x038C, 0x0100, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__WDOG1_WDOG_ANY                   = IOMUX_PAD(0x038C, 0x0100, 8, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__EPDC_SDDO15                      = IOMUX_PAD(0x038C, 0x0100, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_CLK__LCDIF_CLK                            = IOMUX_PAD(0x0390, 0x0104, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__LCDIF_WR_RWN                         = IOMUX_PAD(0x0390, 0x0104, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__UART4_DCE_TX                         = IOMUX_PAD(0x0390, 0x0104, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__UART4_DTE_RX                         = IOMUX_PAD(0x0390, 0x0104, 2, 0x063C, 2, 0),
+	MX6_PAD_LCD_CLK__SAI3_MCLK                            = IOMUX_PAD(0x0390, 0x0104, 3, 0x0600, 0, 0),
+	MX6_PAD_LCD_CLK__EIM_CS2_B                            = IOMUX_PAD(0x0390, 0x0104, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__GPIO3_IO00                           = IOMUX_PAD(0x0390, 0x0104, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__WDOG1_WDOG_RST_B_DEB                 = IOMUX_PAD(0x0390, 0x0104, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__EPDC_SDCLK                           = IOMUX_PAD(0x0390, 0x0104, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE                      = IOMUX_PAD(0x0394, 0x0108, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__LCDIF_RD_E                        = IOMUX_PAD(0x0394, 0x0108, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__UART4_DCE_RX                      = IOMUX_PAD(0x0394, 0x0108, 2, 0x063C, 3, 0),
+	MX6_PAD_LCD_ENABLE__UART4_DTE_TX                      = IOMUX_PAD(0x0394, 0x0108, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__SAI3_TX_SYNC                      = IOMUX_PAD(0x0394, 0x0108, 3, 0x060C, 0, 0),
+	MX6_PAD_LCD_ENABLE__EIM_CS3_B                         = IOMUX_PAD(0x0394, 0x0108, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__GPIO3_IO01                        = IOMUX_PAD(0x0394, 0x0108, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__ECSPI2_RDY                        = IOMUX_PAD(0x0394, 0x0108, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__EPDC_SDLE                         = IOMUX_PAD(0x0394, 0x0108, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC                        = IOMUX_PAD(0x0398, 0x010C, 0, 0x05DC, 0, 0),
+	MX6_PAD_LCD_HSYNC__LCDIF_RS                           = IOMUX_PAD(0x0398, 0x010C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__UART4_DCE_CTS                      = IOMUX_PAD(0x0398, 0x010C, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__UART4_DTE_RTS                      = IOMUX_PAD(0x0398, 0x010C, 2, 0x0638, 2, 0),
+	MX6_PAD_LCD_HSYNC__SAI3_TX_BCLK                       = IOMUX_PAD(0x0398, 0x010C, 3, 0x0608, 0, 0),
+	MX6_PAD_LCD_HSYNC__WDOG3_WDOG_RST_B_DEB               = IOMUX_PAD(0x0398, 0x010C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__GPIO3_IO02                         = IOMUX_PAD(0x0398, 0x010C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__ECSPI2_SS1                         = IOMUX_PAD(0x0398, 0x010C, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__EPDC_SDOE                          = IOMUX_PAD(0x0398, 0x010C, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC                        = IOMUX_PAD(0x039C, 0x0110, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__LCDIF_BUSY                         = IOMUX_PAD(0x039C, 0x0110, 1, 0x05DC, 1, 0),
+	MX6_PAD_LCD_VSYNC__UART4_DCE_RTS                      = IOMUX_PAD(0x039C, 0x0110, 2, 0x0638, 3, 0),
+	MX6_PAD_LCD_VSYNC__UART4_DTE_CTS                      = IOMUX_PAD(0x039C, 0x0110, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__SAI3_RX_DATA                       = IOMUX_PAD(0x039C, 0x0110, 3, 0x0604, 0, 0),
+	MX6_PAD_LCD_VSYNC__WDOG2_WDOG_B                       = IOMUX_PAD(0x039C, 0x0110, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__GPIO3_IO03                         = IOMUX_PAD(0x039C, 0x0110, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__ECSPI2_SS2                         = IOMUX_PAD(0x039C, 0x0110, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__EPDC_SDCE0                         = IOMUX_PAD(0x039C, 0x0110, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_RESET__LCDIF_RESET                        = IOMUX_PAD(0x03A0, 0x0114, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__LCDIF_CS                           = IOMUX_PAD(0x03A0, 0x0114, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__CA7_MX6ULL_EVENTI                  = IOMUX_PAD(0x03A0, 0x0114, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__SAI3_TX_DATA                       = IOMUX_PAD(0x03A0, 0x0114, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__WDOG1_WDOG_ANY                     = IOMUX_PAD(0x03A0, 0x0114, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__GPIO3_IO04                         = IOMUX_PAD(0x03A0, 0x0114, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__ECSPI2_SS3                         = IOMUX_PAD(0x03A0, 0x0114, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__EPDC_GDOE                          = IOMUX_PAD(0x03A0, 0x0114, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00                      = IOMUX_PAD(0x03A4, 0x0118, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__PWM1_OUT                          = IOMUX_PAD(0x03A4, 0x0118, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__ENET1_1588_EVENT2_IN              = IOMUX_PAD(0x03A4, 0x0118, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__I2C3_SDA                          = IOMUX_PAD(0x03A4, 0x0118, IOMUX_CONFIG_SION | 4, 0x05B8, 2, 0),
+	MX6_PAD_LCD_DATA00__GPIO3_IO05                        = IOMUX_PAD(0x03A4, 0x0118, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__SRC_BT_CFG00                      = IOMUX_PAD(0x03A4, 0x0118, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__SAI1_MCLK                         = IOMUX_PAD(0x03A4, 0x0118, 8, 0x05E0, 1, 0),
+	MX6_PAD_LCD_DATA00__EPDC_SDDO00                       = IOMUX_PAD(0x03A4, 0x0118, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01                      = IOMUX_PAD(0x03A8, 0x011C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__PWM2_OUT                          = IOMUX_PAD(0x03A8, 0x011C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__ENET1_1588_EVENT2_OUT             = IOMUX_PAD(0x03A8, 0x011C, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__I2C3_SCL                          = IOMUX_PAD(0x03A8, 0x011C, IOMUX_CONFIG_SION | 4, 0x05B4, 2, 0),
+	MX6_PAD_LCD_DATA01__GPIO3_IO06                        = IOMUX_PAD(0x03A8, 0x011C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__SRC_BT_CFG01                      = IOMUX_PAD(0x03A8, 0x011C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__SAI1_TX_SYNC                      = IOMUX_PAD(0x03A8, 0x011C, 8, 0x05EC, 0, 0),
+	MX6_PAD_LCD_DATA01__EPDC_SDDO01                       = IOMUX_PAD(0x03A8, 0x011C, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02                      = IOMUX_PAD(0x03AC, 0x0120, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__PWM3_OUT                          = IOMUX_PAD(0x03AC, 0x0120, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__ENET1_1588_EVENT3_IN              = IOMUX_PAD(0x03AC, 0x0120, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__I2C4_SDA                          = IOMUX_PAD(0x03AC, 0x0120, IOMUX_CONFIG_SION | 4, 0x05C0, 2, 0),
+	MX6_PAD_LCD_DATA02__GPIO3_IO07                        = IOMUX_PAD(0x03AC, 0x0120, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__SRC_BT_CFG02                      = IOMUX_PAD(0x03AC, 0x0120, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__SAI1_TX_BCLK                      = IOMUX_PAD(0x03AC, 0x0120, 8, 0x05E8, 0, 0),
+	MX6_PAD_LCD_DATA02__EPDC_SDDO02                       = IOMUX_PAD(0x03AC, 0x0120, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03                      = IOMUX_PAD(0x03B0, 0x0124, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__PWM4_OUT                          = IOMUX_PAD(0x03B0, 0x0124, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__ENET1_1588_EVENT3_OUT             = IOMUX_PAD(0x03B0, 0x0124, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__I2C4_SCL                          = IOMUX_PAD(0x03B0, 0x0124, IOMUX_CONFIG_SION | 4, 0x05BC, 2, 0),
+	MX6_PAD_LCD_DATA03__GPIO3_IO08                        = IOMUX_PAD(0x03B0, 0x0124, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__SRC_BT_CFG03                      = IOMUX_PAD(0x03B0, 0x0124, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__SAI1_RX_DATA                      = IOMUX_PAD(0x03B0, 0x0124, 8, 0x05E4, 0, 0),
+	MX6_PAD_LCD_DATA03__EPDC_SDDO03                       = IOMUX_PAD(0x03B0, 0x0124, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04                      = IOMUX_PAD(0x03B4, 0x0128, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__UART8_DCE_CTS                     = IOMUX_PAD(0x03B4, 0x0128, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__UART8_DTE_RTS                     = IOMUX_PAD(0x03B4, 0x0128, 1, 0x0658, 2, 0),
+	MX6_PAD_LCD_DATA04__ENET2_1588_EVENT2_IN              = IOMUX_PAD(0x03B4, 0x0128, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SPDIF_SR_CLK                      = IOMUX_PAD(0x03B4, 0x0128, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__GPIO3_IO09                        = IOMUX_PAD(0x03B4, 0x0128, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SRC_BT_CFG04                      = IOMUX_PAD(0x03B4, 0x0128, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SAI1_TX_DATA                      = IOMUX_PAD(0x03B4, 0x0128, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__EPDC_SDDO04                       = IOMUX_PAD(0x03B4, 0x0128, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05                      = IOMUX_PAD(0x03B8, 0x012C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__UART8_DCE_RTS                     = IOMUX_PAD(0x03B8, 0x012C, 1, 0x0658, 3, 0),
+	MX6_PAD_LCD_DATA05__UART8_DTE_CTS                     = IOMUX_PAD(0x03B8, 0x012C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__ENET2_1588_EVENT2_OUT             = IOMUX_PAD(0x03B8, 0x012C, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__SPDIF_OUT                         = IOMUX_PAD(0x03B8, 0x012C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__GPIO3_IO10                        = IOMUX_PAD(0x03B8, 0x012C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__SRC_BT_CFG05                      = IOMUX_PAD(0x03B8, 0x012C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__ECSPI1_SS1                        = IOMUX_PAD(0x03B8, 0x012C, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__EPDC_SDDO05                       = IOMUX_PAD(0x03B8, 0x012C, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06                      = IOMUX_PAD(0x03BC, 0x0130, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__UART7_DCE_CTS                     = IOMUX_PAD(0x03BC, 0x0130, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__UART7_DTE_RTS                     = IOMUX_PAD(0x03BC, 0x0130, 1, 0x0650, 2, 0),
+	MX6_PAD_LCD_DATA06__ENET2_1588_EVENT3_IN              = IOMUX_PAD(0x03BC, 0x0130, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__SPDIF_LOCK                        = IOMUX_PAD(0x03BC, 0x0130, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__GPIO3_IO11                        = IOMUX_PAD(0x03BC, 0x0130, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__SRC_BT_CFG06                      = IOMUX_PAD(0x03BC, 0x0130, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__ECSPI1_SS2                        = IOMUX_PAD(0x03BC, 0x0130, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__EPDC_SDDO06                       = IOMUX_PAD(0x03BC, 0x0130, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07                      = IOMUX_PAD(0x03C0, 0x0134, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__UART7_DCE_RTS                     = IOMUX_PAD(0x03C0, 0x0134, 1, 0x0650, 3, 0),
+	MX6_PAD_LCD_DATA07__UART7_DTE_CTS                     = IOMUX_PAD(0x03C0, 0x0134, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__ENET2_1588_EVENT3_OUT             = IOMUX_PAD(0x03C0, 0x0134, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__SPDIF_EXT_CLK                     = IOMUX_PAD(0x03C0, 0x0134, 4, 0x061C, 0, 0),
+	MX6_PAD_LCD_DATA07__GPIO3_IO12                        = IOMUX_PAD(0x03C0, 0x0134, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__SRC_BT_CFG07                      = IOMUX_PAD(0x03C0, 0x0134, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__ECSPI1_SS3                        = IOMUX_PAD(0x03C0, 0x0134, 8, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__EPDC_SDDO07                       = IOMUX_PAD(0x03C0, 0x0134, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08                      = IOMUX_PAD(0x03C4, 0x0138, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__SPDIF_IN                          = IOMUX_PAD(0x03C4, 0x0138, 1, 0x0618, 2, 0),
+	MX6_PAD_LCD_DATA08__CSI_DATA16                        = IOMUX_PAD(0x03C4, 0x0138, 3, 0x0504, 1, 0),
+	MX6_PAD_LCD_DATA08__EIM_DATA00                        = IOMUX_PAD(0x03C4, 0x0138, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__GPIO3_IO13                        = IOMUX_PAD(0x03C4, 0x0138, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__SRC_BT_CFG08                      = IOMUX_PAD(0x03C4, 0x0138, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__FLEXCAN1_TX                       = IOMUX_PAD(0x03C4, 0x0138, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09                      = IOMUX_PAD(0x03C8, 0x013C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__SAI3_MCLK                         = IOMUX_PAD(0x03C8, 0x013C, 1, 0x0600, 1, 0),
+	MX6_PAD_LCD_DATA09__CSI_DATA17                        = IOMUX_PAD(0x03C8, 0x013C, 3, 0x0508, 1, 0),
+	MX6_PAD_LCD_DATA09__EIM_DATA01                        = IOMUX_PAD(0x03C8, 0x013C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__GPIO3_IO14                        = IOMUX_PAD(0x03C8, 0x013C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__SRC_BT_CFG09                      = IOMUX_PAD(0x03C8, 0x013C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__FLEXCAN1_RX                       = IOMUX_PAD(0x03C8, 0x013C, 8, 0x0584, 2, 0),
+
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10                      = IOMUX_PAD(0x03CC, 0x0140, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__SAI3_RX_SYNC                      = IOMUX_PAD(0x03CC, 0x0140, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__CSI_DATA18                        = IOMUX_PAD(0x03CC, 0x0140, 3, 0x050C, 1, 0),
+	MX6_PAD_LCD_DATA10__EIM_DATA02                        = IOMUX_PAD(0x03CC, 0x0140, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__GPIO3_IO15                        = IOMUX_PAD(0x03CC, 0x0140, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__SRC_BT_CFG10                      = IOMUX_PAD(0x03CC, 0x0140, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__FLEXCAN2_TX                       = IOMUX_PAD(0x03CC, 0x0140, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11                      = IOMUX_PAD(0x03D0, 0x0144, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__SAI3_RX_BCLK                      = IOMUX_PAD(0x03D0, 0x0144, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__CSI_DATA19                        = IOMUX_PAD(0x03D0, 0x0144, 3, 0x0510, 1, 0),
+	MX6_PAD_LCD_DATA11__EIM_DATA03                        = IOMUX_PAD(0x03D0, 0x0144, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__GPIO3_IO16                        = IOMUX_PAD(0x03D0, 0x0144, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__SRC_BT_CFG11                      = IOMUX_PAD(0x03D0, 0x0144, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__FLEXCAN2_RX                       = IOMUX_PAD(0x03D0, 0x0144, 8, 0x0588, 2, 0),
+
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12                      = IOMUX_PAD(0x03D4, 0x0148, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__SAI3_TX_SYNC                      = IOMUX_PAD(0x03D4, 0x0148, 1, 0x060C, 1, 0),
+	MX6_PAD_LCD_DATA12__CSI_DATA20                        = IOMUX_PAD(0x03D4, 0x0148, 3, 0x0514, 1, 0),
+	MX6_PAD_LCD_DATA12__EIM_DATA04                        = IOMUX_PAD(0x03D4, 0x0148, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__GPIO3_IO17                        = IOMUX_PAD(0x03D4, 0x0148, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__SRC_BT_CFG12                      = IOMUX_PAD(0x03D4, 0x0148, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__ECSPI1_RDY                        = IOMUX_PAD(0x03D4, 0x0148, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13                      = IOMUX_PAD(0x03D8, 0x014C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__SAI3_TX_BCLK                      = IOMUX_PAD(0x03D8, 0x014C, 1, 0x0608, 1, 0),
+	MX6_PAD_LCD_DATA13__CSI_DATA21                        = IOMUX_PAD(0x03D8, 0x014C, 3, 0x0518, 1, 0),
+	MX6_PAD_LCD_DATA13__EIM_DATA05                        = IOMUX_PAD(0x03D8, 0x014C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__GPIO3_IO18                        = IOMUX_PAD(0x03D8, 0x014C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__SRC_BT_CFG13                      = IOMUX_PAD(0x03D8, 0x014C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__USDHC2_RESET_B                    = IOMUX_PAD(0x03D8, 0x014C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14                      = IOMUX_PAD(0x03DC, 0x0150, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__SAI3_RX_DATA                      = IOMUX_PAD(0x03DC, 0x0150, 1, 0x0604, 1, 0),
+	MX6_PAD_LCD_DATA14__CSI_DATA22                        = IOMUX_PAD(0x03DC, 0x0150, 3, 0x051C, 1, 0),
+	MX6_PAD_LCD_DATA14__EIM_DATA06                        = IOMUX_PAD(0x03DC, 0x0150, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__GPIO3_IO19                        = IOMUX_PAD(0x03DC, 0x0150, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__SRC_BT_CFG14                      = IOMUX_PAD(0x03DC, 0x0150, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__USDHC2_DATA4                      = IOMUX_PAD(0x03DC, 0x0150, 8, 0x068C, 0, 0),
+	MX6_PAD_LCD_DATA14__EPDC_SDSHR                        = IOMUX_PAD(0x03DC, 0x0150, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15                      = IOMUX_PAD(0x03E0, 0x0154, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__SAI3_TX_DATA                      = IOMUX_PAD(0x03E0, 0x0154, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__CSI_DATA23                        = IOMUX_PAD(0x03E0, 0x0154, 3, 0x0520, 1, 0),
+	MX6_PAD_LCD_DATA15__EIM_DATA07                        = IOMUX_PAD(0x03E0, 0x0154, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__GPIO3_IO20                        = IOMUX_PAD(0x03E0, 0x0154, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__SRC_BT_CFG15                      = IOMUX_PAD(0x03E0, 0x0154, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__USDHC2_DATA5                      = IOMUX_PAD(0x03E0, 0x0154, 8, 0x0690, 0, 0),
+	MX6_PAD_LCD_DATA15__EPDC_GDRL                         = IOMUX_PAD(0x03E0, 0x0154, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA16__LCDIF_DATA16                      = IOMUX_PAD(0x03E4, 0x0158, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__UART7_DCE_TX                      = IOMUX_PAD(0x03E4, 0x0158, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__UART7_DTE_RX                      = IOMUX_PAD(0x03E4, 0x0158, 1, 0x0654, 2, 0),
+	MX6_PAD_LCD_DATA16__CSI_DATA01                        = IOMUX_PAD(0x03E4, 0x0158, 3, 0x04D4, 1, 0),
+	MX6_PAD_LCD_DATA16__EIM_DATA08                        = IOMUX_PAD(0x03E4, 0x0158, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__GPIO3_IO21                        = IOMUX_PAD(0x03E4, 0x0158, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__SRC_BT_CFG24                      = IOMUX_PAD(0x03E4, 0x0158, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__USDHC2_DATA6                      = IOMUX_PAD(0x03E4, 0x0158, 8, 0x0694, 0, 0),
+	MX6_PAD_LCD_DATA16__EPDC_GDCLK                        = IOMUX_PAD(0x03E4, 0x0158, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA17__LCDIF_DATA17                      = IOMUX_PAD(0x03E8, 0x015C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__UART7_DCE_RX                      = IOMUX_PAD(0x03E8, 0x015C, 1, 0x0654, 3, 0),
+	MX6_PAD_LCD_DATA17__UART7_DTE_TX                      = IOMUX_PAD(0x03E8, 0x015C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__CSI_DATA00                        = IOMUX_PAD(0x03E8, 0x015C, 3, 0x04D0, 1, 0),
+	MX6_PAD_LCD_DATA17__EIM_DATA09                        = IOMUX_PAD(0x03E8, 0x015C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__GPIO3_IO22                        = IOMUX_PAD(0x03E8, 0x015C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__SRC_BT_CFG25                      = IOMUX_PAD(0x03E8, 0x015C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__USDHC2_DATA7                      = IOMUX_PAD(0x03E8, 0x015C, 8, 0x0698, 0, 0),
+	MX6_PAD_LCD_DATA17__EPDC_GDSP                         = IOMUX_PAD(0x03E8, 0x015C, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA18__LCDIF_DATA18                      = IOMUX_PAD(0x03EC, 0x0160, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__PWM5_OUT                          = IOMUX_PAD(0x03EC, 0x0160, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__CA7_MX6ULL_EVENTO                 = IOMUX_PAD(0x03EC, 0x0160, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__CSI_DATA10                        = IOMUX_PAD(0x03EC, 0x0160, 3, 0x04EC, 1, 0),
+	MX6_PAD_LCD_DATA18__EIM_DATA10                        = IOMUX_PAD(0x03EC, 0x0160, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__GPIO3_IO23                        = IOMUX_PAD(0x03EC, 0x0160, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__SRC_BT_CFG26                      = IOMUX_PAD(0x03EC, 0x0160, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__USDHC2_CMD                        = IOMUX_PAD(0x03EC, 0x0160, 8, 0x0678, 1, 0),
+	MX6_PAD_LCD_DATA19__EIM_DATA11                        = IOMUX_PAD(0x03F0, 0x0164, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__GPIO3_IO24                        = IOMUX_PAD(0x03F0, 0x0164, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__SRC_BT_CFG27                      = IOMUX_PAD(0x03F0, 0x0164, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__USDHC2_CLK                        = IOMUX_PAD(0x03F0, 0x0164, 8, 0x0670, 1, 0),
+
+	MX6_PAD_LCD_DATA19__LCDIF_DATA19                      = IOMUX_PAD(0x03F0, 0x0164, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__PWM6_OUT                          = IOMUX_PAD(0x03F0, 0x0164, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__WDOG1_WDOG_ANY                    = IOMUX_PAD(0x03F0, 0x0164, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__CSI_DATA11                        = IOMUX_PAD(0x03F0, 0x0164, 3, 0x04F0, 1, 0),
+	MX6_PAD_LCD_DATA20__EIM_DATA12                        = IOMUX_PAD(0x03F4, 0x0168, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__GPIO3_IO25                        = IOMUX_PAD(0x03F4, 0x0168, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__SRC_BT_CFG28                      = IOMUX_PAD(0x03F4, 0x0168, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__USDHC2_DATA0                      = IOMUX_PAD(0x03F4, 0x0168, 8, 0x067C, 1, 0),
+
+	MX6_PAD_LCD_DATA20__LCDIF_DATA20                      = IOMUX_PAD(0x03F4, 0x0168, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__UART8_DCE_TX                      = IOMUX_PAD(0x03F4, 0x0168, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__UART8_DTE_RX                      = IOMUX_PAD(0x03F4, 0x0168, 1, 0x065C, 2, 0),
+	MX6_PAD_LCD_DATA20__ECSPI1_SCLK                       = IOMUX_PAD(0x03F4, 0x0168, 2, 0x0534, 0, 0),
+	MX6_PAD_LCD_DATA20__CSI_DATA12                        = IOMUX_PAD(0x03F4, 0x0168, 3, 0x04F4, 1, 0),
+
+	MX6_PAD_LCD_DATA21__LCDIF_DATA21                      = IOMUX_PAD(0x03F8, 0x016C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__UART8_DCE_RX                      = IOMUX_PAD(0x03F8, 0x016C, 1, 0x065C, 3, 0),
+	MX6_PAD_LCD_DATA21__UART8_DTE_TX                      = IOMUX_PAD(0x03F8, 0x016C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__ECSPI1_SS0                        = IOMUX_PAD(0x03F8, 0x016C, 2, 0x0540, 0, 0),
+	MX6_PAD_LCD_DATA21__CSI_DATA13                        = IOMUX_PAD(0x03F8, 0x016C, 3, 0x04F8, 1, 0),
+	MX6_PAD_LCD_DATA21__EIM_DATA13                        = IOMUX_PAD(0x03F8, 0x016C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__GPIO3_IO26                        = IOMUX_PAD(0x03F8, 0x016C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__SRC_BT_CFG29                      = IOMUX_PAD(0x03F8, 0x016C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__USDHC2_DATA1                      = IOMUX_PAD(0x03F8, 0x016C, 8, 0x0680, 1, 0),
+	MX6_PAD_LCD_DATA21__EPDC_SDCE1                        = IOMUX_PAD(0x03F8, 0x016C, 9, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA22__LCDIF_DATA22                      = IOMUX_PAD(0x03FC, 0x0170, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__MQS_RIGHT                         = IOMUX_PAD(0x03FC, 0x0170, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__ECSPI1_MOSI                       = IOMUX_PAD(0x03FC, 0x0170, 2, 0x053C, 0, 0),
+	MX6_PAD_LCD_DATA22__CSI_DATA14                        = IOMUX_PAD(0x03FC, 0x0170, 3, 0x04FC, 1, 0),
+	MX6_PAD_LCD_DATA22__EIM_DATA14                        = IOMUX_PAD(0x03FC, 0x0170, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__GPIO3_IO27                        = IOMUX_PAD(0x03FC, 0x0170, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__SRC_BT_CFG30                      = IOMUX_PAD(0x03FC, 0x0170, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__USDHC2_DATA2                      = IOMUX_PAD(0x03FC, 0x0170, 8, 0x0684, 0, 0),
+
+	MX6_PAD_LCD_DATA23__LCDIF_DATA23                      = IOMUX_PAD(0x0400, 0x0174, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__MQS_LEFT                          = IOMUX_PAD(0x0400, 0x0174, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__ECSPI1_MISO                       = IOMUX_PAD(0x0400, 0x0174, 2, 0x0538, 0, 0),
+	MX6_PAD_LCD_DATA23__CSI_DATA15                        = IOMUX_PAD(0x0400, 0x0174, 3, 0x0500, 1, 0),
+	MX6_PAD_LCD_DATA23__EIM_DATA15                        = IOMUX_PAD(0x0400, 0x0174, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__GPIO3_IO28                        = IOMUX_PAD(0x0400, 0x0174, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__SRC_BT_CFG31                      = IOMUX_PAD(0x0400, 0x0174, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__USDHC2_DATA3                      = IOMUX_PAD(0x0400, 0x0174, 8, 0x0688, 1, 0),
+
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B                       = IOMUX_PAD(0x0404, 0x0178, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__USDHC2_CLK                         = IOMUX_PAD(0x0404, 0x0178, 1, 0x0670, 2, 0),
+	MX6_PAD_NAND_RE_B__QSPI_B_SCLK                        = IOMUX_PAD(0x0404, 0x0178, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__KPP_ROW00                          = IOMUX_PAD(0x0404, 0x0178, 3, 0x05D0, 1, 0),
+	MX6_PAD_NAND_RE_B__EIM_EB_B00                         = IOMUX_PAD(0x0404, 0x0178, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__GPIO4_IO00                         = IOMUX_PAD(0x0404, 0x0178, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__ECSPI3_SS2                         = IOMUX_PAD(0x0404, 0x0178, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B                       = IOMUX_PAD(0x0408, 0x017C, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__USDHC2_CMD                         = IOMUX_PAD(0x0408, 0x017C, 1, 0x0678, 2, 0),
+	MX6_PAD_NAND_WE_B__QSPI_B_SS0_B                       = IOMUX_PAD(0x0408, 0x017C, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__KPP_COL00                          = IOMUX_PAD(0x0408, 0x017C, 3, 0x05C4, 1, 0),
+	MX6_PAD_NAND_WE_B__EIM_EB_B01                         = IOMUX_PAD(0x0408, 0x017C, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__GPIO4_IO01                         = IOMUX_PAD(0x0408, 0x017C, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__ECSPI3_SS3                         = IOMUX_PAD(0x0408, 0x017C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00                   = IOMUX_PAD(0x040C, 0x0180, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0                     = IOMUX_PAD(0x040C, 0x0180, 1, 0x067C, 2, 0),
+	MX6_PAD_NAND_DATA00__QSPI_B_SS1_B                     = IOMUX_PAD(0x040C, 0x0180, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__KPP_ROW01                        = IOMUX_PAD(0x040C, 0x0180, 3, 0x05D4, 1, 0),
+	MX6_PAD_NAND_DATA00__EIM_AD08                         = IOMUX_PAD(0x040C, 0x0180, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__GPIO4_IO02                       = IOMUX_PAD(0x040C, 0x0180, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__ECSPI4_RDY                       = IOMUX_PAD(0x040C, 0x0180, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01                   = IOMUX_PAD(0x0410, 0x0184, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1                     = IOMUX_PAD(0x0410, 0x0184, 1, 0x0680, 2, 0),
+	MX6_PAD_NAND_DATA01__QSPI_B_DQS                       = IOMUX_PAD(0x0410, 0x0184, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__KPP_COL01                        = IOMUX_PAD(0x0410, 0x0184, 3, 0x05C8, 1, 0),
+	MX6_PAD_NAND_DATA01__EIM_AD09                         = IOMUX_PAD(0x0410, 0x0184, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__GPIO4_IO03                       = IOMUX_PAD(0x0410, 0x0184, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__ECSPI4_SS1                       = IOMUX_PAD(0x0410, 0x0184, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02                   = IOMUX_PAD(0x0414, 0x0188, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2                     = IOMUX_PAD(0x0414, 0x0188, 1, 0x0684, 1, 0),
+	MX6_PAD_NAND_DATA02__QSPI_B_DATA00                    = IOMUX_PAD(0x0414, 0x0188, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__KPP_ROW02                        = IOMUX_PAD(0x0414, 0x0188, 3, 0x05D8, 1, 0),
+	MX6_PAD_NAND_DATA02__EIM_AD10                         = IOMUX_PAD(0x0414, 0x0188, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__GPIO4_IO04                       = IOMUX_PAD(0x0414, 0x0188, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__ECSPI4_SS2                       = IOMUX_PAD(0x0414, 0x0188, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03                   = IOMUX_PAD(0x0418, 0x018C, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3                     = IOMUX_PAD(0x0418, 0x018C, 1, 0x0688, 2, 0),
+	MX6_PAD_NAND_DATA03__QSPI_B_DATA01                    = IOMUX_PAD(0x0418, 0x018C, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__KPP_COL02                        = IOMUX_PAD(0x0418, 0x018C, 3, 0x05CC, 1, 0),
+	MX6_PAD_NAND_DATA03__EIM_AD11                         = IOMUX_PAD(0x0418, 0x018C, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__GPIO4_IO05                       = IOMUX_PAD(0x0418, 0x018C, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__ECSPI4_SS3                       = IOMUX_PAD(0x0418, 0x018C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04                   = IOMUX_PAD(0x041C, 0x0190, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__USDHC2_DATA4                     = IOMUX_PAD(0x041C, 0x0190, 1, 0x068C, 1, 0),
+	MX6_PAD_NAND_DATA04__QSPI_B_DATA02                    = IOMUX_PAD(0x041C, 0x0190, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__ECSPI4_SCLK                      = IOMUX_PAD(0x041C, 0x0190, 3, 0x0564, 1, 0),
+	MX6_PAD_NAND_DATA04__EIM_AD12                         = IOMUX_PAD(0x041C, 0x0190, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__GPIO4_IO06                       = IOMUX_PAD(0x041C, 0x0190, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__UART2_DCE_TX                     = IOMUX_PAD(0x041C, 0x0190, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__UART2_DTE_RX                     = IOMUX_PAD(0x041C, 0x0190, 8, 0x062C, 2, 0),
+
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05                   = IOMUX_PAD(0x0420, 0x0194, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__USDHC2_DATA5                     = IOMUX_PAD(0x0420, 0x0194, 1, 0x0690, 1, 0),
+	MX6_PAD_NAND_DATA05__QSPI_B_DATA03                    = IOMUX_PAD(0x0420, 0x0194, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__ECSPI4_MOSI                      = IOMUX_PAD(0x0420, 0x0194, 3, 0x056C, 1, 0),
+	MX6_PAD_NAND_DATA05__EIM_AD13                         = IOMUX_PAD(0x0420, 0x0194, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__GPIO4_IO07                       = IOMUX_PAD(0x0420, 0x0194, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__UART2_DCE_RX                     = IOMUX_PAD(0x0420, 0x0194, 8, 0x062C, 3, 0),
+	MX6_PAD_NAND_DATA05__UART2_DTE_TX                     = IOMUX_PAD(0x0420, 0x0194, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06                   = IOMUX_PAD(0x0424, 0x0198, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__USDHC2_DATA6                     = IOMUX_PAD(0x0424, 0x0198, 1, 0x0694, 1, 0),
+	MX6_PAD_NAND_DATA06__SAI2_RX_BCLK                     = IOMUX_PAD(0x0424, 0x0198, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__ECSPI4_MISO                      = IOMUX_PAD(0x0424, 0x0198, 3, 0x0568, 1, 0),
+	MX6_PAD_NAND_DATA06__EIM_AD14                         = IOMUX_PAD(0x0424, 0x0198, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__GPIO4_IO08                       = IOMUX_PAD(0x0424, 0x0198, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__UART2_DCE_CTS                    = IOMUX_PAD(0x0424, 0x0198, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__UART2_DTE_RTS                    = IOMUX_PAD(0x0424, 0x0198, 8, 0x0628, 4, 0),
+
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07                   = IOMUX_PAD(0x0428, 0x019C, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__USDHC2_DATA7                     = IOMUX_PAD(0x0428, 0x019C, 1, 0x0698, 1, 0),
+	MX6_PAD_NAND_DATA07__QSPI_A_SS1_B                     = IOMUX_PAD(0x0428, 0x019C, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__ECSPI4_SS0                       = IOMUX_PAD(0x0428, 0x019C, 3, 0x0570, 1, 0),
+	MX6_PAD_NAND_DATA07__EIM_AD15                         = IOMUX_PAD(0x0428, 0x019C, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__GPIO4_IO09                       = IOMUX_PAD(0x0428, 0x019C, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__UART2_DCE_RTS                    = IOMUX_PAD(0x0428, 0x019C, 8, 0x0628, 5, 0),
+	MX6_PAD_NAND_DATA07__UART2_DTE_CTS                    = IOMUX_PAD(0x0428, 0x019C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_ALE__RAWNAND_ALE                         = IOMUX_PAD(0x042C, 0x01A0, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__USDHC2_RESET_B                      = IOMUX_PAD(0x042C, 0x01A0, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__QSPI_A_DQS                          = IOMUX_PAD(0x042C, 0x01A0, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__PWM3_OUT                            = IOMUX_PAD(0x042C, 0x01A0, 3, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__EIM_ADDR17                          = IOMUX_PAD(0x042C, 0x01A0, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__GPIO4_IO10                          = IOMUX_PAD(0x042C, 0x01A0, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__ECSPI3_SS1                          = IOMUX_PAD(0x042C, 0x01A0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B                       = IOMUX_PAD(0x0430, 0x01A4, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__USDHC1_RESET_B                     = IOMUX_PAD(0x0430, 0x01A4, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__QSPI_A_SCLK                        = IOMUX_PAD(0x0430, 0x01A4, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__PWM4_OUT                           = IOMUX_PAD(0x0430, 0x01A4, 3, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__EIM_BCLK                           = IOMUX_PAD(0x0430, 0x01A4, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__GPIO4_IO11                         = IOMUX_PAD(0x0430, 0x01A4, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__ECSPI3_RDY                         = IOMUX_PAD(0x0430, 0x01A4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B                 = IOMUX_PAD(0x0434, 0x01A8, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__USDHC1_DATA4                    = IOMUX_PAD(0x0434, 0x01A8, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__QSPI_A_DATA00                   = IOMUX_PAD(0x0434, 0x01A8, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__ECSPI3_SS0                      = IOMUX_PAD(0x0434, 0x01A8, 3, 0x0560, 1, 0),
+	MX6_PAD_NAND_READY_B__EIM_CS1_B                       = IOMUX_PAD(0x0434, 0x01A8, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__GPIO4_IO12                      = IOMUX_PAD(0x0434, 0x01A8, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__UART3_DCE_TX                    = IOMUX_PAD(0x0434, 0x01A8, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__UART3_DTE_RX                    = IOMUX_PAD(0x0434, 0x01A8, 8, 0x0634, 2, 0),
+
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B                     = IOMUX_PAD(0x0438, 0x01AC, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__USDHC1_DATA5                      = IOMUX_PAD(0x0438, 0x01AC, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01                     = IOMUX_PAD(0x0438, 0x01AC, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__ECSPI3_SCLK                       = IOMUX_PAD(0x0438, 0x01AC, 3, 0x0554, 1, 0),
+	MX6_PAD_NAND_CE0_B__EIM_DTACK_B                       = IOMUX_PAD(0x0438, 0x01AC, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__GPIO4_IO13                        = IOMUX_PAD(0x0438, 0x01AC, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__UART3_DCE_RX                      = IOMUX_PAD(0x0438, 0x01AC, 8, 0x0634, 3, 0),
+	MX6_PAD_NAND_CE0_B__UART3_DTE_TX                      = IOMUX_PAD(0x0438, 0x01AC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B                     = IOMUX_PAD(0x043C, 0x01B0, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__USDHC1_DATA6                      = IOMUX_PAD(0x043C, 0x01B0, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02                     = IOMUX_PAD(0x043C, 0x01B0, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__ECSPI3_MOSI                       = IOMUX_PAD(0x043C, 0x01B0, 3, 0x055C, 1, 0),
+	MX6_PAD_NAND_CE1_B__EIM_ADDR18                        = IOMUX_PAD(0x043C, 0x01B0, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__GPIO4_IO14                        = IOMUX_PAD(0x043C, 0x01B0, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__UART3_DCE_CTS                     = IOMUX_PAD(0x043C, 0x01B0, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__UART3_DTE_RTS                     = IOMUX_PAD(0x043C, 0x01B0, 8, 0x0630, 2, 0),
+
+	MX6_PAD_NAND_CLE__RAWNAND_CLE                         = IOMUX_PAD(0x0440, 0x01B4, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__USDHC1_DATA7                        = IOMUX_PAD(0x0440, 0x01B4, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__QSPI_A_DATA03                       = IOMUX_PAD(0x0440, 0x01B4, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__ECSPI3_MISO                         = IOMUX_PAD(0x0440, 0x01B4, 3, 0x0558, 1, 0),
+	MX6_PAD_NAND_CLE__EIM_ADDR16                          = IOMUX_PAD(0x0440, 0x01B4, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__GPIO4_IO15                          = IOMUX_PAD(0x0440, 0x01B4, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__UART3_DCE_RTS                       = IOMUX_PAD(0x0440, 0x01B4, 8, 0x0630, 3, 0),
+	MX6_PAD_NAND_CLE__UART3_DTE_CTS                       = IOMUX_PAD(0x0440, 0x01B4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DQS__RAWNAND_DQS                         = IOMUX_PAD(0x0444, 0x01B8, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__CSI_FIELD                           = IOMUX_PAD(0x0444, 0x01B8, 1, 0x0530, 1, 0),
+	MX6_PAD_NAND_DQS__QSPI_A_SS0_B                        = IOMUX_PAD(0x0444, 0x01B8, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__PWM5_OUT                            = IOMUX_PAD(0x0444, 0x01B8, 3, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__EIM_WAIT                            = IOMUX_PAD(0x0444, 0x01B8, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__GPIO4_IO16                          = IOMUX_PAD(0x0444, 0x01B8, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__SDMA_EXT_EVENT01                    = IOMUX_PAD(0x0444, 0x01B8, 6, 0x0614, 1, 0),
+	MX6_PAD_NAND_DQS__SPDIF_EXT_CLK                       = IOMUX_PAD(0x0444, 0x01B8, 8, 0x061C, 1, 0),
+
+	MX6_PAD_SD1_CMD__USDHC1_CMD                           = IOMUX_PAD(0x0448, 0x01BC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__GPT2_COMPARE1                        = IOMUX_PAD(0x0448, 0x01BC, 1, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__SAI2_RX_SYNC                         = IOMUX_PAD(0x0448, 0x01BC, 2, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__SPDIF_OUT                            = IOMUX_PAD(0x0448, 0x01BC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__EIM_ADDR19                           = IOMUX_PAD(0x0448, 0x01BC, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__GPIO2_IO16                           = IOMUX_PAD(0x0448, 0x01BC, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__SDMA_EXT_EVENT00                     = IOMUX_PAD(0x0448, 0x01BC, 6, 0x0610, 2, 0),
+	MX6_PAD_SD1_CMD__USB_OTG1_PWR                         = IOMUX_PAD(0x0448, 0x01BC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_CLK__USDHC1_CLK                           = IOMUX_PAD(0x044C, 0x01C0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__GPT2_COMPARE2                        = IOMUX_PAD(0x044C, 0x01C0, 1, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__SAI2_MCLK                            = IOMUX_PAD(0x044C, 0x01C0, 2, 0x05F0, 1, 0),
+	MX6_PAD_SD1_CLK__SPDIF_IN                             = IOMUX_PAD(0x044C, 0x01C0, 3, 0x0618, 3, 0),
+	MX6_PAD_SD1_CLK__EIM_ADDR20                           = IOMUX_PAD(0x044C, 0x01C0, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__GPIO2_IO17                           = IOMUX_PAD(0x044C, 0x01C0, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__USB_OTG1_OC                          = IOMUX_PAD(0x044C, 0x01C0, 8, 0x0664, 2, 0),
+
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0                       = IOMUX_PAD(0x0450, 0x01C4, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__GPT2_COMPARE3                      = IOMUX_PAD(0x0450, 0x01C4, 1, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__SAI2_TX_SYNC                       = IOMUX_PAD(0x0450, 0x01C4, 2, 0x05FC, 1, 0),
+	MX6_PAD_SD1_DATA0__FLEXCAN1_TX                        = IOMUX_PAD(0x0450, 0x01C4, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__EIM_ADDR21                         = IOMUX_PAD(0x0450, 0x01C4, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__GPIO2_IO18                         = IOMUX_PAD(0x0450, 0x01C4, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__ANATOP_OTG1_ID                     = IOMUX_PAD(0x0450, 0x01C4, 8, 0x04B8, 2, 0),
+
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1                       = IOMUX_PAD(0x0454, 0x01C8, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__GPT2_CLK                           = IOMUX_PAD(0x0454, 0x01C8, 1, 0x05A0, 1, 0),
+	MX6_PAD_SD1_DATA1__SAI2_TX_BCLK                       = IOMUX_PAD(0x0454, 0x01C8, 2, 0x05F8, 1, 0),
+	MX6_PAD_SD1_DATA1__FLEXCAN1_RX                        = IOMUX_PAD(0x0454, 0x01C8, 3, 0x0584, 3, 0),
+	MX6_PAD_SD1_DATA1__EIM_ADDR22                         = IOMUX_PAD(0x0454, 0x01C8, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__GPIO2_IO19                         = IOMUX_PAD(0x0454, 0x01C8, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__USB_OTG2_PWR                       = IOMUX_PAD(0x0454, 0x01C8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2                       = IOMUX_PAD(0x0458, 0x01CC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__GPT2_CAPTURE1                      = IOMUX_PAD(0x0458, 0x01CC, 1, 0x0598, 1, 0),
+	MX6_PAD_SD1_DATA2__SAI2_RX_DATA                       = IOMUX_PAD(0x0458, 0x01CC, 2, 0x05F4, 1, 0),
+	MX6_PAD_SD1_DATA2__FLEXCAN2_TX                        = IOMUX_PAD(0x0458, 0x01CC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__EIM_ADDR23                         = IOMUX_PAD(0x0458, 0x01CC, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__GPIO2_IO20                         = IOMUX_PAD(0x0458, 0x01CC, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__CCM_CLKO1                          = IOMUX_PAD(0x0458, 0x01CC, 6, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__USB_OTG2_OC                        = IOMUX_PAD(0x0458, 0x01CC, 8, 0x0660, 2, 0),
+
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3                       = IOMUX_PAD(0x045C, 0x01D0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__GPT2_CAPTURE2                      = IOMUX_PAD(0x045C, 0x01D0, 1, 0x059C, 1, 0),
+	MX6_PAD_SD1_DATA3__SAI2_TX_DATA                       = IOMUX_PAD(0x045C, 0x01D0, 2, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__FLEXCAN2_RX                        = IOMUX_PAD(0x045C, 0x01D0, 3, 0x0588, 3, 0),
+	MX6_PAD_SD1_DATA3__EIM_ADDR24                         = IOMUX_PAD(0x045C, 0x01D0, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__GPIO2_IO21                         = IOMUX_PAD(0x045C, 0x01D0, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__CCM_CLKO2                          = IOMUX_PAD(0x045C, 0x01D0, 6, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__ANATOP_OTG2_ID                     = IOMUX_PAD(0x045C, 0x01D0, 8, 0x04BC, 2, 0),
+
+	MX6_PAD_CSI_MCLK__CSI_MCLK                            = IOMUX_PAD(0x0460, 0x01D4, 0, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__USDHC2_CD_B                         = IOMUX_PAD(0x0460, 0x01D4, 1, 0x0674, 0, 0),
+	MX6_PAD_CSI_MCLK__RAWNAND_CE2_B                       = IOMUX_PAD(0x0460, 0x01D4, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__I2C1_SDA                            = IOMUX_PAD(0x0460, 0x01D4, IOMUX_CONFIG_SION | 3, 0x05A8, 0, 0),
+	MX6_PAD_CSI_MCLK__EIM_CS0_B                           = IOMUX_PAD(0x0460, 0x01D4, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__GPIO4_IO17                          = IOMUX_PAD(0x0460, 0x01D4, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__SNVS_HP_VIO_5_CTL                   = IOMUX_PAD(0x0460, 0x01D4, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__UART6_DCE_TX                        = IOMUX_PAD(0x0460, 0x01D4, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__UART6_DTE_RX                        = IOMUX_PAD(0x0460, 0x01D4, 8, 0x064C, 0, 0),
+
+	MX6_PAD_CSI_PIXCLK__CSI_PIXCLK                        = IOMUX_PAD(0x0464, 0x01D8, 0, 0x0528, 1, 0),
+	MX6_PAD_CSI_PIXCLK__USDHC2_WP                         = IOMUX_PAD(0x0464, 0x01D8, 1, 0x069C, 2, 0),
+	MX6_PAD_CSI_PIXCLK__RAWNAND_CE3_B                     = IOMUX_PAD(0x0464, 0x01D8, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__I2C1_SCL                          = IOMUX_PAD(0x0464, 0x01D8, IOMUX_CONFIG_SION | 3, 0x05A4, 2, 0),
+	MX6_PAD_CSI_PIXCLK__EIM_OE                            = IOMUX_PAD(0x0464, 0x01D8, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__GPIO4_IO18                        = IOMUX_PAD(0x0464, 0x01D8, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__SNVS_HP_VIO_5                     = IOMUX_PAD(0x0464, 0x01D8, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__UART6_DCE_RX                      = IOMUX_PAD(0x0464, 0x01D8, 8, 0x064C, 3, 0),
+	MX6_PAD_CSI_PIXCLK__UART6_DTE_TX                      = IOMUX_PAD(0x0464, 0x01D8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_VSYNC__CSI_VSYNC                          = IOMUX_PAD(0x0468, 0x01DC, 0, 0x052C, 0, 0),
+	MX6_PAD_CSI_VSYNC__USDHC2_CLK                         = IOMUX_PAD(0x0468, 0x01DC, 1, 0x0670, 0, 0),
+	MX6_PAD_CSI_VSYNC__SIM1_PORT1_CLK                     = IOMUX_PAD(0x0468, 0x01DC, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__I2C2_SDA                           = IOMUX_PAD(0x0468, 0x01DC, IOMUX_CONFIG_SION | 3, 0x05B0, 0, 0),
+	MX6_PAD_CSI_VSYNC__EIM_RW                             = IOMUX_PAD(0x0468, 0x01DC, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__GPIO4_IO19                         = IOMUX_PAD(0x0468, 0x01DC, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__PWM7_OUT                           = IOMUX_PAD(0x0468, 0x01DC, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__UART6_DCE_RTS                      = IOMUX_PAD(0x0468, 0x01DC, 8, 0x0648, 0, 0),
+	MX6_PAD_CSI_VSYNC__UART6_DTE_CTS                      = IOMUX_PAD(0x0468, 0x01DC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_HSYNC__CSI_HSYNC                          = IOMUX_PAD(0x046C, 0x01E0, 0, 0x0524, 0, 0),
+	MX6_PAD_CSI_HSYNC__USDHC2_CMD                         = IOMUX_PAD(0x046C, 0x01E0, 1, 0x0678, 0, 0),
+	MX6_PAD_CSI_HSYNC__SIM1_PORT1_PD                      = IOMUX_PAD(0x046C, 0x01E0, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__I2C2_SCL                           = IOMUX_PAD(0x046C, 0x01E0, IOMUX_CONFIG_SION | 3, 0x05AC, 0, 0),
+	MX6_PAD_CSI_HSYNC__EIM_LBA_B                          = IOMUX_PAD(0x046C, 0x01E0, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__GPIO4_IO20                         = IOMUX_PAD(0x046C, 0x01E0, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__PWM8_OUT                           = IOMUX_PAD(0x046C, 0x01E0, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__UART6_DCE_CTS                      = IOMUX_PAD(0x046C, 0x01E0, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__UART6_DTE_RTS                      = IOMUX_PAD(0x046C, 0x01E0, 8, 0x0648, 1, 0),
+
+	MX6_PAD_CSI_DATA00__CSI_DATA02                        = IOMUX_PAD(0x0470, 0x01E4, 0, 0x04C4, 0, 0),
+	MX6_PAD_CSI_DATA00__USDHC2_DATA0                      = IOMUX_PAD(0x0470, 0x01E4, 1, 0x067C, 0, 0),
+	MX6_PAD_CSI_DATA00__SIM1_PORT1_RST_B                  = IOMUX_PAD(0x0470, 0x01E4, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__ECSPI2_SCLK                       = IOMUX_PAD(0x0470, 0x01E4, 3, 0x0544, 0, 0),
+	MX6_PAD_CSI_DATA00__EIM_AD00                          = IOMUX_PAD(0x0470, 0x01E4, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__GPIO4_IO21                        = IOMUX_PAD(0x0470, 0x01E4, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__SRC_INT_BOOT                      = IOMUX_PAD(0x0470, 0x01E4, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__UART5_DCE_TX                      = IOMUX_PAD(0x0470, 0x01E4, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__UART5_DTE_RX                      = IOMUX_PAD(0x0470, 0x01E4, 8, 0x0644, 0, 0),
+
+	MX6_PAD_CSI_DATA01__CSI_DATA03                        = IOMUX_PAD(0x0474, 0x01E8, 0, 0x04C8, 0, 0),
+	MX6_PAD_CSI_DATA01__USDHC2_DATA1                      = IOMUX_PAD(0x0474, 0x01E8, 1, 0x0680, 0, 0),
+	MX6_PAD_CSI_DATA01__SIM1_PORT1_SVEN                   = IOMUX_PAD(0x0474, 0x01E8, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA01__ECSPI2_SS0                        = IOMUX_PAD(0x0474, 0x01E8, 3, 0x0550, 0, 0),
+	MX6_PAD_CSI_DATA01__EIM_AD01                          = IOMUX_PAD(0x0474, 0x01E8, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA01__GPIO4_IO22                        = IOMUX_PAD(0x0474, 0x01E8, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA01__SAI1_MCLK                         = IOMUX_PAD(0x0474, 0x01E8, 6, 0x05E0, 0, 0),
+	MX6_PAD_CSI_DATA01__UART5_DCE_RX                      = IOMUX_PAD(0x0474, 0x01E8, 8, 0x0644, 1, 0),
+	MX6_PAD_CSI_DATA01__UART5_DTE_TX                      = IOMUX_PAD(0x0474, 0x01E8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_DATA02__CSI_DATA04                        = IOMUX_PAD(0x0478, 0x01EC, 0, 0x04D8, 1, 0),
+	MX6_PAD_CSI_DATA02__USDHC2_DATA2                      = IOMUX_PAD(0x0478, 0x01EC, 1, 0x0684, 2, 0),
+	MX6_PAD_CSI_DATA02__SIM1_PORT1_TRXD                   = IOMUX_PAD(0x0478, 0x01EC, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__ECSPI2_MOSI                       = IOMUX_PAD(0x0478, 0x01EC, 3, 0x054C, 1, 0),
+	MX6_PAD_CSI_DATA02__EIM_AD02                          = IOMUX_PAD(0x0478, 0x01EC, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__GPIO4_IO23                        = IOMUX_PAD(0x0478, 0x01EC, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__SAI1_RX_SYNC                      = IOMUX_PAD(0x0478, 0x01EC, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__UART5_DCE_RTS                     = IOMUX_PAD(0x0478, 0x01EC, 8, 0x0640, 5, 0),
+	MX6_PAD_CSI_DATA02__UART5_DTE_CTS                     = IOMUX_PAD(0x0478, 0x01EC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_DATA03__CSI_DATA05                        = IOMUX_PAD(0x047C, 0x01F0, 0, 0x04CC, 0, 0),
+	MX6_PAD_CSI_DATA03__USDHC2_DATA3                      = IOMUX_PAD(0x047C, 0x01F0, 1, 0x0688, 0, 0),
+	MX6_PAD_CSI_DATA03__SIM2_PORT1_PD                     = IOMUX_PAD(0x047C, 0x01F0, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__ECSPI2_MISO                       = IOMUX_PAD(0x047C, 0x01F0, 3, 0x0548, 0, 0),
+	MX6_PAD_CSI_DATA03__EIM_AD03                          = IOMUX_PAD(0x047C, 0x01F0, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__GPIO4_IO24                        = IOMUX_PAD(0x047C, 0x01F0, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__SAI1_RX_BCLK                      = IOMUX_PAD(0x047C, 0x01F0, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__UART5_DCE_CTS                     = IOMUX_PAD(0x047C, 0x01F0, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__UART5_DTE_RTS                     = IOMUX_PAD(0x047C, 0x01F0, 8, 0x0640, 0, 0),
+
+	MX6_PAD_CSI_DATA04__CSI_DATA06                        = IOMUX_PAD(0x0480, 0x01F4, 0, 0x04DC, 1, 0),
+	MX6_PAD_CSI_DATA04__USDHC2_DATA4                      = IOMUX_PAD(0x0480, 0x01F4, 1, 0x068C, 2, 0),
+	MX6_PAD_CSI_DATA04__SIM2_PORT1_CLK                    = IOMUX_PAD(0x0480, 0x01F4, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA04__ECSPI1_SCLK                       = IOMUX_PAD(0x0480, 0x01F4, 3, 0x0534, 1, 0),
+	MX6_PAD_CSI_DATA04__EIM_AD04                          = IOMUX_PAD(0x0480, 0x01F4, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA04__GPIO4_IO25                        = IOMUX_PAD(0x0480, 0x01F4, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA04__SAI1_TX_SYNC                      = IOMUX_PAD(0x0480, 0x01F4, 6, 0x05EC, 1, 0),
+	MX6_PAD_CSI_DATA04__USDHC1_WP                         = IOMUX_PAD(0x0480, 0x01F4, 8, 0x066C, 2, 0),
+
+	MX6_PAD_CSI_DATA05__CSI_DATA07                        = IOMUX_PAD(0x0484, 0x01F8, 0, 0x04E0, 1, 0),
+	MX6_PAD_CSI_DATA05__USDHC2_DATA5                      = IOMUX_PAD(0x0484, 0x01F8, 1, 0x0690, 2, 0),
+	MX6_PAD_CSI_DATA05__SIM2_PORT1_RST_B                  = IOMUX_PAD(0x0484, 0x01F8, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA05__ECSPI1_SS0                        = IOMUX_PAD(0x0484, 0x01F8, 3, 0x0540, 1, 0),
+	MX6_PAD_CSI_DATA05__EIM_AD05                          = IOMUX_PAD(0x0484, 0x01F8, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA05__GPIO4_IO26                        = IOMUX_PAD(0x0484, 0x01F8, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA05__SAI1_TX_BCLK                      = IOMUX_PAD(0x0484, 0x01F8, 6, 0x05E8, 1, 0),
+	MX6_PAD_CSI_DATA05__USDHC1_CD_B                       = IOMUX_PAD(0x0484, 0x01F8, 8, 0x0668, 2, 0),
+
+	MX6_PAD_CSI_DATA06__CSI_DATA08                        = IOMUX_PAD(0x0488, 0x01FC, 0, 0x04E4, 1, 0),
+	MX6_PAD_CSI_DATA06__USDHC2_DATA6                      = IOMUX_PAD(0x0488, 0x01FC, 1, 0x0694, 2, 0),
+	MX6_PAD_CSI_DATA06__SIM2_PORT1_SVEN                   = IOMUX_PAD(0x0488, 0x01FC, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA06__ECSPI1_MOSI                       = IOMUX_PAD(0x0488, 0x01FC, 3, 0x053C, 1, 0),
+	MX6_PAD_CSI_DATA06__EIM_AD06                          = IOMUX_PAD(0x0488, 0x01FC, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA06__GPIO4_IO27                        = IOMUX_PAD(0x0488, 0x01FC, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA06__SAI1_RX_DATA                      = IOMUX_PAD(0x0488, 0x01FC, 6, 0x05E4, 1, 0),
+	MX6_PAD_CSI_DATA06__USDHC1_RESET_B                    = IOMUX_PAD(0x0488, 0x01FC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_DATA07__CSI_DATA09                        = IOMUX_PAD(0x048C, 0x0200, 0, 0x04E8, 1, 0),
+	MX6_PAD_CSI_DATA07__USDHC2_DATA7                      = IOMUX_PAD(0x048C, 0x0200, 1, 0x0698, 2, 0),
+	MX6_PAD_CSI_DATA07__SIM2_PORT1_TRXD                   = IOMUX_PAD(0x048C, 0x0200, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__ECSPI1_MISO                       = IOMUX_PAD(0x048C, 0x0200, 3, 0x0538, 1, 0),
+	MX6_PAD_CSI_DATA07__EIM_AD07                          = IOMUX_PAD(0x048C, 0x0200, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__GPIO4_IO28                        = IOMUX_PAD(0x048C, 0x0200, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__SAI1_TX_DATA                      = IOMUX_PAD(0x048C, 0x0200, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__USDHC1_VSELECT                    = IOMUX_PAD(0x048C, 0x0200, 8, 0x0000, 0, 0),
+};
+#endif  /* __ASM_ARCH_IMX6ULL_PINS_H__ */
diff -urN u-boot-2016.03/arch/arm/include/asm/arch-mx6/mx6ul_pins.h ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/mx6ul_pins.h
--- u-boot-2016.03/arch/arm/include/asm/arch-mx6/mx6ul_pins.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/mx6ul_pins.h	2021-04-16 14:42:14.692580786 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015 - 2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -67,6 +67,7 @@
 	MX6_PAD_JTAG_TCK__SAI2_RX_DATA                         = IOMUX_PAD(0x02E0, 0x0054, 2, 0x05F4, 0, 0),
 	MX6_PAD_JTAG_TCK__PWM7_OUT                             = IOMUX_PAD(0x02E0, 0x0054, 4, 0x0000, 0, 0),
 	MX6_PAD_JTAG_TCK__GPIO1_IO14                           = IOMUX_PAD(0x02E0, 0x0054, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__REF_CLK_32K                          = IOMUX_PAD(0x02E0, 0x0054, 6, 0x0000, 0, 0),
 	MX6_PAD_JTAG_TCK__SIM2_POWER_FAIL                      = IOMUX_PAD(0x02E0, 0x0054, 8, 0x0000, 0, 0),
 
 	MX6_PAD_JTAG_TRST_B__SJC_TRSTB                         = IOMUX_PAD(0x02E4, 0x0058, 0, 0x0000, 0, 0),
@@ -74,6 +75,7 @@
 	MX6_PAD_JTAG_TRST_B__SAI2_TX_DATA                      = IOMUX_PAD(0x02E4, 0x0058, 2, 0x0000, 0, 0),
 	MX6_PAD_JTAG_TRST_B__PWM8_OUT                          = IOMUX_PAD(0x02E4, 0x0058, 4, 0x0000, 0, 0),
 	MX6_PAD_JTAG_TRST_B__GPIO1_IO15                        = IOMUX_PAD(0x02E4, 0x0058, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__REF_CLK_24M                       = IOMUX_PAD(0x02E4, 0x0058, 6, 0x0000, 0, 0),
 	MX6_PAD_JTAG_TRST_B__CAAM_RNG_OSC_OBS                  = IOMUX_PAD(0x02E4, 0x0058, 8, 0x0000, 0, 0),
 
 	MX6_PAD_GPIO1_IO00__I2C2_SCL                           = IOMUX_PAD(0x02E8, 0x005C, IOMUX_CONFIG_SION | 0, 0x05AC, 1, 0),
@@ -110,6 +112,7 @@
 	MX6_PAD_GPIO1_IO03__I2C1_SDA                           = IOMUX_PAD(0x02F4, 0x0068, IOMUX_CONFIG_SION | 0, 0x05A8, 1, 0),
 	MX6_PAD_GPIO1_IO03__GPT1_COMPARE3                      = IOMUX_PAD(0x02F4, 0x0068, 1, 0x0000, 0, 0),
 	MX6_PAD_GPIO1_IO03__USB_OTG2_OC                        = IOMUX_PAD(0x02F4, 0x0068, 2, 0x0660, 0, 0),
+	MX6_PAD_GPIO1_IO03__REF_CLK_32K                        = IOMUX_PAD(0x02F4, 0x0068, 3, 0x0000, 0, 0),
 	MX6_PAD_GPIO1_IO03__USDHC1_CD_B                        = IOMUX_PAD(0x02F4, 0x0068, 4, 0x0668, 0, 0),
 	MX6_PAD_GPIO1_IO03__GPIO1_IO03                         = IOMUX_PAD(0x02F4, 0x0068, 5, 0x0000, 0, 0),
 	MX6_PAD_GPIO1_IO03__CCM_DI0_EXT_CLK                    = IOMUX_PAD(0x02F4, 0x0068, 6, 0x0000, 0, 0),
@@ -120,6 +123,7 @@
 	MX6_PAD_GPIO1_IO04__ENET1_REF_CLK1                     = IOMUX_PAD(0x02F8, 0x006C, 0, 0x0574, 1, 0),
 	MX6_PAD_GPIO1_IO04__PWM3_OUT                           = IOMUX_PAD(0x02F8, 0x006C, 1, 0x0000, 0, 0),
 	MX6_PAD_GPIO1_IO04__USB_OTG1_PWR                       = IOMUX_PAD(0x02F8, 0x006C, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__REF_CLK_24M                        = IOMUX_PAD(0x02F8, 0x006C, 3, 0x0000, 0, 0),
 	MX6_PAD_GPIO1_IO04__USDHC1_RESET_B                     = IOMUX_PAD(0x02F8, 0x006C, 4, 0x0000, 0, 0),
 	MX6_PAD_GPIO1_IO04__GPIO1_IO04                         = IOMUX_PAD(0x02F8, 0x006C, 5, 0x0000, 0, 0),
 	MX6_PAD_GPIO1_IO04__ENET2_1588_EVENT0_IN               = IOMUX_PAD(0x02F8, 0x006C, 6, 0x0000, 0, 0),
@@ -366,6 +370,7 @@
 	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN                       = IOMUX_PAD(0x0358, 0x00CC, 0, 0x0000, 0, 0),
 	MX6_PAD_ENET1_RX_EN__UART5_DCE_RTS                     = IOMUX_PAD(0x0358, 0x00CC, 1, 0x0640, 3, 0),
 	MX6_PAD_ENET1_RX_EN__UART5_DTE_CTS                     = IOMUX_PAD(0x0358, 0x00CC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__REF_CLK_32K                       = IOMUX_PAD(0x0358, 0x00CC, 2, 0x0000, 0, 0),
 	MX6_PAD_ENET1_RX_EN__CSI_DATA18                        = IOMUX_PAD(0x0358, 0x00CC, 3, 0x050C, 0, 0),
 	MX6_PAD_ENET1_RX_EN__FLEXCAN2_TX                       = IOMUX_PAD(0x0358, 0x00CC, 4, 0x0000, 0, 0),
 	MX6_PAD_ENET1_RX_EN__GPIO2_IO02                        = IOMUX_PAD(0x0358, 0x00CC, 5, 0x0000, 0, 0),
@@ -375,6 +380,7 @@
 	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00                  = IOMUX_PAD(0x035C, 0x00D0, 0, 0x0000, 0, 0),
 	MX6_PAD_ENET1_TX_DATA0__UART5_DCE_CTS                  = IOMUX_PAD(0x035C, 0x00D0, 1, 0x0000, 0, 0),
 	MX6_PAD_ENET1_TX_DATA0__UART5_DTE_RTS                  = IOMUX_PAD(0x035C, 0x00D0, 1, 0x0640, 4, 0),
+	MX6_PAD_ENET1_TX_DATA0__REF_CLK_24M                    = IOMUX_PAD(0x035C, 0x00D0, 2, 0x0000, 0, 0),
 	MX6_PAD_ENET1_TX_DATA0__CSI_DATA19                     = IOMUX_PAD(0x035C, 0x00D0, 3, 0x0510, 0, 0),
 	MX6_PAD_ENET1_TX_DATA0__FLEXCAN2_RX                    = IOMUX_PAD(0x035C, 0x00D0, 4, 0x0588, 1, 0),
 	MX6_PAD_ENET1_TX_DATA0__GPIO2_IO03                     = IOMUX_PAD(0x035C, 0x00D0, 5, 0x0000, 0, 0),
@@ -459,6 +465,7 @@
 	MX6_PAD_ENET2_TX_DATA0__EIM_EB_B02                     = IOMUX_PAD(0x037C, 0x00F0, 4, 0x0000, 0, 0),
 	MX6_PAD_ENET2_TX_DATA0__GPIO2_IO11                     = IOMUX_PAD(0x037C, 0x00F0, 5, 0x0000, 0, 0),
 	MX6_PAD_ENET2_TX_DATA0__KPP_COL05                      = IOMUX_PAD(0x037C, 0x00F0, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__REF_CLK_24M                    = IOMUX_PAD(0x037C, 0x00F0, 8, 0x0000, 0, 0),
 
 	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01                  = IOMUX_PAD(0x0380, 0x00F4, 0, 0x0000, 0, 0),
 	MX6_PAD_ENET2_TX_DATA1__UART8_DCE_TX                   = IOMUX_PAD(0x0380, 0x00F4, 1, 0x0000, 0, 0),
@@ -546,6 +553,7 @@
 
 	MX6_PAD_LCD_DATA00__LCDIF_DATA00                       = IOMUX_PAD(0x03A4, 0x0118, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA00__PWM1_OUT                           = IOMUX_PAD(0x03A4, 0x0118, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__CA7_MX6UL_TRACE0                   = IOMUX_PAD(0x03A4, 0x0118, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA00__ENET1_1588_EVENT2_IN               = IOMUX_PAD(0x03A4, 0x0118, 3, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA00__I2C3_SDA                           = IOMUX_PAD(0x03A4, 0x0118, IOMUX_CONFIG_SION | 4, 0x05B8, 2, 0),
 	MX6_PAD_LCD_DATA00__GPIO3_IO05                         = IOMUX_PAD(0x03A4, 0x0118, 5, 0x0000, 0, 0),
@@ -554,6 +562,7 @@
 
 	MX6_PAD_LCD_DATA01__LCDIF_DATA01                       = IOMUX_PAD(0x03A8, 0x011C, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA01__PWM2_OUT                           = IOMUX_PAD(0x03A8, 0x011C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__CA7_MX6UL_TRACE1                   = IOMUX_PAD(0x03A8, 0x011C, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA01__ENET1_1588_EVENT2_OUT              = IOMUX_PAD(0x03A8, 0x011C, 3, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA01__I2C3_SCL                           = IOMUX_PAD(0x03A8, 0x011C, IOMUX_CONFIG_SION | 4, 0x05B4, 2, 0),
 	MX6_PAD_LCD_DATA01__GPIO3_IO06                         = IOMUX_PAD(0x03A8, 0x011C, 5, 0x0000, 0, 0),
@@ -562,6 +571,7 @@
 
 	MX6_PAD_LCD_DATA02__LCDIF_DATA02                       = IOMUX_PAD(0x03AC, 0x0120, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA02__PWM3_OUT                           = IOMUX_PAD(0x03AC, 0x0120, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__CA7_MX6UL_TRACE2                   = IOMUX_PAD(0x03AC, 0x0120, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA02__ENET1_1588_EVENT3_IN               = IOMUX_PAD(0x03AC, 0x0120, 3, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA02__I2C4_SDA                           = IOMUX_PAD(0x03AC, 0x0120, IOMUX_CONFIG_SION | 4, 0x05C0, 2, 0),
 	MX6_PAD_LCD_DATA02__GPIO3_IO07                         = IOMUX_PAD(0x03AC, 0x0120, 5, 0x0000, 0, 0),
@@ -570,6 +580,7 @@
 
 	MX6_PAD_LCD_DATA03__LCDIF_DATA03                       = IOMUX_PAD(0x03B0, 0x0124, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA03__PWM4_OUT                           = IOMUX_PAD(0x03B0, 0x0124, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__CA7_MX6UL_TRACE3                   = IOMUX_PAD(0x03B0, 0x0124, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA03__ENET1_1588_EVENT3_OUT              = IOMUX_PAD(0x03B0, 0x0124, 3, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA03__I2C4_SCL                           = IOMUX_PAD(0x03B0, 0x0124, IOMUX_CONFIG_SION | 4, 0x05BC, 2, 0),
 	MX6_PAD_LCD_DATA03__GPIO3_IO08                         = IOMUX_PAD(0x03B0, 0x0124, 5, 0x0000, 0, 0),
@@ -579,6 +590,7 @@
 	MX6_PAD_LCD_DATA04__LCDIF_DATA04                       = IOMUX_PAD(0x03B4, 0x0128, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA04__UART8_DCE_CTS                      = IOMUX_PAD(0x03B4, 0x0128, 1, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA04__UART8_DTE_RTS                      = IOMUX_PAD(0x03B4, 0x0128, 1, 0x0658, 2, 0),
+	MX6_PAD_LCD_DATA04__CA7_MX6UL_TRACE4                   = IOMUX_PAD(0x03B4, 0x0128, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA04__ENET2_1588_EVENT2_IN               = IOMUX_PAD(0x03B4, 0x0128, 3, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA04__SPDIF_SR_CLK                       = IOMUX_PAD(0x03B4, 0x0128, 4, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA04__GPIO3_IO09                         = IOMUX_PAD(0x03B4, 0x0128, 5, 0x0000, 0, 0),
@@ -588,6 +600,7 @@
 	MX6_PAD_LCD_DATA05__LCDIF_DATA05                       = IOMUX_PAD(0x03B8, 0x012C, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA05__UART8_DCE_RTS                      = IOMUX_PAD(0x03B8, 0x012C, 1, 0x0658, 3, 0),
 	MX6_PAD_LCD_DATA05__UART8_DTE_CTS                      = IOMUX_PAD(0x03B8, 0x012C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__CA7_MX6UL_TRACE5                   = IOMUX_PAD(0x03B8, 0x012C, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA05__ENET2_1588_EVENT2_OUT              = IOMUX_PAD(0x03B8, 0x012C, 3, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA05__SPDIF_OUT                          = IOMUX_PAD(0x03B8, 0x012C, 4, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA05__GPIO3_IO10                         = IOMUX_PAD(0x03B8, 0x012C, 5, 0x0000, 0, 0),
@@ -597,6 +610,7 @@
 	MX6_PAD_LCD_DATA06__LCDIF_DATA06                       = IOMUX_PAD(0x03BC, 0x0130, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA06__UART7_DCE_CTS                      = IOMUX_PAD(0x03BC, 0x0130, 1, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA06__UART7_DTE_RTS                      = IOMUX_PAD(0x03BC, 0x0130, 1, 0x0650, 2, 0),
+	MX6_PAD_LCD_DATA06__CA7_MX6UL_TRACE6                   = IOMUX_PAD(0x03BC, 0x0130, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA06__ENET2_1588_EVENT3_IN               = IOMUX_PAD(0x03BC, 0x0130, 3, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA06__SPDIF_LOCK                         = IOMUX_PAD(0x03BC, 0x0130, 4, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA06__GPIO3_IO11                         = IOMUX_PAD(0x03BC, 0x0130, 5, 0x0000, 0, 0),
@@ -606,6 +620,7 @@
 	MX6_PAD_LCD_DATA07__LCDIF_DATA07                       = IOMUX_PAD(0x03C0, 0x0134, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA07__UART7_DCE_RTS                      = IOMUX_PAD(0x03C0, 0x0134, 1, 0x0650, 3, 0),
 	MX6_PAD_LCD_DATA07__UART7_DTE_CTS                      = IOMUX_PAD(0x03C0, 0x0134, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__CA7_MX6UL_TRACE7                   = IOMUX_PAD(0x03C0, 0x0134, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA07__ENET2_1588_EVENT3_OUT              = IOMUX_PAD(0x03C0, 0x0134, 3, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA07__SPDIF_EXT_CLK                      = IOMUX_PAD(0x03C0, 0x0134, 4, 0x061C, 0, 0),
 	MX6_PAD_LCD_DATA07__GPIO3_IO12                         = IOMUX_PAD(0x03C0, 0x0134, 5, 0x0000, 0, 0),
@@ -614,6 +629,7 @@
 
 	MX6_PAD_LCD_DATA08__LCDIF_DATA08                       = IOMUX_PAD(0x03C4, 0x0138, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA08__SPDIF_IN                           = IOMUX_PAD(0x03C4, 0x0138, 1, 0x0618, 2, 0),
+	MX6_PAD_LCD_DATA08__CA7_MX6UL_TRACE8                   = IOMUX_PAD(0x03C4, 0x0138, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA08__CSI_DATA16                         = IOMUX_PAD(0x03C4, 0x0138, 3, 0x0504, 1, 0),
 	MX6_PAD_LCD_DATA08__EIM_DATA00                         = IOMUX_PAD(0x03C4, 0x0138, 4, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA08__GPIO3_IO13                         = IOMUX_PAD(0x03C4, 0x0138, 5, 0x0000, 0, 0),
@@ -622,6 +638,7 @@
 
 	MX6_PAD_LCD_DATA09__LCDIF_DATA09                       = IOMUX_PAD(0x03C8, 0x013C, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA09__SAI3_MCLK                          = IOMUX_PAD(0x03C8, 0x013C, 1, 0x0600, 1, 0),
+	MX6_PAD_LCD_DATA09__CA7_MX6UL_TRACE9                   = IOMUX_PAD(0x03C8, 0x013C, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA09__CSI_DATA17                         = IOMUX_PAD(0x03C8, 0x013C, 3, 0x0508, 1, 0),
 	MX6_PAD_LCD_DATA09__EIM_DATA01                         = IOMUX_PAD(0x03C8, 0x013C, 4, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA09__GPIO3_IO14                         = IOMUX_PAD(0x03C8, 0x013C, 5, 0x0000, 0, 0),
@@ -630,6 +647,7 @@
 
 	MX6_PAD_LCD_DATA10__LCDIF_DATA10                       = IOMUX_PAD(0x03CC, 0x0140, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA10__SAI3_RX_SYNC                       = IOMUX_PAD(0x03CC, 0x0140, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__CA7_MX6UL_TRACE10                  = IOMUX_PAD(0x03CC, 0x0140, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA10__CSI_DATA18                         = IOMUX_PAD(0x03CC, 0x0140, 3, 0x050C, 1, 0),
 	MX6_PAD_LCD_DATA10__EIM_DATA02                         = IOMUX_PAD(0x03CC, 0x0140, 4, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA10__GPIO3_IO15                         = IOMUX_PAD(0x03CC, 0x0140, 5, 0x0000, 0, 0),
@@ -638,6 +656,7 @@
 
 	MX6_PAD_LCD_DATA11__LCDIF_DATA11                       = IOMUX_PAD(0x03D0, 0x0144, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA11__SAI3_RX_BCLK                       = IOMUX_PAD(0x03D0, 0x0144, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__CA7_MX6UL_TRACE11                  = IOMUX_PAD(0x03D0, 0x0144, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA11__CSI_DATA19                         = IOMUX_PAD(0x03D0, 0x0144, 3, 0x0510, 1, 0),
 	MX6_PAD_LCD_DATA11__EIM_DATA03                         = IOMUX_PAD(0x03D0, 0x0144, 4, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA11__GPIO3_IO16                         = IOMUX_PAD(0x03D0, 0x0144, 5, 0x0000, 0, 0),
@@ -646,6 +665,7 @@
 
 	MX6_PAD_LCD_DATA12__LCDIF_DATA12                       = IOMUX_PAD(0x03D4, 0x0148, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA12__SAI3_TX_SYNC                       = IOMUX_PAD(0x03D4, 0x0148, 1, 0x060C, 1, 0),
+	MX6_PAD_LCD_DATA12__CA7_MX6UL_TRACE12                  = IOMUX_PAD(0x03D4, 0x0148, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA12__CSI_DATA20                         = IOMUX_PAD(0x03D4, 0x0148, 3, 0x0514, 1, 0),
 	MX6_PAD_LCD_DATA12__EIM_DATA04                         = IOMUX_PAD(0x03D4, 0x0148, 4, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA12__GPIO3_IO17                         = IOMUX_PAD(0x03D4, 0x0148, 5, 0x0000, 0, 0),
@@ -654,6 +674,7 @@
 
 	MX6_PAD_LCD_DATA13__LCDIF_DATA13                       = IOMUX_PAD(0x03D8, 0x014C, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA13__SAI3_TX_BCLK                       = IOMUX_PAD(0x03D8, 0x014C, 1, 0x0608, 1, 0),
+	MX6_PAD_LCD_DATA13__CA7_MX6UL_TRACE13                  = IOMUX_PAD(0x03D8, 0x014C, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA13__CSI_DATA21                         = IOMUX_PAD(0x03D8, 0x014C, 3, 0x0518, 1, 0),
 	MX6_PAD_LCD_DATA13__EIM_DATA05                         = IOMUX_PAD(0x03D8, 0x014C, 4, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA13__GPIO3_IO18                         = IOMUX_PAD(0x03D8, 0x014C, 5, 0x0000, 0, 0),
@@ -662,6 +683,7 @@
 
 	MX6_PAD_LCD_DATA14__LCDIF_DATA14                       = IOMUX_PAD(0x03DC, 0x0150, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA14__SAI3_RX_DATA                       = IOMUX_PAD(0x03DC, 0x0150, 1, 0x0604, 1, 0),
+	MX6_PAD_LCD_DATA14__CA7_MX6UL_TRACE14                  = IOMUX_PAD(0x03DC, 0x0150, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA14__CSI_DATA22                         = IOMUX_PAD(0x03DC, 0x0150, 3, 0x051C, 1, 0),
 	MX6_PAD_LCD_DATA14__EIM_DATA06                         = IOMUX_PAD(0x03DC, 0x0150, 4, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA14__GPIO3_IO19                         = IOMUX_PAD(0x03DC, 0x0150, 5, 0x0000, 0, 0),
@@ -670,6 +692,7 @@
 
 	MX6_PAD_LCD_DATA15__LCDIF_DATA15                       = IOMUX_PAD(0x03E0, 0x0154, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA15__SAI3_TX_DATA                       = IOMUX_PAD(0x03E0, 0x0154, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__CA7_MX6UL_TRACE15                  = IOMUX_PAD(0x03E0, 0x0154, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA15__CSI_DATA23                         = IOMUX_PAD(0x03E0, 0x0154, 3, 0x0520, 1, 0),
 	MX6_PAD_LCD_DATA15__EIM_DATA07                         = IOMUX_PAD(0x03E0, 0x0154, 4, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA15__GPIO3_IO20                         = IOMUX_PAD(0x03E0, 0x0154, 5, 0x0000, 0, 0),
@@ -679,6 +702,7 @@
 	MX6_PAD_LCD_DATA16__LCDIF_DATA16                       = IOMUX_PAD(0x03E4, 0x0158, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA16__UART7_DCE_TX                       = IOMUX_PAD(0x03E4, 0x0158, 1, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA16__UART7_DTE_RX                       = IOMUX_PAD(0x03E4, 0x0158, 1, 0x0654, 2, 0),
+	MX6_PAD_LCD_DATA16__CA7_MX6UL_TRACE_CLK                = IOMUX_PAD(0x03E4, 0x0158, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA16__CSI_DATA01                         = IOMUX_PAD(0x03E4, 0x0158, 3, 0x04D4, 1, 0),
 	MX6_PAD_LCD_DATA16__EIM_DATA08                         = IOMUX_PAD(0x03E4, 0x0158, 4, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA16__GPIO3_IO21                         = IOMUX_PAD(0x03E4, 0x0158, 5, 0x0000, 0, 0),
@@ -688,6 +712,7 @@
 	MX6_PAD_LCD_DATA17__LCDIF_DATA17                       = IOMUX_PAD(0x03E8, 0x015C, 0, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA17__UART7_DCE_RX                       = IOMUX_PAD(0x03E8, 0x015C, 1, 0x0654, 3, 0),
 	MX6_PAD_LCD_DATA17__UART7_DTE_TX                       = IOMUX_PAD(0x03E8, 0x015C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__CA7_MX6UL_TRACE_CTL                = IOMUX_PAD(0x03E8, 0x015C, 2, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA17__CSI_DATA00                         = IOMUX_PAD(0x03E8, 0x015C, 3, 0x04D0, 1, 0),
 	MX6_PAD_LCD_DATA17__EIM_DATA09                         = IOMUX_PAD(0x03E8, 0x015C, 4, 0x0000, 0, 0),
 	MX6_PAD_LCD_DATA17__GPIO3_IO22                         = IOMUX_PAD(0x03E8, 0x015C, 5, 0x0000, 0, 0),
diff -urN u-boot-2016.03/arch/arm/include/asm/arch-mx6/sys_proto.h ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/sys_proto.h
--- u-boot-2016.03/arch/arm/include/asm/arch-mx6/sys_proto.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch-mx6/sys_proto.h	2021-04-16 14:42:14.692580786 +0800
@@ -2,7 +2,20 @@
  * (C) Copyright 2009
  * Stefano Babic, DENX Software Engineering, sbabic@denx.de.
  *
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <asm/imx-common/sys_proto.h>
+#include <asm/arch/module_fuse.h>
+
+void set_wdog_reset(struct wdog_regs *wdog);
+#ifdef CONFIG_LDO_BYPASS_CHECK
+int check_ldo_bypass(void);
+int check_1_2G(void);
+int set_anatop_bypass(int wdog_reset_pin);
+void ldo_mode_set(int ldo_bypass);
+void prep_anatop_bypass(void);
+void finish_anatop_bypass(void);
+#endif
diff -urN u-boot-2016.03/arch/arm/include/asm/arch-mx7/mx7d_pins.h ebf_6ull_uboot/arch/arm/include/asm/arch-mx7/mx7d_pins.h
--- u-boot-2016.03/arch/arm/include/asm/arch-mx7/mx7d_pins.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch-mx7/mx7d_pins.h	2021-04-16 14:42:14.692580786 +0800
@@ -635,7 +635,7 @@
 	MX7D_PAD_LCD_DATA23__GPIO3_IO28                          = IOMUX_PAD(0x0394, 0x0124, 5, 0x0000, 0, 0),
 	MX7D_PAD_LCD_DATA23__I2C4_SDA                            = IOMUX_PAD(0x0394, 0x0124, IOMUX_CONFIG_SION | 6, 0x05F0, 1, 0),
 
-	MX7D_PAD_UART1_RX_DATA__UART1_DCE_RX                     = IOMUX_PAD(0x0398, 0x0128, 0, 0x0000, 0, 0),
+	MX7D_PAD_UART1_RX_DATA__UART1_DCE_RX                     = IOMUX_PAD(0x0398, 0x0128, 0, 0x06F4, 0, 0),
 
 	MX7D_PAD_UART1_RX_DATA__UART1_DTE_TX                     = IOMUX_PAD(0x0398, 0x0128, 0, 0x0000, 0, 0),
 	MX7D_PAD_UART1_RX_DATA__I2C1_SCL                         = IOMUX_PAD(0x0398, 0x0128, IOMUX_CONFIG_SION | 1, 0x0000, 0, 0),
@@ -655,7 +655,7 @@
 	MX7D_PAD_UART1_TX_DATA__GPIO4_IO1                        = IOMUX_PAD(0x039C, 0x012C, 5, 0x0000, 0, 0),
 	MX7D_PAD_UART1_TX_DATA__ENET1_MDC                        = IOMUX_PAD(0x039C, 0x012C, 6, 0x0000, 0, 0),
 
-	MX7D_PAD_UART2_RX_DATA__UART2_DCE_RX                     = IOMUX_PAD(0x03A0, 0x0130, 0, 0x0000, 0, 0),
+	MX7D_PAD_UART2_RX_DATA__UART2_DCE_RX                     = IOMUX_PAD(0x03A0, 0x0130, 0, 0x06FC, 2, 0),
 
 	MX7D_PAD_UART2_RX_DATA__UART2_DTE_TX                     = IOMUX_PAD(0x03A0, 0x0130, 0, 0x0000, 0, 0),
 	MX7D_PAD_UART2_RX_DATA__I2C2_SCL                         = IOMUX_PAD(0x03A0, 0x0130, IOMUX_CONFIG_SION | 1, 0x0000, 0, 0),
@@ -667,7 +667,7 @@
 
 	MX7D_PAD_UART2_TX_DATA__UART2_DCE_TX                     = IOMUX_PAD(0x03A4, 0x0134, 0, 0x0000, 0, 0),
 
-	MX7D_PAD_UART2_TX_DATA__UART2_DTE_RX                     = IOMUX_PAD(0x03A4, 0x0134, 0, 0x0000, 0, 0),
+	MX7D_PAD_UART2_TX_DATA__UART2_DTE_RX                     = IOMUX_PAD(0x03A4, 0x0134, 0, 0x06FC, 3, 0),
 	MX7D_PAD_UART2_TX_DATA__I2C2_SDA                         = IOMUX_PAD(0x03A4, 0x0134, IOMUX_CONFIG_SION | 1, 0x05E0, 0, 0),
 	MX7D_PAD_UART2_TX_DATA__SAI3_RX_DATA0                    = IOMUX_PAD(0x03A4, 0x0134, 2, 0x06C8, 0, 0),
 	MX7D_PAD_UART2_TX_DATA__ECSPI1_RDY                       = IOMUX_PAD(0x03A4, 0x0134, 3, 0x0000, 0, 0),
@@ -695,7 +695,7 @@
 	MX7D_PAD_UART3_TX_DATA__GPIO4_IO5                        = IOMUX_PAD(0x03AC, 0x013C, 5, 0x0000, 0, 0),
 	MX7D_PAD_UART3_TX_DATA__SD2_LCTL                         = IOMUX_PAD(0x03AC, 0x013C, 6, 0x0000, 0, 0),
 
-	MX7D_PAD_UART3_RTS_B__UART3_DCE_RTS                      = IOMUX_PAD(0x03B0, 0x0140, 0, 0x0000, 0, 0),
+	MX7D_PAD_UART3_RTS_B__UART3_DCE_RTS                      = IOMUX_PAD(0x03B0, 0x0140, 0, 0x0700, 2, 0),
 
 	MX7D_PAD_UART3_RTS_B__UART3_DTE_CTS                      = IOMUX_PAD(0x03B0, 0x0140, 0, 0x0000, 0, 0),
 	MX7D_PAD_UART3_RTS_B__USB_OTG2_OC                        = IOMUX_PAD(0x03B0, 0x0140, 1, 0x0000, 0, 0),
diff -urN u-boot-2016.03/arch/arm/include/asm/arch-mx7/mx7_plugin.S ebf_6ull_uboot/arch/arm/include/asm/arch-mx7/mx7_plugin.S
--- u-boot-2016.03/arch/arm/include/asm/arch-mx7/mx7_plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/arch-mx7/mx7_plugin.S	2021-04-16 14:42:14.692580786 +0800
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <config.h>
+
+#define ROM_API_TABLE_BASE_ADDR_LEGACY		0x180
+#define ROM_VERSION_OFFSET               	0x80
+#define ROM_API_HWCNFG_SETUP_OFFSET		0x08
+
+plugin_start:
+
+	push    {r0-r4, lr}
+
+	imx7_ddr_setting
+	imx7_clock_gating
+	imx7_qos_setting
+
+/*
+ * Check if we are in USB serial download mode and immediately return to ROM
+ * Need to check USB CTRL clock firstly, then check the USBx_nASYNCLISTADDR
+ */
+ 	ldr r0, =0x30384680
+ 	ldr r1, [r0]
+ 	cmp r1, #0
+ 	beq normal_boot
+
+	ldr r0, =0x30B10158
+	ldr r1, [r0]
+	cmp r1, #0
+	beq normal_boot
+
+	pop {r0-r4, lr}
+	bx lr
+
+normal_boot:
+
+/*
+ * The following is to fill in those arguments for this ROM function
+ * pu_irom_hwcnfg_setup(void **start, size_t *bytes, const void *boot_data)
+ * This function is used to copy data from the storage media into DDR.
+ * start - Initial (possibly partial) image load address on entry.
+ *         Final image load address on exit.
+ * bytes - Initial (possibly partial) image size on entry.
+ *         Final image size on exit.
+ * boot_data - Initial @ref ivt Boot Data load address.
+ */
+	adr r0, boot_data2
+	adr r1, image_len2
+	adr r2, boot_data2
+
+/*
+ * check the _pu_irom_api_table for the address
+ */
+before_calling_rom___pu_irom_hwcnfg_setup:
+	ldr r3, =ROM_VERSION_OFFSET
+	ldr r4, [r3]
+	ldr r3, =ROM_API_TABLE_BASE_ADDR_LEGACY
+	ldr r4, [r3, #ROM_API_HWCNFG_SETUP_OFFSET]
+	blx r4
+after_calling_rom___pu_irom_hwcnfg_setup:
+
+
+/* To return to ROM from plugin, we need to fill in these argument.
+ * Here is what need to do:
+ * Need to construct the paramters for this function before return to ROM:
+ * plugin_download(void **start, size_t *bytes, UINT32 *ivt_offset)
+ */
+	pop {r0-r4, lr}
+	push {r5}
+	ldr r5, boot_data2
+	str r5, [r0]
+	ldr r5, image_len2
+	str r5, [r1]
+	ldr r5, second_ivt_offset
+	str r5, [r2]
+	mov r0, #1
+	pop {r5}
+
+	/* return back to ROM code */
+	bx lr
+
+/* make the following data right in the end of the output*/
+.ltorg
+
+#define FLASH_OFFSET 0x400
+
+/*
+ * second_ivt_offset is the offset from the "second_ivt_header" to
+ * "image_copy_start", which involves FLASH_OFFSET, plus the first
+ * ivt_header, the plugin code size itself recorded by "ivt2_header"
+ */
+
+second_ivt_offset:      .long (ivt2_header + 0x2C + FLASH_OFFSET)
+
+/*
+ * The following is the second IVT header plus the second boot data
+ */
+ivt2_header:            .long 0x0
+app2_code_jump_v:       .long 0x0
+reserv3:                .long 0x0
+dcd2_ptr:               .long 0x0
+boot_data2_ptr:         .long 0x0
+self_ptr2:              .long 0x0
+app_code_csf2:          .long 0x0
+reserv4:                .long 0x0
+boot_data2:             .long 0x0
+image_len2:             .long 0x0
+plugin2:                .long 0x0
diff -urN u-boot-2016.03/arch/arm/include/asm/imx-common/boot_mode.h ebf_6ull_uboot/arch/arm/include/asm/imx-common/boot_mode.h
--- u-boot-2016.03/arch/arm/include/asm/imx-common/boot_mode.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/imx-common/boot_mode.h	2021-04-16 14:42:14.700580828 +0800
@@ -1,6 +1,8 @@
 /*
  * Copyright (C) 2012 Boundary Devices Inc.
  *
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -37,5 +39,6 @@
 
 void add_board_boot_modes(const struct boot_mode *p);
 void boot_mode_apply(unsigned cfg_val);
+enum boot_device get_boot_device(void);
 extern const struct boot_mode soc_boot_modes[];
 #endif
diff -urN u-boot-2016.03/arch/arm/include/asm/imx-common/iomux-v3.h ebf_6ull_uboot/arch/arm/include/asm/imx-common/iomux-v3.h
--- u-boot-2016.03/arch/arm/include/asm/imx-common/iomux-v3.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/imx-common/iomux-v3.h	2021-04-16 14:42:14.700580828 +0800
@@ -3,7 +3,7 @@
  * Copyright (C) 2009 by Jan Weitzel Phytec Messtechnik GmbH,
  *			<armlinux@phytec.de>
  *
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011, 2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -39,10 +39,9 @@
  * MUX_CTRL_OFS:	    0..11 (12)
  * PAD_CTRL_OFS:	   12..23 (12)
  * SEL_INPUT_OFS:	   24..35 (12)
- * MUX_MODE + SION:	   36..40  (5)
- * PAD_CTRL + NO_PAD_CTRL: 41..58 (18)
- * SEL_INP:		   59..62  (4)
- * reserved:		     63    (1)
+ * MUX_MODE + SION:	   36..41  (6)
+ * PAD_CTRL + NO_PAD_CTRL: 42..59 (18)
+ * SEL_INP:		   60..63  (4)
 */
 
 typedef u64 iomux_v3_cfg_t;
@@ -57,10 +56,10 @@
 	MUX_SEL_INPUT_OFS_SHIFT)
 
 #define MUX_MODE_SHIFT		36
-#define MUX_MODE_MASK		((iomux_v3_cfg_t)0x1f << MUX_MODE_SHIFT)
-#define MUX_PAD_CTRL_SHIFT	41
+#define MUX_MODE_MASK		((iomux_v3_cfg_t)0x3f << MUX_MODE_SHIFT)
+#define MUX_PAD_CTRL_SHIFT	42
 #define MUX_PAD_CTRL_MASK	((iomux_v3_cfg_t)0x3ffff << MUX_PAD_CTRL_SHIFT)
-#define MUX_SEL_INPUT_SHIFT	59
+#define MUX_SEL_INPUT_SHIFT	60
 #define MUX_SEL_INPUT_MASK	((iomux_v3_cfg_t)0xf << MUX_SEL_INPUT_SHIFT)
 
 #define MUX_MODE_SION		((iomux_v3_cfg_t)IOMUX_CONFIG_SION << \
@@ -85,12 +84,12 @@
 
 #define NO_PAD_CTRL		(1 << 17)
 
+#define IOMUX_CONFIG_LPSR       0x20
+#define MUX_MODE_LPSR           ((iomux_v3_cfg_t)IOMUX_CONFIG_LPSR << \
+				MUX_MODE_SHIFT)
 #ifdef CONFIG_MX7
 
 #define IOMUX_LPSR_SEL_INPUT_OFS 0x70000
-#define IOMUX_CONFIG_LPSR       0x8
-#define MUX_MODE_LPSR           ((iomux_v3_cfg_t)IOMUX_CONFIG_LPSR << \
-				MUX_MODE_SHIFT)
 
 #define PAD_CTL_DSE_1P8V_140OHM   (0x0<<0)
 #define PAD_CTL_DSE_1P8V_35OHM    (0x1<<0)
@@ -145,9 +144,10 @@
 #define PAD_CTL_DSE_40ohm	(6 << 3)
 #define PAD_CTL_DSE_34ohm	(7 << 3)
 
-#if defined CONFIG_MX6SL
+#if defined(CONFIG_MX6SL) || defined(CONFIG_MX6SLL)
 #define PAD_CTL_LVE		(1 << 1)
 #define PAD_CTL_LVE_BIT		(1 << 22)
+#define PAD_CTL_IPD_BIT		(1 << 27)
 #endif
 
 #elif defined(CONFIG_VF610)
diff -urN u-boot-2016.03/arch/arm/include/asm/imx-common/mxc_key_defs.h ebf_6ull_uboot/arch/arm/include/asm/imx-common/mxc_key_defs.h
--- u-boot-2016.03/arch/arm/include/asm/imx-common/mxc_key_defs.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/imx-common/mxc_key_defs.h	2021-04-16 14:42:14.700580828 +0800
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2009-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _MXC_KEYPAD_H_
+#define _MXC_KEYPAD_H_
+
+#include <config.h>
+
+#define KEY_1                   2
+#define KEY_2                   3
+#define KEY_3                   4
+#define KEY_F1                  59
+#define KEY_UP                  103
+#define KEY_F2                  60
+
+#define KEY_4                   5
+#define KEY_5                   6
+#define KEY_6                   7
+#define KEY_LEFT                105
+#define KEY_SELECT              0x161
+#define KEY_RIGHT               106
+
+#define KEY_7                   8
+#define KEY_8                   9
+#define KEY_9                   10
+#define KEY_F3                  61
+#define KEY_DOWN                108
+#define KEY_F4                  62
+
+#define KEY_0                   11
+#define KEY_OK                  0x160
+#define KEY_ESC                 1
+#define KEY_ENTER               28
+#define KEY_MENU                139     /* Menu (show menu) */
+#define KEY_BACK                158     /* AC Back */
+
+#endif
diff -urN u-boot-2016.03/arch/arm/include/asm/imx-common/regs-bch.h ebf_6ull_uboot/arch/arm/include/asm/imx-common/regs-bch.h
--- u-boot-2016.03/arch/arm/include/asm/imx-common/regs-bch.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/imx-common/regs-bch.h	2021-04-16 14:42:14.700580828 +0800
@@ -5,7 +5,7 @@
  * on behalf of DENX Software Engineering GmbH
  *
  * Based on code from LTIB:
- * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2010, 2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -41,6 +41,7 @@
 	mxs_reg_32(hw_bch_dbgahbmread)
 	mxs_reg_32(hw_bch_blockname)
 	mxs_reg_32(hw_bch_version)
+	mxs_reg_32(hw_bch_debug1)
 };
 #endif
 
@@ -76,6 +77,9 @@
 
 #define	BCH_MODE_ERASE_THRESHOLD_MASK			0xff
 #define	BCH_MODE_ERASE_THRESHOLD_OFFSET			0
+#define BCH_MODE_ERASE_THRESHOLD(v)			\
+	(((v) << BCH_MODE_ERASE_THRESHOLD_OFFSET) &	\
+	 BCH_MODE_ERASE_THRESHOLD_MASK)
 
 #define	BCH_ENCODEPTR_ADDR_MASK				0xffffffff
 #define	BCH_ENCODEPTR_ADDR_OFFSET			0
diff -urN u-boot-2016.03/arch/arm/include/asm/imx-common/regs-lcdif.h ebf_6ull_uboot/arch/arm/include/asm/imx-common/regs-lcdif.h
--- u-boot-2016.03/arch/arm/include/asm/imx-common/regs-lcdif.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/imx-common/regs-lcdif.h	2021-04-16 14:42:14.700580828 +0800
@@ -5,7 +5,7 @@
  * on behalf of DENX Software Engineering GmbH
  *
  * Based on code from LTIB:
- * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2010, 2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -20,7 +20,7 @@
 	mxs_reg_32(hw_lcdif_ctrl)		/* 0x00 */
 	mxs_reg_32(hw_lcdif_ctrl1)		/* 0x10 */
 #if defined(CONFIG_MX28) || defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || \
-	defined(CONFIG_MX7)
+	defined(CONFIG_MX7) || defined(CONFIG_MX6SL) || defined(CONFIG_MX6SLL)
 	mxs_reg_32(hw_lcdif_ctrl2)		/* 0x20 */
 #endif
 	mxs_reg_32(hw_lcdif_transfer_count)	/* 0x20/0x30 */
@@ -56,7 +56,7 @@
 	mxs_reg_32(hw_lcdif_data)		/* 0x1b0/0x180 */
 	mxs_reg_32(hw_lcdif_bm_error_stat)	/* 0x1c0/0x190 */
 #if defined(CONFIG_MX28) || defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || \
-	defined(CONFIG_MX7)
+	defined(CONFIG_MX7) || defined(CONFIG_MX6SL) || defined(CONFIG_MX6SLL)
 	mxs_reg_32(hw_lcdif_crc_stat)		/* 0x1a0 */
 #endif
 	mxs_reg_32(hw_lcdif_lcdif_stat)		/* 0x1d0/0x1b0 */
@@ -64,7 +64,8 @@
 	mxs_reg_32(hw_lcdif_debug0)		/* 0x1f0/0x1d0 */
 	mxs_reg_32(hw_lcdif_debug1)		/* 0x200/0x1e0 */
 	mxs_reg_32(hw_lcdif_debug2)		/* 0x1f0 */
-#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || defined(CONFIG_MX7)
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || defined(CONFIG_MX7) || \
+	defined(CONFIG_MX6SL) || defined(CONFIG_MX6SLL)
 	mxs_reg_32(hw_lcdif_thres)
 	mxs_reg_32(hw_lcdif_as_ctrl)
 	mxs_reg_32(hw_lcdif_as_buf)
diff -urN u-boot-2016.03/arch/arm/include/asm/imx-common/sys_proto.h ebf_6ull_uboot/arch/arm/include/asm/imx-common/sys_proto.h
--- u-boot-2016.03/arch/arm/include/asm/imx-common/sys_proto.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/imx-common/sys_proto.h	2021-04-16 14:42:14.700580828 +0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2009
  * Stefano Babic, DENX Software Engineering, sbabic@denx.de.
  *
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -52,4 +54,16 @@
 int mxs_reset_block(struct mxs_register_32 *reg);
 int mxs_wait_mask_set(struct mxs_register_32 *reg, u32 mask, u32 timeout);
 int mxs_wait_mask_clr(struct mxs_register_32 *reg, u32 mask, u32 timeout);
+
+int mmc_get_env_dev(void);
+void board_late_mmc_env_init(void);
+
+void vadc_power_up(void);
+void vadc_power_down(void);
+
+void pcie_power_up(void);
+void pcie_power_off(void);
+
+int arch_auxiliary_core_up(u32 core_id, u32 boot_private_data);
+int arch_auxiliary_core_check_up(u32 core_id);
 #endif
diff -urN u-boot-2016.03/arch/arm/include/asm/imx-common/video.h ebf_6ull_uboot/arch/arm/include/asm/imx-common/video.h
--- u-boot-2016.03/arch/arm/include/asm/imx-common/video.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/imx-common/video.h	2021-04-16 14:42:14.704580848 +0800
@@ -1,4 +1,6 @@
 /*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -6,7 +8,11 @@
 #define __IMX_VIDEO_H_
 
 #include <linux/fb.h>
+#if defined(CONFIG_VIDEO_IPUV3)
 #include <ipu_pixfmt.h>
+#elif defined(CONFIG_VIDEO_MXS)
+#include <mxsfb.h>
+#endif
 
 struct display_info_t {
 	int	bus;
diff -urN u-boot-2016.03/arch/arm/include/asm/pl310.h ebf_6ull_uboot/arch/arm/include/asm/pl310.h
--- u-boot-2016.03/arch/arm/include/asm/pl310.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/arch/arm/include/asm/pl310.h	2021-04-16 14:42:14.704580848 +0800
@@ -3,6 +3,8 @@
  * Texas Instruments, <www.ti.com>
  * Aneesh V <aneesh@ti.com>
  *
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 #ifndef _PL310_H_
@@ -79,4 +81,9 @@
 void pl310_inval_range(u32 start, u32 end);
 void pl310_clean_inval_range(u32 start, u32 end);
 
+#define L2X0_CACHE_ID_PART_MASK		(0xf << 6)
+#define L2X0_CACHE_ID_PART_L310		(3 << 6)
+#define L2X0_CACHE_ID_RTL_MASK          0x3f
+#define L2X0_CACHE_ID_RTL_R3P2          0x8
+
 #endif
diff -urN u-boot-2016.03/board/freescale/common/epdc_setup.c ebf_6ull_uboot/board/freescale/common/epdc_setup.c
--- u-boot-2016.03/board/freescale/common/epdc_setup.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/common/epdc_setup.c	2021-04-16 14:42:16.612590723 +0800
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Peng Fan <Peng.Fan@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <lcd.h>
+#include <linux/err.h>
+#include <linux/types.h>
+#include <malloc.h>
+#include <mxc_epdc_fb.h>
+
+#define is_digit(c)	((c) >= '0' && (c) <= '9')
+__weak int mmc_get_env_devno(void)
+{
+	return 0;
+}
+__weak int check_mmc_autodetect(void)
+{
+	return 0;
+}
+
+int board_setup_waveform_file(ulong waveform_buf)
+{
+	char *fs_argv[5];
+	char addr[17];
+	ulong file_len, mmc_dev;
+
+	if (!check_mmc_autodetect())
+		mmc_dev = getenv_ulong("mmcdev", 10, 0);
+	else
+		mmc_dev = mmc_get_env_devno();
+
+	sprintf(addr, "%lx", waveform_buf);
+
+	fs_argv[0] = "fatload";
+	fs_argv[1] = "mmc";
+	fs_argv[2] = simple_itoa(mmc_dev);
+	fs_argv[3] = addr;
+	fs_argv[4] = getenv("epdc_waveform");
+
+	if (!fs_argv[4])
+		fs_argv[4] = "epdc_splash.bin";
+
+	if (do_fat_fsload(NULL, 0, 5, fs_argv)) {
+		printf("File %s not found on MMC Device %lu!\n", fs_argv[4], mmc_dev);
+		return -1;
+	}
+
+	file_len = getenv_hex("filesize", 0);
+	if (!file_len)
+		return -1;
+
+	flush_cache(waveform_buf, file_len);
+
+	return 0;
+}
+
+int board_setup_logo_file(void *display_buf)
+{
+	int logo_width, logo_height;
+	char *fs_argv[5];
+	char addr[17];
+	int array[3];
+	ulong file_len, mmc_dev;
+	char *buf, *s;
+	int arg = 0, val = 0, pos = 0;
+	int i, j, max_check_length;
+	int row, col, row_end, col_end;
+
+	if (!display_buf)
+		return -EINVAL;
+
+	/* Assume PGM header not exceeds 128 bytes */
+	max_check_length = 128;
+
+	if (!check_mmc_autodetect())
+		mmc_dev = getenv_ulong("mmcdev", 10, 0);
+	else
+		mmc_dev = mmc_get_env_devno();
+
+	memset(display_buf, 0xFF, panel_info.vl_col * panel_info.vl_row);
+
+	fs_argv[0] = "fatsize";
+	fs_argv[1] = "mmc";
+	fs_argv[2] = simple_itoa(mmc_dev);
+	fs_argv[3] = getenv("epdc_logo");
+	if (!fs_argv[3])
+		fs_argv[3] = "epdc_logo.pgm";
+	if (do_fat_size(NULL, 0, 4, fs_argv)) {
+		debug("File %s not found on MMC Device %lu, use black border\n", fs_argv[3], mmc_dev);
+		/* Draw black border around framebuffer*/
+		memset(display_buf, 0x0, 24 * panel_info.vl_col);
+		for (i = 24; i < (panel_info.vl_row - 24); i++) {
+			memset((u8 *)display_buf + i * panel_info.vl_col,
+			       0x00, 24);
+			memset((u8 *)display_buf + i * panel_info.vl_col
+				+ panel_info.vl_col - 24, 0x00, 24);
+		}
+		memset((u8 *)display_buf +
+		       panel_info.vl_col * (panel_info.vl_row - 24),
+		       0x00, 24 * panel_info.vl_col);
+		return 0;
+	}
+
+	file_len = getenv_hex("filesize", 0);
+	if (!file_len)
+		return -EINVAL;
+
+	buf = memalign(ARCH_DMA_MINALIGN, file_len);
+	if (!buf)
+		return -ENOMEM;
+
+	sprintf(addr, "%lx", (ulong)buf);
+
+	fs_argv[0] = "fatload";
+	fs_argv[1] = "mmc";
+	fs_argv[2] = simple_itoa(mmc_dev);
+	fs_argv[3] = addr;
+	fs_argv[4] = getenv("epdc_logo");
+
+	if (!fs_argv[4])
+		fs_argv[4] = "epdc_logo.pgm";
+
+	if (do_fat_fsload(NULL, 0, 5, fs_argv)) {
+		printf("File %s not found on MMC Device %lu!\n", fs_argv[4], mmc_dev);
+		free(buf);
+		return -1;
+	}
+
+	if (strncmp(buf, "P5", 2)) {
+		printf("Wrong format for epdc logo, use PGM-P5 format.\n");
+		free(buf);
+		return -EINVAL;
+	}
+	/* Skip P5\n */
+	pos += 3;
+	arg = 0;
+	for (i = 3; i < max_check_length; ) {
+		/* skip \n \t and space */
+		if ((buf[i] == '\n') || (buf[i] == '\t') || (buf[i] == ' ')) {
+			i++;
+			continue;
+		}
+		/* skip comment */
+		if (buf[i] == '#') {
+			while (buf[i++] != '\n')
+				;
+			continue;
+		}
+
+		/* HEIGTH, WIDTH, MAX PIXEL VLAUE total 3 args */
+		if (arg > 2)
+			break;
+		val = 0;
+		while (is_digit(buf[i])) {
+			val = val * 10 + buf[i] - '0';
+			i++;
+		}
+		array[arg++] = val;
+
+		i++;
+	}
+
+	/* Point to data area */
+	pos = i;
+
+	logo_width = array[0];
+	logo_height = array[1];
+
+	if ((logo_width > panel_info.vl_col) ||
+	    (logo_height > panel_info.vl_row)) {
+		printf("Picture: too big\n");
+		free(buf);
+		return -EINVAL;
+	}
+
+	/* m,m means center of screen */
+	row = 0;
+	col = 0;
+	s = getenv("splashpos");
+	if (s) {
+		if (s[0] == 'm')
+			col = (panel_info.vl_col  - logo_width) >> 1;
+		else
+			col = simple_strtol(s, NULL, 0);
+		s = strchr(s + 1, ',');
+		if (s != NULL) {
+			if (s[1] == 'm')
+				row = (panel_info.vl_row  - logo_height) >> 1;
+			else
+				row = simple_strtol(s + 1, NULL, 0);
+		}
+	}
+	if ((col + logo_width > panel_info.vl_col) ||
+	    (row + logo_height > panel_info.vl_row)) {
+		printf("Incorrect pos, use (0, 0)\n");
+		row = 0;
+		col = 0;
+	}
+
+	/* Draw picture at the center of screen */
+	row_end = row + logo_height;
+	col_end = col + logo_width;
+	for (i = row; i < row_end; i++) {
+		for (j = col; j < col_end; j++) {
+			*((u8 *)display_buf + i * (panel_info.vl_col) + j) =
+				 buf[pos++];
+		}
+	}
+
+	free(buf);
+
+	flush_cache((ulong)display_buf, file_len - pos - 1);
+
+	return 0;
+}
diff -urN u-boot-2016.03/board/freescale/common/Makefile ebf_6ull_uboot/board/freescale/common/Makefile
--- u-boot-2016.03/board/freescale/common/Makefile	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/common/Makefile	2021-04-16 14:42:16.612590723 +0800
@@ -61,6 +61,11 @@
 obj-$(CONFIG_IDT8T49N222A)	+= idt8t49n222a_serdes_clk.o
 obj-$(CONFIG_ZM7300)		+= zm7300.o
 obj-$(CONFIG_POWER_PFUZE100)	+= pfuze.o
+obj-$(CONFIG_MXC_EPDC)		+= epdc_setup.o
+obj-y				+= mmc.o
+ifdef CONFIG_FSL_FASTBOOT
+obj-${CONFIG_ANDROID_RECOVERY} += recovery.o
+endif
 
 obj-$(CONFIG_LS102XA_STREAM_ID)	+= ls102xa_stream_id.o
 
diff -urN u-boot-2016.03/board/freescale/common/mmc.c ebf_6ull_uboot/board/freescale/common/mmc.c
--- u-boot-2016.03/board/freescale/common/mmc.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/common/mmc.c	2021-04-16 14:42:16.612590723 +0800
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <stdbool.h>
+
+static int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+/* This should be defined for each board */
+__weak int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no;
+}
+
+void board_late_mmc_env_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_dev();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
diff -urN u-boot-2016.03/board/freescale/common/recovery.c ebf_6ull_uboot/board/freescale/common/recovery.c
--- u-boot-2016.03/board/freescale/common/recovery.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/common/recovery.c	2021-04-16 14:42:16.616590743 +0800
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <malloc.h>
+#include <recovery.h>
+#ifdef CONFIG_MXC_KPD
+#include <mxc_keyb.h>
+#endif
+#include <asm/imx-common/boot_mode.h>
+
+#ifdef CONFIG_MXC_KPD
+#define PRESSED_VOL_DOWN	0x01
+#define PRESSED_POWER	    0x02
+#define RECOVERY_KEY_MASK (PRESSED_VOL_DOWN | PRESSED_POWER)
+
+inline int test_key(int value, struct kpp_key_info *ki)
+{
+	return (ki->val == value) && (ki->evt == KDepress);
+}
+
+int check_key_pressing(void)
+{
+	struct kpp_key_info *key_info = NULL;
+	int state = 0, keys, i;
+
+	int ret = 0;
+
+	mxc_kpp_init();
+	/* due to glitch suppression circuit,
+	   wait sometime to let all keys scanned. */
+	udelay(1000);
+	keys = mxc_kpp_getc(&key_info);
+
+	printf("Detecting VOL_DOWN+POWER key for recovery(%d:%d) ...\n",
+		keys, keys ? key_info->val : 0);
+	if (keys > 1) {
+		for (i = 0; i < keys; i++) {
+			if (test_key(CONFIG_POWER_KEY, &key_info[i]))
+				state |= PRESSED_POWER;
+			else if (test_key(CONFIG_VOL_DOWN_KEY, &key_info[i]))
+				state |= PRESSED_VOL_DOWN;
+		}
+	}
+	if ((state & RECOVERY_KEY_MASK) == RECOVERY_KEY_MASK)
+		ret = 1;
+	if (key_info)
+		free(key_info);
+	return ret;
+}
+#else
+/* If not using mxc keypad, currently we will detect power key on board */
+int check_key_pressing(void)
+{
+	return 0;
+}
+#endif
+
+void setup_recovery_env(void)
+{
+	board_recovery_setup();
+}
+
+/* export to lib_arm/board.c */
+void check_recovery_mode(void)
+{
+	if (check_key_pressing()) {
+		puts("Fastboot: Recovery key pressing got!\n");
+		setup_recovery_env();
+	} else if (check_recovery_cmd_file()) {
+		puts("Fastboot: Recovery command file found!\n");
+		setup_recovery_env();
+	} else {
+		puts("Fastboot: Normal\n");
+	}
+}
diff -urN u-boot-2016.03/board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg ebf_6ull_uboot/board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg
--- u-boot-2016.03/board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,600 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+
+BOOT_FROM	sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6dscm/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+#ifdef CONFIG_SCM_LPDDR2_512MB
+/* DCD */
+/* DDR clock to 400MHz */
+DATA 4, 0x020C4018 0x00060324
+/* AHB_ROOT_CLK change divide ratio from 4 to 3 for ENET */
+DATA 4, 0x020C4014 0x00018900
+
+DATA 4 0x020C4018 0x00060324
+
+DATA 4 0x020e0798 0x00080000
+DATA 4 0x020e0758 0x00000000
+
+DATA 4 0x020E0588 0x00000030
+DATA 4 0x020E0594 0x00000030
+
+DATA 4 0x020E056c 0x00000030
+DATA 4 0x020E0578 0x00000030
+DATA 4 0x020E074c 0x00000030
+
+DATA 4 0x020E057c 0x00000030
+DATA 4 0x020E058c 0x00000000
+DATA 4 0x020E059c 0x00000030
+DATA 4 0x020E05a0 0x00000030
+DATA 4 0x020E078c 0x00000030
+
+DATA 4 0x020E0750 0x00020000
+DATA 4 0x020E05a8 0x00003030
+DATA 4 0x020E05b0 0x00003030
+DATA 4 0x020E0524 0x00003030
+DATA 4 0x020E051c 0x00003030
+DATA 4 0x020E0518 0x00003030
+DATA 4 0x020E050c 0x00003030
+DATA 4 0x020E05b8 0x00003030
+DATA 4 0x020E05c0 0x00003030
+
+DATA 4 0x020E0774 0x00020000
+
+DATA 4 0x020E0784 0x00000030
+DATA 4 0x020E0788 0x00000030
+DATA 4 0x020E0794 0x00000030
+DATA 4 0x020E079c 0x00000030
+DATA 4 0x020E07a0 0x00000030
+DATA 4 0x020E07a4 0x00000030
+DATA 4 0x020E07a8 0x00000030
+DATA 4 0x020E0748 0x00000030
+
+DATA 4 0x020E05ac 0x00000030
+DATA 4 0x020E05b4 0x00000030
+DATA 4 0x020E0528 0x00000030
+DATA 4 0x020E0520 0x00000030
+DATA 4 0x020E0514 0x00000030
+DATA 4 0x020E0510 0x00000030
+DATA 4 0x020E05bc 0x00000030
+DATA 4 0x020E05c4 0x00000030
+
+DATA 4 0x020E0590 0x00000020
+DATA 4 0x020E0598 0x00000020
+
+DATA 4 0x021b001c 0x00008000
+
+DATA 4 0x021b085c 0x1b4700c7
+
+DATA 4 0x021b0800 0xa1390003
+
+
+DATA 4 0x021b0890 0x00400000
+
+DATA 4 0x021b0848 0x44404044
+
+DATA 4 0x021b0850 0x34343A38
+
+DATA 4 0x021b083c 0x20000000
+DATA 4 0x021b0840 0x00000000
+
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+
+DATA 4 0x021b082c 0xf3333333
+DATA 4 0x021b0830 0xf3333333
+DATA 4 0x021b0834 0xf3333333
+DATA 4 0x021b0838 0xf3333333
+
+DATA 4 0x021b08b8 0x00000800
+
+DATA 4 0x021b0004 0x00020036
+DATA 4 0x021b0008 0x00000000
+DATA 4 0x021b000c 0x33374133
+
+DATA 4 0x021b0010 0x00100a82
+
+DATA 4 0x021b0014 0x00000093
+
+DATA 4 0x021b0018 0x0000174C
+DATA 4 0x021b001c 0x00008050
+DATA 4 0x021b002c 0x0f9f26d2
+DATA 4 0x021b0030 0x00000010
+DATA 4 0x021b0038 0x00190778
+
+/* 1-Ch Mode */
+DATA 4 0x021b0040 0x0000004f
+
+DATA 4 0x021b0000 0x83110000
+
+/* Channel 0 */
+DATA 4 0x021b001c 0x003f8030
+DATA 4 0x021b001c 0xff0a8030
+DATA 4 0x021b001c 0x82018030
+DATA 4 0x021b001c 0x04028030
+DATA 4 0x021b001c 0x04038030
+
+DATA 4 0x021b0800 0xa1390003
+
+DATA 4 0x021b0020 0x00001800
+
+DATA 4 0x021b0818 0x00000000
+
+DATA 4 0x021b0004 0x00025576
+
+DATA 4 0x021b0404 0x00011006
+
+DATA 4 0x021b001c 0x00000000
+
+
+DATA 4 0x020c4068 0x00C03F3F
+DATA 4 0x020c406c 0x0030FC03
+DATA 4 0x020c4070 0x0FFFC000
+DATA 4 0x020c4074 0x3FF00000
+DATA 4 0x020c4078 0x00FFF300
+DATA 4 0x020c407c 0x0F0000C3
+DATA 4 0x020c4080 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4 0x020e0010 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4 0x020e0018 0x007F007F
+DATA 4 0x020e001c 0x007F007F
+
+#elif CONFIG_SCM_LPDDR2_2GB
+/* DDR clock to 400MHz */
+DATA 4, 0x020C4018 0x00060324
+/* AHB_ROOT_CLK change divide ratio from 4 to 3 for ENET */
+DATA 4, 0x020C4014 0x00018900
+
+DATA 4, 0x020e0798, 0x00080000
+DATA 4, 0x020e0758, 0x00000000
+
+
+
+DATA 4, 0x020E0588, 0x00000030
+DATA 4, 0x020E0594, 0x00000030
+
+DATA 4, 0x020E056c, 0x00000030
+DATA 4, 0x020E0578, 0x00000030
+DATA 4, 0x020E074c, 0x00000030
+
+DATA 4, 0x020E057c, 0x00000030
+DATA 4, 0x020E058c, 0x00000000
+DATA 4, 0x020E059c, 0x00000030
+DATA 4, 0x020E05a0, 0x00000030
+DATA 4, 0x020E078c, 0x00000030
+
+DATA 4, 0x020E0750, 0x00020000
+DATA 4, 0x020E05a8, 0x00003030
+DATA 4, 0x020E05b0, 0x00003030
+DATA 4, 0x020E0524, 0x00003030
+DATA 4, 0x020E051c, 0x00003030
+DATA 4, 0x020E0518, 0x00003030
+DATA 4, 0x020E050c, 0x00003030
+DATA 4, 0x020E05b8, 0x00003030
+DATA 4, 0x020E05c0, 0x00003030
+
+DATA 4, 0x020E0774, 0x00020000
+
+DATA 4, 0x020E0784, 0x00000030
+DATA 4, 0x020E0788, 0x00000030
+DATA 4, 0x020E0794, 0x00000030
+DATA 4, 0x020E079c, 0x00000030
+DATA 4, 0x020E07a0, 0x00000030
+DATA 4, 0x020E07a4, 0x00000030
+DATA 4, 0x020E07a8, 0x00000030
+DATA 4, 0x020E0748, 0x00000030
+
+DATA 4, 0x020E05ac, 0x00000030
+DATA 4, 0x020E05b4, 0x00000030
+DATA 4, 0x020E0528, 0x00000030
+DATA 4, 0x020E0520, 0x00000030
+DATA 4, 0x020E0514, 0x00000030
+DATA 4, 0x020E0510, 0x00000030
+DATA 4, 0x020E05bc, 0x00000030
+DATA 4, 0x020E05c4, 0x00000030
+
+
+
+DATA 4, 0x020E0590, 0x00000020
+DATA 4, 0x020E0598, 0x00000020
+
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b401c, 0x00008000
+
+DATA 4, 0x021b085c, 0x1b4700c7
+DATA 4, 0x021b485c, 0x1b4700c7
+
+DATA 4, 0x021b0800, 0xa1390003
+
+DATA 4, 0x021b0890, 0x00400000
+DATA 4, 0x021b4890, 0x00400000
+
+DATA 4, 0x021b0848, 0x44404044
+DATA 4, 0x021b4848, 0x44443A46
+
+DATA 4, 0x021b0850, 0x34343A38
+DATA 4, 0x021b4850, 0x382F3835
+
+DATA 4, 0x021b083c, 0x20000000
+DATA 4, 0x021b0840, 0x00000000
+DATA 4, 0x021b483c, 0x20000000
+DATA 4, 0x021b4840, 0x00000000
+
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x00000000
+DATA 4, 0x021b4828, 0x33333333
+DATA 4, 0x021b082c, 0xf3333333
+DATA 4, 0x021b0830, 0xf3333333
+DATA 4, 0x021b0834, 0xf3333333
+DATA 4, 0x021b0838, 0xf3333333
+DATA 4, 0x021b482c, 0xf3333333
+DATA 4, 0x021b4830, 0xf3333333
+DATA 4, 0x021b4834, 0x00000000
+DATA 4, 0x021b4838, 0xf3333333
+
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b48b8, 0x00000800
+
+DATA 4, 0x021b0004, 0x00020036
+DATA 4, 0x021b0008, 0x00000000
+DATA 4, 0x021b000c, 0x33374133
+
+DATA 4, 0x021b0010, 0x00100a82
+
+DATA 4, 0x021b0014, 0x00000093
+
+DATA 4, 0x021b0018, 0x0000174C
+DATA 4, 0x021b001c, 0x00008050
+DATA 4, 0x021b002c, 0x0f9f26d2
+DATA 4, 0x021b0030, 0x009F0E10
+DATA 4, 0x021b0038, 0x00190778
+
+#ifdef CONFIG_INTERLEAVING_MODE
+DATA 4, 0x021b0040, 0x00000053
+#else
+DATA 4, 0x021b0040, 0x0000004f
+#endif
+
+DATA 4, 0x021b0000, 0xc3110000
+
+DATA 4, 0x021b4004, 0x00020036
+DATA 4, 0x021b4008, 0x00000000
+
+DATA 4, 0x021b400c, 0x33374133
+
+DATA 4, 0x021b4010, 0x00100a82
+
+DATA 4, 0x021b4014, 0x00000093
+
+DATA 4, 0x021b4018, 0x0000174C
+DATA 4, 0x021b401c, 0x00008050
+
+DATA 4, 0x021b402c, 0x0f9f26d2
+
+DATA 4, 0x021b4030, 0x009F0E10
+
+DATA 4, 0x021b4038, 0x00190778
+
+#ifdef CONFIG_INTERLEAVING_MODE
+DATA 4, 0x021b4040, 0x00000013
+#else
+DATA 4, 0x021b4040, 0x00000017
+#endif
+
+DATA 4, 0x021b4000, 0xc3110000
+
+/* Channel 0 */
+/* CS0 */
+DATA 4, 0x021b001c, 0x003f8030
+DATA 4, 0x021b001c, 0xff0a8030
+DATA 4, 0x021b001c, 0x82018030
+DATA 4, 0x021b001c, 0x04028030
+DATA 4, 0x021b001c, 0x04038030
+DATA 4, 0x021b001c, 0x01038030
+/* CS1 */
+DATA 4, 0x021b001c, 0x003f8038
+DATA 4, 0x021b001c, 0xff0a8038
+DATA 4, 0x021b001c, 0x82018038
+DATA 4, 0x021b001c, 0x04028038
+DATA 4, 0x021b001c, 0x04038038
+DATA 4, 0x021b001c, 0x01038038
+
+/* Channel 1 */
+/* CS0 */
+DATA 4, 0x021b401c, 0x003f8030
+DATA 4, 0x021b401c, 0xff0a8030
+DATA 4, 0x021b401c, 0x82018030
+DATA 4, 0x021b401c, 0x04028030
+DATA 4, 0x021b401c, 0x04038030
+DATA 4, 0x021b401c, 0x01038030
+/* CS1 */
+DATA 4, 0x021b401c, 0x003f8038
+DATA 4, 0x021b401c, 0xff0a8038
+DATA 4, 0x021b401c, 0x82018038
+DATA 4, 0x021b401c, 0x04028038
+DATA 4, 0x021b401c, 0x04038038
+DATA 4, 0x021b401c, 0x01038038
+DATA 4, 0x021b4800, 0xa1390003
+
+DATA 4, 0x021b0020, 0x00001800
+DATA 4, 0x021b4020, 0x00001800
+
+DATA 4, 0x021b0818, 0x00000000
+DATA 4, 0x021b4818, 0x00000000
+
+DATA 4, 0x021b0004, 0x00025576
+DATA 4, 0x021b4004, 0x00025576
+
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b4404, 0x00011006
+
+DATA 4, 0x021b001c, 0x00000000
+DATA 4, 0x021b401c, 0x00000000
+
+/* enable clocks */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000C3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+
+#else
+/* DCD */
+/* DDR clock to 400MHz */
+DATA 4, 0x020C4018 0x00060324
+/* AHB_ROOT_CLK change divide ratio from 4 to 3 for ENET */
+DATA 4, 0x020C4014 0x00018900
+
+/* DSE to 80 ohms, 100K PD on DQS */
+DATA 4 0x020e0798 0x00080000
+DATA 4 0x020e0758 0x00000000
+
+
+
+DATA 4, 0x020E0588, 0x00000030
+DATA 4, 0x020E0594, 0x00000030
+
+DATA 4, 0x020E056c, 0x00000030
+DATA 4, 0x020E0578, 0x00000030
+DATA 4, 0x020E074c, 0x00000030
+
+DATA 4, 0x020E057c, 0x00000030
+DATA 4, 0x020E058c, 0x00000000
+DATA 4, 0x020E059c, 0x00000030
+DATA 4, 0x020E05a0, 0x00000030
+DATA 4, 0x020E078c, 0x00000030
+
+DATA 4, 0x020E0750, 0x00020000
+DATA 4, 0x020E05a8, 0x00003030
+DATA 4, 0x020E05b0, 0x00003030
+DATA 4, 0x020E0524, 0x00003030
+DATA 4, 0x020E051c, 0x00003030
+DATA 4, 0x020E0518, 0x00003030
+DATA 4, 0x020E050c, 0x00003030
+DATA 4, 0x020E05b8, 0x00003030
+DATA 4, 0x020E05c0, 0x00003030
+
+DATA 4, 0x020E0774, 0x00020000
+
+DATA 4, 0x020E0784, 0x00000030
+DATA 4, 0x020E0788, 0x00000030
+DATA 4, 0x020E0794, 0x00000030
+DATA 4, 0x020E079c, 0x00000030
+DATA 4, 0x020E07a0, 0x00000030
+DATA 4, 0x020E07a4, 0x00000030
+DATA 4, 0x020E07a8, 0x00000030
+DATA 4, 0x020E0748, 0x00000030
+
+DATA 4, 0x020E05ac, 0x00000030
+DATA 4, 0x020E05b4, 0x00000030
+DATA 4, 0x020E0528, 0x00000030
+DATA 4, 0x020E0520, 0x00000030
+DATA 4, 0x020E0514, 0x00000030
+DATA 4, 0x020E0510, 0x00000030
+DATA 4, 0x020E05bc, 0x00000030
+DATA 4, 0x020E05c4, 0x00000030
+
+
+
+DATA 4, 0x020E0590, 0x00000020
+DATA 4, 0x020E0598, 0x00000020
+
+
+/* DDR setup */
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b401c, 0x00008000
+
+/*SCM CONF*/
+
+DATA 4, 0x021b085c, 0x1b4700c7
+DATA 4, 0x021b485c, 0x1b4700c7
+
+DATA 4, 0x021b0800, 0xa1390003
+
+/* calibration required */
+DATA 4, 0x021b0890, 0x00400000
+DATA 4, 0x021b4890, 0x00400000
+
+/* calibration required */
+/*SCM CONF*/
+
+DATA 4, 0x021b0848, 0x44404044
+DATA 4, 0x021b4848, 0x44443A46
+
+DATA 4, 0x021b0850, 0x34343A38
+DATA 4, 0x021b4850, 0x3E2E483C
+
+DATA 4, 0x021b083c, 0x20000000
+DATA 4, 0x021b0840, 0x00000000
+DATA 4, 0x021b483c, 0x20000000
+DATA 4, 0x021b4840, 0x00000000
+
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x33333333
+DATA 4, 0x021b4828, 0x33333333
+DATA 4, 0x021b082c, 0xf3333333
+DATA 4, 0x021b0830, 0xf3333333
+DATA 4, 0x021b0834, 0xf3333333
+DATA 4, 0x021b0838, 0xf3333333
+DATA 4, 0x021b482c, 0xf3333333
+DATA 4, 0x021b4830, 0xf3333333
+DATA 4, 0x021b4834, 0xf3333333
+DATA 4, 0x021b4838, 0xf3333333
+
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b48b8, 0x00000800
+
+DATA 4, 0x021b0004, 0x00020036
+DATA 4, 0x021b0008, 0x00000000
+DATA 4, 0x021b000c, 0x33374133
+
+DATA 4, 0x021b0010, 0x00100a82
+
+DATA 4, 0x021b0014, 0x00000093
+
+DATA 4, 0x021b0018, 0x0000174C
+DATA 4, 0x021b001c, 0x00008050
+DATA 4, 0x021b002c, 0x0f9f26d2
+DATA 4, 0x021b0030, 0x00000010
+DATA 4, 0x021b0038, 0x00190778
+#ifdef CONFIG_INTERLEAVING_MODE
+DATA 4, 0x021b0040, 0x00000053
+#else
+DATA 4, 0x021b0040, 0x0000004f
+#endif
+
+DATA 4, 0x021b0000, 0x83110000
+
+DATA 4, 0x021b4008, 0x00000000
+
+DATA 4, 0x021b400c, 0x33374133
+DATA 4, 0x021b4004, 0x00020036
+DATA 4, 0x021b4010, 0x00100a82
+
+DATA 4, 0x021b4014, 0x00000093
+
+DATA 4, 0x021b4018, 0x0000174C
+DATA 4, 0x021b401c, 0x00008050
+
+DATA 4, 0x021b402c, 0x0f9f26d2
+
+DATA 4, 0x021b4030, 0x00000010
+
+DATA 4, 0x021b4038, 0x00190778
+#ifdef CONFIG_INTERLEAVING_MODE
+DATA 4, 0x021b4040, 0x00000013
+#else
+DATA 4, 0x021b4040, 0x00000017
+#endif
+
+DATA 4, 0x021b4000, 0x83110000
+
+/* Channel 0 */
+DATA 4, 0x021b001c, 0x003f8030
+DATA 4, 0x021b001c, 0xff0a8030
+DATA 4, 0x021b001c, 0x82018030
+DATA 4, 0x021b001c, 0x04028030
+DATA 4, 0x021b001c, 0x04038030
+
+/* Channel 1 */
+DATA 4, 0x021b401c, 0x003f8030
+DATA 4, 0x021b401c, 0xff0a8030
+DATA 4, 0x021b401c, 0x82018030
+DATA 4, 0x021b401c, 0x04028030
+DATA 4, 0x021b401c, 0x04038030
+
+DATA 4, 0x021b0800, 0xa1390003
+
+DATA 4, 0x021b0020, 0x00001800
+DATA 4, 0x021b4020, 0x00001800
+
+DATA 4, 0x021b0818, 0x00000000
+DATA 4, 0x021b4818, 0x00000000
+
+DATA 4, 0x021b0004, 0x00025576
+DATA 4, 0x021b4004, 0x00025576
+
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b4404, 0x00011006
+
+DATA 4, 0x021b001c, 0x00000000
+DATA 4, 0x021b401c, 0x00000000
+
+/* enable clocks */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000C3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif /*CONFIG_SCM_LPDDR2_2GB*/
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6dqscm/Kconfig ebf_6ull_uboot/board/freescale/mx6dqscm/Kconfig
--- u-boot-2016.03/board/freescale/mx6dqscm/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6dqscm/Kconfig	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,15 @@
+if TARGET_MX6DQSCM
+
+config SYS_BOARD
+	default "mx6dqscm"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "mx6dqscm"
+
+endif
diff -urN u-boot-2016.03/board/freescale/mx6dqscm/MAINTAINERS ebf_6ull_uboot/board/freescale/mx6dqscm/MAINTAINERS
--- u-boot-2016.03/board/freescale/mx6dqscm/MAINTAINERS	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6dqscm/MAINTAINERS	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,11 @@
+MX6DQSCM BOARDS
+M:	Alejandro Sierra <alejandro.sierra@nxp.com>
+M:	Juan Gutierrez <juan.gutierrez@nxp.com>
+S:	Maintained
+F:	board/freescale/mx6dqscm/
+F:	include/configs/mx6dqscm.h
+F:	configs/mx6dqscm_1gb_fix_evb_defconfig
+F:	configs/mx6dqscm_1gb_fix_qwks_rev2_defconfig
+F:	configs/mx6dqscm_1gb_fix_qwks_rev2_spinor_defconfig
+F:	configs/mx6dqscm_1gb_interleaving_evb_android_defconfig
+F:	configs/mx6dqscm_1gb_interleaving_qwks_rev2_android_defconfig
diff -urN u-boot-2016.03/board/freescale/mx6dqscm/Makefile ebf_6ull_uboot/board/freescale/mx6dqscm/Makefile
--- u-boot-2016.03/board/freescale/mx6dqscm/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6dqscm/Makefile	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,11 @@
+#
+# (C) Copyright 2016 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:  GPL-2.0+
+#
+
+obj-y  := mx6dqscm.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6dqscm/mx6dqscm.c ebf_6ull_uboot/board/freescale/mx6dqscm/mx6dqscm.c
--- u-boot-2016.03/board/freescale/mx6dqscm/mx6dqscm.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6dqscm/mx6dqscm.c	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,1040 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/video.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include "../common/pfuze.h"
+#include <asm/arch/mx6-ddr.h>
+#include <usb.h>
+#include <micrel.h>
+#ifdef CONFIG_CMD_SATA
+#include <asm/imx-common/sata.h>
+#endif
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define I2C_PMIC	1
+
+#define I2C_PAD MUX_PAD_CTRL(I2C_PAD_CTRL)
+
+#ifdef CONFIG_SCMEVB
+#define DISP0_PWR_EN	IMX_GPIO_NR(1, 21)
+#else
+#define DISP0_PWR_EN	IMX_GPIO_NR(1, 18)
+#endif
+
+int dram_init(void)
+{
+#ifdef CONFIG_INTERLEAVING_MODE
+	u32 mdmisc = readl(MMDC_P0_BASE_ADDR + 0x18);
+
+	gd->ram_size = imx_ddr_size() << ((mdmisc & 0x00000004) ? 1 : 0);
+#else
+	gd->ram_size = imx_ddr_size();
+#endif
+
+	return 0;
+}
+
+#if !defined(CONFIG_INTERLEAVING_MODE) && !defined(CONFIG_SCM_LPDDR2_512MB)
+void dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_0;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_0_SIZE;
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[1].size = PHYS_SDRAM_1_SIZE;
+}
+#endif
+#ifdef CONFIG_SCMHVB
+iomux_v3_cfg_t const uart_pads[] = {
+	MX6_PAD_KEY_COL0__UART4_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_KEY_ROW0__UART4_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+#else
+static iomux_v3_cfg_t const uart_pads[] = {
+	MX6_PAD_CSI0_DAT10__UART1_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSI0_DAT11__UART1_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+#endif
+
+static iomux_v3_cfg_t const enet_pads[] = {
+	MX6_PAD_ENET_MDIO__ENET_MDIO		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_MDC__ENET_MDC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TXC__RGMII_TXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD0__RGMII_TD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD1__RGMII_TD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD2__RGMII_TD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD3__RGMII_TD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TX_CTL__RGMII_TX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+#ifdef CONFIG_QWKS_REV3
+	MX6_PAD_GPIO_16__ENET_REF_CLK	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+#else
+	MX6_PAD_ENET_REF_CLK__ENET_TX_CLK	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+#endif
+	MX6_PAD_RGMII_RXC__RGMII_RXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD0__RGMII_RD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD1__RGMII_RD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD2__RGMII_RD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD3__RGMII_RD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	/* AR8031 PHY Reset */
+	MX6_PAD_ENET_CRS_DV__GPIO1_IO25		| MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_enet(void)
+{
+	imx_iomux_v3_setup_multiple_pads(enet_pads, ARRAY_SIZE(enet_pads));
+
+	/* Reset AR8031 PHY */
+	gpio_direction_output(IMX_GPIO_NR(1, 25) , 0);
+	mdelay(10);
+	gpio_set_value(IMX_GPIO_NR(1, 25), 1);
+	udelay(100);
+}
+
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_SD2_CLK__SD2_CLK	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_CMD__SD2_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT0__SD2_DATA0	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT1__SD2_DATA1	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT2__SD2_DATA2	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT3__SD2_DATA3	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_D4__SD2_DATA4	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_D5__SD2_DATA5	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_D6__SD2_DATA6	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_D7__SD2_DATA7	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+#ifdef CONFIG_SCMEVB
+	MX6_PAD_NANDF_D2__GPIO2_IO02 | MUX_PAD_CTRL(NO_PAD_CTRL), /* CD */
+#else
+	MX6_PAD_GPIO_4__GPIO1_IO04	| MUX_PAD_CTRL(NO_PAD_CTRL), /* CD */
+#endif
+};
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6_PAD_SD3_CLK__SD3_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_CMD__SD3_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+#ifndef CONFIG_QWKS_REV3
+	MX6_PAD_SD3_DAT4__GPIO7_IO01 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+#endif
+	MX6_PAD_SD3_DAT5__SD3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT6__SD3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT7__SD3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_D0__GPIO2_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL), /* CD */
+};
+
+static iomux_v3_cfg_t const usdhc4_pads[] = {
+	MX6_PAD_SD4_CLK__SD4_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_CMD__SD4_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT0__SD4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT1__SD4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT2__SD4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT3__SD4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT4__SD4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT5__SD4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT6__SD4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT7__SD4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+#ifdef CONFIG_MXC_SPI
+static iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX6_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_EB2__GPIO2_IO30 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_spi(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(2, 30)) : -1;
+}
+#endif
+
+static iomux_v3_cfg_t const rgb_pads[] = {
+	MX6_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DI0_PIN15__IPU1_DI0_PIN15 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DI0_PIN2__IPU1_DI0_PIN02 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DI0_PIN3__IPU1_DI0_PIN03 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DI0_PIN4__IPU1_DI0_PIN04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT0__IPU1_DISP0_DATA00 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT1__IPU1_DISP0_DATA01 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT2__IPU1_DISP0_DATA02 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT3__IPU1_DISP0_DATA03 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT4__IPU1_DISP0_DATA04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT5__IPU1_DISP0_DATA05 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT6__IPU1_DISP0_DATA06 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT7__IPU1_DISP0_DATA07 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT8__IPU1_DISP0_DATA08 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT9__IPU1_DISP0_DATA09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT10__IPU1_DISP0_DATA10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT11__IPU1_DISP0_DATA11 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT12__IPU1_DISP0_DATA12 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT13__IPU1_DISP0_DATA13 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT14__IPU1_DISP0_DATA14 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT15__IPU1_DISP0_DATA15 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT16__IPU1_DISP0_DATA16 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT17__IPU1_DISP0_DATA17 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT18__IPU1_DISP0_DATA18 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT19__IPU1_DISP0_DATA19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT20__IPU1_DISP0_DATA20 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT21__IPU1_DISP0_DATA21 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT22__IPU1_DISP0_DATA22 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT23__IPU1_DISP0_DATA23 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_SD1_DAT3__GPIO1_IO21 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void enable_rgb(struct display_info_t const *dev)
+{
+	imx_iomux_v3_setup_multiple_pads(rgb_pads, ARRAY_SIZE(rgb_pads));
+	gpio_direction_output(DISP0_PWR_EN, 1);
+}
+
+static struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_KEY_COL3__I2C2_SCL | I2C_PAD,
+		.gpio_mode = MX6_PAD_KEY_COL3__GPIO4_IO12 | I2C_PAD,
+		.gp = IMX_GPIO_NR(4, 12)
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_KEY_ROW3__I2C2_SDA | I2C_PAD,
+		.gpio_mode = MX6_PAD_KEY_ROW3__GPIO4_IO13 | I2C_PAD,
+		.gp = IMX_GPIO_NR(4, 13)
+	}
+};
+
+iomux_v3_cfg_t const pcie_pads[] = {
+	MX6_PAD_EIM_D19__GPIO3_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL), /* POWER */
+	MX6_PAD_GPIO_17__GPIO7_IO12 | MUX_PAD_CTRL(NO_PAD_CTRL), /* RESET */
+};
+
+static void setup_pcie(void)
+{
+	imx_iomux_v3_setup_multiple_pads(pcie_pads, ARRAY_SIZE(pcie_pads));
+}
+
+iomux_v3_cfg_t const di0_pads[] = {
+	MX6_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK,	/* DISP0_CLK */
+	MX6_PAD_DI0_PIN2__IPU1_DI0_PIN02,		/* DISP0_HSYNC */
+	MX6_PAD_DI0_PIN3__IPU1_DI0_PIN03,		/* DISP0_VSYNC */
+};
+
+iomux_v3_cfg_t const lvds_pwr_en_pads[] = {
+	MX6_PAD_SD1_CMD__GPIO1_IO18 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart_pads, ARRAY_SIZE(uart_pads));
+}
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC2_BASE_ADDR},
+	{USDHC3_BASE_ADDR},
+	{USDHC4_BASE_ADDR},
+};
+
+#ifdef CONFIG_SCMEVB
+	#define USDHC2_CD_GPIO IMX_GPIO_NR(2, 2)
+#else
+	#define USDHC2_CD_GPIO  IMX_GPIO_NR(1, 4)
+#endif
+
+#ifdef CONFIG_QWKS_REV3
+#define USDHC3_CD_GPIO  IMX_GPIO_NR(7, 1)
+#else
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(2, 0)
+#endif
+
+int board_mmc_get_env_dev(int devno)
+{
+	return devno - 1;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	return devno + 1;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD_GPIO);
+		break;
+	case USDHC3_BASE_ADDR:
+#ifdef CONFIG_SCMHVB
+		ret = 1;
+#else
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+#endif
+		break;
+	case USDHC4_BASE_ADDR:
+		ret = 1; /* eMMC/uSDHC4 is always present */
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    SD2
+	 * mmc1                    SD3
+	 * mmc2                    eMMC
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_direction_input(USDHC2_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		case 1:
+#ifndef CONFIG_SCMHVB
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+#endif
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		case 2:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more ");
+			printf("USDHC controllers ");
+			printf("(%d) than supported by the board (%d)\n",
+			       i + 1, CONFIG_SYS_FSL_USDHC_NUM);
+			return -EINVAL;
+		}
+
+		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+#endif
+
+int mx6_rgmii_rework(struct phy_device *phydev)
+{
+	/* add necessary delays for RGMII,
+	 * there are no board skew delays added
+	 * additional rx data delay = 0, rx clk delay = 0.3ns, total = 1.5ns
+	 * additional tx data delay = -0.42ns, tx clk delay = 0.96ns,
+	 * total = 1.38ns
+	 */
+
+	if (ksz9031_phy_extended_write(phydev, 0x2,
+				       MII_KSZ9031_EXT_RGMII_CTRL_SIG_SKEW,
+				       MII_KSZ9031_MOD_DATA_NO_POST_INC,
+				       0x0070))
+		return -EIO;
+
+	if (ksz9031_phy_extended_write(phydev, 0x2,
+				       MII_KSZ9031_EXT_RGMII_RX_DATA_SKEW,
+				       MII_KSZ9031_MOD_DATA_NO_POST_INC,
+				       0x7777))
+		return -EIO;
+
+	if (ksz9031_phy_extended_write(phydev, 0x2,
+				       MII_KSZ9031_EXT_RGMII_TX_DATA_SKEW,
+				       MII_KSZ9031_MOD_DATA_NO_POST_INC,
+				       0x0000))
+		return -EIO;
+
+	if (ksz9031_phy_extended_write(phydev, 0x2,
+				       MII_KSZ9031_EXT_RGMII_CLOCK_SKEW,
+				       MII_KSZ9031_MOD_DATA_NO_POST_INC,
+				       0x03f4))
+		return -EIO;
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	mx6_rgmii_rework(phydev);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+#if defined(CONFIG_VIDEO_IPUV3)
+static void disable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	int reg = readl(&iomux->gpr[2]);
+
+	reg &= ~(IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+		 IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
+
+	writel(reg, &iomux->gpr[2]);
+#ifndef CONFIG_SCMEVB
+	gpio_direction_output(DISP0_PWR_EN, 0);
+#endif
+}
+
+static void do_enable_hdmi(struct display_info_t const *dev)
+{
+	disable_lvds(dev);
+	imx_enable_hdmi_phy();
+}
+
+static void enable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)
+				IOMUXC_BASE_ADDR;
+	u32 reg = readl(&iomux->gpr[2]);
+
+	reg |= IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT |
+	       IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT;
+	writel(reg, &iomux->gpr[2]);
+#ifndef CONFIG_SCMEVB
+	gpio_direction_output(DISP0_PWR_EN, 1);
+#endif
+}
+
+struct display_info_t const displays[] = {{
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB666,
+	.detect	= NULL,
+	.enable	= enable_lvds,
+	.mode	= {
+		.name           = "Hannstar-XGA",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= NULL,
+	.enable	= do_enable_hdmi,
+	.mode	= {
+		.name           = "HDMI",
+		.refresh        = 60,
+		.xres           = 640,
+		.yres           = 480,
+		.pixclock       = 39721,
+		.left_margin    = 48,
+		.right_margin   = 16,
+		.upper_margin   = 33,
+		.lower_margin   = 10,
+		.hsync_len      = 96,
+		.vsync_len      = 2,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= 0,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= NULL,
+	.enable	= enable_rgb,
+	.mode	= {
+		.name           = "SEIKO-WVGA",
+		.refresh        = 60,
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int reg;
+
+	/* Setup HSYNC, VSYNC, DISP_CLK for debugging purposes */
+	imx_iomux_v3_setup_multiple_pads(di0_pads, ARRAY_SIZE(di0_pads));
+
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	/* Turn on LDB0, LDB1, IPU,IPU DI0 clocks */
+	reg = readl(&mxc_ccm->CCGR3);
+	reg |=  MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
+	writel(reg, &mxc_ccm->CCGR3);
+
+	/* set LDB0, LDB1 clk select to 011/011 */
+	reg = readl(&mxc_ccm->cs2cdr);
+	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
+		 | MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
+	      | (3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->cs2cdr);
+
+	reg = readl(&mxc_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+	writel(reg, &mxc_ccm->cscmr2);
+
+	reg = readl(&mxc_ccm->chsccdr);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->chsccdr);
+
+	reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
+	     | IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT
+	     | IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
+	     | IOMUXC_GPR2_LVDS_CH0_MODE_DISABLED
+	     | IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI0;
+	writel(reg, &iomux->gpr[2]);
+
+	reg = readl(&iomux->gpr[3]);
+	reg = (reg & ~(IOMUXC_GPR3_LVDS1_MUX_CTL_MASK
+	     | IOMUXC_GPR3_HDMI_MUX_CTL_MASK))
+	     | (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
+	     << IOMUXC_GPR3_LVDS1_MUX_CTL_OFFSET);
+	writel(reg, &iomux->gpr[3]);
+#ifndef CONFIG_SCMEVB
+	imx_iomux_v3_setup_multiple_pads(lvds_pwr_en_pads,
+					 ARRAY_SIZE(lvds_pwr_en_pads));
+#endif
+}
+#endif /* CONFIG_VIDEO_IPUV3 */
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
+
+static void setup_fec(void)
+{
+	return;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	setup_iomux_enet();
+	setup_pcie();
+
+	return cpu_eth_init(bis);
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+static iomux_v3_cfg_t const usb_otg_pads[] = {
+#ifdef CONFIG_QWKS_REV3
+	MX6_PAD_KEY_ROW4__USB_OTG_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_KEY_COL4__USB_OTG_OC | MUX_PAD_CTRL(NO_PAD_CTRL),
+#else
+	MX6_PAD_EIM_D22__USB_OTG_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+#endif
+#ifdef CONFIG_SCMEVB
+	MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+#else
+	MX6_PAD_GPIO_1__USB_OTG_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+#endif
+};
+
+static iomux_v3_cfg_t const usb_hc1_pads[] = {
+	MX6_PAD_ENET_TXD1__GPIO1_IO29 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+					 ARRAY_SIZE(usb_otg_pads));
+
+	/*
+	 * set daisy chain for otg_pin_id on 6q.
+	 * for 6dl, this bit is reserved
+	 */
+#ifdef CONFIG_SCMEVB
+	imx_iomux_set_gpr_register(1, 13, 1, 0);
+#else
+	imx_iomux_set_gpr_register(1, 13, 1, 1);
+#endif
+
+	imx_iomux_v3_setup_multiple_pads(usb_hc1_pads,
+					 ARRAY_SIZE(usb_hc1_pads));
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	switch (port) {
+	case 0:
+		break;
+	case 1:
+		if (on)
+			gpio_direction_output(IMX_GPIO_NR(1, 29), 1);
+		else
+			gpio_direction_output(IMX_GPIO_NR(1, 29), 0);
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+#if defined(CONFIG_VIDEO_IPUV3)
+	setup_display();
+#endif
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_MXC_SPI
+	setup_spi();
+#endif
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
+#endif
+
+#ifdef CONFIG_CMD_SATA
+	setup_sata();
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec();
+#endif
+	return 0;
+}
+
+int power_init_board(void)
+{
+	struct pmic *pfuze;
+	unsigned int reg;
+	int ret;
+
+	pfuze = pfuze_common_init(I2C_PMIC);
+	if (!pfuze)
+		return -ENODEV;
+
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	/* set SW3A to 1.25V for LPDDR2 */
+	pmic_reg_read(pfuze, PFUZE100_SW3AVOL, &reg);
+	reg &= ~0x3f;
+	reg |= 0x22;
+	pmic_reg_write(pfuze, PFUZE100_SW3AVOL, reg);
+
+	/* set SW2 to 3.2V */
+	pmic_reg_read(pfuze, PFUZE100_SW2VOL, &reg);
+	reg &= ~0x7f;
+	reg |= 0x72;
+	pmic_reg_write(pfuze, PFUZE100_SW2VOL, reg);
+
+	/* set VGEN1 to 1.5V */
+	pmic_reg_read(pfuze, PFUZE100_VGEN1VOL, &reg);
+	reg &= ~0x0f;
+	reg |= 0x0e;
+	pmic_reg_write(pfuze, PFUZE100_VGEN1VOL, reg);
+
+	/* set VGEN3 to 2.8V */
+	pmic_reg_read(pfuze, PFUZE100_VGEN3VOL, &reg);
+	reg &= ~0x0f;
+	reg |= 0x0a;
+	pmic_reg_write(pfuze, PFUZE100_VGEN3VOL, reg);
+
+	/* set VGEN4 to 2.5V */
+	pmic_reg_read(pfuze, PFUZE100_VGEN4VOL, &reg);
+	reg &= ~0x0f;
+	reg |= 0x07;
+	pmic_reg_write(pfuze, PFUZE100_VGEN4VOL, reg);
+
+	/* set VGEN5 to 3.3V */
+	pmic_reg_read(pfuze, PFUZE100_VGEN5VOL, &reg);
+	reg &= ~0x0f;
+#ifdef CONFIG_QWKS_REV3
+	reg |= 0x07;
+#else
+	reg |= 0x0f;
+#endif
+	pmic_reg_write(pfuze, PFUZE100_VGEN5VOL, reg);
+
+	/* set VGEN6 to 3.2V */
+	pmic_reg_read(pfuze, PFUZE100_VGEN6VOL, &reg);
+	reg &= ~0x0f;
+	reg |= 0x0e;
+	pmic_reg_write(pfuze, PFUZE100_VGEN6VOL, reg);
+
+	/* set SW1AB staby volatage 0.975V*/
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= 0x1b;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, reg);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, reg);
+
+	/* set SW1C staby volatage 0.975V*/
+	pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= 0x1b;
+	pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, reg);
+
+	/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1CCONF, reg);
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	int is_400M;
+	unsigned char vddarm;
+	struct pmic *p = pmic_get("PFUZE100");
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* increase VDDARM/VDDSOC to support 1.2G chip */
+	if (check_1_2G()) {
+		ldo_bypass = 0;	/* ldo_enable on 1.2G chip */
+		printf("1.2G chip, increase VDDARM_IN/VDDSOC_IN\n");
+		/* increase VDDARM to 1.425V */
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= 0x2d;
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		/* increase VDDSOC to 1.425V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x2d;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+	}
+	/* switch to ldo_bypass mode , boot on 800Mhz */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+
+		/* decrease VDDARM for 400Mhz DQ:1.1V */
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= 0x20;
+
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		/* increase VDDSOC to 1.3V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x28;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		/*
+		 * MX6Q:
+		 * VDDARM:1.15V@800M; VDDSOC:1.175V@800M
+		 * VDDARM:0.975V@400M; VDDSOC:1.175V@400M
+		 */
+		is_400M = set_anatop_bypass(2);
+
+		if (is_400M)
+			vddarm = 0x1b;
+		else
+			vddarm = 0x22;
+
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= vddarm;
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		/* decrease VDDSOC to 1.175V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x23;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd2",	 MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	{"sd3",	 MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	/* 8 bit bus width */
+	{"emmc", MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+	return 0;
+}
+
+int checkboard(void)
+{
+#ifdef CONFIG_SCMHVB
+	puts("Board: MX6DQSCM-HVB\n");
+#elif CONFIG_SCMEVB
+	puts("Board: MX6DQSCM-EVB\n");
+#elif CONFIG_QWKS_REV3
+	puts("Board: MX6DQSCM-QWKS-REV3\n");
+#else
+	puts("Board: MX6DQSCM-QWKS\n");
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_FSL_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "sata");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota sata");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+	case MMC4_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc2");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc2");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(1, 5)
+iomux_v3_cfg_t const recovery_key_pads[] = {
+	(MX6_PAD_GPIO_5__GPIO1_IO05 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+int check_recovery_cmd_file(void)
+{
+	int button_pressed = 0;
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+#ifdef CONFIG_EVB_SETTINGS
+	/* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
+					 ARRAY_SIZE(recovery_key_pads));
+
+	gpio_direction_input(GPIO_VOL_DN_KEY);
+
+	if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN is low assert */
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+	}
+#endif
+
+	return recovery_mode || button_pressed;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+			       "boota sata recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+			       "boota mmc0 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+			       "boota mmc1 recovery");
+		break;
+	case MMC4_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+			       "boota mmc2 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+		       bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
diff -urN u-boot-2016.03/board/freescale/mx6dqscm/plugin.S ebf_6ull_uboot/board/freescale/mx6dqscm/plugin.S
--- u-boot-2016.03/board/freescale/mx6dqscm/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6dqscm/plugin.S	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,803 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <config.h>
+
+.macro imx6dq_scm_lpddr2_512mb_setting
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x06c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x070]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x074]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x078]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x07c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x080]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x084]
+
+	/* DDR clock to 400MHz */
+	ldr r1, =0x00060324
+	str r1, [r0, #0x018]
+	/* AHB_ROOT_CLK change divide ratio from 4 to 3 for ENET */
+	ldr r1, =0x00018900
+	str r1, [r0, #0x014]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+	ldr r1, =0x00000030
+
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x74c]
+
+	str r1, [r0, #0x57c]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+	ldr r1, =0x00003030
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+
+	ldr r1, =0x00000020
+	str r1, [r0, #0x590]
+	str r1, [r0, #0x598]
+
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+
+	/* DDR setup */
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+
+	/*SCM CONF*/
+	ldr r2, =0x1B4700C7
+	str r2, [r0, #0x85c]
+
+	ldr r2, =0xA1390003
+	str r2, [r0, #0x800]
+
+	/* calibration required */
+	ldr r2, =0x00400000
+	str r2, [r0, #0x890]
+
+	ldr r2, =0x44404044
+	str r2, [r0, #0x848]
+
+	ldr r2, =0x34343A38
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x20000000
+	str r2, [r0, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	ldr r2, =0xf3333333
+	str r2, [r0, #0x82c]
+	str r2, [r0, #0x830]
+	str r2, [r0, #0x834]
+	str r2, [r0, #0x838]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x00020036
+	str r2, [r0, #0x4]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x8]
+	ldr r2, =0x33374133
+	str r2, [r0, #0xc]
+
+	ldr r2, =0x00100a82
+	str r2, [r0, #0x10]
+
+	ldr r2, =0x00000093
+	str r2, [r0, #0x14]
+
+	ldr r2, =0x0000174C
+	str r2, [r0, #0x18]
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	ldr r2, =0x0f9f26d2
+	str r2, [r0, #0x2c]
+	ldr r2, =0x00000010
+	str r2, [r0, #0x30]
+	ldr r2, =0x00190778
+	str r2, [r0, #0x38]
+
+	ldr r2, =0x0000004F
+	str r2, [r0, #0x40]
+
+	ldr r2, =0x83110000
+	str r2, [r0, #0x0]
+
+	/* Channel 0 */
+	ldr r2, =0x003F8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0xFF0A8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x82018030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x04028030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x04038030
+	str r2, [r0, #0x1c]
+
+	ldr r2, =0xA1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x00001800
+	str r2, [r0, #0x20]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x818]
+
+	ldr r2, =0x00025576
+	str r2, [r0, #0x4]
+
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x1c]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x1c]
+.endm
+
+
+.macro imx6dq_scm_lpddr2_1gb_setting
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x06c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x070]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x074]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x078]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x07c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x080]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x084]
+
+	/* DDR clock to 400MHz */
+	ldr r1, =0x00060324
+	str r1, [r0, #0x018]
+	/* AHB_ROOT_CLK change divide ratio from 4 to 3 for ENET */
+	ldr r1, =0x00018900
+	str r1, [r0, #0x014]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+	ldr r1, =0x00000030
+
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x74c]
+
+	str r1, [r0, #0x57c]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+	ldr r1, =0x00003030
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+
+	ldr r1, =0x00000020
+	str r1, [r0, #0x590]
+	str r1, [r0, #0x598]
+
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =MMDC_P1_BASE_ADDR
+
+	/* DDR setup */
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	str r2, [r1, #0x1c]
+
+	/*SCM CONF*/
+	ldr r2, =0x1B4700C7
+	str r2, [r0, #0x85c]
+	str r2, [r1, #0x85c]
+
+	ldr r2, =0xA1390003
+	str r2, [r0, #0x800]
+
+	/* calibration required */
+	ldr r2, =0x00400000
+	str r2, [r0, #0x890]
+	str r2, [r1, #0x890]
+
+	ldr r2, =0x44404044
+	str r2, [r0, #0x848]
+	ldr r2, =0x44443A46
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x34343A38
+	str r2, [r0, #0x850]
+	ldr r2, =0x3E2E483C
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x20000000
+	str r2, [r0, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x840]
+	ldr r2, =0x20000000
+	str r2, [r1, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+	ldr r2, =0xf3333333
+	str r2, [r0, #0x82c]
+	str r2, [r0, #0x830]
+	str r2, [r0, #0x834]
+	str r2, [r0, #0x838]
+	str r2, [r1, #0x82c]
+	str r2, [r1, #0x830]
+	str r2, [r1, #0x834]
+	str r2, [r1, #0x838]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020036
+	str r2, [r0, #0x4]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x8]
+	ldr r2, =0x33374133
+	str r2, [r0, #0xc]
+
+	ldr r2, =0x00100a82
+	str r2, [r0, #0x10]
+
+	ldr r2, =0x00000093
+	str r2, [r0, #0x14]
+
+	ldr r2, =0x0000174C
+	str r2, [r0, #0x18]
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	ldr r2, =0x0f9f26d2
+	str r2, [r0, #0x2c]
+	ldr r2, =0x00000010
+	str r2, [r0, #0x30]
+	ldr r2, =0x00190778
+	str r2, [r0, #0x38]
+#ifdef CONFIG_INTERLEAVING_MODE
+	ldr r2, =0x00000053
+#else
+	ldr r2, =0x0000004F
+#endif
+	str r2, [r0, #0x40]
+
+	ldr r2, =0x83110000
+	str r2, [r0, #0x0]
+
+	ldr r2, =0x00020036
+	str r2, [r1, #0x4]
+	ldr r2, =0x00000000
+	str r2, [r1, #0x8]
+	ldr r2, =0x33374133
+	str r2, [r1, #0xc]
+	ldr r2, =0x00100a82
+	str r2, [r1, #0x10]
+	ldr r2, =0x00000093
+	str r2, [r1, #0x14]
+
+	ldr r2, =0x0000174C
+	str r2, [r1, #0x18]
+	ldr r2, =0x00008000
+	str r2, [r1, #0x1c]
+
+	ldr r2, =0x0f9f26d2
+	str r2, [r1, #0x2c]
+
+	ldr r2, =0x00000010
+	str r2, [r1, #0x30]
+
+	ldr r2, =0x00190778
+	str r2, [r1, #0x38]
+
+#ifdef CONFIG_INTERLEAVING_MODE
+	ldr r2, =0x00000013
+#else
+	ldr r2, =0x00000017
+#endif
+	str r2, [r1, #0x40]
+
+	ldr r2, =0x83110000
+	str r2, [r1, #0x0]
+
+	/* Channel 0 */
+	ldr r2, =0x003F8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0xFF0A8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x82018030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x04028030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x04038030
+	str r2, [r0, #0x1c]
+
+	/* Channel 1 */
+	ldr r2, =0x003F8030
+	str r2, [r1, #0x1c]
+	ldr r2, =0xFF0A8030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x82018030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x04028030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x04038030
+	str r2, [r1, #0x1c]
+
+	ldr r2, =0xA1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x00001800
+	str r2, [r0, #0x20]
+	str r2, [r1, #0x20]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+
+	ldr r2, =0x00025576
+	str r2, [r0, #0x4]
+	str r2, [r1, #0x4]
+
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	str r2, [r1, #0x404]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x1c]
+	str r2, [r1, #0x1c]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x1c]
+.endm
+
+
+.macro imx6dq_scm_lpddr2_2gb_setting
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x06c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x070]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x074]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x078]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x07c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x080]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x084]
+
+	/* DDR clock to 400MHz */
+	ldr r1, =0x00060324
+	str r1, [r0, #0x018]
+	/* AHB_ROOT_CLK change divide ratio from 4 to 3 for ENET */
+	ldr r1, =0x00018900
+	str r1, [r0, #0x014]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+	ldr r1, =0x00000030
+
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x74c]
+
+	str r1, [r0, #0x57c]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+	ldr r1, =0x00003030
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+
+	ldr r1, =0x00000020
+	str r1, [r0, #0x590]
+	str r1, [r0, #0x598]
+
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =MMDC_P1_BASE_ADDR
+
+	/* DDR setup */
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	str r2, [r1, #0x1c]
+
+	/*SCM CONF*/
+	ldr r2, =0x1B4700C7
+	str r2, [r0, #0x85c]
+	str r2, [r1, #0x85c]
+
+	ldr r2, =0xA1390003
+	str r2, [r0, #0x800]
+
+	/* calibration required */
+	ldr r2, =0x00400000
+	str r2, [r0, #0x890]
+	str r2, [r1, #0x890]
+
+	ldr r2, =0x44404044
+	str r2, [r0, #0x848]
+	ldr r2, =0x44443A46
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x34343A38
+	str r2, [r0, #0x850]
+	ldr r2, =0x3E2E483C
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x20000000
+	str r2, [r0, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x840]
+	ldr r2, =0x20000000
+	str r2, [r1, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	ldr r2, =0x00000000
+	str r2, [r1, #0x824]
+	ldr r2, =0x33333333
+	str r2, [r1, #0x828]
+	ldr r2, =0xf3333333
+	str r2, [r0, #0x82c]
+	str r2, [r0, #0x830]
+	str r2, [r0, #0x834]
+	str r2, [r0, #0x838]
+	str r2, [r1, #0x82c]
+	str r2, [r1, #0x830]
+	ldr r2, =0x00000000
+	str r2, [r1, #0x834]
+	ldr r2, =0xf3333333
+	str r2, [r1, #0x838]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020036
+	str r2, [r0, #0x4]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x8]
+	ldr r2, =0x33374133
+	str r2, [r0, #0xc]
+
+	ldr r2, =0x00100a82
+	str r2, [r0, #0x10]
+
+	ldr r2, =0x00000093
+	str r2, [r0, #0x14]
+
+	ldr r2, =0x0000174C
+	str r2, [r0, #0x18]
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	ldr r2, =0x0f9f26d2
+	str r2, [r0, #0x2c]
+	ldr r2, =0x009F0E10
+	str r2, [r0, #0x30]
+	ldr r2, =0x00190778
+	str r2, [r0, #0x38]
+#ifdef CONFIG_INTERLEAVING_MODE
+	ldr r2, =0x00000063
+#else
+	ldr r2, =0x0000005F
+#endif
+	str r2, [r0, #0x40]
+
+	ldr r2, =0xC3110000
+	str r2, [r0, #0x0]
+
+	ldr r2, =0x00020036
+	str r2, [r1, #0x4]
+	ldr r2, =0x00000000
+	str r2, [r1, #0x8]
+	ldr r2, =0x33374133
+	str r2, [r1, #0xc]
+	ldr r2, =0x00100a82
+	str r2, [r1, #0x10]
+	ldr r2, =0x00000093
+	str r2, [r1, #0x14]
+
+	ldr r2, =0x0000174C
+	str r2, [r1, #0x18]
+	ldr r2, =0x00008000
+	str r2, [r1, #0x1c]
+
+	ldr r2, =0x0f9f26d2
+	str r2, [r1, #0x2c]
+
+	ldr r2, =0x00000010
+	str r2, [r1, #0x30]
+
+	ldr r2, =0x00190778
+	str r2, [r1, #0x38]
+
+#ifdef CONFIG_INTERLEAVING_MODE
+	ldr r2, =0x00000023
+#else
+	ldr r2, =0x00000027
+#endif
+	str r2, [r1, #0x40]
+
+	ldr r2, =0xC3110000
+	str r2, [r1, #0x0]
+
+	/* Channel 0 */
+	/* CS0 */
+	ldr r2, =0x003F8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0xFF0A8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x82018030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x04028030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x04038030
+	str r2, [r0, #0x1c]
+	/* CS1 */
+	ldr r2, =0x003F8038
+	str r2, [r0, #0x1c]
+	ldr r2, =0xFF0A8038
+	str r2, [r0, #0x1c]
+	ldr r2, =0x82018038
+	str r2, [r0, #0x1c]
+	ldr r2, =0x04028038
+	str r2, [r0, #0x1c]
+	ldr r2, =0x04038038
+	str r2, [r0, #0x1c]
+
+	/* Channel 1 */
+	/* CS0 */
+	ldr r2, =0x003F8030
+	str r2, [r1, #0x1c]
+	ldr r2, =0xFF0A8030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x82018030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x04028030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x04038030
+	str r2, [r1, #0x1c]
+	/* CS1 */
+	ldr r2, =0x003F8038
+	str r2, [r1, #0x1c]
+	ldr r2, =0xFF0A8038
+	str r2, [r1, #0x1c]
+	ldr r2, =0x82018038
+	str r2, [r1, #0x1c]
+	ldr r2, =0x04028038
+	str r2, [r1, #0x1c]
+	ldr r2, =0x04038038
+	str r2, [r1, #0x1c]
+
+	ldr r2, =0xA1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x00001800
+	str r2, [r0, #0x20]
+	str r2, [r1, #0x20]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+
+	ldr r2, =0x00025576
+	str r2, [r0, #0x4]
+	str r2, [r1, #0x4]
+
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	str r2, [r1, #0x404]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x1c]
+	str r2, [r1, #0x1c]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x1c]
+.endm
+
+
+.macro imx6_ddr_setting
+#if defined (CONFIG_SCM_LPDDR2_512MB)
+	imx6dq_scm_lpddr2_512mb_setting
+#elif defined (CONFIG_SCM_LPDDR2_2GB)
+	imx6dq_scm_lpddr2_2gb_setting
+#else
+	imx6dq_scm_lpddr2_1gb_setting
+#endif
+.endm
+
+.macro imx6_clock_gating
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6dqscm/README ebf_6ull_uboot/board/freescale/mx6dqscm/README
--- u-boot-2016.03/board/freescale/mx6dqscm/README	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6dqscm/README	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,89 @@
+How to use U-Boot on Freescale MX6DQSCM boards
+----------------------------------------------
+
+- Build U-Boot for MX6DQSCM QWKS rev2 board*:
+
+$ make mx6dqscm_1gb_fix_qwks_rev2_defconfig
+$ make
+
+This will generate the u-boot image u-boot.imx.
+
+- Flash the u-boot image into the micro SD card:
+
+sudo dd if=u-boot.imx of=/dev/sdX bs=1k seek=1; sync
+
+*Other defconfigs availabe are:
+    mx6dqscm_1gb_fix_qwks_rev2_defconfig
+    mx6dqscm_1gb_fix_qwks_rev2_spinor_defconfig
+    mx6dqscm_1gb_interleaving_qwks_rev2_android_defconfig
+
+
+- Jumper settings for fix mode images to boot from the top SD:
+
+Fix mode                        SW1: ON  ON  OFF OFF ON  OFF OFF ON
+Interleave mode                 SW1: ON  OFF ON  OFF ON  OFF OFF ON
+Single channel(512MB/epop)      SW1: ON  OFF OFF OFF ON  OFF OFF ON
+
+- Jumper settings for fix mode images to boot from internal SPI-NOR:
+
+Fix mode                        SW1: ON  ON  OFF X   X   ON  ON  OFF
+Interleave mode                 SW1: ON  OFF ON  X   X   ON  ON  OFF
+Single channel(512MB/epop)      SW1: ON  OFF OFF X   X   ON  ON  OFF
+
+- Jumper settings to boot from internal eMMC (just for ePOP):
+
+Single channel(epop)            SW1: ON  OFF OFF ON  ON  OFF ON  ON
+
+
+Additional configurations
+==========================
+
+For custom configurations like 2GB or 512MB, the CONFIG_SYS_EXTRA_OPTIONS option on the defconfig
+file can be modified according to the customization needed.
+
+Here are some examples for some combinations among the different supported options:
+
+ - memory size option: 512MB, 1GB, 2GB
+ - memeory mode: fix, interleave or single(only for 512MB)
+ - boot mode: SPI-NOR boot or SD
+ - board: evb, qwks
+
+
+512mb qwks-rev2:
+----------------
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg,MX6Q,DDR_MB=512,SYS_USE_SPINOR,DEFAULT_FDT_FILE=\"imx6dqscm-512mb-qwks-rev2-ldo.dtb\",SCM_LPDDR2_512MB"
+
+
+512mb qwks-rev2 spinor-boot:
+----------------------------
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg,MX6Q,DDR_MB=512,SYS_BOOT_SPINOR,DEFAULT_FDT_FILE=\"imx6dqscm-512mb-qwks-rev2-ldo.dtb\",SCM_LPDDR2_512MB"
+
+
+2gb fix evb:
+------------
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg,MX6Q,DDR_MB=2048,SYS_USE_SPINOR,DEFAULT_FDT_FILE=\"imx6dqscm-2gb-evb-fix-ldo.dtb\",SCMEVB,SCM_LPDDR2_2GB"
+
+
+2gb interleaving evb:
+---------------------
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg,MX6Q,DDR_MB=2048,SYS_USE_SPINOR,DEFAULT_FDT_FILE=\"imx6dqscm-2gb-evb-interleave-ldo.dtb\",INTERLEAVING_MODE,SCMEVB,SCM_LPDDR2_2GB"
+
+
+2gb interleaving evb spinor-boot:
+---------------------------------
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg,MX6Q,DDR_MB=2048,SYS_BOOT_SPINOR,DEFAULT_FDT_FILE=\"imx6dqscm-2gb-evb-interleave-ldo.dtb\",INTERLEAVING_MODE,SCMEVB,SCM_LPDDR2_2GB"
+
+1gb interleaving evb android:
+-----------------------------
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg,MX6Q,DDR_MB=1024,SYS_USE_SPINOR,DEFAULT_FDT_FILE=\"imx6dqscm-1gb-evb-interleave-ldo.dtb\",INTERLEAVING_MODE,SCMEVB,ANDROID_SUPPORT"
+
+
+1gb interleaving qwks_rev2:
+---------------------------
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg,MX6Q,DDR_MB=1024,SYS_USE_SPINOR,DEFAULT_FDT_FILE=\"imx6dqscm-1gb-qwks-rev2-interleave-ldo.dtb\",INTERLEAVING_MODE"
+
+
+1gb interleaving evb spinor-boot:
+---------------------------------
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg,MX6Q,DDR_MB=1024,SYS_BOOT_SPINOR,DEFAULT_FDT_FILE=\"imx6dqscm-1gb-evb-interleave-ldo.dtb\",INTERLEAVING_MODE,SCMEVB"
+
diff -urN u-boot-2016.03/board/freescale/mx6qarm2/imximage.cfg ebf_6ull_uboot/board/freescale/mx6qarm2/imximage.cfg
--- u-boot-2016.03/board/freescale/mx6qarm2/imximage.cfg	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6qarm2/imximage.cfg	2021-04-16 14:42:16.956592502 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2014 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2016 Freescale Semiconductor, Inc.
  * Jason Liu <r64343@freescale.com>
  *
  * SPDX-License-Identifier:	GPL-2.0+
@@ -10,6 +10,9 @@
  * The syntax is taken as close as possible with the kwbimage
  */
 
+#define __ASSEMBLY__
+#include <config.h>
+
 /* image version */
 IMAGE_VERSION 2
 
@@ -19,6 +22,15 @@
  */
 BOOT_FROM	sd
 
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qarm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
 /*
  * Device Configuration Data (DCD)
  *
@@ -30,8 +42,179 @@
  *	Address	  absolute address of the register
  *	value	  value to be stored in the register
  */
-#ifdef CONFIG_MX6DQ_LPDDR2
+#ifdef CONFIG_MX6DQ_POP_LPDDR2
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+/* DCD */
+DATA 4 0x020e0798 0x00080000
+DATA 4 0x020e0758 0x00000000
+
+DATA 4 0x020e0588 0x00000030
+DATA 4 0x020e0594 0x00000030
+
+DATA 4 0x020e056c 0x00000030
+DATA 4 0x020e0578 0x00000030
+DATA 4 0x020e074c 0x00000030
+
+DATA 4 0x020e057c 0x00000030
+DATA 4 0x020e058c 0x00000000
+DATA 4 0x020e059c 0x00000030
+DATA 4 0x020e05a0 0x00000030
+DATA 4 0x020e078c 0x00000030
+
+DATA 4 0x020e0750 0x00020000
+DATA 4 0x020e05a8 0x00003030
+DATA 4 0x020e05b0 0x00003030
+DATA 4 0x020e0524 0x00003030
+DATA 4 0x020e051c 0x00003030
+DATA 4 0x020e0518 0x00003030
+DATA 4 0x020e050c 0x00003030
+DATA 4 0x020e05b8 0x00003030
+DATA 4 0x020e05c0 0x00003030
+
+DATA 4 0x020e0774 0x00020000
+DATA 4 0x020e0784 0x00000030
+DATA 4 0x020e0788 0x00000030
+DATA 4 0x020e0794 0x00000030
+DATA 4 0x020e079c 0x00000030
+DATA 4 0x020e07a0 0x00000030
+DATA 4 0x020e07a4 0x00000030
+DATA 4 0x020e07a8 0x00000030
+DATA 4 0x020e0748 0x00000030
+
+DATA 4 0x020e05ac 0x00000030
+DATA 4 0x020e05b4 0x00000030
+DATA 4 0x020e0528 0x00000030
+DATA 4 0x020e0520 0x00000030
+DATA 4 0x020e0514 0x00000030
+DATA 4 0x020e0510 0x00000030
+DATA 4 0x020e05bc 0x00000030
+DATA 4 0x020e05c4 0x00000030
+
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b401c 0x00008000
+
+DATA 4 0x021b085c 0x1B5F0107
+DATA 4 0x021b485c 0x1B5F0107
+
+DATA 4 0x021b0800 0xA1390003
+
+DATA 4 0x021b0890 0x00400000
+DATA 4 0x021b4890 0x00400000
+
+DATA 4 0x021b0848 0x3C3A3A44
+DATA 4 0x021b4848 0x3C3A3A44
+
+DATA 4 0x021b0850 0x4238423A
+DATA 4 0x021b4850 0x4238423A
+
+DATA 4 0x021b083c 0x20000000
+DATA 4 0x021b0840 0x00000000
+DATA 4 0x021b483c 0x20000000
+DATA 4 0x021b4840 0x00000000
+
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b481c 0x33333333
+DATA 4 0x021b4820 0x33333333
+DATA 4 0x021b4824 0x33333333
+DATA 4 0x021b4828 0x33333333
+
+DATA 4 0x021b082c 0xf3333333
+DATA 4 0x021b0830 0xf3333333
+DATA 4 0x021b0834 0xf3333333
+DATA 4 0x021b0838 0xf3333333
+DATA 4 0x021b482c 0xf3333333
+DATA 4 0x021b4830 0xf3333333
+DATA 4 0x021b4834 0xf3333333
+DATA 4 0x021b4838 0xf3333333
+
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b48b8 0x00000800
+
+DATA 4 0x021b0004 0x00020036
+DATA 4 0x021b0008 0x00000000
+DATA 4 0x021b000c 0x444961A5
+DATA 4 0x021b0010 0x00160E83
+DATA 4 0x021b0014 0x000000DD
+
+DATA 4 0x021b0018 0x0000174C
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x149F26D2
+DATA 4 0x021b0030 0x00000010
+DATA 4 0x021b0038 0x0021099B
+DATA 4 0x021b0040 0x0000004F
+DATA 4 0x021b0400 0x11420000
+DATA 4 0x021b0000 0x83110000
+
+DATA 4 0x021b4004 0x00020036
+DATA 4 0x021b4008 0x00000000
+DATA 4 0x021b400c 0x444961A5
+DATA 4 0x021b4010 0x00160E83
+DATA 4 0x021b4014 0x000000DD
+
+DATA 4 0x021b4018 0x0000174C
+DATA 4 0x021b401c 0x00008000
+DATA 4 0x021b402c 0x149F26D2
+DATA 4 0x021b4030 0x00000010
+DATA 4 0x021b4038 0x0021099B
+DATA 4 0x021b4040 0x00000017
+DATA 4 0x021b4400 0x11420000
+DATA 4 0x021b4000 0x83110000
+
+DATA 4 0x021b001c 0x003F8030
+DATA 4 0x021b001c 0xFF0A8030
+DATA 4 0x021b001c 0xC2018030
+DATA 4 0x021b001c 0x06028030
+DATA 4 0x021b001c 0x02038030
+
+DATA 4 0x021b401c 0x003F8030
+DATA 4 0x021b401c 0xFF0A8030
+DATA 4 0x021b401c 0xC2018030
+DATA 4 0x021b401c 0x06028030
+DATA 4 0x021b401c 0x02038030
+
+DATA 4 0x021b0800 0xA1390003
+
+DATA 4 0x021b0020 0x00001800
+DATA 4 0x021b4020 0x00001800
+
+DATA 4 0x021b0818 0x00000000
+DATA 4 0x021b4818 0x00000000
+
+DATA 4 0x021b0004 0x00025576
+DATA 4 0x021b4004 0x00025576
+
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b4404 0x00011006
+
+DATA 4 0x021b001c 0x00000000
+DATA 4 0x021b401c 0x00000000
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+
+#elif defined(CONFIG_MX6DQ_LPDDR2)
 /* DCD */
+DATA 4 0x020C4018 0x21324
+DATA 4 0x020C4014 0x2018D00
+CHECK_BITS_CLR 4 0x020C4048 0x3F
+DATA 4 0x020C4018 0x61324
+DATA 4 0x020C4014 0x18D00
+CHECK_BITS_CLR 4 0x020C4048 0x3F
 DATA 4 0x020C4018 0x60324
 
 DATA 4 0x020E05a8 0x00003038
@@ -336,3 +519,4 @@
 DATA 4 0x020e001c 0x007F007F
 
 #endif /* CONFIG_MX6DQ_LPDDR2 */
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6qarm2/imximage_mx6dl.cfg ebf_6ull_uboot/board/freescale/mx6qarm2/imximage_mx6dl.cfg
--- u-boot-2016.03/board/freescale/mx6qarm2/imximage_mx6dl.cfg	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6qarm2/imximage_mx6dl.cfg	2021-04-16 14:42:16.956592502 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  * Jason Liu <r64343@freescale.com>
  *
  * SPDX-License-Identifier:	GPL-2.0+
@@ -10,6 +10,9 @@
  * The syntax is taken as close as possible with the kwbimage
  */
 
+#define __ASSEMBLY__
+#include <config.h>
+
 /* image version */
 IMAGE_VERSION 2
 
@@ -19,6 +22,15 @@
  */
 BOOT_FROM	sd
 
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qarm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
 /*
  * Device Configuration Data (DCD)
  *
@@ -460,3 +472,4 @@
 DATA 4 0x020e0018 0x007F007F
 DATA 4 0x020e001c 0x007F007F
 #endif /* CONFIG_MX6DL_LPDDR2 */
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6qarm2/Makefile ebf_6ull_uboot/board/freescale/mx6qarm2/Makefile
--- u-boot-2016.03/board/freescale/mx6qarm2/Makefile	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6qarm2/Makefile	2021-04-16 14:42:16.956592502 +0800
@@ -1,9 +1,13 @@
 #
 # Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
 #
-# (C) Copyright 2011 Freescale Semiconductor, Inc.
+# (C) Copyright 2011-2016 Freescale Semiconductor, Inc.
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
 obj-y	:= mx6qarm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6qarm2/mt128x64mx32.cfg ebf_6ull_uboot/board/freescale/mx6qarm2/mt128x64mx32.cfg
--- u-boot-2016.03/board/freescale/mx6qarm2/mt128x64mx32.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6qarm2/mt128x64mx32.cfg	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM	sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qarm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+#ifdef CONFIG_MX6DQ_POP_LPDDR2
+/* set ddr to 400Mhz */
+DATA 4 0x020C4018 0x21324
+DATA 4 0x020C4014 0x2018100
+CHECK_BITS_CLR 4 0x020C4048 0x3F
+DATA 4 0x020C4018 0x61324
+DATA 4 0x020C4014 0x18900
+CHECK_BITS_CLR 4 0x020C4048 0x3F
+DATA 4 0x020C4018 0x60324
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+// Switch PL301_FAST2 to DDR dual channel mapping
+//DATA 4 0x00B00000 0x1
+
+//=============================================================================
+/// IOMUX
+//=============================================================================
+//DDR IO TYPE:
+DATA 4 	0x020e0774	0x00020000	// IOMUXC_SW_PAD_CTL_GRP_DDRMODE
+DATA 4 	0x020e0758	0x00000000	// IOMUXC_SW_PAD_CTL_GRP_DDRPKE
+
+//CLOCK:
+DATA 4 	0x020e0588	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0
+DATA 4 	0x020e0594	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1
+
+//Control:
+DATA 4 	0x020e056c	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS
+DATA 4 	0x020e0578	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS
+DATA 4 	0x020e057c	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET
+DATA 4 	0x020e058c	0x00000000	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2 - DSE can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS
+DATA 4 	0x020e059c	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
+DATA 4 	0x020e05a0	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
+DATA 4 	0x020e074c	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_ADDDS
+DATA 4 	0x020e078c	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_CTLDS
+
+//Data Strobes:
+DATA 4 	0x020e0750	0x00020000	// IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL
+DATA 4 	0x020e05a8	0x00003030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0
+DATA 4 	0x020e05b0	0x00003030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1
+DATA 4 	0x020e0524	0x00003030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2
+DATA 4 	0x020e051c	0x00003030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3
+DATA 4 	0x020e0518	0x00003030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4
+DATA 4 	0x020e050c	0x00003030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5
+DATA 4 	0x020e05b8	0x00003030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6
+DATA 4 	0x020e05c0	0x00003030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7
+
+//Data:
+DATA 4 	0x020e0798	0x00080000	// IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE
+DATA 4 	0x020e0784	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B0DS
+DATA 4 	0x020e0788	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B1DS
+DATA 4 	0x020e0794	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B2DS
+DATA 4 	0x020e079c	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B3DS
+DATA 4 	0x020e07a0	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B4DS
+DATA 4 	0x020e07a4	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B5DS
+DATA 4 	0x020e07a8	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B6DS
+DATA 4 	0x020e0748	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B7DS
+
+DATA 4 	0x020e05ac	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0
+DATA 4 	0x020e05b4	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1
+DATA 4 	0x020e0528	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2
+DATA 4 	0x020e0520	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3
+DATA 4 	0x020e0514	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4
+DATA 4 	0x020e0510	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5
+DATA 4 	0x020e05bc	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6
+DATA 4 	0x020e05c4	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7
+
+//=============================================================================
+// DDR Controller Registers
+//=============================================================================
+// Manufacturer:	Micron - POP Package
+// Device Part Number:	MT42L128M64D2LL-25WT
+// Clock Freq.: 	400MHz
+// Density per CS in Gb: 	4
+// Chip Selects used:	1
+// Number of channels	2
+// Density per channel (Gb)	4
+// Total DRAM density (Gb)	8
+// Number of Banks:	8
+// Row address:    	14
+// Column address: 	10
+// Data bus width	32
+//=============================================================================
+
+// MMDC0_MDSCR, set the Configuration request bit during MMDC set up
+DATA 4 	0x021b001c	0x00008000	// Chan 0
+DATA 4 	0x021b401c	0x00008000	// Chan 1
+// Adjust ZQ delay for MMDC clock frequency at 400MHz
+DATA 4 	0x021b085c	0x1b4700c7	//LPDDR2 ZQ params
+DATA 4 	0x021b485c	0x1b4700c7	//LPDDR2 ZQ params
+
+//=============================================================================
+// Calibration setup.
+//
+//=============================================================================
+DATA 4 	0x021b0800	0xa1390003	// DDR_PHY_P0_MPZQHWCTRL, enable one time ZQ calibration
+DATA 4 	0x021b4800	0xa1380003	// DDR_PHY_P1_MPZQHWCTRL
+
+DATA 4  0x021b0890 	0x00400000 //ca bus abs delay
+DATA 4  0x021b4890 	0x00400000 //ca bus abs delay
+
+//DATA 4  0x021b48bc0x00055555 // DDR_PHY_P1_MPWRCADL
+
+DATA 4 	0x021b08b8	0x00000800	//frc_msr.
+DATA 4 	0x021b48b8	0x00000800	//frc_msr.
+
+// read delays, settings recommended by design to remain constant
+DATA 4 	0x021b081c	0x33333333	// DDR_PHY_P0_MPREDQBY0DL3
+DATA 4 	0x021b0820	0x33333333	// DDR_PHY_P0_MPREDQBY1DL3
+DATA 4 	0x021b0824	0x33333333	// DDR_PHY_P0_MPREDQBY2DL3
+DATA 4 	0x021b0828	0x33333333	// DDR_PHY_P0_MPREDQBY3DL3
+DATA 4 	0x021b481c	0x33333333	// DDR_PHY_P1_MPREDQBY0DL3
+DATA 4 	0x021b4820	0x33333333	// DDR_PHY_P1_MPREDQBY1DL3
+DATA 4 	0x021b4824	0x33333333	// DDR_PHY_P1_MPREDQBY2DL3
+DATA 4 	0x021b4828	0x33333333	// DDR_PHY_P1_MPREDQBY3DL3
+
+// write delays, settings recommended by design to remain constant
+DATA 4 	0x021b082c	0xF3333333	//DDR_PHY_P0 all byte 0 data & dm delayed by 3
+DATA 4 	0x021b0830	0xF3333333	//DDR_PHY_P0 all byte 0 data & dm delayed by 3
+DATA 4 	0x021b0834	0xF3333333	//DDR_PHY_P0 all byte 0 data & dm delayed by 3
+DATA 4 	0x021b0838	0xF3333333	//DDR_PHY_P0 all byte 0 data & dm delayed by 3
+DATA 4 	0x021b482c	0xF3333333	//DDR_PHY_P1 all byte 0 data & dm delayed by 3
+DATA 4 	0x021b4830	0xF3333333	//DDR_PHY_P1 all byte 0 data & dm delayed by 3
+DATA 4 	0x021b4834	0xF3333333	//DDR_PHY_P1 all byte 0 data & dm delayed by 3
+DATA 4 	0x021b4838	0xF3333333	//DDR_PHY_P1 all byte 0 data & dm delayed by 3
+
+DATA 4 	0x021b0848	0x36383644	// MPRDDLCTL PHY0
+DATA 4 	0x021b4848	0x3a383846	// MPRDDLCTL PHY1
+
+DATA 4 	0x021b0850	0x38343E34	// MPWRDLCTL PHY0
+DATA 4 	0x021b4850	0x48384A44	// MPWRDLCTL PHY1
+
+DATA 4 	0x021b083c	0x20000000	//PHY0 dqs gating dis
+DATA 4 	0x021b0840	0x0
+DATA 4 	0x021b483c	0x20000000	//PHY0 dqs gating dis
+DATA 4 	0x021b4840	0x0
+
+//For i.mx6qd parts of versions C and later (v1.2, v1.3).
+DATA 4 	0x021b08c0	0x24921492	// fine tune SDCLK duty cyc to low - seen to improve measured duty cycle of i.mx6
+DATA 4 	0x021b48c0	0x24921492
+
+DATA 4 	0x021b08b8	0x00000800	//frc_msr.
+DATA 4 	0x021b48b8	0x00000800	//frc_msr.
+//=============================================================================
+// Calibration setup end
+//=============================================================================
+
+// Channel0 - starting address 0x80000000
+DATA 4 	0x021b000c	0x33374133	// MMDC0_MDCFG0
+DATA 4 	0x021b0004	0x00020024	// MMDC0_MDPDC
+DATA 4 	0x021b0010	0x00100A82	// MMDC0_MDCFG1
+DATA 4 	0x021b0014	0x00000093	// MMDC0_MDCFG2
+
+//MDMISC: RALAT kept to the high level of 5.
+//MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits:
+//a. better operation at low frequency, for LPDDR2 freq < 100MHz, change RALAT to 3
+//b. Small performence improvment
+DATA 4 	0x021b0018	0x0000174C	// MMDC0_MDMISC
+DATA 4 	0x021b002c	0x0F9F26D2	// MMDC0_MDRWD
+DATA 4 	0x021b0030	0x009F0E10	// MMDC0_MDOR
+DATA 4 	0x021b0038	0x001A0889	// MMDC0_MDCFG3LP
+DATA 4 	0x021b0008	0x00000000	// MMDC0_MDOTC
+DATA 4 	0x021b0040	0x0000004F	// Chan0 CS0_END 2 channel with 2 Channel fixed mode
+// DATA 4  	0x021b0400	0x11420000      	//MMDC0_MAARCR ADOPT optimized priorities. Dyn jump disabled
+DATA 4 	0x021b0000	0x83110000	// MMDC0_MDCTL
+
+// Channel1 - starting address 0x10000000
+// Note: the values for Chan1 should match those of Chan0
+DATA 4 	0x021b400c	0x33374133	// MMDC1_MDCFG0
+DATA 4 	0x021b4004	0x00020024	// MMDC1_MDPDC
+DATA 4 	0x021b4010	0x00100A82	// MMDC1_MDCFG1
+DATA 4 	0x021b4014	0x00000093	// MMDC1_MDCFG2
+DATA 4 	0x021b4018	0x0000174C	// MMDC1_MDMISC
+DATA 4 	0x021b402c	0x0F9F26D2	// MMDC1_MDRWD
+DATA 4 	0x021b4030	0x009F0E10	// MMDC1_MDOR
+DATA 4 	0x021b4038	0x001A0889	// MMDC1_MDCFG3LP
+DATA 4 	0x021b4008	0x00000000	// MMDC1_MDOTC
+DATA 4 	0x021b4040	0x00000017	// Chan1 CS0_END
+// DATA 4  	0x021b4400	0x11420000      	//MMDC0_MAARCR ADOPT optimized priorities. Dyn jump disabled
+DATA 4 	0x021b4000	0x83110000	// MMDC1_MDCTL
+
+// Precharge all commands per JEDEC
+// The memory controller may optionally issue a Precharge-All command
+// prior to the MRW Reset command.
+// This is strongly recommended to ensure a robust DRAM initialization
+DATA 4 	0x021b001c	0x00008010	// precharge-all commnad CS0 - Chan 0
+DATA 4 	0x021b401c	0x00008010	// precharge-all commnad CS0 - Chan 1
+
+//=============================================================================
+// LPDDR2 Mode Register Writes
+//=============================================================================
+// Channel 0 CS0
+DATA 4 	0x021b001c	0x003F8030	// MRW: BA=0 CS=0 MR_ADDR=63 MR_OP=0 (Reset)
+DATA 4 	0x021b001c	0xFF0A8030	// MRW: BA=0 CS=0 MR_ADDR=10 MR_OP=0xff (IO calibration, calibration code)
+DATA 4 	0x021b001c	0xC2018030	// MRW: BA=0 CS=0 MR_ADDR=1  MR_OP=see Register Configuration
+DATA 4 	0x021b001c	0x04028030	// MRW: BA=0 CS=0 MR_ADDR=2  MR_OP=see Register Configuration
+DATA 4 	0x021b001c	0x03038030	// MRW: BA=0 CS=0 MR_ADDR=3  MR_OP=see Register Configuration
+// Channel 0 CS1
+// Note, CS1 does not exist in this memory hence these writes are commented out
+// They are only shown here for completeness
+// If you use a memory where CS1 exists, simply uncomment these lines
+//DATA 4 	0x021b001c	0x003F8038	// MRW: BA=0 CS=1 MR_ADDR=63 MR_OP=0 (Reset)
+//DATA 4 	0x021b001c	0xFF0A8038	// MRW: BA=0 CS=1 MR_ADDR=10 MR_OP=0xff (IO calibration, calibration code)
+//DATA 4 	0x021b001c	0xC2018038	// MRW: BA=0 CS=1 MR_ADDR=1  MR_OP=see Register Configuration
+//DATA 4 	0x021b001c	0x04028038	// MRW: BA=0 CS=1 MR_ADDR=2  MR_OP=see Register Configuration
+//DATA 4 	0x021b001c	0x03038038	// MRW: BA=0 CS=1 MR_ADDR=3  MR_OP=see Register Configuration
+
+// For Channel 1 mode register writes - these should match channel 0 settings
+// Channel 1 CS0
+DATA 4 	0x021b401c	0x003F8030	// MRW: BA=0 CS=0 MR_ADDR=63 MR_OP=0 (Reset)
+DATA 4 	0x021b401c	0xFF0A8030	// MRW: BA=0 CS=0 MR_ADDR=10 MR_OP=0xff (IO calibration, calibration code)
+DATA 4 	0x021b401c	0xC2018030	// MRW: BA=0 CS=0 MR_ADDR=1  MR_OP=see Register Configuration
+DATA 4 	0x021b401c	0x04028030	// MRW: BA=0 CS=0 MR_ADDR=2  MR_OP=see Register Configuration
+DATA 4 	0x021b401c	0x03038030	// MRW: BA=0 CS=0 MR_ADDR=3  MR_OP=see Register Configuration
+// Channel 1 CS1
+// Note, CS1 does not exist in this memory hence these writes are commented out
+// They are only shown here for completeness
+// If you use a memory where CS1 exists, simply uncomment these lines
+//DATA 4 	0x021b401c	0x003F8038	// MRW: BA=0 CS=1 MR_ADDR=63 MR_OP=0 (Reset)
+//DATA 4 	0x021b401c	0xFF0A8038	// MRW: BA=0 CS=1 MR_ADDR=10 MR_OP=0xff (IO calibration, calibration code)
+//DATA 4 	0x021b401c	0xC2018038	// MRW: BA=0 CS=1 MR_ADDR=1  MR_OP=see Register Configuration
+//DATA 4 	0x021b401c	0x04028038	// MRW: BA=0 CS=1 MR_ADDR=2  MR_OP=see Register Configuration
+//DATA 4 	0x021b401c	0x03038038	// MRW: BA=0 CS=1 MR_ADDR=3  MR_OP=see Register Configuration
+
+//////////#################################################//
+//final DDR setup, before operation start:
+
+DATA 4 	0x021b0020	0x00001800	// MMDC0_MDREF
+DATA 4 	0x021b4020	0x00001800	// MMDC1_MDREF, align with Chan 0 setting
+
+DATA 4 	0x021b0818	0x0	// DDR_PHY_P0_MPODTCTRL
+DATA 4 	0x021b4818	0x0	// DDR_PHY_P1_MPODTCTRL
+
+DATA 4 	0x021b08b8	0x00000800	// DDR_PHY_P0_MPMUR0, frc_msr
+DATA 4 	0x021b48b8	0x00000800	// DDR_PHY_P1_MPMUR0, frc_msr
+
+DATA 4 	0x021b0004	0x00025564	// MMDC0_MDPDC now SDCTL power down enabled
+DATA 4 	0x021b4004	0x00025564	// MMDC1_MDPDC now SDCTL power down enabled, align with Chan 0 setting
+
+DATA 4 	0x021b0404	0x00011006 	//MMDC0_MAPSR ADOPT power down enabled
+DATA 4 	0x021b4404	0x00011006 	//MMDC1_MAPSR ADOPT power down enabled, align with Chan 0 setting
+
+DATA 4 	0x021b001c	0x00000000	// MMDC0_MDSCR, clear this register
+DATA 4 	0x021b401c	0x00000000	// MMDC1_MDSCR, clear this register
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6qarm2/mx6qarm2.c ebf_6ull_uboot/board/freescale/mx6qarm2/mx6qarm2.c
--- u-boot-2016.03/board/freescale/mx6qarm2/mx6qarm2.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6qarm2/mx6qarm2.c	2021-04-16 14:42:16.956592502 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -12,11 +12,20 @@
 #include <asm/errno.h>
 #include <asm/gpio.h>
 #include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
 #include <mmc.h>
 #include <fsl_esdhc.h>
 #include <miiphy.h>
 #include <netdev.h>
 #include <usb.h>
+#include <asm/arch/sys_proto.h>
+
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -31,6 +40,10 @@
 #define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
 	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
 
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
 int dram_init(void)
 {
 #if defined(CONFIG_MX6DL) && !defined(CONFIG_MX6DL_LPDDR2) && \
@@ -43,6 +56,16 @@
 	return 0;
 }
 
+#if defined(CONFIG_MX6DQ_POP_LPDDR2)
+void dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_0;
+	gd->bd->bi_dram[0].size = (phys_size_t)CONFIG_DDR_MB * 1024 * 1024;
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[1].size = (phys_size_t)CONFIG_DDR_MB * 1024 * 1024;
+}
+#endif
+
 iomux_v3_cfg_t const uart4_pads[] = {
 	MX6_PAD_KEY_COL0__UART4_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
 	MX6_PAD_KEY_ROW0__UART4_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
@@ -59,7 +82,11 @@
 	MX6_PAD_SD3_DAT5__SD3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
 	MX6_PAD_SD3_DAT6__SD3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
 	MX6_PAD_SD3_DAT7__SD3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+#ifdef CONFIG_MX6DQ_POP_LPDDR2
+	MX6_PAD_GPIO_18__SD3_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+#else
 	MX6_PAD_NANDF_CS0__GPIO6_IO11  | MUX_PAD_CTRL(NO_PAD_CTRL), /* CD */
+#endif
 };
 
 iomux_v3_cfg_t const usdhc4_pads[] = {
@@ -115,17 +142,23 @@
 	return devno - 2;
 }
 
+int mmc_map_to_kernel_blk(int devno)
+{
+	return devno + 2;
+}
+
 int board_mmc_getcd(struct mmc *mmc)
 {
+	int ret = 1;
+#ifndef CONFIG_MX6DQ_POP_LPDDR2
 	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
-	int ret;
 
 	if (cfg->esdhc_base == USDHC3_BASE_ADDR) {
 		gpio_direction_input(IMX_GPIO_NR(6, 11));
 		ret = !gpio_get_value(IMX_GPIO_NR(6, 11));
 	} else /* Don't have the CD GPIO pin on board */
 		ret = 1;
-
+#endif
 	return ret;
 }
 
@@ -225,7 +258,7 @@
 
 static iomux_v3_cfg_t const usb_otg_pads[] = {
 	MX6_PAD_EIM_D22__USB_OTG_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
-	MX6_PAD_GPIO_1__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO_1__USB_OTG_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
 };
 
 static void setup_usb(void)
@@ -276,6 +309,15 @@
 	return 0;
 }
 
+int board_late_init(void)
+{
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	return 0;
+}
+
 int checkboard(void)
 {
 #ifdef CONFIG_MX6DL
@@ -286,3 +328,36 @@
 
 	return 0;
 }
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+/* no external pmic, always ldo_enable */
+void ldo_mode_set(int ldo_bypass)
+{
+	return;
+}
+#endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+void board_fastboot_setup(void)
+{
+	if (!getenv("fastboot_dev"))
+		setenv("fastboot_dev", "mmc0");
+	if (!getenv("bootcmd"))
+		setenv("bootcmd", "boota mmc0");
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+int check_recovery_cmd_file(void) {
+	return 0;
+}
+
+void board_recovery_setup(void)
+{
+	if (!getenv("bootcmd_android_recovery"))
+		setenv("bootcmd_android_recovery", "boota mmc0 recovery");
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6qarm2/plugin.S ebf_6ull_uboot/board/freescale/mx6qarm2/plugin.S
--- u-boot-2016.03/board/freescale/mx6qarm2/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6qarm2/plugin.S	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,1176 @@
+/*
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
+ *
+ * Author: Fabio Estevam <fabio.estevam@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+.macro imx6dlarm2_ddr_setting
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x06c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x070]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x074]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x078]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x07c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x080]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x084]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x57c]
+
+	ldr r1, =0x00003000
+	str r1, [r0, #0x590]
+	str r1, [r0, #0x598]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+
+	ldr r1, =0x00003030
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =MMDC_P1_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	str r2, [r1, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+
+	ldr r2, =0x00370037
+	str r2, [r1, #0x80c]
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x422f0220
+	str r2, [r0, #0x83c]
+	ldr r2, =0x021f0219
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x422f0220
+	str r2, [r1, #0x83c]
+	ldr r2, =0x022d022f
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x47494b49
+	str r2, [r0, #0x848]
+	ldr r2, =0x48484c47
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x39382b2f
+	str r2, [r0, #0x850]
+	ldr r2, =0x2f35312c
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	ldr r2, =0x00000800
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x0002002d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+	ldr r2, =0x40445323
+	str r2, [r0, #0x00c]
+	ldr r2, =0xb66e8c63
+	str r2, [r0, #0x010]
+	ldr r2, =0x01ff00db
+	str r2, [r0, #0x014]
+	ldr r2, =0x00081740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x00440e21
+	str r2, [r0, #0x030]
+
+#ifdef CONFIG_DDR_32BIT
+	ldr r2, =0x00000017
+	str r2, [r0, #0x040]
+	ldr r2, =0xc3190000
+	str r2, [r0, #0x000]
+#else
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+	ldr r2, =0xc31a0000
+	str r2, [r0, #0x000]
+#endif
+
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x0400803a
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x0000803b
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00428031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00428039
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x07208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x07208038
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008048
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+
+	ldr r2, =0x00000007
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+
+	ldr r2, =0x0002556d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r1, #0x004]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6dqarm2_ddr_setting
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x06c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x070]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x074]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x078]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x07c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x080]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x084]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x588]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x594]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x56c]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x578]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x74c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x57c]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x59c]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5a0]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000038
+	str r1, [r0, #0x5a8]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x5b0]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x524]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x51c]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x518]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x50c]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x5b8]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x784]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x788]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x794]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x79c]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x7a0]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x7a4]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x7a8]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x748]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5ac]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5b4]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x528]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x520]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x514]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x510]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5bc]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5c4]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x810]
+
+	ldr r1, =MMDC_P1_BASE_ADDR
+	ldr r2, =0x00440044
+	str r2, [r1, #0x80c]
+	ldr r2, =0x00440044
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x4333033F
+	str r2, [r0, #0x83c]
+	ldr r2, =0x0339033E
+	str r2, [r0, #0x840]
+	ldr r2, =0x433F0343
+	str r2, [r1, #0x83c]
+	ldr r2, =0x03490320
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x42363838
+	str r2, [r0, #0x848]
+	ldr r2, =0x3F343242
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x37424844
+	str r2, [r0, #0x850]
+	ldr r2, =0x48264731
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	ldr r2, =0x33333333
+	str r2, [r0, #0x820]
+	ldr r2, =0x33333333
+	str r2, [r0, #0x824]
+	ldr r2, =0x33333333
+	str r2, [r0, #0x828]
+	ldr r2, =0x33333333
+	str r2, [r1, #0x81c]
+	ldr r2, =0x33333333
+	str r2, [r1, #0x820]
+	ldr r2, =0x33333333
+	str r2, [r1, #0x824]
+	ldr r2, =0x33333333
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	ldr r2, =0x00000800
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020036
+	str r2, [r0, #0x004]
+	ldr r2, =0x09444040
+	str r2, [r0, #0x008]
+	ldr r2, =0x555A7975
+	str r2, [r0, #0x00c]
+	ldr r2, =0xFF538F64
+	str r2, [r0, #0x010]
+	ldr r2, =0x01ff00db
+	str r2, [r0, #0x014]
+	ldr r2, =0x00081740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x005a1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x11420000
+	str r2, [r0, #0x400]
+	ldr r2, =0x11420000
+	str r2, [r1, #0x400]
+
+	ldr r2, =0xc31a0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04088032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x0408803a
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x0000803b
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048039
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x09408030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x09408038
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008048
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6dlarm2_lpddr2_setting
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x06c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x070]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x074]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x078]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x07c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x080]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x084]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00003028
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+	str r1, [r0, #0x4cc]
+	str r1, [r0, #0x4d0]
+	str r1, [r0, #0x4d4]
+	str r1, [r0, #0x4d8]
+
+	ldr r1, =0x00000038
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+	str r1, [r0, #0x480]
+	str r1, [r0, #0x484]
+	str r1, [r0, #0x488]
+	str r1, [r0, #0x48c]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x494]
+	str r1, [r0, #0x4a4]
+	str r1, [r0, #0x4a8]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x780]
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x78c]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x76c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+	ldr r1, =0x00080000
+	str r1, [r0, #0x774]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =MMDC_P1_BASE_ADDR
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	str r2, [r1, #0x1c]
+	ldr r2, =0x1b5f01ff
+	str r2, [r0, #0x85c]
+	str r2, [r1, #0x85c]
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00400000
+	str r2, [r0, #0x890]
+	str r2, [r1, #0x890]
+	ldr r2, =0x00055555
+	str r2, [r1, #0x8bc]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x4b4b524f
+	str r2, [r0, #0x848]
+	ldr r2, =0x494f4c44
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x3c3d303c
+	str r2, [r0, #0x850]
+	ldr r2, =0x3c343d38
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x20000000
+	str r2, [r0, #0x83c]
+	str r2, [r1, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x840]
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x00000a00
+	str r2, [r0, #0x858]
+	str r2, [r1, #0x858]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x34386145
+	str r2, [r0, #0xc]
+	ldr r2, =0x00020036
+	str r2, [r0, #0x4]
+	ldr r2, =0x00100c83
+	str r2, [r0, #0x10]
+	ldr r2, =0x000000Dc
+	str r2, [r0, #0x14]
+	ldr r2, =0x0000174C
+	str r2, [r0, #0x18]
+	ldr r2, =0x0f9f26d2
+	str r2, [r0, #0x2c]
+	ldr r2, =0x0000020e
+	str r2, [r0, #0x30]
+	ldr r2, =0x00190778
+	str r2, [r0, #0x38]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x8]
+
+	ldr r2, =0x0000005f
+	str r2, [r0, #0x40]
+	ldr r2, =0x0000000f
+	str r2, [r0, #0x404]
+
+	ldr r2, =0xc3010000
+	str r2, [r0, #0x0]
+
+	ldr r2, =0x34386145
+	str r2, [r1, #0xc]
+
+	ldr r2, =0x00020036
+	str r2, [r1, #0x4]
+	ldr r2, =0x00100c83
+	str r2, [r1, #0x10]
+	ldr r2, =0x000000Dc
+	str r2, [r1, #0x14]
+	ldr r2, =0x0000174C
+	str r2, [r1, #0x18]
+	ldr r2, =0x0f9f26d2
+	str r2, [r1, #0x2c]
+	ldr r2, =0x0000020e
+	str r2, [r1, #0x30]
+	ldr r2, =0x00190778
+	str r2, [r1, #0x38]
+	ldr r2, =0x00000000
+	str r2, [r1, #0x8]
+
+	ldr r2, =0x0000003f
+	str r2, [r1, #0x40]
+
+	ldr r2, =0xc3010000
+	str r2, [r1, #0x0]
+
+	ldr r2, =0x003f8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0xff0a8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0xa2018030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x06028030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x01038030
+	str r2, [r0, #0x1c]
+
+	ldr r2, =0x003f8030
+	str r2, [r1, #0x1c]
+	ldr r2, =0xff0a8030
+	str r2, [r1, #0x1c]
+	ldr r2, =0xa2018030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x06028030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x01038030
+	str r2, [r1, #0x1c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x20]
+	str r2, [r1, #0x20]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+
+	ldr r2, =0xa1310003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x1c]
+	str r2, [r1, #0x1c]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x1c]
+.endm
+
+.macro imx6dqarm2_lpddr2_setting
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x60324
+	str r1, [r0, #0x18]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x06c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x070]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x074]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x078]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x07c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x080]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x084]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00003038
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00000038
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+	str r1, [r0, #0x57c]
+	str r1, [r0, #0x590]
+	str r1, [r0, #0x598]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x74c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x78c]
+	ldr r1, =0x00080000
+	str r1, [r0, #0x798]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =MMDC_P1_BASE_ADDR
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	str r2, [r1, #0x1c]
+	ldr r2, =0x1b5f01ff
+	str r2, [r0, #0x85c]
+	str r2, [r1, #0x85c]
+	ldr r2, =0xa1390000
+	str r2, [r0, #0x800]
+	str r2, [r1, #0x800]
+	ldr r2, =0x00400000
+	str r2, [r0, #0x890]
+	str r2, [r1, #0x890]
+	ldr r2, =0x00055555
+	str r2, [r1, #0x8bc]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0xf3333333
+	str r2, [r0, #0x82c]
+	str r2, [r0, #0x830]
+	str r2, [r0, #0x834]
+	str r2, [r0, #0x838]
+	str r2, [r1, #0x82c]
+	str r2, [r1, #0x830]
+	str r2, [r1, #0x834]
+	str r2, [r1, #0x838]
+
+	ldr r2, =0x49383b39
+	str r2, [r0, #0x848]
+	ldr r2, =0x30364738
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x3e3c3846
+	str r2, [r1, #0x848]
+	ldr r2, =0x4c294b35
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x20000000
+	str r2, [r0, #0x83c]
+	str r2, [r1, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x840]
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x00000f00
+	str r2, [r0, #0x858]
+	str r2, [r1, #0x858]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x555a61a5
+	str r2, [r0, #0xc]
+	ldr r2, =0x00020036
+	str r2, [r0, #0x4]
+	ldr r2, =0x00160e83
+	str r2, [r0, #0x10]
+	ldr r2, =0x000000dd
+	str r2, [r0, #0x14]
+	ldr r2, =0x0008174C
+	str r2, [r0, #0x18]
+	ldr r2, =0x0f9f26d2
+	str r2, [r0, #0x2c]
+	ldr r2, =0x0000020e
+	str r2, [r0, #0x30]
+	ldr r2, =0x200aac
+	str r2, [r0, #0x38]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x8]
+
+	ldr r2, =0x0000005f
+	str r2, [r0, #0x40]
+
+	ldr r2, =0xc3010000
+	str r2, [r0, #0x0]
+
+	ldr r2, =0x555a61a5
+	str r2, [r1, #0xc]
+	ldr r2, =0x00020036
+	str r2, [r1, #0x4]
+	ldr r2, =0x00160e83
+	str r2, [r1, #0x10]
+	ldr r2, =0x000000dd
+	str r2, [r1, #0x14]
+	ldr r2, =0x0008174C
+	str r2, [r1, #0x18]
+	ldr r2, =0x0f9f26d2
+	str r2, [r1, #0x2c]
+	ldr r2, =0x0000020e
+	str r2, [r1, #0x30]
+	ldr r2, =0x00200aac
+	str r2, [r1, #0x38]
+	ldr r2, =0x00000000
+	str r2, [r1, #0x8]
+
+	ldr r2, =0x0000003f
+	str r2, [r1, #0x40]
+
+	ldr r2, =0xc3010000
+	str r2, [r1, #0x0]
+
+	ldr r2, =0x003f8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0xff0a8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0xc2018030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x06028030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x02038030
+	str r2, [r0, #0x1c]
+
+	ldr r2, =0x003f8030
+	str r2, [r1, #0x1c]
+	ldr r2, =0xff0a8030
+	str r2, [r1, #0x1c]
+	ldr r2, =0xc2018030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x06028030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x02038030
+	str r2, [r1, #0x1c]
+
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	str r2, [r1, #0x800]
+
+	ldr r2, =0x00007800
+	str r2, [r0, #0x20]
+	str r2, [r1, #0x20]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+
+	ldr r2, =0xa1310003
+	str r2, [r0, #0x800]
+	str r2, [r1, #0x800]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x1c]
+	str r2, [r1, #0x1c]
+
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x1c]
+.endm
+
+.macro imx6dq_pop_arm2_lpddr2_setting
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x06c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x070]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x074]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x078]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x07c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x080]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x084]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x57c]
+	str r1, [r0, #0x58c]
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+	ldr r1, =0x00003030
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =MMDC_P1_BASE_ADDR
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	str r2, [r1, #0x1c]
+	ldr r2, =0x1B5F0107
+	str r2, [r0, #0x85c]
+	str r2, [r1, #0x85c]
+	ldr r2, =0xA1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00400000
+	str r2, [r0, #0x890]
+	str r2, [r1, #0x890]
+	ldr r2, =0x3C3A3A44
+	str r2, [r0, #0x848]
+	str r2, [r1, #0x848]
+	ldr r2, =0x4238423A
+	str r2, [r0, #0x850]
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x20000000
+	str r2, [r0, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x840]
+	ldr r2, =0x20000000
+	str r2, [r1, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0xf3333333
+	str r2, [r0, #0x82c]
+	str r2, [r0, #0x830]
+	str r2, [r0, #0x834]
+	str r2, [r0, #0x838]
+	str r2, [r1, #0x82c]
+	str r2, [r1, #0x830]
+	str r2, [r1, #0x834]
+	str r2, [r1, #0x838]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020036
+	str r2, [r0, #0x4]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x8]
+	ldr r2, =0x444961A5
+	str r2, [r0, #0xc]
+	ldr r2, =0x00160E83
+	str r2, [r0, #0x10]
+	ldr r2, =0x000000DD
+	str r2, [r0, #0x14]
+
+	ldr r2, =0x0000174C
+	str r2, [r0, #0x18]
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	ldr r2, =0x149F26D2
+	str r2, [r0, #0x2c]
+	ldr r2, =0x00000010
+	str r2, [r0, #0x30]
+	ldr r2, =0x0021099B
+	str r2, [r0, #0x38]
+	ldr r2, =0x0000004F
+	str r2, [r0, #0x40]
+	ldr r2, =0x11420000
+	str r2, [r0, #0x400]
+	ldr r2, =0x83110000
+	str r2, [r0, #0x0]
+
+	ldr r2, =0x00020036
+	str r2, [r1, #0x4]
+	ldr r2, =0x00000000
+	str r2, [r1, #0x8]
+	ldr r2, =0x444961A5
+	str r2, [r1, #0xc]
+	ldr r2, =0x00160E83
+	str r2, [r1, #0x10]
+	ldr r2, =0x000000DD
+	str r2, [r1, #0x14]
+
+	ldr r2, =0x0000174C
+	str r2, [r1, #0x18]
+	ldr r2, =0x00008000
+	str r2, [r1, #0x1c]
+	ldr r2, =0x149F26D2
+	str r2, [r1, #0x2c]
+	ldr r2, =0x00000010
+	str r2, [r1, #0x30]
+	ldr r2, =0x0021099B
+	str r2, [r1, #0x38]
+	ldr r2, =0x00000017
+	str r2, [r1, #0x40]
+	ldr r2, =0x11420000
+	str r2, [r1, #0x400]
+	ldr r2, =0x83110000
+	str r2, [r1, #0x0]
+
+	ldr r2, =0x003F8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0xFF0A8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0xC2018030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x06028030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x02038030
+	str r2, [r0, #0x1c]
+
+	ldr r2, =0x003F8030
+	str r2, [r1, #0x1c]
+	ldr r2, =0xFF0A8030
+	str r2, [r1, #0x1c]
+	ldr r2, =0xC2018030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x06028030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x02038030
+	str r2, [r1, #0x1c]
+
+	ldr r2, =0xA1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x00001800
+	str r2, [r0, #0x20]
+	str r2, [r1, #0x20]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+
+	ldr r2, =0x00025576
+	str r2, [r0, #0x4]
+	str r2, [r1, #0x4]
+
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	str r2, [r1, #0x404]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x1c]
+	str r2, [r1, #0x1c]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x1c]
+.endm
+
+.macro imx6_ddr_setting
+	#if defined (CONFIG_MX6DQ_POP_LPDDR2)
+        imx6dq_pop_arm2_lpddr2_setting
+	#elif defined (CONFIG_MX6DQ_LPDDR2)
+	imx6dqarm2_lpddr2_setting
+	#elif defined (CONFIG_MX6Q)
+	imx6dqarm2_ddr_setting
+	#elif defined (CONFIG_MX6DL_LPDDR2)
+	imx6dlarm2_lpddr2_setting
+	#elif defined (CONFIG_MX6DL)
+	imx6dlarm2_ddr_setting
+	#else
+	#error "SOC not configured"
+	#endif
+.endm
+
+.macro imx6_clock_gating
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6qsabreauto/imximage.cfg ebf_6ull_uboot/board/freescale/mx6qsabreauto/imximage.cfg
--- u-boot-2016.03/board/freescale/mx6qsabreauto/imximage.cfg	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6qsabreauto/imximage.cfg	2021-04-16 14:42:16.956592502 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  *
@@ -10,13 +10,34 @@
  */
 /* image version */
 
+#define __ASSEMBLY__
+#include <config.h>
+
 IMAGE_VERSION 2
 
 /*
- * Boot Device : one of
- * spi, sd (the board has no nand neither onenand)
+ * Boot Device : one of spi, sd, eimnor, nand, sata:
+ * spinor: flash_offset: 0x0400
+ * nand:   flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ * eimnor: flash_offset: 0x1000
  */
+
+#if defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else /* others has the same flash_offset as sd */
 BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabreauto/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
 
 /*
  * Device Configuration Data (DCD)
@@ -127,3 +148,4 @@
 /* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
 DATA 4 0x020e0018 0x007F007F
 DATA 4 0x020e001c 0x007F007F
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6qsabreauto/Makefile ebf_6ull_uboot/board/freescale/mx6qsabreauto/Makefile
--- u-boot-2016.03/board/freescale/mx6qsabreauto/Makefile	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6qsabreauto/Makefile	2021-04-16 14:42:16.956592502 +0800
@@ -1,9 +1,13 @@
 #
 # Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
 #
-# (C) Copyright 2011 Freescale Semiconductor, Inc.
+# (C) Copyright 2011-2016 Freescale Semiconductor, Inc.
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
 obj-y  := mx6qsabreauto.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6qsabreauto/mx6dl.cfg ebf_6ull_uboot/board/freescale/mx6qsabreauto/mx6dl.cfg
--- u-boot-2016.03/board/freescale/mx6qsabreauto/mx6dl.cfg	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6qsabreauto/mx6dl.cfg	2021-04-16 14:42:16.956592502 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc.
  * Jason Liu <r64343@freescale.com>
  *
  * SPDX-License-Identifier:	GPL-2.0+
@@ -11,13 +11,34 @@
  */
 /* image version */
 
+#define __ASSEMBLY__
+#include <config.h>
+
 IMAGE_VERSION 2
 
 /*
- * Boot Device : one of
- * spi, sd (the board has no nand neither onenand)
+ * Boot Device : one of spi, sd, eimnor, nand, sata:
+ * spinor: flash_offset: 0x0400
+ * nand:   flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ * eimnor: flash_offset: 0x1000
  */
+
+#if defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else /* others has the same flash_offset as sd */
 BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabreauto/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
 
 /*
  * Device Configuration Data (DCD)
@@ -128,3 +149,4 @@
 /* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
 DATA 4 0x020e0018 0x007F007F
 DATA 4 0x020e001c 0x007F007F
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6qsabreauto/mx6qp.cfg ebf_6ull_uboot/board/freescale/mx6qsabreauto/mx6qp.cfg
--- u-boot-2016.03/board/freescale/mx6qsabreauto/mx6qp.cfg	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6qsabreauto/mx6qp.cfg	2021-04-16 14:42:16.956592502 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  *
@@ -23,7 +23,21 @@
  * sd/mmc: flash_offset: 0x0400
  * eimnor: flash_offset: 0x1000
  */
+
+#if defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else /* others has the same flash_offset as sd */
 BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabreauto/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
 
 /*
  * Device Configuration Data (DCD)
@@ -95,14 +109,14 @@
 DATA 4 0x021b4820 0x33333333
 DATA 4 0x021b4824 0x33333333
 DATA 4 0x021b4828 0x33333333
-DATA 4 0x021b08c0 0x24912492
-DATA 4 0x021b48c0 0x24912492
+DATA 4 0x021b08c0 0x24912249
+DATA 4 0x021b48c0 0x24914289
 DATA 4 0x021b08b8 0x00000800
 DATA 4 0x021b48b8 0x00000800
 DATA 4 0x021b0004 0x00020036
-DATA 4 0x021b0008 0x09444040
+DATA 4 0x021b0008 0x24444040
 DATA 4 0x021b000c 0x898E7955
-DATA 4 0x021b0010 0xFF328F64
+DATA 4 0x021b0010 0xFF320F64
 DATA 4 0x021b0014 0x01FF00DB
 DATA 4 0x021b0018 0x00001740
 DATA 4 0x021b001c 0x00008000
@@ -112,7 +126,8 @@
 DATA 4 0x021b0040 0x00000047
 DATA 4 0x021b0400 0x14420000
 DATA 4 0x021b0000 0x841A0000
-DATA 4 0x00bb0008 0x00000004
+DATA 4 0x021b0890 0x00400C58
+DATA 4 0x00bb0008 0x00000000
 DATA 4 0x00bb000c 0x2891E41A
 DATA 4 0x00bb0038 0x00000564
 DATA 4 0x00bb0014 0x00000040
@@ -143,3 +158,4 @@
 /* set IPU AXI-id1 Qos=0x1 AXI-id0/2/3 Qos=0x7 */
 DATA 4, 0x020e0018, 0x77177717
 DATA 4, 0x020e001c, 0x77177717
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6qsabreauto/mx6qsabreauto.c ebf_6ull_uboot/board/freescale/mx6qsabreauto/mx6qsabreauto.c
--- u-boot-2016.03/board/freescale/mx6qsabreauto/mx6qsabreauto.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6qsabreauto/mx6qsabreauto.c	2021-04-16 14:42:16.956592502 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
  *
  * Author: Fabio Estevam <fabio.estevam@freescale.com>
  *
@@ -32,6 +32,16 @@
 #include <power/pfuze100_pmic.h>
 #include "../common/pfuze.h"
 
+#ifdef CONFIG_CMD_SATA
+#include <asm/imx-common/sata.h>
+#endif
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
@@ -42,6 +52,11 @@
 	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
 	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
 
+/*Need more drive strength for SD1 slot on base board*/
+#define USDHC1_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |               \
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
 #define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
 	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
 
@@ -56,10 +71,18 @@
 
 #define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
 
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
 #define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |          \
 	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
 	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
 
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
 #define I2C_PMIC	1
 
 int dram_init(void)
@@ -90,6 +113,7 @@
 	MX6_PAD_RGMII_RD2__RGMII_RD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
 	MX6_PAD_RGMII_RD3__RGMII_RD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
 	MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO_16__ENET_REF_CLK		| MUX_PAD_CTRL(ENET_PAD_CTRL),
 };
 
 /* I2C2 PMIC, iPod, Tuner, Codec, Touch, HDMI EDID, MIPI CSI2 card */
@@ -171,6 +195,7 @@
 	return 0;
 }
 
+#ifdef CONFIG_SYS_USE_EIMNOR
 static iomux_v3_cfg_t const eimnor_pads[] = {
 	MX6_PAD_EIM_D16__EIM_DATA16	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
 	MX6_PAD_EIM_D17__EIM_DATA17	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
@@ -239,12 +264,26 @@
 
 	eimnor_cs_setup();
 }
+#endif
 
 static void setup_iomux_enet(void)
 {
 	imx_iomux_v3_setup_multiple_pads(enet_pads, ARRAY_SIZE(enet_pads));
 }
 
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	/*To avoid pin conflict with NAND, set usdhc1 to 4 pins*/
+	MX6_PAD_SD1_CLK__SD1_CLK	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
+	MX6_PAD_SD1_CMD__SD1_CMD	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
+	MX6_PAD_SD1_DAT0__SD1_DATA0	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
+	MX6_PAD_SD1_DAT1__SD1_DATA1	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
+	MX6_PAD_SD1_DAT2__SD1_DATA2	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
+	MX6_PAD_SD1_DAT3__SD1_DATA3	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
+
+	/*CD pin*/
+	MX6_PAD_GPIO_1__GPIO1_IO01 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
 static iomux_v3_cfg_t const usdhc3_pads[] = {
 	MX6_PAD_SD3_CLK__SD3_CLK	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
 	MX6_PAD_SD3_CMD__SD3_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
@@ -266,22 +305,89 @@
 }
 
 #ifdef CONFIG_FSL_ESDHC
-static struct fsl_esdhc_cfg usdhc_cfg[1] = {
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(1, 1)
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(6, 15)
+
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC1_BASE_ADDR, 0, 4},
 	{USDHC3_BASE_ADDR},
 };
 
+int board_mmc_get_env_dev(int devno)
+{
+	/*
+	 * need ubstract 1 to map to the mmc3 device id
+	 * see the comments in board_mmc_init function
+	 */
+	if (devno == 2)
+		devno--;
+
+	return devno;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	if (devno == 1)
+		devno = 2;
+
+	return devno;
+}
+
 int board_mmc_getcd(struct mmc *mmc)
 {
-	gpio_direction_input(IMX_GPIO_NR(6, 15));
-	return !gpio_get_value(IMX_GPIO_NR(6, 15));
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		gpio_direction_input(USDHC1_CD_GPIO);
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	case USDHC3_BASE_ADDR:
+		gpio_direction_input(USDHC3_CD_GPIO);
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	}
+
+	return ret;
 }
 
 int board_mmc_init(bd_t *bis)
 {
-	imx_iomux_v3_setup_multiple_pads(usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+	int i;
 
-	usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
-	return fsl_esdhc_initialize(bis, &usdhc_cfg[0]);
+	/*
+	* According to the board_mmc_init() the following map is done:
+	* (U-boot device node)    (Physical Port)
+	* mmc0				USDHC1
+	* mmc1				USDHC3
+	*/
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+		if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+			printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
 }
 #endif
 
@@ -356,20 +462,25 @@
 
 static void setup_fec(void)
 {
+	int ret;
+
 	if (is_mx6dqp()) {
 		/*
 		 * select ENET MAC0 TX clock from PLL
 		 */
 		imx_iomux_set_gpr_register(5, 9, 1, 1);
-		enable_fec_anatop_clock(0, ENET_125MHZ);
+	} else {
+		imx_iomux_set_gpr_register(1, 21, 1, 1);
 	}
 
-	setup_iomux_enet();
+	ret = enable_fec_anatop_clock(0, ENET_125MHZ);
+	if (ret)
+		printf("Error fec anatop clock settings!\n");
 }
 
 int board_eth_init(bd_t *bis)
 {
-	setup_fec();
+	setup_iomux_enet();
 
 	return cpu_eth_init(bis);
 }
@@ -451,21 +562,21 @@
 	.bus	= -1,
 	.addr	= 0,
 	.pixfmt	= IPU_PIX_FMT_RGB24,
-	.detect	= detect_hdmi,
+	.detect	= NULL,
 	.enable	= do_enable_hdmi,
 	.mode	= {
 		.name           = "HDMI",
 		.refresh        = 60,
-		.xres           = 1024,
-		.yres           = 768,
-		.pixclock       = 15385,
-		.left_margin    = 220,
-		.right_margin   = 40,
-		.upper_margin   = 21,
-		.lower_margin   = 7,
-		.hsync_len      = 60,
-		.vsync_len      = 10,
-		.sync           = FB_SYNC_EXT,
+		.xres           = 640,
+		.yres           = 480,
+		.pixclock       = 39721,
+		.left_margin    = 48,
+		.right_margin   = 16,
+		.upper_margin   = 33,
+		.lower_margin   = 10,
+		.hsync_len      = 96,
+		.vsync_len      = 2,
+		.sync           = 0,
 		.vmode          = FB_VMODE_NONINTERLACED,
 } } };
 size_t display_count = ARRAY_SIZE(displays);
@@ -545,14 +656,34 @@
 	return 1;
 }
 
-int board_early_init_f(void)
+#ifdef CONFIG_MXC_SPI
+iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX6_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D19__GPIO3_IO19  | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* Steer logic */
+	MX6_PAD_EIM_A24__GPIO5_IO04  | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void setup_spinor(void)
 {
-	setup_iomux_uart();
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
+					 ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(5, 4), 0);
+	gpio_direction_output(IMX_GPIO_NR(3, 19), 0);
+}
 
-#ifdef CONFIG_NAND_MXS
-	setup_gpmi_nand();
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 1) ? (IMX_GPIO_NR(3, 19)) : -1;
+}
 #endif
 
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
 	return 0;
 }
 
@@ -575,36 +706,138 @@
 #ifdef CONFIG_VIDEO_IPUV3
 	setup_display();
 #endif
-	setup_iomux_eimnor();
-	return 0;
-}
 
 #ifdef CONFIG_MXC_SPI
-int board_spi_cs_gpio(unsigned bus, unsigned cs)
-{
-	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 9)) : -1;
-}
+	setup_spinor();
 #endif
 
+#ifdef CONFIG_NAND_MXS
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_CMD_SATA
+	setup_sata();
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+	setup_iomux_eimnor();
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec();
+#endif
+
+	return 0;
+}
+
 int power_init_board(void)
 {
-	struct pmic *p;
+	struct pmic *pfuze;
 	unsigned int value;
+	int ret;
 
-	p = pfuze_common_init(I2C_PMIC);
-	if (!p)
+	pfuze = pfuze_common_init(I2C_PMIC);
+	if (!pfuze)
 		return -ENODEV;
 
+	if (is_mx6dqp())
+		ret = pfuze_mode_init(pfuze, APS_APS);
+	else
+		ret = pfuze_mode_init(pfuze, APS_PFM);
+
+	if (ret < 0)
+		return ret;
+
 	if (is_mx6dqp()) {
+		/* set SW1C staby volatage 1.075V*/
+		pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &value);
+		value &= ~0x3f;
+		value |= 0x1f;
+		pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, value);
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &value);
+		value &= ~0xc0;
+		value |= 0x40;
+		pmic_reg_write(pfuze, PFUZE100_SW1CCONF, value);
+
 		/* set SW2 staby volatage 0.975V*/
-		pmic_reg_read(p, PFUZE100_SW2STBY, &value);
+		pmic_reg_read(pfuze, PFUZE100_SW2STBY, &value);
 		value &= ~0x3f;
 		value |= 0x17;
-		pmic_reg_write(p, PFUZE100_SW2STBY, value);
+		pmic_reg_write(pfuze, PFUZE100_SW2STBY, value);
+
+		/* set SW2/VDDARM step ramp up time to from 16us to 4us/25mV */
+		pmic_reg_read(pfuze, PFUZE100_SW2CONF, &value);
+		value &= ~0xc0;
+		value |= 0x40;
+		pmic_reg_write(pfuze, PFUZE100_SW2CONF, value);
+	} else {
+		/* set SW1AB staby volatage 0.975V*/
+		pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &value);
+		value &= ~0x3f;
+		value |= 0x1b;
+		pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, value);
+
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &value);
+		value &= ~0xc0;
+		value |= 0x40;
+		pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, value);
+
+		/* set SW1C staby volatage 0.975V*/
+		pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &value);
+		value &= ~0x3f;
+		value |= 0x1b;
+		pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, value);
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &value);
+		value &= ~0xc0;
+		value |= 0x40;
+		pmic_reg_write(pfuze, PFUZE100_SW1CCONF, value);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	struct pmic *p = pmic_get("PFUZE100");
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
 	}
 
-	return pfuze_mode_init(p, APS_PFM);
+	/* increase VDDARM/VDDSOC to support 1.2G chip */
+	if (check_1_2G()) {
+		ldo_bypass = 0;	/* ldo_enable on 1.2G chip */
+		printf("1.2G chip, increase VDDARM_IN/VDDSOC_IN\n");
+
+		if (is_mx6dqp()) {
+			/* increase VDDARM to 1.425V */
+			pmic_reg_read(p, PFUZE100_SW2VOL, &value);
+			value &= ~0x3f;
+			value |= 0x29;
+			pmic_reg_write(p, PFUZE100_SW2VOL, value);
+		} else {
+			/* increase VDDARM to 1.425V */
+			pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+			value &= ~0x3f;
+			value |= 0x2d;
+			pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+		}
+		/* increase VDDSOC to 1.425V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x2d;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+	}
 }
+#endif
 
 #ifdef CONFIG_CMD_BMODE
 static const struct boot_mode board_boot_modes[] = {
@@ -631,6 +864,10 @@
 		setenv("board_rev", "MX6DL");
 #endif
 
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
 	return 0;
 }
 
@@ -659,7 +896,7 @@
 #define USB_OTG_PWR       PORTEXP_IO_NR(0x34, 1)
 
 iomux_v3_cfg_t const usb_otg_pads[] = {
-	MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
 };
 
 int board_ehci_hcd_init(int port)
@@ -707,3 +944,122 @@
 	return 0;
 }
 #endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "sata");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota sata");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "nand");
+		if (!getenv("fbparts"))
+			setenv("fbparts", ANDROID_FASTBOOT_NAND_PARTS);
+		if (!getenv("bootcmd"))
+			setenv("bootcmd",
+				"nand read ${loadaddr} ${boot_nand_offset} "
+				"${boot_nand_size};boota ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(5, 14)
+iomux_v3_cfg_t const recovery_key_pads[] = {
+	(MX6_PAD_DISP0_DAT20__GPIO5_IO14 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+int check_recovery_cmd_file(void)
+{
+	int button_pressed = 0;
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	/* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
+		ARRAY_SIZE(recovery_key_pads));
+
+	gpio_direction_input(GPIO_VOL_DN_KEY);
+
+	if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN key is low assert */
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+	}
+
+	return recovery_mode || button_pressed;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota sata recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc0 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc1 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"nand read ${loadaddr} ${recovery_nand_offset} "
+				"${recovery_nand_size};boota ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
+
diff -urN u-boot-2016.03/board/freescale/mx6qsabreauto/mx6solo.cfg ebf_6ull_uboot/board/freescale/mx6qsabreauto/mx6solo.cfg
--- u-boot-2016.03/board/freescale/mx6qsabreauto/mx6solo.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6qsabreauto/mx6solo.cfg	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, eimnor, nand, sata:
+ * spinor: flash_offset: 0x0400
+ * nand:   flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ * eimnor: flash_offset: 0x1000
+ */
+
+#if defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else /* others has the same flash_offset as sd */
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabreauto/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+DATA 4, 0x020e0774, 0x000C0000
+DATA 4, 0x020e0754, 0x00000000
+DATA 4, 0x020e04ac, 0x00000030
+DATA 4, 0x020e04b0, 0x00000030
+DATA 4, 0x020e0464, 0x00000030
+DATA 4, 0x020e0490, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e0494, 0x00000030
+DATA 4, 0x020e04a0, 0x00000000
+DATA 4, 0x020e04b4, 0x00000030
+DATA 4, 0x020e04b8, 0x00000030
+DATA 4, 0x020e076c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e04bc, 0x00000028
+DATA 4, 0x020e04c0, 0x00000028
+DATA 4, 0x020e04c4, 0x00000028
+DATA 4, 0x020e04c8, 0x00000028
+DATA 4, 0x020e0760, 0x00020000
+DATA 4, 0x020e0764, 0x00000028
+DATA 4, 0x020e0770, 0x00000028
+DATA 4, 0x020e0778, 0x00000028
+DATA 4, 0x020e077c, 0x00000028
+DATA 4, 0x020e0470, 0x00000028
+DATA 4, 0x020e0474, 0x00000028
+DATA 4, 0x020e0478, 0x00000028
+DATA 4, 0x020e047c, 0x00000028
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b083c, 0x421C0216
+DATA 4, 0x021b0840, 0x017B017A
+DATA 4, 0x021b0848, 0x4B4A4E4C
+DATA 4, 0x021b0850, 0x3F3F3334
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b0004, 0x00020025
+DATA 4, 0x021b0008, 0x00333030
+DATA 4, 0x021b000c, 0x676B5313
+DATA 4, 0x021b0010, 0xB66E8B63
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x006B1023
+DATA 4, 0x021b0040, 0x00000027
+DATA 4, 0x021b0000, 0x84190000
+DATA 4, 0x021b001c, 0x04008032
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x05208030
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b0020, 0x00005800
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b0004, 0x00025565
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0xFFFFF300
+DATA 4, 0x020c407c, 0x0F0000C3
+DATA 4, 0x020c4080, 0x00000FFF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6qsabreauto/plugin.S ebf_6ull_uboot/board/freescale/mx6qsabreauto/plugin.S
--- u-boot-2016.03/board/freescale/mx6qsabreauto/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6qsabreauto/plugin.S	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,667 @@
+/*
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6dqpsabreauto_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x57c]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001b001e
+	str r2, [r0, #0x80c]
+	ldr r2, =0x002e0029
+	str r2, [r0, #0x810]
+	ldr r1, =MMDC_P1_BASE_ADDR
+	ldr r2, =0x001b002a
+	str r2, [r1, #0x80c]
+	ldr r2, =0x0019002c
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x43240334
+	str r2, [r0, #0x83c]
+	ldr r2, =0x0324031a
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x43340344
+	str r2, [r1, #0x83c]
+	ldr r2, =0x03280276
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x44383A3E
+	str r2, [r0, #0x848]
+	ldr r2, =0x3C3C3846
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x2e303230
+	str r2, [r0, #0x850]
+	ldr r2, =0x38283E34
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x24912249
+	str r2, [r0, #0x8c0]
+	ldr r2, =0x24914289
+	str r2, [r1, #0x8c0]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020036
+	str r2, [r0, #0x004]
+	ldr r2, =0x24444040
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x898E7955
+	str r2, [r0, #0x00c]
+	ldr r2, =0xFF320F64
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x008E1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000047
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x14420000
+	str r2, [r0, #0x400]
+	ldr r2, =0x841A0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x00400C58
+	str r2, [r0, #0x890]
+
+	ldr r3, =0x00bb0000
+	ldr r2, =0x00000000
+	str r2, [r3, #0x008]
+	ldr r2, =0x2891E41A
+	str r2, [r3, #0x00c]
+	ldr r2, =0x00000564
+	str r2, [r3, #0x038]
+	ldr r2, =0x00000040
+	str r2, [r3, #0x014]
+	ldr r2, =0x00000020
+	str r2, [r3, #0x028]
+	str r2, [r3, #0x02c]
+
+	ldr r2, =0x04088032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x09408030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6dqsabreauto_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x57c]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+	ldr r1, =MMDC_P1_BASE_ADDR
+	str r2, [r1, #0x80c]
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x43260335
+	str r2, [r0, #0x83c]
+	ldr r2, =0x031A030B
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x4323033B
+	str r2, [r1, #0x83c]
+	ldr r2, =0x0323026F
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x483D4545
+	str r2, [r0, #0x848]
+	ldr r2, =0x44433E48
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x41444840
+	str r2, [r0, #0x850]
+	ldr r2, =0x4835483E
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020036
+	str r2, [r0, #0x004]
+	ldr r2, =0x09444040
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x8A8F7955
+	str r2, [r0, #0x00c]
+	ldr r2, =0xFF328F64
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x008F1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000047
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x841A0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04088032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x09408030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6dlsabreauto_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x76c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+	str r1, [r0, #0x4cc]
+	str r1, [r0, #0x4d0]
+	str r1, [r0, #0x4d4]
+	str r1, [r0, #0x4d8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x780]
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x78c]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+	str r1, [r0, #0x480]
+	str r1, [r0, #0x484]
+	str r1, [r0, #0x488]
+	str r1, [r0, #0x48c]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001f001f
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+	ldr r1, =MMDC_P1_BASE_ADDR
+	str r2, [r1, #0x80c]
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x42190217
+	str r2, [r0, #0x83c]
+	ldr r2, =0x017b017b
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x4176017b
+	str r2, [r1, #0x83c]
+	ldr r2, =0x015f016c
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x4c4c4d4c
+	str r2, [r0, #0x848]
+	ldr r2, =0x4a4d4c48
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x3f3f3f40
+	str r2, [r0, #0x850]
+	ldr r2, =0x3538382e
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020025
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x676b5313
+	str r2, [r0, #0x00c]
+	ldr r2, =0xb66e8b63
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01ff00db
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x006b1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000047
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x841a0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x00025565
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6solosabreauto_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x76c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+
+	ldr r2, =0x421C0216
+	str r2, [r0, #0x83c]
+	ldr r2, =0x017B017A
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x4B4A4E4C
+	str r2, [r0, #0x848]
+
+	ldr r2, =0x3F3F3334
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x00020025
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x676B5313
+	str r2, [r0, #0x00c]
+	ldr r2, =0xB66E8B63
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x006B1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x84190000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	ldr r2, =0x00025565
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x00C03F3F
+	str r1, [r0, #0x068]
+	ldr r1, =0x0030FC03
+	str r1, [r0, #0x06c]
+	ldr r1, =0x0FFFC000
+	str r1, [r0, #0x070]
+	ldr r1, =0x3FF00000
+	str r1, [r0, #0x074]
+	ldr r1, =0xFFFFF300
+	str r1, [r0, #0x078]
+	ldr r1, =0x0F0000C3
+	str r1, [r0, #0x07c]
+	ldr r1, =0x00000FFF
+	str r1, [r0, #0x080]
+.endm
+
+.macro imx6_qos_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+
+#if defined(CONFIG_MX6QP)
+	ldr r1, =0x77177717
+	str r1, [r0, #0x18]
+	str r1, [r0, #0x1c]
+#else
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	str r1, [r0, #0x1c]
+#endif
+.endm
+
+.macro imx6_ddr_setting
+#if defined (CONFIG_MX6SOLO)
+	imx6solosabreauto_ddr_setting
+#elif defined (CONFIG_MX6DL)
+	imx6dlsabreauto_ddr_setting
+#elif defined (CONFIG_MX6QP)
+	imx6dqpsabreauto_ddr_setting
+#elif defined (CONFIG_MX6Q)
+	imx6dqsabreauto_ddr_setting
+#else
+	#error "SOC not configured"
+#endif
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6sabresd/Makefile ebf_6ull_uboot/board/freescale/mx6sabresd/Makefile
--- u-boot-2016.03/board/freescale/mx6sabresd/Makefile	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sabresd/Makefile	2021-04-16 14:42:16.956592502 +0800
@@ -1,9 +1,13 @@
 #
 # Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
 #
-# (C) Copyright 2011 Freescale Semiconductor, Inc.
+# (C) Copyright 2011-2016 Freescale Semiconductor, Inc.
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
 obj-y  := mx6sabresd.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6sabresd/mx6dlsabresd.cfg ebf_6ull_uboot/board/freescale/mx6sabresd/mx6dlsabresd.cfg
--- u-boot-2016.03/board/freescale/mx6sabresd/mx6dlsabresd.cfg	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sabresd/mx6dlsabresd.cfg	2021-04-16 14:42:16.956592502 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  *
@@ -9,6 +9,8 @@
  * The syntax is taken as close as possible with the kwbimage
  */
 
+#define __ASSEMBLY__
+#include <config.h>
 /* image version */
 
 IMAGE_VERSION 2
@@ -19,6 +21,14 @@
  */
 
 BOOT_FROM	sd
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN board/freescale/mx6sabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
 
 /*
  * Device Configuration Data (DCD)
@@ -129,3 +139,4 @@
 /* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
 DATA 4 0x020e0018 0x007F007F
 DATA 4 0x020e001c 0x007F007F
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6sabresd/mx6q_4x_mt41j128.cfg ebf_6ull_uboot/board/freescale/mx6sabresd/mx6q_4x_mt41j128.cfg
--- u-boot-2016.03/board/freescale/mx6sabresd/mx6q_4x_mt41j128.cfg	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sabresd/mx6q_4x_mt41j128.cfg	2021-04-16 14:42:16.956592502 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2016 Freescale Semiconductor, Inc.
  * Jason Liu <r64343@freescale.com>
  *
  * SPDX-License-Identifier:	GPL-2.0+
@@ -10,15 +10,31 @@
  * The syntax is taken as close as possible with the kwbimage
  */
 
+#define __ASSEMBLY__
+#include <config.h>
 /* image version */
 IMAGE_VERSION 2
 
 /*
- * Boot Device : one of
- * spi, sd (the board has no nand neither onenand)
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
  */
+
+/* the same flash_offset as sd */
 BOOT_FROM      sd
 
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
 /*
  * Device Configuration Data (DCD)
  *
@@ -30,117 +46,89 @@
  *      Address   absolute address of the register
  *      value     value to be stored in the register
  */
+DATA 4 0x020e0798 0x000C0000
+DATA 4 0x020e0758 0x00000000
+DATA 4 0x020e0588 0x00000030
+DATA 4 0x020e0594 0x00000030
+DATA 4 0x020e056c 0x00000030
+DATA 4 0x020e0578 0x00000030
+DATA 4 0x020e074c 0x00000030
+DATA 4 0x020e057c 0x00000030
+DATA 4 0x020e058c 0x00000000
+DATA 4 0x020e059c 0x00000030
+DATA 4 0x020e05a0 0x00000030
+DATA 4 0x020e078c 0x00000030
+DATA 4 0x020e0750 0x00020000
 DATA 4 0x020e05a8 0x00000030
 DATA 4 0x020e05b0 0x00000030
 DATA 4 0x020e0524 0x00000030
 DATA 4 0x020e051c 0x00000030
-
 DATA 4 0x020e0518 0x00000030
 DATA 4 0x020e050c 0x00000030
 DATA 4 0x020e05b8 0x00000030
 DATA 4 0x020e05c0 0x00000030
-
-DATA 4 0x020e05ac 0x00020030
-DATA 4 0x020e05b4 0x00020030
-DATA 4 0x020e0528 0x00020030
-DATA 4 0x020e0520 0x00020030
-
-DATA 4 0x020e0514 0x00020030
-DATA 4 0x020e0510 0x00020030
-DATA 4 0x020e05bc 0x00020030
-DATA 4 0x020e05c4 0x00020030
-
-DATA 4 0x020e056c 0x00020030
-DATA 4 0x020e0578 0x00020030
-DATA 4 0x020e0588 0x00020030
-DATA 4 0x020e0594 0x00020030
-
-DATA 4 0x020e057c 0x00020030
-DATA 4 0x020e0590 0x00003000
-DATA 4 0x020e0598 0x00003000
-DATA 4 0x020e058c 0x00000000
-
-DATA 4 0x020e059c 0x00003030
-DATA 4 0x020e05a0 0x00003030
+DATA 4 0x020e0774 0x00020000
 DATA 4 0x020e0784 0x00000030
 DATA 4 0x020e0788 0x00000030
-
 DATA 4 0x020e0794 0x00000030
 DATA 4 0x020e079c 0x00000030
 DATA 4 0x020e07a0 0x00000030
 DATA 4 0x020e07a4 0x00000030
-
 DATA 4 0x020e07a8 0x00000030
 DATA 4 0x020e0748 0x00000030
-DATA 4 0x020e074c 0x00000030
-DATA 4 0x020e0750 0x00020000
-
-DATA 4 0x020e0758 0x00000000
-DATA 4 0x020e0774 0x00020000
-DATA 4 0x020e078c 0x00000030
-DATA 4 0x020e0798 0x000C0000
-
+DATA 4 0x020e05ac 0x00000030
+DATA 4 0x020e05b4 0x00000030
+DATA 4 0x020e0528 0x00000030
+DATA 4 0x020e0520 0x00000030
+DATA 4 0x020e0514 0x00000030
+DATA 4 0x020e0510 0x00000030
+DATA 4 0x020e05bc 0x00000030
+DATA 4 0x020e05c4 0x00000030
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b080c 0x001F001F
+DATA 4 0x021b0810 0x001F001F
+DATA 4 0x021b480c 0x001F001F
+DATA 4 0x021b4810 0x001F001F
+DATA 4 0x021b083c 0x43270338
+DATA 4 0x021b0840 0x03200314
+DATA 4 0x021b483c 0x431A032F
+DATA 4 0x021b4840 0x03200263
+DATA 4 0x021b0848 0x4B434748
+DATA 4 0x021b4848 0x4445404C
+DATA 4 0x021b0850 0x38444542
+DATA 4 0x021b4850 0x4935493A
 DATA 4 0x021b081c 0x33333333
 DATA 4 0x021b0820 0x33333333
 DATA 4 0x021b0824 0x33333333
 DATA 4 0x021b0828 0x33333333
-
 DATA 4 0x021b481c 0x33333333
 DATA 4 0x021b4820 0x33333333
 DATA 4 0x021b4824 0x33333333
 DATA 4 0x021b4828 0x33333333
-
-DATA 4 0x021b0018 0x00081740
-
-DATA 4 0x021b001c 0x00008000
-DATA 4 0x021b000c 0x555A7974
-DATA 4 0x021b0010 0xDB538F64
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b48b8 0x00000800
+DATA 4 0x021b0004 0x00020036
+DATA 4 0x021b0008 0x09444040
+DATA 4 0x021b000c 0x555A7975
+DATA 4 0x021b0010 0xFF538F64
 DATA 4 0x021b0014 0x01FF00DB
-DATA 4 0x021b002c 0x000026D2
-
+DATA 4 0x021b0018 0x00001740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
 DATA 4 0x021b0030 0x005A1023
-DATA 4 0x021b0008 0x09444040
-DATA 4 0x021b0004 0x00025576
 DATA 4 0x021b0040 0x00000027
 DATA 4 0x021b0000 0x831A0000
-
 DATA 4 0x021b001c 0x04088032
-DATA 4 0x021b001c 0x0408803A
 DATA 4 0x021b001c 0x00008033
-DATA 4 0x021b001c 0x0000803B
-DATA 4 0x021b001c 0x00428031
-DATA 4 0x021b001c 0x00428039
-DATA 4 0x021b001c 0x19308030
-DATA 4 0x021b001c 0x19308038
-
+DATA 4 0x021b001c 0x00048031
+DATA 4 0x021b001c 0x09408030
 DATA 4 0x021b001c 0x04008040
-DATA 4 0x021b001c 0x04008048
-DATA 4 0x021b0800 0xA1380003
-DATA 4 0x021b4800 0xA1380003
 DATA 4 0x021b0020 0x00005800
-DATA 4 0x021b0818 0x00022227
-DATA 4 0x021b4818 0x00022227
-
-DATA 4 0x021b083c 0x434B0350
-DATA 4 0x021b0840 0x034C0359
-DATA 4 0x021b483c 0x434B0350
-DATA 4 0x021b4840 0x03650348
-DATA 4 0x021b0848 0x4436383B
-DATA 4 0x021b4848 0x39393341
-DATA 4 0x021b0850 0x35373933
-DATA 4 0x021b4850 0x48254A36
-
-DATA 4 0x021b080c 0x001F001F
-DATA 4 0x021b0810 0x001F001F
-
-DATA 4 0x021b480c 0x00440044
-DATA 4 0x021b4810 0x00440044
-
-DATA 4 0x021b08b8 0x00000800
-DATA 4 0x021b48b8 0x00000800
-
-DATA 4 0x021b001c 0x00000000
+DATA 4 0x021b0818 0x00011117
+DATA 4 0x021b4818 0x00011117
+DATA 4 0x021b0004 0x00025576
 DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
 
 /* set the default clock gate to save power */
 DATA 4 0x020c4068 0x00C03F3F
@@ -148,7 +136,7 @@
 DATA 4 0x020c4070 0x0FFFC000
 DATA 4 0x020c4074 0x3FF00000
 DATA 4 0x020c4078 0x00FFF300
-DATA 4 0x020c407c 0x0F0000C3
+DATA 4 0x020c407c 0x0F0000F3
 DATA 4 0x020c4080 0x000003FF
 
 /* enable AXI cache for VDOA/VPU/IPU */
@@ -167,3 +155,4 @@
  * This sets CKO1 at ahb_clk_root/8 = 132/8 = 16.5 MHz
  */
 DATA 4 0x020c4060 0x000000fb
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6sabresd/mx6qp.cfg ebf_6ull_uboot/board/freescale/mx6sabresd/mx6qp.cfg
--- u-boot-2016.03/board/freescale/mx6sabresd/mx6qp.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sabresd/mx6qp.cfg	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+DATA 4, 0x020e0798, 0x000c0000
+DATA 4, 0x020e0758, 0x00000000
+DATA 4, 0x020e0588, 0x00000030
+DATA 4, 0x020e0594, 0x00000030
+DATA 4, 0x020e056c, 0x00000030
+DATA 4, 0x020e0578, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e057c, 0x00000030
+DATA 4, 0x020e058c, 0x00000000
+DATA 4, 0x020e059c, 0x00000030
+DATA 4, 0x020e05a0, 0x00000030
+DATA 4, 0x020e078c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e05a8, 0x00000030
+DATA 4, 0x020e05b0, 0x00000030
+DATA 4, 0x020e0524, 0x00000030
+DATA 4, 0x020e051c, 0x00000030
+DATA 4, 0x020e0518, 0x00000030
+DATA 4, 0x020e050c, 0x00000030
+DATA 4, 0x020e05b8, 0x00000030
+DATA 4, 0x020e05c0, 0x00000030
+
+DATA 4, 0x020e0534, 0x00018200
+DATA 4, 0x020e0538, 0x00008000
+DATA 4, 0x020e053c, 0x00018200
+DATA 4, 0x020e0540, 0x00018200
+DATA 4, 0x020e0544, 0x00018200
+DATA 4, 0x020e0548, 0x00018200
+DATA 4, 0x020e054c, 0x00018200
+DATA 4, 0x020e0550, 0x00018200
+
+DATA 4, 0x020e0774, 0x00020000
+DATA 4, 0x020e0784, 0x00000030
+DATA 4, 0x020e0788, 0x00000030
+DATA 4, 0x020e0794, 0x00000030
+DATA 4, 0x020e079c, 0x00000030
+DATA 4, 0x020e07a0, 0x00000030
+DATA 4, 0x020e07a4, 0x00000030
+DATA 4, 0x020e07a8, 0x00000030
+DATA 4, 0x020e0748, 0x00000030
+DATA 4, 0x020e05ac, 0x00000030
+DATA 4, 0x020e05b4, 0x00000030
+DATA 4, 0x020e0528, 0x00000030
+DATA 4, 0x020e0520, 0x00000030
+DATA 4, 0x020e0514, 0x00000030
+DATA 4, 0x020e0510, 0x00000030
+DATA 4, 0x020e05bc, 0x00000030
+DATA 4, 0x020e05c4, 0x00000030
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001b001e
+DATA 4, 0x021b0810, 0x002e0029
+DATA 4, 0x021b480c, 0x001b002a
+DATA 4, 0x021b4810, 0x0019002c
+DATA 4, 0x021b083c, 0x43240334
+DATA 4, 0x021b0840, 0x0324031a
+DATA 4, 0x021b483c, 0x43340344
+DATA 4, 0x021b4840, 0x03280276
+DATA 4, 0x021b0848, 0x44383A3E
+DATA 4, 0x021b4848, 0x3C3C3846
+DATA 4, 0x021b0850, 0x2e303230
+DATA 4, 0x021b4850, 0x38283E34
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x33333333
+DATA 4, 0x021b4828, 0x33333333
+DATA 4, 0x021b08c0, 0x24912489
+DATA 4, 0x021b48c0, 0x24914452
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b48b8, 0x00000800
+DATA 4, 0x021b0004, 0x00020036
+DATA 4, 0x021b0008, 0x24444040
+DATA 4, 0x021b000c, 0x555A7955
+DATA 4, 0x021b0010, 0xFF320F64
+DATA 4, 0x021b0014, 0x01ff00db
+DATA 4, 0x021b0018, 0x00011740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x005A1023
+DATA 4, 0x021b0040, 0x00000027
+DATA 4, 0x021b0400, 0x14420000
+DATA 4, 0x021b0000, 0x831A0000
+DATA 4, 0x021b0890, 0x00400C58
+DATA 4, 0x00bb0008, 0x00000000
+DATA 4, 0x00bb000c, 0x2891E41A
+DATA 4, 0x00bb0038, 0x00000564
+DATA 4, 0x00bb0014, 0x00000040
+DATA 4, 0x00bb0028, 0x00000020
+DATA 4, 0x00bb002c, 0x00000020
+DATA 4, 0x021b001c, 0x04088032
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x09408030
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b0020, 0x00005800
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b4818, 0x00011117
+DATA 4, 0x021b0004, 0x00025576
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id1 Qos=0x1 AXI-id0/2/3 Qos=0x7 */
+DATA 4, 0x020e0018, 0x77177717
+DATA 4, 0x020e001c, 0x77177717
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6sabresd/mx6sabresd.c ebf_6ull_uboot/board/freescale/mx6sabresd/mx6sabresd.c
--- u-boot-2016.03/board/freescale/mx6sabresd/mx6sabresd.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sabresd/mx6sabresd.c	2021-04-16 14:42:16.956592502 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
  *
  * Author: Fabio Estevam <fabio.estevam@freescale.com>
  *
@@ -30,6 +30,19 @@
 #include "../common/pfuze.h"
 #include <asm/arch/mx6-ddr.h>
 #include <usb.h>
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
+#ifdef CONFIG_CMD_SATA
+#include <asm/imx-common/sata.h>
+#endif
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -51,6 +64,14 @@
 	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
 	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
 
+#define EPDC_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+
 #define I2C_PMIC	1
 
 #define I2C_PAD MUX_PAD_CTRL(I2C_PAD_CTRL)
@@ -140,6 +161,7 @@
 	MX6_PAD_SD4_DAT7__SD4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
 };
 
+#ifdef CONFIG_MXC_SPI
 static iomux_v3_cfg_t const ecspi1_pads[] = {
 	MX6_PAD_KEY_COL0__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
 	MX6_PAD_KEY_COL1__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
@@ -147,6 +169,17 @@
 	MX6_PAD_KEY_ROW1__GPIO4_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
 };
 
+static void setup_spi(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 9)) : -1;
+}
+#endif
+
 static iomux_v3_cfg_t const rgb_pads[] = {
 	MX6_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK | MUX_PAD_CTRL(NO_PAD_CTRL),
 	MX6_PAD_DI0_PIN15__IPU1_DI0_PIN15 | MUX_PAD_CTRL(NO_PAD_CTRL),
@@ -199,11 +232,6 @@
 	}
 };
 
-static void setup_spi(void)
-{
-	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
-}
-
 iomux_v3_cfg_t const pcie_pads[] = {
 	MX6_PAD_EIM_D19__GPIO3_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),	/* POWER */
 	MX6_PAD_GPIO_17__GPIO7_IO12 | MUX_PAD_CTRL(NO_PAD_CTRL),	/* RESET */
@@ -225,6 +253,54 @@
 	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
 }
 
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+static iomux_v3_cfg_t const epdc_enable_pads[] = {
+	MX6_PAD_EIM_A16__EPDC_DATA00	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA10__EPDC_DATA01	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA12__EPDC_DATA02	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA11__EPDC_DATA03	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_LBA__EPDC_DATA04	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_EB2__EPDC_DATA05	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_CS0__EPDC_DATA06	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_RW__EPDC_DATA07	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A21__EPDC_GDCLK	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A22__EPDC_GDSP	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A23__EPDC_GDOE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A24__EPDC_GDRL	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_D31__EPDC_SDCLK_P	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_D27__EPDC_SDOE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA1__EPDC_SDLE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_EB1__EPDC_SDSHR	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA2__EPDC_BDR0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA4__EPDC_SDCE0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA5__EPDC_SDCE1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA6__EPDC_SDCE2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const epdc_disable_pads[] = {
+	MX6_PAD_EIM_A16__GPIO2_IO22,
+	MX6_PAD_EIM_DA10__GPIO3_IO10,
+	MX6_PAD_EIM_DA12__GPIO3_IO12,
+	MX6_PAD_EIM_DA11__GPIO3_IO11,
+	MX6_PAD_EIM_LBA__GPIO2_IO27,
+	MX6_PAD_EIM_EB2__GPIO2_IO30,
+	MX6_PAD_EIM_CS0__GPIO2_IO23,
+	MX6_PAD_EIM_RW__GPIO2_IO26,
+	MX6_PAD_EIM_A21__GPIO2_IO17,
+	MX6_PAD_EIM_A22__GPIO2_IO16,
+	MX6_PAD_EIM_A23__GPIO6_IO06,
+	MX6_PAD_EIM_A24__GPIO5_IO04,
+	MX6_PAD_EIM_D31__GPIO3_IO31,
+	MX6_PAD_EIM_D27__GPIO3_IO27,
+	MX6_PAD_EIM_DA1__GPIO3_IO01,
+	MX6_PAD_EIM_EB1__GPIO2_IO29,
+	MX6_PAD_EIM_DA2__GPIO3_IO02,
+	MX6_PAD_EIM_DA4__GPIO3_IO04,
+	MX6_PAD_EIM_DA5__GPIO3_IO05,
+	MX6_PAD_EIM_DA6__GPIO3_IO06,
+};
+#endif
+
 #ifdef CONFIG_FSL_ESDHC
 struct fsl_esdhc_cfg usdhc_cfg[3] = {
 	{USDHC2_BASE_ADDR},
@@ -240,6 +316,11 @@
 	return devno - 1;
 }
 
+int mmc_map_to_kernel_blk(int devno)
+{
+	return devno + 1;
+}
+
 int board_mmc_getcd(struct mmc *mmc)
 {
 	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
@@ -346,6 +427,225 @@
 }
 #endif
 
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+vidinfo_t panel_info = {
+	.vl_refresh = 85,
+	.vl_col = 800,
+	.vl_row = 600,
+	.vl_pixclock = 26666667,
+	.vl_left_margin = 8,
+	.vl_right_margin = 100,
+	.vl_upper_margin = 4,
+	.vl_lower_margin = 8,
+	.vl_hsync = 4,
+	.vl_vsync = 1,
+	.vl_sync = 0,
+	.vl_mode = 0,
+	.vl_flag = 0,
+	.vl_bpix = 3,
+	.cmap = 0,
+};
+
+struct epdc_timing_params panel_timings = {
+	.vscan_holdoff = 4,
+	.sdoed_width = 10,
+	.sdoed_delay = 20,
+	.sdoez_width = 10,
+	.sdoez_delay = 20,
+	.gdclk_hp_offs = 419,
+	.gdsp_offs = 20,
+	.gdoe_offs = 0,
+	.gdclk_offs = 5,
+	.num_ce = 1,
+};
+
+static void setup_epdc_power(void)
+{
+	/* Setup epdc voltage */
+
+	/* EIM_A17 - GPIO2[21] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A17__GPIO2_IO21 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as input */
+	gpio_direction_input(IMX_GPIO_NR(2, 21));
+
+	/* EIM_D17 - GPIO3[17] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D17__GPIO3_IO17 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(3, 17), 1);
+
+	/* EIM_D20 - GPIO3[20] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D20__GPIO3_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(3, 20), 1);
+
+	/* EIM_A18 - GPIO2[20] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A18__GPIO2_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 20), 1);
+}
+
+static void epdc_enable_pins(void)
+{
+	/* epdc iomux settings */
+	imx_iomux_v3_setup_multiple_pads(epdc_enable_pads,
+				ARRAY_SIZE(epdc_enable_pads));
+}
+
+static void epdc_disable_pins(void)
+{
+	/* Configure MUX settings for EPDC pins to GPIO */
+	imx_iomux_v3_setup_multiple_pads(epdc_disable_pads,
+				ARRAY_SIZE(epdc_disable_pads));
+}
+
+static void setup_epdc(void)
+{
+	unsigned int reg;
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/*** epdc Maxim PMIC settings ***/
+
+	/* EPDC PWRSTAT - GPIO2[21] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A17__GPIO2_IO21 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC VCOM0 - GPIO3[17] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D17__GPIO3_IO17 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* UART4 TXD - GPIO3[20] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D20__GPIO3_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EIM_A18 - GPIO2[20] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A18__GPIO2_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/*** Set pixel clock rates for EPDC ***/
+
+	/* EPDC AXI clk (IPU2_CLK) from PFD_400M, set to 396/2 = 198MHz */
+	reg = readl(&ccm_regs->cscdr3);
+	reg &= ~0x7C000;
+	reg |= (1 << 16) | (1 << 14);
+	writel(reg, &ccm_regs->cscdr3);
+
+	/* EPDC AXI clk enable */
+	reg = readl(&ccm_regs->CCGR3);
+	reg |= 0x00C0;
+	writel(reg, &ccm_regs->CCGR3);
+
+	/* EPDC PIX clk (IPU2_DI1_CLK) from PLL5, set to 650/4/6 = ~27MHz */
+	reg = readl(&ccm_regs->cscdr2);
+	reg &= ~0x3FE00;
+	reg |= (2 << 15) | (5 << 12);
+	writel(reg, &ccm_regs->cscdr2);
+
+	/* PLL5 enable (defaults to 650) */
+	reg = readl(&ccm_regs->analog_pll_video);
+	reg &= ~((1 << 16) | (1 << 12));
+	reg |= (1 << 13);
+	writel(reg, &ccm_regs->analog_pll_video);
+
+	/* EPDC PIX clk enable */
+	reg = readl(&ccm_regs->CCGR3);
+	reg |= 0x0C00;
+	writel(reg, &ccm_regs->CCGR3);
+
+	panel_info.epdc_data.wv_modes.mode_init = 0;
+	panel_info.epdc_data.wv_modes.mode_du = 1;
+	panel_info.epdc_data.wv_modes.mode_gc4 = 3;
+	panel_info.epdc_data.wv_modes.mode_gc8 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc16 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc32 = 2;
+
+	panel_info.epdc_data.epdc_timings = panel_timings;
+
+	setup_epdc_power();
+}
+
+void epdc_power_on(void)
+{
+	unsigned int reg;
+	struct gpio_regs *gpio_regs = (struct gpio_regs *)GPIO2_BASE_ADDR;
+
+	/* Set EPD_PWR_CTL0 to high - enable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 20), 1);
+	udelay(1000);
+
+	/* Enable epdc signal pin */
+	epdc_enable_pins();
+
+	/* Set PMIC Wakeup to high - enable Display power */
+	gpio_set_value(IMX_GPIO_NR(3, 20), 1);
+
+	/* Wait for PWRGOOD == 1 */
+	while (1) {
+		reg = readl(&gpio_regs->gpio_psr);
+		if (!(reg & (1 << 21)))
+			break;
+
+		udelay(100);
+	}
+
+	/* Enable VCOM */
+	gpio_set_value(IMX_GPIO_NR(3, 17), 1);
+
+	udelay(500);
+}
+
+void epdc_power_off(void)
+{
+	/* Set PMIC Wakeup to low - disable Display power */
+	gpio_set_value(IMX_GPIO_NR(3, 20), 0);
+
+	/* Disable VCOM */
+	gpio_set_value(IMX_GPIO_NR(3, 17), 0);
+
+	epdc_disable_pins();
+
+	/* Set EPD_PWR_CTL0 to low - disable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 20), 0);
+}
+#endif
+
+int mx6_rgmii_rework(struct phy_device *phydev)
+{
+	unsigned short val;
+
+	/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x7);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x8016);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4007);
+
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
+	val &= 0xffe3;
+	val |= 0x18;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, val);
+
+	/* introduce tx clock delay */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x5);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
+	val |= 0x0100;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, val);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	mx6_rgmii_rework(phydev);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
 #if defined(CONFIG_VIDEO_IPUV3)
 static void disable_lvds(struct display_info_t const *dev)
 {
@@ -399,21 +699,21 @@
 	.bus	= -1,
 	.addr	= 0,
 	.pixfmt	= IPU_PIX_FMT_RGB24,
-	.detect	= detect_hdmi,
+	.detect	= NULL,
 	.enable	= do_enable_hdmi,
 	.mode	= {
 		.name           = "HDMI",
 		.refresh        = 60,
-		.xres           = 1024,
-		.yres           = 768,
-		.pixclock       = 15385,
-		.left_margin    = 220,
-		.right_margin   = 40,
-		.upper_margin   = 21,
-		.lower_margin   = 7,
-		.hsync_len      = 60,
-		.vsync_len      = 10,
-		.sync           = FB_SYNC_EXT,
+		.xres           = 640,
+		.yres           = 480,
+		.pixclock       = 39721,
+		.left_margin    = 48,
+		.right_margin   = 16,
+		.upper_margin   = 33,
+		.lower_margin   = 10,
+		.hsync_len      = 96,
+		.vsync_len      = 2,
+		.sync           = 0,
 		.vmode          = FB_VMODE_NONINTERLACED
 } }, {
 	.bus	= 0,
@@ -503,6 +803,19 @@
 	return 1;
 }
 
+static void setup_fec(void)
+{
+	if (is_mx6dqp()) {
+		int ret;
+
+		/* select ENET MAC0 TX clock from PLL */
+		imx_iomux_set_gpr_register(5, 9, 1, 1);
+		ret = enable_fec_anatop_clock(0, ENET_125MHZ);
+		if (ret)
+		    printf("Error fec anatop clock settings!\n");
+	}
+}
+
 int board_eth_init(bd_t *bis)
 {
 	setup_iomux_enet();
@@ -517,7 +830,7 @@
 
 static iomux_v3_cfg_t const usb_otg_pads[] = {
 	MX6_PAD_EIM_D22__USB_OTG_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
-	MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
 };
 
 static iomux_v3_cfg_t const usb_hc1_pads[] = {
@@ -598,42 +911,212 @@
 	setup_usb();
 #endif
 
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+	setup_epdc();
+#endif
+
+#ifdef CONFIG_CMD_SATA
+	setup_sata();
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec();
+#endif
+
 	return 0;
 }
 
 int power_init_board(void)
 {
-	struct pmic *p;
+	struct pmic *pfuze;
 	unsigned int reg;
 	int ret;
 
-	p = pfuze_common_init(I2C_PMIC);
-	if (!p)
+	pfuze = pfuze_common_init(I2C_PMIC);
+	if (!pfuze)
 		return -ENODEV;
 
-	ret = pfuze_mode_init(p, APS_PFM);
+	if (is_mx6dqp())
+		ret = pfuze_mode_init(pfuze, APS_APS);
+	else
+		ret = pfuze_mode_init(pfuze, APS_PFM);
+
 	if (ret < 0)
 		return ret;
+	/* VGEN3 and VGEN5 corrected on i.mx6qp board */
+	if (!is_mx6dqp()) {
+		/* Increase VGEN3 from 2.5 to 2.8V */
+		pmic_reg_read(pfuze, PFUZE100_VGEN3VOL, &reg);
+		reg &= ~LDO_VOL_MASK;
+		reg |= LDOB_2_80V;
+		pmic_reg_write(pfuze, PFUZE100_VGEN3VOL, reg);
+
+		/* Increase VGEN5 from 2.8 to 3V */
+		pmic_reg_read(pfuze, PFUZE100_VGEN5VOL, &reg);
+		reg &= ~LDO_VOL_MASK;
+		reg |= LDOB_3_00V;
+		pmic_reg_write(pfuze, PFUZE100_VGEN5VOL, reg);
+	}
 
-	/* Increase VGEN3 from 2.5 to 2.8V */
-	pmic_reg_read(p, PFUZE100_VGEN3VOL, &reg);
-	reg &= ~LDO_VOL_MASK;
-	reg |= LDOB_2_80V;
-	pmic_reg_write(p, PFUZE100_VGEN3VOL, reg);
-
-	/* Increase VGEN5 from 2.8 to 3V */
-	pmic_reg_read(p, PFUZE100_VGEN5VOL, &reg);
-	reg &= ~LDO_VOL_MASK;
-	reg |= LDOB_3_00V;
-	pmic_reg_write(p, PFUZE100_VGEN5VOL, reg);
+	if (is_mx6dqp()) {
+		/* set SW1C staby volatage 1.075V*/
+		pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &reg);
+		reg &= ~0x3f;
+		reg |= 0x1f;
+		pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, reg);
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &reg);
+		reg &= ~0xc0;
+		reg |= 0x40;
+		pmic_reg_write(pfuze, PFUZE100_SW1CCONF, reg);
+
+		/* set SW2/VDDARM staby volatage 0.975V*/
+		pmic_reg_read(pfuze, PFUZE100_SW2STBY, &reg);
+		reg &= ~0x3f;
+		reg |= 0x17;
+		pmic_reg_write(pfuze, PFUZE100_SW2STBY, reg);
+
+		/* set SW2/VDDARM step ramp up time to from 16us to 4us/25mV */
+		pmic_reg_read(pfuze, PFUZE100_SW2CONF, &reg);
+		reg &= ~0xc0;
+		reg |= 0x40;
+		pmic_reg_write(pfuze, PFUZE100_SW2CONF, reg);
+	} else {
+		/* set SW1AB staby volatage 0.975V*/
+		pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &reg);
+		reg &= ~0x3f;
+		reg |= 0x1b;
+		pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, reg);
+
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &reg);
+		reg &= ~0xc0;
+		reg |= 0x40;
+		pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, reg);
+
+		/* set SW1C staby volatage 0.975V*/
+		pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &reg);
+		reg &= ~0x3f;
+		reg |= 0x1b;
+		pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, reg);
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &reg);
+		reg &= ~0xc0;
+		reg |= 0x40;
+		pmic_reg_write(pfuze, PFUZE100_SW1CCONF, reg);
+	}
 
 	return 0;
 }
 
-#ifdef CONFIG_MXC_SPI
-int board_spi_cs_gpio(unsigned bus, unsigned cs)
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
 {
-	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 9)) : -1;
+	unsigned int value;
+	int is_400M;
+	unsigned char vddarm;
+	struct pmic *p = pmic_get("PFUZE100");
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* increase VDDARM/VDDSOC to support 1.2G chip */
+	if (check_1_2G()) {
+		ldo_bypass = 0;	/* ldo_enable on 1.2G chip */
+		printf("1.2G chip, increase VDDARM_IN/VDDSOC_IN\n");
+		if (is_mx6dqp()) {
+			/* increase VDDARM to 1.425V */
+			pmic_reg_read(p, PFUZE100_SW2VOL, &value);
+			value &= ~0x3f;
+			value |= 0x29;
+			pmic_reg_write(p, PFUZE100_SW2VOL, value);
+		} else {
+			/* increase VDDARM to 1.425V */
+			pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+			value &= ~0x3f;
+			value |= 0x2d;
+			pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+		}
+		/* increase VDDSOC to 1.425V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x2d;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+	}
+	/* switch to ldo_bypass mode , boot on 800Mhz */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		if (is_mx6dqp()) {
+			/* decrease VDDARM for 400Mhz DQP:1.1V*/
+			pmic_reg_read(p, PFUZE100_SW2VOL, &value);
+			value &= ~0x3f;
+			value |= 0x1c;
+			pmic_reg_write(p, PFUZE100_SW2VOL, value);
+		} else {
+			/* decrease VDDARM for 400Mhz DQ:1.1V, DL:1.275V */
+			pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+			value &= ~0x3f;
+			if (is_cpu_type(MXC_CPU_MX6DL))
+				value |= 0x27;
+			else
+				value |= 0x20;
+
+			pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+		}
+		/* increase VDDSOC to 1.3V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x28;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		/*
+		 * MX6Q/DQP:
+		 * VDDARM:1.15V@800M; VDDSOC:1.175V@800M
+		 * VDDARM:0.975V@400M; VDDSOC:1.175V@400M
+		 * MX6DL:
+		 * VDDARM:1.175V@800M; VDDSOC:1.175V@800M
+		 * VDDARM:1.075V@400M; VDDSOC:1.175V@400M
+		 */
+		is_400M = set_anatop_bypass(2);
+		if (is_mx6dqp()) {
+			pmic_reg_read(p, PFUZE100_SW2VOL, &value);
+			value &= ~0x3f;
+			if (is_400M)
+				value |= 0x17;
+			else
+				value |= 0x1e;
+			pmic_reg_write(p, PFUZE100_SW2VOL, value);
+		}
+
+		if (is_400M) {
+			if (is_cpu_type(MXC_CPU_MX6DL))
+				vddarm = 0x1f;
+			else
+				vddarm = 0x1b;
+		} else {
+			if (is_cpu_type(MXC_CPU_MX6DL))
+				vddarm = 0x23;
+			else
+				vddarm = 0x22;
+		}
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= vddarm;
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		/* decrease VDDSOC to 1.175V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x23;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
 }
 #endif
 
@@ -665,6 +1148,10 @@
 		setenv("board_rev", "MX6DL");
 #endif
 
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
 	return 0;
 }
 
@@ -674,6 +1161,122 @@
 	return 0;
 }
 
+#ifdef CONFIG_FSL_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "sata");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota sata");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+	    if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+	    if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+	    break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+	    if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+	    if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+	    break;
+	case MMC4_BOOT:
+	    if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc2");
+	    if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc2");
+	    break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(1, 5)
+iomux_v3_cfg_t const recovery_key_pads[] = {
+	(MX6_PAD_GPIO_5__GPIO1_IO05 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+int check_recovery_cmd_file(void)
+{
+    int button_pressed = 0;
+    int recovery_mode = 0;
+
+    recovery_mode = recovery_check_and_clean_flag();
+
+    /* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
+			ARRAY_SIZE(recovery_key_pads));
+
+    gpio_direction_input(GPIO_VOL_DN_KEY);
+
+    if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN key is low assert */
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+    }
+
+    return recovery_mode || button_pressed;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"boota sata recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"boota mmc0 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"boota mmc1 recovery");
+		break;
+	case MMC4_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"boota mmc2 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+
 #ifdef CONFIG_SPL_BUILD
 #include <spl.h>
 #include <libfdt.h>
diff -urN u-boot-2016.03/board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg ebf_6ull_uboot/board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg
--- u-boot-2016.03/board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN board/freescale/mx6sabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+DATA 4, 0x020e0774, 0x000C0000
+DATA 4, 0x020e0754, 0x00000000
+DATA 4, 0x020e04ac, 0x00000030
+DATA 4, 0x020e04b0, 0x00000030
+DATA 4, 0x020e0464, 0x00000030
+DATA 4, 0x020e0490, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e0494, 0x00000030
+DATA 4, 0x020e04a0, 0x00000000
+DATA 4, 0x020e04b4, 0x00000030
+DATA 4, 0x020e04b8, 0x00000030
+DATA 4, 0x020e076c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e04bc, 0x00000030
+DATA 4, 0x020e04c0, 0x00000030
+DATA 4, 0x020e04c4, 0x00000030
+DATA 4, 0x020e04c8, 0x00000030
+DATA 4, 0x020e0760, 0x00020000
+DATA 4, 0x020e0764, 0x00000030
+DATA 4, 0x020e0770, 0x00000030
+DATA 4, 0x020e0778, 0x00000030
+DATA 4, 0x020e077c, 0x00000030
+DATA 4, 0x020e0470, 0x00000030
+DATA 4, 0x020e0474, 0x00000030
+DATA 4, 0x020e0478, 0x00000030
+DATA 4, 0x020e047c, 0x00000030
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b083c, 0x42190219
+DATA 4, 0x021b0840, 0x017B0177
+DATA 4, 0x021b0848, 0x4B4D4E4D
+DATA 4, 0x021b0850, 0x3F3E2D36
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b0004, 0x0002002D
+DATA 4, 0x021b0008, 0x00333030
+DATA 4, 0x021b000c, 0x3F435313
+DATA 4, 0x021b0010, 0xB66E8B63
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x00431023
+DATA 4, 0x021b0040, 0x00000017
+DATA 4, 0x021b0000, 0x83190000
+DATA 4, 0x021b001c, 0x04008032
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x05208030
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b0020, 0x00005800
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b0004, 0x0002556D
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000C3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6sabresd/plugin.S ebf_6ull_uboot/board/freescale/mx6sabresd/plugin.S
--- u-boot-2016.03/board/freescale/mx6sabresd/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sabresd/plugin.S	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,682 @@
+/*
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6dqpsabresd_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x57c]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00018200
+	str r1, [r0, #0x534]
+	ldr r1, =0x00008000
+	str r1, [r0, #0x538]
+	ldr r1, =0x00018200
+	str r1, [r0, #0x53c]
+	str r1, [r0, #0x540]
+	str r1, [r0, #0x544]
+	str r1, [r0, #0x548]
+	str r1, [r0, #0x54c]
+	str r1, [r0, #0x550]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001b001e
+	str r2, [r0, #0x80c]
+	ldr r2, =0x002e0029
+	str r2, [r0, #0x810]
+
+	ldr r1, =MMDC_P1_BASE_ADDR
+	ldr r2, =0x001b002a
+	str r2, [r1, #0x80c]
+	ldr r2, =0x0019002c
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x43240334
+	str r2, [r0, #0x83c]
+	ldr r2, =0x0324031a
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x43340344
+	str r2, [r1, #0x83c]
+	ldr r2, =0x03280276
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x44383A3E
+	str r2, [r0, #0x848]
+	ldr r2, =0x3C3C3846
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x2e303230
+	str r2, [r0, #0x850]
+	ldr r2, =0x38283E34
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x24912489
+	str r2, [r0, #0x8c0]
+	ldr r2, =0x24914452
+	str r2, [r1, #0x8c0]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020036
+	str r2, [r0, #0x004]
+	ldr r2, =0x24444040
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x555A7955
+	str r2, [r0, #0x00c]
+	ldr r2, =0xFF320F64
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00011740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x005A1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x14420000
+	str r2, [r0, #0x400]
+
+	ldr r2, =0x831A0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x00400C58
+	str r2, [r0, #0x890]
+
+	ldr r3, =0x00bb0000
+	ldr r2, =0x00000000
+	str r2, [r3, #0x008]
+	ldr r2, =0x2891E41A
+	str r2, [r3, #0x00C]
+	ldr r2, =0x00000564
+	str r2, [r3, #0x038]
+	ldr r2, =0x00000040
+	str r2, [r3, #0x014]
+	ldr r2, =0x00000020
+	str r2, [r3, #0x028]
+	ldr r2, =0x00000020
+	str r2, [r3, #0x02c]
+
+	ldr r2, =0x04088032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x09408030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6dqsabresd_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x57c]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+	ldr r1, =MMDC_P1_BASE_ADDR
+	str r2, [r1, #0x80c]
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x43270338
+	str r2, [r0, #0x83c]
+	ldr r2, =0x03200314
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x431A032F
+	str r2, [r1, #0x83c]
+	ldr r2, =0x03200263
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x4B434748
+	str r2, [r0, #0x848]
+	ldr r2, =0x4445404C
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x38444542
+	str r2, [r0, #0x850]
+	ldr r2, =0x4935493A
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020036
+	str r2, [r0, #0x004]
+	ldr r2, =0x09444040
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x555A7975
+	str r2, [r0, #0x00c]
+	ldr r2, =0xFF538F64
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x005A1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x831A0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04088032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x09408030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6dlsabresd_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x76c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+	str r1, [r0, #0x4cc]
+	str r1, [r0, #0x4d0]
+	str r1, [r0, #0x4d4]
+	str r1, [r0, #0x4d8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x780]
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x78c]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+	str r1, [r0, #0x480]
+	str r1, [r0, #0x484]
+	str r1, [r0, #0x488]
+	str r1, [r0, #0x48c]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001f001f
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+	ldr r1, =MMDC_P1_BASE_ADDR
+	str r2, [r1, #0x80c]
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x4220021F
+	str r2, [r0, #0x83c]
+	ldr r2, =0x0207017E
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x4201020C
+	str r2, [r1, #0x83c]
+	ldr r2, =0x01660172
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x4A4D4E4D
+	str r2, [r0, #0x848]
+	ldr r2, =0x4A4F5049
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x3F3C3D31
+	str r2, [r0, #0x850]
+	ldr r2, =0x3238372B
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x0002002D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x3F435313
+	str r2, [r0, #0x00c]
+	ldr r2, =0xB66E8B63
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x00431023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x831A0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x0002556D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6solosabresd_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x76c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+
+	ldr r2, =0x42190219
+	str r2, [r0, #0x83c]
+	ldr r2, =0x017B0177
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x4B4D4E4D
+	str r2, [r0, #0x848]
+
+	ldr r2, =0x3F3E2D36
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x0002002D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x3F435313
+	str r2, [r0, #0x00c]
+	ldr r2, =0xB66E8B63
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x00431023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000017
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x83190000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	ldr r2, =0x0002556D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x00C03F3F
+	str r1, [r0, #0x068]
+	ldr r1, =0x0030FC03
+	str r1, [r0, #0x06c]
+	ldr r1, =0x0FFFC000
+	str r1, [r0, #0x070]
+	ldr r1, =0x3FF00000
+	str r1, [r0, #0x074]
+	ldr r1, =0x00FFF300
+	str r1, [r0, #0x078]
+	ldr r1, =0x0F0000C3
+	str r1, [r0, #0x07c]
+	ldr r1, =0x000003FF
+	str r1, [r0, #0x080]
+.endm
+
+.macro imx6_qos_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+
+#if defined(CONFIG_MX6QP)
+	ldr r1, =0x77177717
+	str r1, [r0, #0x18]
+	str r1, [r0, #0x1c]
+#else
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	str r1, [r0, #0x1c]
+#endif
+.endm
+
+.macro imx6_ddr_setting
+#if defined (CONFIG_MX6SOLO)
+	imx6solosabresd_ddr_setting
+#elif defined (CONFIG_MX6DL)
+	imx6dlsabresd_ddr_setting
+#elif defined (CONFIG_MX6QP)
+	imx6dqpsabresd_ddr_setting
+#elif defined (CONFIG_MX6Q)
+	imx6dqsabresd_ddr_setting
+#else
+	#error "SOC not configured"
+#endif
+
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6slevk/imximage.cfg ebf_6ull_uboot/board/freescale/mx6slevk/imximage.cfg
--- u-boot-2016.03/board/freescale/mx6slevk/imximage.cfg	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6slevk/imximage.cfg	2021-04-16 14:42:16.956592502 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  *
@@ -9,6 +9,9 @@
  * The syntax is taken as close as possible with the kwbimage
  */
 
+#define __ASSEMBLY__
+#include <config.h>
+
 /* image version */
 
 IMAGE_VERSION 2
@@ -20,6 +23,15 @@
 
 BOOT_FROM	sd
 
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6slevk/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
 /*
  * Device Configuration Data (DCD)
  *
@@ -97,6 +109,7 @@
 DATA 4 0x021b0008 0x00000000
 DATA 4 0x021b0040 0x0000004f
 DATA 4 0x021b0000 0xc3110000
+DATA 4 0x021b001c 0x00008050
 DATA 4 0x021b001c 0x003f8030
 DATA 4 0x021b001c 0xff0a8030
 DATA 4 0x021b001c 0x82018030
@@ -113,3 +126,4 @@
 DATA 4 0x021b0004 0x00025564
 DATA 4 0x021b0404 0x00011006
 DATA 4 0x021b001c 0x00000000
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6slevk/Makefile ebf_6ull_uboot/board/freescale/mx6slevk/Makefile
--- u-boot-2016.03/board/freescale/mx6slevk/Makefile	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6slevk/Makefile	2021-04-16 14:42:16.956592502 +0800
@@ -1,6 +1,10 @@
-# (C) Copyright 2013 Freescale Semiconductor, Inc.
+# (C) Copyright 2013-2016 Freescale Semiconductor, Inc.
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
 obj-y  := mx6slevk.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6slevk/mx6slevk.c ebf_6ull_uboot/board/freescale/mx6slevk/mx6slevk.c
--- u-boot-2016.03/board/freescale/mx6slevk/mx6slevk.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6slevk/mx6slevk.c	2021-04-16 14:42:16.956592502 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013 - 2016 Freescale Semiconductor, Inc.
  *
  * Author: Fabio Estevam <fabio.estevam@freescale.com>
  *
@@ -14,6 +14,7 @@
 #include <asm/arch/mx6-pins.h>
 #include <asm/arch/sys_proto.h>
 #include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
 #include <asm/imx-common/iomux-v3.h>
 #include <asm/imx-common/mxc_i2c.h>
 #include <asm/imx-common/spi.h>
@@ -29,6 +30,16 @@
 #include "../common/pfuze.h"
 #include <usb.h>
 #include <usb/ehci-fsl.h>
+#if defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -57,6 +68,12 @@
 			PAD_CTL_DSE_80ohm | PAD_CTL_HYS |	\
 			PAD_CTL_SRE_FAST)
 
+#define ELAN_INTR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
+			    PAD_CTL_PUS_47K_UP | PAD_CTL_HYS)
+
+#define EPDC_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
 #define ETH_PHY_POWER	IMX_GPIO_NR(4, 21)
 
 int dram_init(void)
@@ -126,6 +143,12 @@
 	MX6_PAD_FEC_TX_CLK__GPIO_4_21 | MUX_PAD_CTRL(NO_PAD_CTRL),
 };
 
+static iomux_v3_cfg_t const elan_pads[] = {
+	MX6_PAD_EPDC_PWRCTRL2__GPIO_2_9 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_EPDC_PWRCTRL3__GPIO_2_10 | MUX_PAD_CTRL(ELAN_INTR_PAD_CTRL),
+	MX6_PAD_KEY_COL6__GPIO_4_4 | MUX_PAD_CTRL(EPDC_PAD_CTRL),
+};
+
 #ifdef CONFIG_MXC_SPI
 static iomux_v3_cfg_t ecspi1_pads[] = {
 	MX6_PAD_ECSPI1_MISO__ECSPI_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
@@ -145,6 +168,52 @@
 }
 #endif
 
+static iomux_v3_cfg_t const epdc_enable_pads[] = {
+	MX6_PAD_EPDC_D0__EPDC_SDDO_0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_D1__EPDC_SDDO_1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_D2__EPDC_SDDO_2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_D3__EPDC_SDDO_3	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_D4__EPDC_SDDO_4	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_D5__EPDC_SDDO_5	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_D6__EPDC_SDDO_6	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_D7__EPDC_SDDO_7	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDCLK__EPDC_GDCLK	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDSP__EPDC_GDSP	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDOE__EPDC_GDOE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDRL__EPDC_GDRL	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDCLK__EPDC_SDCLK	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDOE__EPDC_SDOE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDLE__EPDC_SDLE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDSHR__EPDC_SDSHR	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_BDR0__EPDC_BDR_0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDCE0__EPDC_SDCE_0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDCE1__EPDC_SDCE_1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDCE2__EPDC_SDCE_2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const epdc_disable_pads[] = {
+	MX6_PAD_EPDC_D0__GPIO_1_7,
+	MX6_PAD_EPDC_D1__GPIO_1_8,
+	MX6_PAD_EPDC_D2__GPIO_1_9,
+	MX6_PAD_EPDC_D3__GPIO_1_10,
+	MX6_PAD_EPDC_D4__GPIO_1_11,
+	MX6_PAD_EPDC_D5__GPIO_1_12,
+	MX6_PAD_EPDC_D6__GPIO_1_13,
+	MX6_PAD_EPDC_D7__GPIO_1_14,
+	MX6_PAD_EPDC_GDCLK__GPIO_1_31,
+	MX6_PAD_EPDC_GDSP__GPIO_2_2,
+	MX6_PAD_EPDC_GDOE__GPIO_2_0,
+	MX6_PAD_EPDC_GDRL__GPIO_2_1,
+	MX6_PAD_EPDC_SDCLK__GPIO_1_23,
+	MX6_PAD_EPDC_SDOE__GPIO_1_25,
+	MX6_PAD_EPDC_SDLE__GPIO_1_24,
+	MX6_PAD_EPDC_SDSHR__GPIO_1_26,
+	MX6_PAD_EPDC_BDR0__GPIO_2_5,
+	MX6_PAD_EPDC_SDCE0__GPIO_1_27,
+	MX6_PAD_EPDC_SDCE1__GPIO_1_28,
+	MX6_PAD_EPDC_SDCE2__GPIO_1_29,
+};
+
 static void setup_iomux_uart(void)
 {
 	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
@@ -299,16 +368,101 @@
 
 int power_init_board(void)
 {
-	struct pmic *p;
+	struct pmic *pfuze;
+	unsigned int reg;
+	int ret;
 
-	p = pfuze_common_init(I2C_PMIC);
-	if (!p)
+	pfuze = pfuze_common_init(I2C_PMIC);
+	if (!pfuze)
 		return -ENODEV;
 
-	return pfuze_mode_init(p, APS_PFM);
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	/* set SW1AB staby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= 0x1b;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, reg);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, reg);
+
+	/* set SW1C staby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= 0x1b;
+	pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, reg);
+
+	/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1CCONF, reg);
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	u32 value;
+	int is_400M;
+	struct pmic *p = pmic_get("PFUZE100");
+
+	if (!p) {
+		printf("No pmic!\n");
+		return;
+	}
+
+	/* swith to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+
+		/* decrease VDDARM to 1.1V */
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= 0x20;
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		/* increase VDDSOC to 1.3V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x28;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		is_400M = set_anatop_bypass(0);
+
+		/*
+		 * MX6SL: VDDARM:1.175V@800M; VDDSOC:1.175V@800M
+		 *        VDDARM:0.975V@400M; VDDSOC:1.175V@400M
+		 */
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		if (is_400M)
+			value |= 0x1b;
+		else
+			value |= 0x23;
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		/* decrease VDDSOC to 1.175V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x23;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
 }
 #endif
 
+#endif
+
 #ifdef CONFIG_FEC_MXC
 int board_eth_init(bd_t *bis)
 {
@@ -380,6 +534,199 @@
 	return 0;
 }
 
+#ifdef CONFIG_MXC_EPDC
+vidinfo_t panel_info = {
+	.vl_refresh = 85,
+	.vl_col = 800,
+	.vl_row = 600,
+	.vl_rot = 0,
+	.vl_pixclock = 26666667,
+	.vl_left_margin = 8,
+	.vl_right_margin = 100,
+	.vl_upper_margin = 4,
+	.vl_lower_margin = 8,
+	.vl_hsync = 4,
+	.vl_vsync = 1,
+	.vl_sync = 0,
+	.vl_mode = 0,
+	.vl_flag = 0,
+	.vl_bpix = 3,
+	.cmap = 0,
+};
+
+struct epdc_timing_params panel_timings = {
+	.vscan_holdoff = 4,
+	.sdoed_width = 10,
+	.sdoed_delay = 20,
+	.sdoez_width = 10,
+	.sdoez_delay = 20,
+	.gdclk_hp_offs = 419,
+	.gdsp_offs = 20,
+	.gdoe_offs = 0,
+	.gdclk_offs = 5,
+	.num_ce = 1,
+};
+
+static void setup_epdc_power(void)
+{
+	/* Setup epdc voltage */
+
+	/* EPDC_PWRSTAT - GPIO2[13] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWRSTAT__GPIO_2_13 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	gpio_direction_input(IMX_GPIO_NR(2, 13));
+
+	/* EPDC_VCOM0 - GPIO2[3] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_VCOM0__GPIO_2_3 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 3), 1);
+
+	/* EPDC_PWRWAKEUP - GPIO2[14] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWRWAKEUP__GPIO_2_14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 14), 1);
+
+	/* EPDC_PWRCTRL0 - GPIO2[7] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWRCTRL0__GPIO_2_7 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 7), 1);
+}
+
+static void epdc_enable_pins(void)
+{
+	/* epdc iomux settings */
+	imx_iomux_v3_setup_multiple_pads(epdc_enable_pads,
+				ARRAY_SIZE(epdc_enable_pads));
+}
+
+static void epdc_disable_pins(void)
+{
+	/* Configure MUX settings for EPDC pins to GPIO  and drive to 0 */
+	imx_iomux_v3_setup_multiple_pads(epdc_disable_pads,
+				ARRAY_SIZE(epdc_disable_pads));
+}
+
+static void setup_epdc(void)
+{
+	unsigned int reg;
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/*** epdc Maxim PMIC settings ***/
+
+	/* EPDC PWRSTAT - GPIO2[13] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWRSTAT__GPIO_2_13 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC VCOM0 - GPIO2[3] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_VCOM0__GPIO_2_3 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* UART4 TXD - GPIO2[14] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWRWAKEUP__GPIO_2_14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EIM_A18 - GPIO2[7] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWRCTRL0__GPIO_2_7 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/*** Set pixel clock rates for EPDC ***/
+
+	/* EPDC AXI clk from PFD_400M, set to 396/2 = 198MHz */
+	reg = readl(&ccm_regs->chsccdr);
+	reg &= ~0x3F000;
+	reg |= (0x4 << 15) | (1 << 12);
+	writel(reg, &ccm_regs->chsccdr);
+
+	/* EPDC AXI clk enable */
+	reg = readl(&ccm_regs->CCGR3);
+	reg |= 0x0030;
+	writel(reg, &ccm_regs->CCGR3);
+
+	/* EPDC PIX clk from PFD_540M, set to 540/4/5 = 27MHz */
+	reg = readl(&ccm_regs->cscdr2);
+	reg &= ~0x03F000;
+	reg |= (0x5 << 15) | (4 << 12);
+	writel(reg, &ccm_regs->cscdr2);
+
+	reg = readl(&ccm_regs->cbcmr);
+	reg &= ~0x03800000;
+	reg |= (0x3 << 23);
+	writel(reg, &ccm_regs->cbcmr);
+
+	/* EPDC PIX clk enable */
+	reg = readl(&ccm_regs->CCGR3);
+	reg |= 0x0C00;
+	writel(reg, &ccm_regs->CCGR3);
+
+	panel_info.epdc_data.wv_modes.mode_init = 0;
+	panel_info.epdc_data.wv_modes.mode_du = 1;
+	panel_info.epdc_data.wv_modes.mode_gc4 = 3;
+	panel_info.epdc_data.wv_modes.mode_gc8 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc16 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc32 = 2;
+
+	panel_info.epdc_data.epdc_timings = panel_timings;
+
+	setup_epdc_power();
+}
+
+void epdc_power_on(void)
+{
+	unsigned int reg;
+	struct gpio_regs *gpio_regs = (struct gpio_regs *)GPIO2_BASE_ADDR;
+
+	/* Set EPD_PWR_CTL0 to high - enable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 7), 1);
+	udelay(1000);
+
+	/* Enable epdc signal pin */
+	epdc_enable_pins();
+
+	/* Set PMIC Wakeup to high - enable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 14), 1);
+
+	/* Wait for PWRGOOD == 1 */
+	while (1) {
+		reg = readl(&gpio_regs->gpio_psr);
+		if (!(reg & (1 << 13)))
+			break;
+
+		udelay(100);
+	}
+
+	/* Enable VCOM */
+	gpio_set_value(IMX_GPIO_NR(2, 3), 1);
+
+	udelay(500);
+}
+
+void epdc_power_off(void)
+{
+	/* Set PMIC Wakeup to low - disable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 14), 0);
+
+	/* Disable VCOM */
+	gpio_set_value(IMX_GPIO_NR(2, 3), 0);
+
+	epdc_disable_pins();
+
+	/* Set EPD_PWR_CTL0 to low - disable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 7), 0);
+}
+#endif
+
+void setup_elan_pads(void)
+{
+#define TOUCH_CS	IMX_GPIO_NR(2, 9)
+#define TOUCH_INT   IMX_GPIO_NR(2, 10)
+#define TOUCH_RST	IMX_GPIO_NR(4, 4)
+	imx_iomux_v3_setup_multiple_pads(elan_pads, ARRAY_SIZE(elan_pads));
+}
+
 int board_init(void)
 {
 	/* address of boot parameters */
@@ -387,12 +734,17 @@
 
 #ifdef CONFIG_SYS_I2C_MXC
 	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_elan_pads();
 #endif
 
 #ifdef	CONFIG_FEC_MXC
 	setup_fec();
 #endif
 
+#ifdef	CONFIG_MXC_EPDC
+	setup_epdc();
+#endif
+
 #ifdef CONFIG_USB_EHCI_MX6
 	setup_usb();
 #endif
@@ -400,6 +752,45 @@
 	return 0;
 }
 
+void elan_init(void)
+{
+	gpio_direction_input(TOUCH_INT);
+	/*
+	 * If epdc panel not plugged in, gpio_get_value(TOUCH_INT) will
+	 * return 1. And no need to mdelay, which will make i2c operation
+	 * slow.
+	 * If epdc panel plugged in, gpio_get_value(TOUCH_INT) will
+	 * return 0. And elan init flow will be executed.
+	 */
+	if (gpio_get_value(TOUCH_INT))
+		return;
+	gpio_direction_output(TOUCH_CS , 1);
+	gpio_set_value(TOUCH_CS, 0);
+	gpio_direction_output(TOUCH_RST , 1);
+	gpio_set_value(TOUCH_RST, 0);
+	mdelay(10);
+	gpio_set_value(TOUCH_RST, 1);
+	gpio_set_value(TOUCH_CS, 1);
+	mdelay(100);
+}
+
+/*
+ * This function overwrite the function defined in
+ * drivers/i2c/mxc_i2c.c, which is a weak symbol
+ */
+void i2c_force_reset_slave(void)
+{
+	elan_init();
+}
+
+int board_late_init(void)
+{
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+	return 0;
+}
+
 int checkboard(void)
 {
 	puts("Board: MX6SLEVK\n");
@@ -407,6 +798,111 @@
 	return 0;
 }
 
+#ifdef CONFIG_MXC_KPD
+#define MX6SL_KEYPAD_CTRL (PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE | \
+			   PAD_CTL_PUS_100K_UP | PAD_CTL_DSE_120ohm)
+
+iomux_v3_cfg_t const mxc_kpd_pads[] = {
+	(MX6_PAD_KEY_COL0__KPP_COL_0 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+	(MX6_PAD_KEY_COL1__KPP_COL_1 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+	(MX6_PAD_KEY_COL2__KPP_COL_2 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+	(MX6_PAD_KEY_COL3__KPP_COL_3 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+
+	(MX6_PAD_KEY_ROW0__KPP_ROW_0 | MUX_PAD_CTRL(MX6SL_KEYPAD_CTRL)),
+	(MX6_PAD_KEY_ROW1__KPP_ROW_1 | MUX_PAD_CTRL(MX6SL_KEYPAD_CTRL)),
+	(MX6_PAD_KEY_ROW2__KPP_ROW_2 | MUX_PAD_CTRL(MX6SL_KEYPAD_CTRL)),
+	(MX6_PAD_KEY_ROW3__KPP_ROW_3 | MUX_PAD_CTRL(MX6SL_KEYPAD_CTRL)),
+};
+int setup_mxc_kpd(void)
+{
+	imx_iomux_v3_setup_multiple_pads(mxc_kpd_pads,
+					 ARRAY_SIZE(mxc_kpd_pads));
+
+	return 0;
+}
+#endif /*CONFIG_MXC_KPD*/
+
+#ifdef CONFIG_FSL_FASTBOOT
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc2");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc2");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+int check_recovery_cmd_file(void)
+{
+    return recovery_check_and_clean_flag();
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	/*current uboot BSP only supports USDHC2*/
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+					"boota mmc0 recovery");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+					"boota mmc1 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+					"boota mmc2 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+
 #ifdef CONFIG_SPL_BUILD
 #include <spl.h>
 #include <libfdt.h>
diff -urN u-boot-2016.03/board/freescale/mx6slevk/plugin.S ebf_6ull_uboot/board/freescale/mx6slevk/plugin.S
--- u-boot-2016.03/board/freescale/mx6slevk/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6slevk/plugin.S	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6slevk_ddr_setting
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x00260324
+	str r1, [r0, #0x018]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5c0]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x5b4]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x338]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x300]
+	str r1, [r0, #0x31c]
+	str r1, [r0, #0x320]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x32c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5c8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5b0]
+
+	ldr r1, =0x00003030
+	str r1, [r0, #0x344]
+	str r1, [r0, #0x348]
+	str r1, [r0, #0x34c]
+	str r1, [r0, #0x350]
+
+	ldr r1, =0x00080000
+	str r1, [r0, #0x5d0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5c4]
+	str r1, [r0, #0x5cc]
+	str r1, [r0, #0x5d4]
+	str r1, [r0, #0x5d8]
+
+	str r1, [r0, #0x30c]
+	str r1, [r0, #0x310]
+	str r1, [r0, #0x314]
+	str r1, [r0, #0x318]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x1b4700c7
+	str r2, [r0, #0x85c]
+
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x00300000
+	str r2, [r0, #0x890]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r0, #0x82c]
+	str r2, [r0, #0x830]
+	str r2, [r0, #0x834]
+	str r2, [r0, #0x838]
+
+	ldr r2, =0x4241444a
+	str r2, [r0, #0x848]
+
+	ldr r2, =0x3030312b
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x20000000
+	str r2, [r0, #0x83c]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x33374133
+	str r2, [r0, #0x00c]
+
+	ldr r2, =0x00020024
+	str r2, [r0, #0x004]
+
+	ldr r2, =0x00100A82
+	str r2, [r0, #0x010]
+	ldr r2, =0x00000093
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001688
+	str r2, [r0, #0x018]
+	ldr r2, =0x0F9F26D2
+	str r2, [r0, #0x02c]
+
+	ldr r2, =0x0000020E
+	str r2, [r0, #0x030]
+	ldr r2, =0x00190778
+	str r2, [r0, #0x038]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x008]
+	ldr r2, =0x0000004F
+	str r2, [r0, #0x040]
+	ldr r2, =0xC3110000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x00008050
+	str r2, [r0, #0x01c]
+	ldr r2, =0x003F8030
+	str r2, [r0, #0x01c]
+	ldr r2, =0xFF0A8030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x82018030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04028030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x02038030
+	str r2, [r0, #0x01c]
+	ldr r2, =0xFF0A8038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x82018038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04028038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x02038038
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0xa1310003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x00001800
+	str r2, [r0, #0x020]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x818]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x00025564
+	str r2, [r0, #0x004]
+
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	str r1, [r0, #0x06c]
+	str r1, [r0, #0x070]
+	str r1, [r0, #0x074]
+	str r1, [r0, #0x078]
+	str r1, [r0, #0x07c]
+	str r1, [r0, #0x080]
+	str r1, [r0, #0x084]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6slevk_ddr_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6sll_arm2/imximage.cfg ebf_6ull_uboot/board/freescale/mx6sll_arm2/imximage.cfg
--- u-boot-2016.03/board/freescale/mx6sll_arm2/imximage.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sll_arm2/imximage.cfg	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+
+BOOT_FROM	sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sll_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+
+DATA 4 0x020E0550 0x00080000
+DATA 4 0x020E0534 0x00000000
+DATA 4 0x020E02AC 0x00000030
+DATA 4 0x020E0548 0x00000030
+DATA 4 0x020E052C 0x00000030
+DATA 4 0x020E0530 0x00020000
+DATA 4 0x020E02B0 0x00003030
+DATA 4 0x020E02B4 0x00003030
+DATA 4 0x020E02B8 0x00003030
+DATA 4 0x020E02BC 0x00003030
+DATA 4 0x020E0540 0x00020000
+DATA 4 0x020E0544 0x00000030
+DATA 4 0x020E054C 0x00000030
+DATA 4 0x020E0554 0x00000030
+DATA 4 0x020E0558 0x00000030
+DATA 4 0x020E0294 0x00000030
+DATA 4 0x020E0298 0x00000030
+DATA 4 0x020E029C 0x00000030
+DATA 4 0x020E02A0 0x00000030
+DATA 4 0x020E02C0 0x00082030
+
+DATA 4 0x021B001C 0x00008000
+
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B085c 0x084700C7
+DATA 4 0x021B0890 0x00400000
+DATA 4 0x021B0848 0x3C3A3C3C
+DATA 4 0x021B0850 0x24293625
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B0824 0x33333333
+DATA 4 0x021B0828 0x33333333
+
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B0834 0xf3333333
+DATA 4 0x021B0838 0xf3333333
+DATA 4 0x021B08C0 0x24922492
+DATA 4 0x021B08b8 0x00000800
+
+DATA 4 0x021B0004 0x00020052
+DATA 4 0x021B000C 0x53574333
+DATA 4 0x021B0010 0x00100B22
+DATA 4 0x021B0038 0x00170778
+DATA 4 0x021B0014 0x00C700DB
+DATA 4 0x021B0018 0x00201718
+DATA 4 0x021B002C 0x0F9F26D2
+DATA 4 0x021B0030 0x009F0E10
+DATA 4 0x021B0040 0x0000005F
+DATA 4 0x021B0000 0xC4190000
+
+DATA 4 0x021B001C 0x00008050
+DATA 4 0x021B001C 0x00008058
+DATA 4 0x021B001C 0x003F8030
+DATA 4 0x021B001C 0x003F8038
+DATA 4 0x021B001C 0xFF0A8030
+DATA 4 0x021B001C 0xFF0A8038
+DATA 4 0x021B001C 0x04028030
+DATA 4 0x021B001C 0x04028038
+DATA 4 0x021B001C 0x83018030
+DATA 4 0x021B001C 0x83018038
+DATA 4 0x021B001C 0x01038030
+DATA 4 0x021B001C 0x01038038
+
+DATA 4 0x021B083C 0x20000000
+
+DATA 4 0x021B0020 0x00001800
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B0004 0x00020052
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6sll_arm2/imximage_lpddr2.cfg ebf_6ull_uboot/board/freescale/mx6sll_arm2/imximage_lpddr2.cfg
--- u-boot-2016.03/board/freescale/mx6sll_arm2/imximage_lpddr2.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sll_arm2/imximage_lpddr2.cfg	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+
+BOOT_FROM	sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sll_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+
+DATA 4 0x020E0550 0x00080000
+DATA 4 0x020E0534 0x00000000
+DATA 4 0x020E02AC 0x00000030
+DATA 4 0x020E0548 0x00000030
+DATA 4 0x020E052C 0x00000030
+DATA 4 0x020E0530 0x00020000
+DATA 4 0x020E02B0 0x00003030
+DATA 4 0x020E02B4 0x00003030
+DATA 4 0x020E02B8 0x00003030
+DATA 4 0x020E02BC 0x00003030
+DATA 4 0x020E0540 0x00020000
+DATA 4 0x020E0544 0x00000030
+DATA 4 0x020E054C 0x00000030
+DATA 4 0x020E0554 0x00000030
+DATA 4 0x020E0558 0x00000030
+DATA 4 0x020E0294 0x00000030
+DATA 4 0x020E0298 0x00000030
+DATA 4 0x020E029C 0x00000030
+DATA 4 0x020E02A0 0x00000030
+DATA 4 0x020E02C0 0x00082030
+
+DATA 4 0x021B001C 0x00008000
+
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B085c 0x084700C7
+DATA 4 0x021B0890 0x00400000
+DATA 4 0x021B0848 0x3A383C40
+DATA 4 0x021B0850 0x242C3020
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B0824 0x33333333
+DATA 4 0x021B0828 0x33333333
+
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B0834 0xf3333333
+DATA 4 0x021B0838 0xf3333333
+DATA 4 0x021B08C0 0x24922492
+DATA 4 0x021B08b8 0x00000800
+
+DATA 4 0x021B0004 0x00020052
+DATA 4 0x021B000C 0x53574333
+DATA 4 0x021B0010 0x00100A82
+DATA 4 0x021B0038 0x00170777
+DATA 4 0x021B0014 0x00C70093
+DATA 4 0x021B0018 0x00201708
+DATA 4 0x021B002C 0x0F9F26D2
+DATA 4 0x021B0030 0x009F0E10
+DATA 4 0x021B0040 0x0000004F
+DATA 4 0x021B0000 0xC3110000
+
+DATA 4 0x021B001C 0x00008050
+DATA 4 0x021B001C 0x00008058
+DATA 4 0x021B001C 0x003F8030
+DATA 4 0x021B001C 0x003F8038
+DATA 4 0x021B001C 0xFF0A8030
+DATA 4 0x021B001C 0xFF0A8038
+DATA 4 0x021B001C 0x04028030
+DATA 4 0x021B001C 0x04028038
+DATA 4 0x021B001C 0x82018030
+DATA 4 0x021B001C 0x82018038
+DATA 4 0x021B001C 0x01038030
+DATA 4 0x021B001C 0x01038038
+
+DATA 4 0x021B083C 0x20000000
+
+DATA 4 0x021B0020 0x00001800
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B0004 0x00020052
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6sll_arm2/Kconfig ebf_6ull_uboot/board/freescale/mx6sll_arm2/Kconfig
--- u-boot-2016.03/board/freescale/mx6sll_arm2/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sll_arm2/Kconfig	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,12 @@
+if TARGET_MX6SLL_ARM2
+
+config SYS_BOARD
+	default "mx6sll_arm2"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_CONFIG_NAME
+	default "mx6sll_arm2"
+
+endif
diff -urN u-boot-2016.03/board/freescale/mx6sll_arm2/Makefile ebf_6ull_uboot/board/freescale/mx6sll_arm2/Makefile
--- u-boot-2016.03/board/freescale/mx6sll_arm2/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sll_arm2/Makefile	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,10 @@
+# (C) Copyright 2016 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6sll_arm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6sll_arm2/mx6sll_arm2.c ebf_6ull_uboot/board/freescale/mx6sll_arm2/mx6sll_arm2.c
--- u-boot-2016.03/board/freescale/mx6sll_arm2/mx6sll_arm2.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sll_arm2/mx6sll_arm2.c	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,752 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch-mx6/clock.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <linux/fb.h>
+#include <miiphy.h>
+#include <mmc.h>
+#include <mxsfb.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include "../common/pfuze.h"
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+#if defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
+#include <asm/imx-common/video.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL_WP (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define EPDC_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC and EPD */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		/* conflict with usb_otg2_pwr */
+		.i2c_mode = MX6_PAD_I2C1_SCL__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_I2C1_SCL__GPIO3_IO12 | PC,
+		.gp = IMX_GPIO_NR(3, 12),
+	},
+	.sda = {
+		/* conflict with usb_otg2_oc */
+		.i2c_mode = MX6_PAD_I2C1_SDA__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_I2C1_SDA__GPIO3_IO13 | PC,
+		.gp = IMX_GPIO_NR(3, 13),
+	},
+};
+
+/* I2C2 for LCD and ADV */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_I2C2_SCL__I2C2_SCL | PC,
+		.gpio_mode = MX6_PAD_I2C2_SCL__GPIO3_IO14 | PC,
+		.gp = IMX_GPIO_NR(3, 14),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_I2C2_SDA__I2C2_SDA | PC,
+		.gpio_mode = MX6_PAD_I2C2_SDA__GPIO3_IO15 | PC,
+		.gp = IMX_GPIO_NR(3, 15),
+	},
+};
+
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const wdog_pads[] = {
+	MX6_PAD_WDOG_B__WDOG1_B | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const led_pads[] = {
+	MX6_PAD_EPDC_VCOM1__GPIO2_IO04 | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_UART1_TXD__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_UART1_RXD__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+/* 8bit SD1 */
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__SD1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__SD1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__SD1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__SD1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__SD1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__SD1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA4__SD1_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA5__SD1_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA6__SD1_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA7__SD1_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* CD */
+	MX6_PAD_KEY_ROW7__GPIO4_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* WP */
+	MX6_PAD_GPIO4_IO22__SD1_WP   | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+/* EMMC */
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_SD2_CLK__SD2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_CMD__SD2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA0__SD2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA1__SD2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA2__SD2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA3__SD2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA4__SD2_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA5__SD2_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA6__SD2_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA7__SD2_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* DQS */
+	MX6_PAD_GPIO4_IO21__SD2_STROBE | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* RST_B */
+	MX6_PAD_SD2_RESET__GPIO4_IO27 | MUX_PAD_CTRL(USDHC_PAD_CTRL | PAD_CTL_LVE),
+};
+
+/* Wifi SD */
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6_PAD_SD3_CLK__SD3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_CMD__SD3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* CD */
+	MX6_PAD_REF_CLK_32K__GPIO3_IO22 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+
+	imx_iomux_v3_setup_multiple_pads(led_pads, ARRAY_SIZE(led_pads));
+}
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[CONFIG_SYS_FSL_USDHC_NUM] = {
+	{USDHC1_BASE_ADDR, 0, 8, 1},
+	{USDHC2_BASE_ADDR, 0, 8, 0, 1}, /* fixed 1.8v IO voltage for eMMC chip */
+	{USDHC3_BASE_ADDR, 0, 4},
+};
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(4, 7)
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(4, 27)
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(3, 22)
+
+int board_mmc_get_env_dev(int devno)
+{
+	return devno;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	return devno;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	case USDHC2_BASE_ADDR:
+		ret = 1;
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 * mmc2                    USDHC3
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			break;
+		case 2:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers (%d) than supported by the board\n", i + 1);
+			return 0;
+		}
+
+		if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+			printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+static struct pmic *pfuze;
+int power_init_board(void)
+{
+	int ret;
+	u32 rev_id, value;
+
+	ret = power_pfuze100_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	pfuze = pmic_get("PFUZE100");
+	if (!pfuze)
+		return -ENODEV;
+
+	ret = pmic_probe(pfuze);
+	if (ret)
+		return ret;
+
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	pmic_reg_read(pfuze, PFUZE100_DEVICEID, &value);
+	pmic_reg_read(pfuze, PFUZE100_REVID, &rev_id);
+	printf("PMIC: PFUZE100! DEV_ID=0x%x REV_ID=0x%x\n", value, rev_id);
+
+	/* set SW1AB standby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &value);
+	value &= ~0x3f;
+	value |= PFUZE100_SW1ABC_SETP(9750);
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, value);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &value);
+	value &= ~0xc0;
+	value |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, value);
+
+	/* set SW1C staby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &value);
+	value &= ~0x3f;
+	value |= 0x1b;
+	pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, value);
+
+	/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &value);
+	value &= ~0xc0;
+	value |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1CCONF, value);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_MXC_SPI
+iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX6_PAD_ECSPI1_SCLK__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_ECSPI1_MOSI__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_ECSPI1_MISO__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+
+	/* CS0 */
+	MX6_PAD_ECSPI1_SS0__GPIO4_IO11   | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
+					 ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(4, 11), 0);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 11)) : -1;
+}
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD_CLK__LCD_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_ENABLE__LCD_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_HSYNC__LCD_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_VSYNC__LCD_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA00__LCD_DATA00 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA01__LCD_DATA01 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA02__LCD_DATA02 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA03__LCD_DATA03 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA04__LCD_DATA04 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA05__LCD_DATA05 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA06__LCD_DATA06 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA07__LCD_DATA07 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA08__LCD_DATA08 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA09__LCD_DATA09 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA10__LCD_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA11__LCD_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA12__LCD_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA13__LCD_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__LCD_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__LCD_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__LCD_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__LCD_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA18__LCD_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA19__LCD_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA20__LCD_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA21__LCD_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA22__LCD_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA23__LCD_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_ECSPI1_SCLK__GPIO4_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_LCD_RESET__GPIO2_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6_PAD_PWM1__GPIO3_IO23 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void do_enable_parallel_lcd(struct display_info_t const *dev)
+
+{
+	int ret;
+
+	ret = enable_lcdif_clock(dev->bus);
+	if (ret) {
+		printf("Enable LCDIF clock failed, %d\n", ret);
+		return;
+	}
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Reset the LCD */
+	gpio_direction_output(IMX_GPIO_NR(2, 19) , 0);
+	udelay(500);
+	gpio_direction_output(IMX_GPIO_NR(2, 19) , 1);
+
+	gpio_direction_output(IMX_GPIO_NR(4, 8) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(3, 23) , 1);
+}
+
+struct display_info_t const displays[] = {{
+	.bus = MX6SLL_LCDIF_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 24,
+	.detect = NULL,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+#endif
+
+#ifdef CONFIG_MXC_EPDC
+static iomux_v3_cfg_t const epdc_enable_pads[] = {
+	MX6_PAD_EPDC_DATA00__EPDC_DATA00	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA01__EPDC_DATA01	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA02__EPDC_DATA02	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA03__EPDC_DATA03	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA04__EPDC_DATA04	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA05__EPDC_DATA05	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA06__EPDC_DATA06	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA07__EPDC_DATA07	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA08__EPDC_DATA08	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA09__EPDC_DATA09	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA10__EPDC_DATA10	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA11__EPDC_DATA11	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA12__EPDC_DATA12	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA13__EPDC_DATA13	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA14__EPDC_DATA14	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA15__EPDC_DATA15	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDCLK__EPDC_SDCLK_P	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDLE__EPDC_SDLE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDOE__EPDC_SDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDSHR__EPDC_SDSHR		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDCE0__EPDC_SDCE0		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDCLK__EPDC_GDCLK		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDOE__EPDC_GDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDRL__EPDC_GDRL		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDSP__EPDC_GDSP		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const epdc_disable_pads[] = {
+	MX6_PAD_EPDC_DATA01__GPIO1_IO08,
+	MX6_PAD_EPDC_DATA02__GPIO1_IO09,
+	MX6_PAD_EPDC_DATA03__GPIO1_IO10,
+	MX6_PAD_EPDC_DATA04__GPIO1_IO11,
+	MX6_PAD_EPDC_DATA05__GPIO1_IO12,
+	MX6_PAD_EPDC_DATA06__GPIO1_IO13,
+	MX6_PAD_EPDC_DATA07__GPIO1_IO14,
+	MX6_PAD_EPDC_DATA08__GPIO1_IO15,
+	MX6_PAD_EPDC_DATA09__GPIO1_IO16,
+	MX6_PAD_EPDC_DATA10__GPIO1_IO17,
+	MX6_PAD_EPDC_DATA11__GPIO1_IO18,
+	MX6_PAD_EPDC_DATA12__GPIO1_IO19,
+	MX6_PAD_EPDC_DATA13__GPIO1_IO20,
+	MX6_PAD_EPDC_DATA14__GPIO1_IO21,
+	MX6_PAD_EPDC_DATA15__GPIO1_IO22,
+	MX6_PAD_EPDC_SDCLK__GPIO1_IO23,
+	MX6_PAD_EPDC_SDLE__GPIO1_IO24,
+	MX6_PAD_EPDC_SDOE__GPIO1_IO25,
+	MX6_PAD_EPDC_SDSHR__GPIO1_IO26,
+	MX6_PAD_EPDC_SDCE0__GPIO1_IO27,
+	MX6_PAD_EPDC_GDCLK__GPIO1_IO31,
+	MX6_PAD_EPDC_GDOE__GPIO2_IO00,
+	MX6_PAD_EPDC_GDRL__GPIO2_IO01,
+	MX6_PAD_EPDC_GDSP__GPIO2_IO02,
+};
+
+vidinfo_t panel_info = {
+	.vl_refresh = 85,
+	.vl_col = 1024,
+	.vl_row = 758,
+	.vl_pixclock = 40000000,
+	.vl_left_margin = 12,
+	.vl_right_margin = 76,
+	.vl_upper_margin = 4,
+	.vl_lower_margin = 5,
+	.vl_hsync = 12,
+	.vl_vsync = 2,
+	.vl_sync = 0,
+	.vl_mode = 0,
+	.vl_flag = 0,
+	.vl_bpix = 3,
+	.cmap = 0,
+};
+
+struct epdc_timing_params panel_timings = {
+	.vscan_holdoff = 4,
+	.sdoed_width = 10,
+	.sdoed_delay = 20,
+	.sdoez_width = 10,
+	.sdoez_delay = 20,
+	.gdclk_hp_offs = 524,
+	.gdsp_offs = 327,
+	.gdoe_offs = 0,
+	.gdclk_offs = 19,
+	.num_ce = 1,
+};
+
+static void setup_epdc_power(void)
+{
+	/* Setup epdc voltage */
+
+	/* EPDC_PWRSTAT - GPIO2[13] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_STAT__GPIO2_IO13 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	gpio_direction_input(IMX_GPIO_NR(2, 13));
+
+	/* EPDC_VCOM0 - GPIO2[03] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_VCOM0__GPIO2_IO03 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 3), 1);
+
+	/* EPDC_PWRWAKEUP - GPIO2[14] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_WAKE__GPIO2_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 14), 1);
+
+	/* EPDC_PWRCTRL0 - GPIO2[07] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_CTRL0__GPIO2_IO07 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 7), 1);
+}
+
+static void epdc_enable_pins(void)
+{
+	/* epdc iomux settings */
+	imx_iomux_v3_setup_multiple_pads(epdc_enable_pads,
+				ARRAY_SIZE(epdc_enable_pads));
+}
+
+static void epdc_disable_pins(void)
+{
+	/* Configure MUX settings for EPDC pins to GPIO  and drive to 0 */
+	imx_iomux_v3_setup_multiple_pads(epdc_disable_pads,
+				ARRAY_SIZE(epdc_disable_pads));
+}
+
+static void setup_epdc(void)
+{
+	/*** epdc Maxim PMIC settings ***/
+
+	/* EPDC_PWRSTAT - GPIO2[13] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_STAT__GPIO2_IO13 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_VCOM0 - GPIO2[03] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_VCOM0__GPIO2_IO03 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRWAKEUP - GPIO2[14] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_WAKE__GPIO2_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRCTRL0 - GPIO2[07] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_CTRL0__GPIO2_IO07 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set pixel clock rates for EPDC in clock.c */
+
+	panel_info.epdc_data.wv_modes.mode_init = 0;
+	panel_info.epdc_data.wv_modes.mode_du = 1;
+	panel_info.epdc_data.wv_modes.mode_gc4 = 3;
+	panel_info.epdc_data.wv_modes.mode_gc8 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc16 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc32 = 2;
+
+	panel_info.epdc_data.epdc_timings = panel_timings;
+
+	setup_epdc_power();
+}
+
+void epdc_power_on(void)
+{
+	unsigned int reg;
+	struct gpio_regs *gpio_regs = (struct gpio_regs *)GPIO2_BASE_ADDR;
+
+	/* Set EPD_PWR_CTL0 to high - enable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 7), 1);
+	udelay(1000);
+
+	/* Enable epdc signal pin */
+	epdc_enable_pins();
+
+	/* Set PMIC Wakeup to high - enable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 14), 1);
+
+	/* Wait for PWRGOOD == 1 */
+	while (1) {
+		reg = readl(&gpio_regs->gpio_psr);
+		if (!(reg & (1 << 13)))
+			break;
+
+		udelay(100);
+	}
+
+	/* Enable VCOM */
+	gpio_set_value(IMX_GPIO_NR(2, 3), 1);
+
+	udelay(500);
+}
+
+void epdc_power_off(void)
+{
+	/* Set PMIC Wakeup to low - disable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 14), 0);
+
+	/* Disable VCOM */
+	gpio_set_value(IMX_GPIO_NR(2, 3), 0);
+
+	epdc_disable_pins();
+
+	/* Set EPD_PWR_CTL0 to low - disable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 7), 0);
+}
+#endif
+
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX6_PAD_KEY_COL4__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_KEY_ROW4__USB_OTG1_OC  | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_EPDC_PWR_COM__USB_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	MX6_PAD_KEY_COL5__USB_OTG2_PWR   | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_ECSPI2_SCLK__USB_OTG2_OC | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_EPDC_PWR_IRQ__USB_OTG2_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+int board_usb_phy_mode(int port)
+{
+	return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+						 ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+						 ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+	enable_uart_clk(true);
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+#endif
+
+#ifdef CONFIG_MXC_SPI
+	setup_spinor();
+#endif
+
+#ifdef	CONFIG_MXC_EPDC
+	enable_epdc_clock();
+	setup_epdc();
+#endif
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	imx_iomux_v3_setup_multiple_pads(wdog_pads, ARRAY_SIZE(wdog_pads));
+
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+#ifdef CONFIG_LPDDR2
+	puts("Board: MX6SLL LPDDR2 ARM2\n");
+#else
+	puts("Board: MX6SLL LPDDR3 ARM2\n");
+#endif
+
+	return 0;
+}
diff -urN u-boot-2016.03/board/freescale/mx6sll_arm2/plugin.S ebf_6ull_uboot/board/freescale/mx6sll_arm2/plugin.S
--- u-boot-2016.03/board/freescale/mx6sll_arm2/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sll_arm2/plugin.S	2021-04-16 14:42:16.956592502 +0800
@@ -0,0 +1,285 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6sll_lpddr3_arm2_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x550]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x534]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x2AC]
+	str r1, [r0, #0x548]
+	str r1, [r0, #0x52C]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x530]
+	ldr r1, =0x00003030
+	str r1, [r0, #0x2B0]
+	str r1, [r0, #0x2B4]
+	str r1, [r0, #0x2B8]
+	str r1, [r0, #0x2BC]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x540]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x544]
+	str r1, [r0, #0x54C]
+	str r1, [r0, #0x554]
+	str r1, [r0, #0x558]
+	str r1, [r0, #0x294]
+	str r1, [r0, #0x298]
+	str r1, [r0, #0x29C]
+	str r1, [r0, #0x2A0]
+
+	ldr r1, =0x00082030
+	str r1, [r0, #0x2C0]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x084700C7
+	str r1, [r0, #0x85C]
+	ldr r1, =0x00400000
+	str r1, [r0, #0x890]
+
+	ldr r1, =0x3C3A3C3C
+	str r1, [r0, #0x848]
+	ldr r1, =0x24293625
+	str r1, [r0, #0x850]
+
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	str r1, [r0, #0x824]
+	str r1, [r0, #0x828]
+
+	ldr r1, =0xf3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	str r1, [r0, #0x834]
+	str r1, [r0, #0x838]
+
+	ldr r1, =0x24922492
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+
+	ldr r1, =0x00020052
+	str r1, [r0, #0x004]
+	ldr r1, =0x53574333
+	str r1, [r0, #0x00C]
+	ldr r1, =0x00100B22
+	str r1, [r0, #0x010]
+	ldr r1, =0x00170778
+	str r1, [r0, #0x038]
+	ldr r1, =0x00C700DB
+	str r1, [r0, #0x014]
+	ldr r1, =0x00201718
+	str r1, [r0, #0x018]
+	ldr r1, =0x0F9F26D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x009F0E10
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000005F
+	str r1, [r0, #0x040]
+	ldr r1, =0xC4190000
+	str r1, [r0, #0x000]
+
+	ldr r1, =0x00008050
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00008058
+	str r1, [r0, #0x01C]
+	ldr r1, =0x003F8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x003F8038
+	str r1, [r0, #0x01C]
+	ldr r1, =0xFF0A8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0xFF0A8038
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04028030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04028038
+	str r1, [r0, #0x01C]
+	ldr r1, =0x83018030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x83018038
+	str r1, [r0, #0x01C]
+	ldr r1, =0x01038030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x01038038
+	str r1, [r0, #0x01C]
+
+	ldr r1, =0x20000000
+	str r1, [r0, #0x83C]
+
+	ldr r1, =0x00001800
+	str r1, [r0, #0x020]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00020052
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6sll_lpddr2_arm2_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x550]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x534]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x2AC]
+	str r1, [r0, #0x548]
+	str r1, [r0, #0x52C]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x530]
+	ldr r1, =0x00003030
+	str r1, [r0, #0x2B0]
+	str r1, [r0, #0x2B4]
+	str r1, [r0, #0x2B8]
+	str r1, [r0, #0x2BC]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x540]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x544]
+	str r1, [r0, #0x54C]
+	str r1, [r0, #0x554]
+	str r1, [r0, #0x558]
+	str r1, [r0, #0x294]
+	str r1, [r0, #0x298]
+	str r1, [r0, #0x29C]
+	str r1, [r0, #0x2A0]
+
+	ldr r1, =0x00082030
+	str r1, [r0, #0x2C0]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x084700C7
+	str r1, [r0, #0x85C]
+	ldr r1, =0x00400000
+	str r1, [r0, #0x890]
+
+	ldr r1, =0x3A383C40
+	str r1, [r0, #0x848]
+	ldr r1, =0x242C3020
+	str r1, [r0, #0x850]
+
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	str r1, [r0, #0x824]
+	str r1, [r0, #0x828]
+
+	ldr r1, =0xf3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	str r1, [r0, #0x834]
+	str r1, [r0, #0x838]
+
+	ldr r1, =0x24922492
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+
+	ldr r1, =0x00020052
+	str r1, [r0, #0x004]
+	ldr r1, =0x53574333
+	str r1, [r0, #0x00C]
+	ldr r1, =0x00100A82
+	str r1, [r0, #0x010]
+	ldr r1, =0x00170777
+	str r1, [r0, #0x038]
+	ldr r1, =0x00C70093
+	str r1, [r0, #0x014]
+	ldr r1, =0x00201708
+	str r1, [r0, #0x018]
+	ldr r1, =0x0F9F26D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x009F0E10
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000004F
+	str r1, [r0, #0x040]
+	ldr r1, =0xC3110000
+	str r1, [r0, #0x000]
+
+	ldr r1, =0x00008050
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00008058
+	str r1, [r0, #0x01C]
+	ldr r1, =0x003F8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x003F8038
+	str r1, [r0, #0x01C]
+	ldr r1, =0xFF0A8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0xFF0A8038
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04028030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04028038
+	str r1, [r0, #0x01C]
+	ldr r1, =0x82018030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x82018038
+	str r1, [r0, #0x01C]
+	ldr r1, =0x01038030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x01038038
+	str r1, [r0, #0x01C]
+
+	ldr r1, =0x20000000
+	str r1, [r0, #0x83C]
+
+	ldr r1, =0x00001800
+	str r1, [r0, #0x020]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00020052
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	str r1, [r0, #0x06c]
+	str r1, [r0, #0x070]
+	str r1, [r0, #0x074]
+	str r1, [r0, #0x078]
+	str r1, [r0, #0x07c]
+	str r1, [r0, #0x080]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+#if defined (CONFIG_LPDDR2)
+	imx6sll_lpddr2_arm2_setting
+#else
+	imx6sll_lpddr3_arm2_setting
+#endif
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6sllevk/imximage.cfg ebf_6ull_uboot/board/freescale/mx6sllevk/imximage.cfg
--- u-boot-2016.03/board/freescale/mx6sllevk/imximage.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sllevk/imximage.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+
+BOOT_FROM	sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sllevk/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+
+DATA 4 0x020E0550 0x00080000
+DATA 4 0x020E0534 0x00000000
+DATA 4 0x020E02AC 0x00000030
+DATA 4 0x020E0548 0x00000030
+DATA 4 0x020E052C 0x00000030
+DATA 4 0x020E0530 0x00020000
+DATA 4 0x020E02B0 0x00003030
+DATA 4 0x020E02B4 0x00003030
+DATA 4 0x020E02B8 0x00003030
+DATA 4 0x020E02BC 0x00003030
+DATA 4 0x020E0540 0x00020000
+DATA 4 0x020E0544 0x00000030
+DATA 4 0x020E054C 0x00000030
+DATA 4 0x020E0554 0x00000030
+DATA 4 0x020E0558 0x00000030
+DATA 4 0x020E0294 0x00000030
+DATA 4 0x020E0298 0x00000030
+DATA 4 0x020E029C 0x00000030
+DATA 4 0x020E02A0 0x00000030
+DATA 4 0x020E02C0 0x00082030
+
+DATA 4 0x021B001C 0x00008000
+
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B085c 0x084700C7
+DATA 4 0x021B0890 0x00400000
+DATA 4 0x021B0848 0x3F393B3C
+DATA 4 0x021B0850 0x262C3826
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B0824 0x33333333
+DATA 4 0x021B0828 0x33333333
+
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B0834 0xf3333333
+DATA 4 0x021B0838 0xf3333333
+DATA 4 0x021B08C0 0x24922492
+DATA 4 0x021B08b8 0x00000800
+
+DATA 4 0x021B0004 0x00020052
+DATA 4 0x021B000C 0x53574333
+DATA 4 0x021B0010 0x00100B22
+DATA 4 0x021B0038 0x00170778
+DATA 4 0x021B0014 0x00C700DB
+DATA 4 0x021B0018 0x00201718
+DATA 4 0x021B002C 0x0F9F26D2
+DATA 4 0x021B0030 0x009F0E10
+DATA 4 0x021B0040 0x0000005F
+DATA 4 0x021B0000 0xC4190000
+
+DATA 4 0x021B001C 0x00008050
+DATA 4 0x021B001C 0x00008058
+DATA 4 0x021B001C 0x003F8030
+DATA 4 0x021B001C 0x003F8038
+DATA 4 0x021B001C 0xFF0A8030
+DATA 4 0x021B001C 0xFF0A8038
+DATA 4 0x021B001C 0x04028030
+DATA 4 0x021B001C 0x04028038
+DATA 4 0x021B001C 0x83018030
+DATA 4 0x021B001C 0x83018038
+DATA 4 0x021B001C 0x01038030
+DATA 4 0x021B001C 0x01038038
+
+DATA 4 0x021B083C 0x20000000
+
+DATA 4 0x021B0020 0x00001800
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B0004 0x00020052
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6sllevk/Kconfig ebf_6ull_uboot/board/freescale/mx6sllevk/Kconfig
--- u-boot-2016.03/board/freescale/mx6sllevk/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sllevk/Kconfig	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,12 @@
+if TARGET_MX6SLLEVK
+
+config SYS_BOARD
+	default "mx6sllevk"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_CONFIG_NAME
+	default "mx6sllevk"
+
+endif
diff -urN u-boot-2016.03/board/freescale/mx6sllevk/Makefile ebf_6ull_uboot/board/freescale/mx6sllevk/Makefile
--- u-boot-2016.03/board/freescale/mx6sllevk/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sllevk/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,10 @@
+# (C) Copyright 2016 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6sllevk.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6sllevk/mx6sllevk.c ebf_6ull_uboot/board/freescale/mx6sllevk/mx6sllevk.c
--- u-boot-2016.03/board/freescale/mx6sllevk/mx6sllevk.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sllevk/mx6sllevk.c	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,713 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <linux/fb.h>
+#include <miiphy.h>
+#include <mmc.h>
+#include <mxsfb.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include "../common/pfuze.h"
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+#if defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
+#include <asm/imx-common/video.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL_WP (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define EPDC_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC and EPD */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		/* conflict with usb_otg2_pwr */
+		.i2c_mode = MX6_PAD_I2C1_SCL__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_I2C1_SCL__GPIO3_IO12 | PC,
+		.gp = IMX_GPIO_NR(3, 12),
+	},
+	.sda = {
+		/* conflict with usb_otg2_oc */
+		.i2c_mode = MX6_PAD_I2C1_SDA__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_I2C1_SDA__GPIO3_IO13 | PC,
+		.gp = IMX_GPIO_NR(3, 13),
+	},
+};
+
+/* I2C2 for LCD and ADV */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_I2C2_SCL__I2C2_SCL | PC,
+		.gpio_mode = MX6_PAD_I2C2_SCL__GPIO3_IO14 | PC,
+		.gp = IMX_GPIO_NR(3, 14),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_I2C2_SDA__I2C2_SDA | PC,
+		.gpio_mode = MX6_PAD_I2C2_SDA__GPIO3_IO15 | PC,
+		.gp = IMX_GPIO_NR(3, 15),
+	},
+};
+
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_UART1_TXD__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_UART1_RXD__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const wdog_pads[] = {
+	MX6_PAD_WDOG_B__WDOG1_B | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+/* 8bit SD1 */
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__SD1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__SD1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__SD1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__SD1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__SD1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__SD1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA4__SD1_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA5__SD1_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA6__SD1_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA7__SD1_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* CD */
+	MX6_PAD_KEY_ROW7__GPIO4_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* WP */
+	MX6_PAD_GPIO4_IO22__SD1_WP   | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+/* EMMC */
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_SD2_CLK__SD2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_CMD__SD2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA0__SD2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA1__SD2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA2__SD2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA3__SD2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA4__SD2_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA5__SD2_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA6__SD2_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA7__SD2_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* DQS */
+	MX6_PAD_GPIO4_IO21__SD2_STROBE | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* RST_B */
+	MX6_PAD_SD2_RESET__GPIO4_IO27 | MUX_PAD_CTRL(USDHC_PAD_CTRL | PAD_CTL_LVE),
+};
+
+/* Wifi SD */
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6_PAD_SD3_CLK__SD3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_CMD__SD3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* CD */
+	MX6_PAD_REF_CLK_32K__GPIO3_IO22 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[CONFIG_SYS_FSL_USDHC_NUM] = {
+	{USDHC1_BASE_ADDR, 0, 8, 1},
+	{USDHC2_BASE_ADDR, 0, 8, 0, 1}, /* fixed 1.8v IO voltage for eMMC chip */
+	{USDHC3_BASE_ADDR, 0, 4},
+};
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(4, 7)
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(4, 27)
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(3, 22)
+
+int board_mmc_get_env_dev(int devno)
+{
+	return devno;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	return devno;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	case USDHC2_BASE_ADDR:
+		ret = 1;
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 * mmc2                    USDHC3
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			break;
+		case 2:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers (%d) than supported by the board\n", i + 1);
+			return 0;
+		}
+
+	if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+		printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+static struct pmic *pfuze;
+int power_init_board(void)
+{
+	int ret;
+	u32 rev_id, value;
+
+	ret = power_pfuze100_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	pfuze = pmic_get("PFUZE100");
+	if (!pfuze)
+		return -ENODEV;
+
+	ret = pmic_probe(pfuze);
+	if (ret)
+		return ret;
+
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	pmic_reg_read(pfuze, PFUZE100_DEVICEID, &value);
+	pmic_reg_read(pfuze, PFUZE100_REVID, &rev_id);
+	printf("PMIC: PFUZE100! DEV_ID=0x%x REV_ID=0x%x\n", value, rev_id);
+
+	/* set SW1AB staby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &value);
+	value &= ~0x3f;
+	value |= 0x1b;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, value);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &value);
+	value &= ~0xc0;
+	value |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, value);
+
+	/* set SW1C staby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &value);
+	value &= ~0x3f;
+	value |= 0x1b;
+	pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, value);
+
+	/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &value);
+	value &= ~0xc0;
+	value |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1CCONF, value);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD_CLK__LCD_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_ENABLE__LCD_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_HSYNC__LCD_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_VSYNC__LCD_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA00__LCD_DATA00 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA01__LCD_DATA01 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA02__LCD_DATA02 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA03__LCD_DATA03 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA04__LCD_DATA04 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA05__LCD_DATA05 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA06__LCD_DATA06 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA07__LCD_DATA07 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA08__LCD_DATA08 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA09__LCD_DATA09 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA10__LCD_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA11__LCD_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA12__LCD_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA13__LCD_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__LCD_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__LCD_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__LCD_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__LCD_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA18__LCD_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA19__LCD_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA20__LCD_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA21__LCD_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA22__LCD_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA23__LCD_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_KEY_ROW5__GPIO4_IO03 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_LCD_RESET__GPIO2_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6_PAD_PWM1__GPIO3_IO23 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void do_enable_parallel_lcd(struct display_info_t const *dev)
+
+{
+	int ret;
+
+	ret = enable_lcdif_clock(dev->bus);
+	if (ret) {
+		printf("Enable LCDIF clock failed, %d\n", ret);
+		return;
+	}
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Reset the LCD */
+	gpio_direction_output(IMX_GPIO_NR(2, 19) , 0);
+	udelay(500);
+	gpio_direction_output(IMX_GPIO_NR(2, 19) , 1);
+
+	gpio_direction_output(IMX_GPIO_NR(4, 3) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(3, 23) , 1);
+}
+
+struct display_info_t const displays[] = {{
+	.bus = MX6SLL_LCDIF_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 24,
+	.detect = NULL,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name		= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+#endif
+
+#ifdef CONFIG_MXC_EPDC
+static iomux_v3_cfg_t const epdc_enable_pads[] = {
+	MX6_PAD_EPDC_DATA00__EPDC_DATA00	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA01__EPDC_DATA01	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA02__EPDC_DATA02	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA03__EPDC_DATA03	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA04__EPDC_DATA04	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA05__EPDC_DATA05	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA06__EPDC_DATA06	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA07__EPDC_DATA07	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA08__EPDC_DATA08	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA09__EPDC_DATA09	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA10__EPDC_DATA10	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA11__EPDC_DATA11	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA12__EPDC_DATA12	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA13__EPDC_DATA13	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA14__EPDC_DATA14	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA15__EPDC_DATA15	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDCLK__EPDC_SDCLK_P	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDLE__EPDC_SDLE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDOE__EPDC_SDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDSHR__EPDC_SDSHR		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDCE0__EPDC_SDCE0		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDCLK__EPDC_GDCLK		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDOE__EPDC_GDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDRL__EPDC_GDRL		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDSP__EPDC_GDSP		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const epdc_disable_pads[] = {
+	MX6_PAD_EPDC_DATA01__GPIO1_IO08,
+	MX6_PAD_EPDC_DATA02__GPIO1_IO09,
+	MX6_PAD_EPDC_DATA03__GPIO1_IO10,
+	MX6_PAD_EPDC_DATA04__GPIO1_IO11,
+	MX6_PAD_EPDC_DATA05__GPIO1_IO12,
+	MX6_PAD_EPDC_DATA06__GPIO1_IO13,
+	MX6_PAD_EPDC_DATA07__GPIO1_IO14,
+	MX6_PAD_EPDC_DATA08__GPIO1_IO15,
+	MX6_PAD_EPDC_DATA09__GPIO1_IO16,
+	MX6_PAD_EPDC_DATA10__GPIO1_IO17,
+	MX6_PAD_EPDC_DATA11__GPIO1_IO18,
+	MX6_PAD_EPDC_DATA12__GPIO1_IO19,
+	MX6_PAD_EPDC_DATA13__GPIO1_IO20,
+	MX6_PAD_EPDC_DATA14__GPIO1_IO21,
+	MX6_PAD_EPDC_DATA15__GPIO1_IO22,
+	MX6_PAD_EPDC_SDCLK__GPIO1_IO23,
+	MX6_PAD_EPDC_SDLE__GPIO1_IO24,
+	MX6_PAD_EPDC_SDOE__GPIO1_IO25,
+	MX6_PAD_EPDC_SDSHR__GPIO1_IO26,
+	MX6_PAD_EPDC_SDCE0__GPIO1_IO27,
+	MX6_PAD_EPDC_GDCLK__GPIO1_IO31,
+	MX6_PAD_EPDC_GDOE__GPIO2_IO00,
+	MX6_PAD_EPDC_GDRL__GPIO2_IO01,
+	MX6_PAD_EPDC_GDSP__GPIO2_IO02,
+};
+
+vidinfo_t panel_info = {
+	.vl_refresh = 85,
+	.vl_col = 1024,
+	.vl_row = 758,
+	.vl_pixclock = 40000000,
+	.vl_left_margin = 12,
+	.vl_right_margin = 76,
+	.vl_upper_margin = 4,
+	.vl_lower_margin = 5,
+	.vl_hsync = 12,
+	.vl_vsync = 2,
+	.vl_sync = 0,
+	.vl_mode = 0,
+	.vl_flag = 0,
+	.vl_bpix = 3,
+	.cmap = 0,
+};
+
+struct epdc_timing_params panel_timings = {
+	.vscan_holdoff = 4,
+	.sdoed_width = 10,
+	.sdoed_delay = 20,
+	.sdoez_width = 10,
+	.sdoez_delay = 20,
+	.gdclk_hp_offs = 524,
+	.gdsp_offs = 327,
+	.gdoe_offs = 0,
+	.gdclk_offs = 19,
+	.num_ce = 1,
+};
+
+static void setup_epdc_power(void)
+{
+	/* Setup epdc voltage */
+
+	/* EPDC_PWRSTAT - GPIO2[13] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_STAT__GPIO2_IO13 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	gpio_direction_input(IMX_GPIO_NR(2, 13));
+
+	/* EPDC_VCOM0 - GPIO2[03] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_VCOM0__GPIO2_IO03 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 3), 1);
+
+	/* EPDC_PWRWAKEUP - GPIO2[14] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_WAKE__GPIO2_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 14), 1);
+
+	/* EPDC_PWRCTRL0 - GPIO2[07] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_CTRL0__GPIO2_IO07 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 7), 1);
+}
+
+static void epdc_enable_pins(void)
+{
+	/* epdc iomux settings */
+	imx_iomux_v3_setup_multiple_pads(epdc_enable_pads,
+				ARRAY_SIZE(epdc_enable_pads));
+}
+
+static void epdc_disable_pins(void)
+{
+	/* Configure MUX settings for EPDC pins to GPIO  and drive to 0 */
+	imx_iomux_v3_setup_multiple_pads(epdc_disable_pads,
+				ARRAY_SIZE(epdc_disable_pads));
+}
+
+static void setup_epdc(void)
+{
+	/*** epdc Maxim PMIC settings ***/
+
+	/* EPDC_PWRSTAT - GPIO2[13] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_STAT__GPIO2_IO13 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_VCOM0 - GPIO2[03] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_VCOM0__GPIO2_IO03 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRWAKEUP - GPIO2[14] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_WAKE__GPIO2_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRCTRL0 - GPIO2[07] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_CTRL0__GPIO2_IO07 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set pixel clock rates for EPDC in clock.c */
+
+	panel_info.epdc_data.wv_modes.mode_init = 0;
+	panel_info.epdc_data.wv_modes.mode_du = 1;
+	panel_info.epdc_data.wv_modes.mode_gc4 = 3;
+	panel_info.epdc_data.wv_modes.mode_gc8 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc16 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc32 = 2;
+
+	panel_info.epdc_data.epdc_timings = panel_timings;
+
+	setup_epdc_power();
+}
+
+void epdc_power_on(void)
+{
+	unsigned int reg;
+	struct gpio_regs *gpio_regs = (struct gpio_regs *)GPIO2_BASE_ADDR;
+
+	/* Set EPD_PWR_CTL0 to high - enable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 7), 1);
+	udelay(1000);
+
+	/* Enable epdc signal pin */
+	epdc_enable_pins();
+
+	/* Set PMIC Wakeup to high - enable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 14), 1);
+
+	/* Wait for PWRGOOD == 1 */
+	while (1) {
+		reg = readl(&gpio_regs->gpio_psr);
+		if (!(reg & (1 << 13)))
+			break;
+
+		udelay(100);
+	}
+
+	/* Enable VCOM */
+	gpio_set_value(IMX_GPIO_NR(2, 3), 1);
+
+	udelay(500);
+}
+
+void epdc_power_off(void)
+{
+	/* Set PMIC Wakeup to low - disable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 14), 0);
+
+	/* Disable VCOM */
+	gpio_set_value(IMX_GPIO_NR(2, 3), 0);
+
+	epdc_disable_pins();
+
+	/* Set EPD_PWR_CTL0 to low - disable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 7), 0);
+}
+#endif
+
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX6_PAD_KEY_COL4__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_KEY_ROW4__USB_OTG1_OC  | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_EPDC_PWR_COM__USB_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	MX6_PAD_KEY_COL5__USB_OTG2_PWR   | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_ECSPI2_SCLK__USB_OTG2_OC | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+						 ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+						 ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+#endif
+
+#ifdef	CONFIG_MXC_EPDC
+	enable_epdc_clock();
+	setup_epdc();
+#endif
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	imx_iomux_v3_setup_multiple_pads(wdog_pads, ARRAY_SIZE(wdog_pads));
+
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: MX6SLL EVK\n");
+
+	return 0;
+}
diff -urN u-boot-2016.03/board/freescale/mx6sllevk/plugin.S ebf_6ull_uboot/board/freescale/mx6sllevk/plugin.S
--- u-boot-2016.03/board/freescale/mx6sllevk/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sllevk/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6sll_evk_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x550]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x534]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x2AC]
+	str r1, [r0, #0x548]
+	str r1, [r0, #0x52C]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x530]
+	ldr r1, =0x00003030
+	str r1, [r0, #0x2B0]
+	str r1, [r0, #0x2B4]
+	str r1, [r0, #0x2B8]
+	str r1, [r0, #0x2BC]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x540]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x544]
+	str r1, [r0, #0x54C]
+	str r1, [r0, #0x554]
+	str r1, [r0, #0x558]
+	str r1, [r0, #0x294]
+	str r1, [r0, #0x298]
+	str r1, [r0, #0x29C]
+	str r1, [r0, #0x2A0]
+
+	ldr r1, =0x00082030
+	str r1, [r0, #0x2C0]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x084700C7
+	str r1, [r0, #0x85C]
+	ldr r1, =0x00400000
+	str r1, [r0, #0x890]
+
+	ldr r1, =0x3F393B3C
+	str r1, [r0, #0x848]
+	ldr r1, =0x262C3826
+	str r1, [r0, #0x850]
+
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	str r1, [r0, #0x824]
+	str r1, [r0, #0x828]
+
+	ldr r1, =0xf3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	str r1, [r0, #0x834]
+	str r1, [r0, #0x838]
+
+	ldr r1, =0x24922492
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+
+	ldr r1, =0x00020052
+	str r1, [r0, #0x004]
+	ldr r1, =0x53574333
+	str r1, [r0, #0x00C]
+	ldr r1, =0x00100B22
+	str r1, [r0, #0x010]
+	ldr r1, =0x00170778
+	str r1, [r0, #0x038]
+	ldr r1, =0x00C700DB
+	str r1, [r0, #0x014]
+	ldr r1, =0x00201718
+	str r1, [r0, #0x018]
+	ldr r1, =0x0F9F26D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x009F0E10
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000005F
+	str r1, [r0, #0x040]
+	ldr r1, =0xC4190000
+	str r1, [r0, #0x000]
+
+	ldr r1, =0x00008050
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00008058
+	str r1, [r0, #0x01C]
+	ldr r1, =0x003F8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x003F8038
+	str r1, [r0, #0x01C]
+	ldr r1, =0xFF0A8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0xFF0A8038
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04028030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04028038
+	str r1, [r0, #0x01C]
+	ldr r1, =0x83018030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x83018038
+	str r1, [r0, #0x01C]
+	ldr r1, =0x01038030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x01038038
+	str r1, [r0, #0x01C]
+
+	ldr r1, =0x20000000
+	str r1, [r0, #0x83C]
+
+	ldr r1, =0x00001800
+	str r1, [r0, #0x020]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00020052
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	str r1, [r0, #0x06c]
+	str r1, [r0, #0x070]
+	str r1, [r0, #0x074]
+	str r1, [r0, #0x078]
+	str r1, [r0, #0x07c]
+	str r1, [r0, #0x080]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6sll_evk_ddr_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6sx_17x17_arm2/imximage.cfg ebf_6ull_uboot/board/freescale/mx6sx_17x17_arm2/imximage.cfg
--- u-boot-2016.03/board/freescale/mx6sx_17x17_arm2/imximage.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sx_17x17_arm2/imximage.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sx_17x17_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+DATA 4 0x020e0618 0x000c0000
+DATA 4 0x020e05fc 0x00000000
+DATA 4 0x020e032c 0x00000030
+
+DATA 4 0x020e0300 0x00000030
+DATA 4 0x020e02fc 0x00000030
+DATA 4 0x020e05f4 0x00000030
+DATA 4 0x020e0340 0x00000030
+
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000030
+DATA 4 0x020e0314 0x00000030
+DATA 4 0x020e0614 0x00000030
+
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00000030
+DATA 4 0x020e0334 0x00000030
+DATA 4 0x020e0338 0x00000030
+DATA 4 0x020e033c 0x00000030
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000030
+DATA 4 0x020e0610 0x00000030
+DATA 4 0x020e061c 0x00000030
+DATA 4 0x020e0620 0x00000030
+DATA 4 0x020e02ec 0x00000030
+DATA 4 0x020e02f0 0x00000030
+DATA 4 0x020e02f4 0x00000030
+DATA 4 0x020e02f8 0x00000030
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b080c 0x00270025
+DATA 4 0x021b0810 0x001B001E
+DATA 4 0x021b083c 0x4144013C
+DATA 4 0x021b0840 0x01300128
+DATA 4 0x021b0848 0x4044464A
+DATA 4 0x021b0850 0x3A383C34
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b0004 0x0002002d
+DATA 4 0x021b0008 0x00333030
+DATA 4 0x021b000c 0x676b52f3
+DATA 4 0x021b0010 0xb66d8b63
+DATA 4 0x021b0014 0x01ff00db
+DATA 4 0x021b0018 0x00011740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
+DATA 4 0x021b0030 0x006b1023
+DATA 4 0x021b0040 0x0000005f
+DATA 4 0x021b0000 0x84190000
+DATA 4 0x021b001c 0x04008032
+DATA 4 0x021b001c 0x00008033
+DATA 4 0x021b001c 0x00068031
+DATA 4 0x021b001c 0x05208030
+DATA 4 0x021b001c 0x04008040
+DATA 4 0x021b0020 0x00000800
+DATA 4 0x021b0818 0x00011117
+DATA 4 0x021b001c 0x00000000
+
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6sx_17x17_arm2/imximage_wp.cfg ebf_6ull_uboot/board/freescale/mx6sx_17x17_arm2/imximage_wp.cfg
--- u-boot-2016.03/board/freescale/mx6sx_17x17_arm2/imximage_wp.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sx_17x17_arm2/imximage_wp.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+DATA 4 0x020e0618 0x000c0000
+DATA 4 0x020e05fc 0x00000000
+DATA 4 0x020e032c 0x00000030
+
+DATA 4 0x020e0300 0x00000030
+DATA 4 0x020e02fc 0x00000030
+DATA 4 0x020e05f4 0x00000030
+DATA 4 0x020e0340 0x00000030
+
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000030
+DATA 4 0x020e0314 0x00000030
+DATA 4 0x020e0614 0x00000030
+
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00000030
+DATA 4 0x020e0334 0x00000030
+DATA 4 0x020e0338 0x00000030
+DATA 4 0x020e033c 0x00000030
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000030
+DATA 4 0x020e0610 0x00000030
+DATA 4 0x020e061c 0x00000030
+DATA 4 0x020e0620 0x00000030
+DATA 4 0x020e02ec 0x00000030
+DATA 4 0x020e02f0 0x00000030
+DATA 4 0x020e02f4 0x00000030
+DATA 4 0x020e02f8 0x00000030
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b080c 0x002E003C
+DATA 4 0x021b0810 0x001A003F
+DATA 4 0x021b083c 0x41480150
+DATA 4 0x021b0840 0x012C0150
+DATA 4 0x021b0848 0x40404646
+DATA 4 0x021b0850 0x38363C32
+DATA 4 0x021b08c0 0x2492244A
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b0004 0x0002002d
+DATA 4 0x021b0008 0x00333030
+DATA 4 0x021b000c 0x676b52f3
+DATA 4 0x021b0010 0xb66d8b63
+DATA 4 0x021b0014 0x01ff00db
+DATA 4 0x021b0018 0x00011740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
+DATA 4 0x021b0030 0x006b1023
+DATA 4 0x021b0040 0x0000005f
+DATA 4 0x021b0000 0x84190000
+DATA 4 0x021b001c 0x04008032
+DATA 4 0x021b001c 0x00008033
+DATA 4 0x021b001c 0x00068031
+DATA 4 0x021b001c 0x05208030
+DATA 4 0x021b001c 0x04008040
+DATA 4 0x021b0020 0x00000800
+DATA 4 0x021b0818 0x00022227
+DATA 4 0x021b0004 0x0002556d
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
diff -urN u-boot-2016.03/board/freescale/mx6sx_17x17_arm2/Kconfig ebf_6ull_uboot/board/freescale/mx6sx_17x17_arm2/Kconfig
--- u-boot-2016.03/board/freescale/mx6sx_17x17_arm2/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sx_17x17_arm2/Kconfig	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,12 @@
+if TARGET_MX6SX_17X17_ARM2
+
+config SYS_BOARD
+	default "mx6sx_17x17_arm2"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_CONFIG_NAME
+	default "mx6sx_17x17_arm2"
+
+endif
diff -urN u-boot-2016.03/board/freescale/mx6sx_17x17_arm2/Makefile ebf_6ull_uboot/board/freescale/mx6sx_17x17_arm2/Makefile
--- u-boot-2016.03/board/freescale/mx6sx_17x17_arm2/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sx_17x17_arm2/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,10 @@
+# (C) Copyright 2014 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6sx_17x17_arm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6sx_17x17_arm2/mx6sx_14x14_lpddr2_arm2.cfg ebf_6ull_uboot/board/freescale/mx6sx_17x17_arm2/mx6sx_14x14_lpddr2_arm2.cfg
--- u-boot-2016.03/board/freescale/mx6sx_17x17_arm2/mx6sx_14x14_lpddr2_arm2.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sx_17x17_arm2/mx6sx_14x14_lpddr2_arm2.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sx_17x17_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+DATA 4 0x020c4018 0x00260324
+
+DATA 4 0x020e0618 0x00080000
+DATA 4 0x020e05fc 0x00000000
+DATA 4 0x020e032c 0x00000030
+
+DATA 4 0x020e0300 0x00000028
+DATA 4 0x020e02fc 0x00000028
+DATA 4 0x020e05f4 0x00000028
+DATA 4 0x020e0340 0x00000028
+
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000000
+DATA 4 0x020e0314 0x00000000
+DATA 4 0x020e0614 0x00000028
+
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00003028
+DATA 4 0x020e0334 0x00003028
+DATA 4 0x020e0338 0x00003028
+DATA 4 0x020e033c 0x00003028
+
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000028
+DATA 4 0x020e0610 0x00000028
+DATA 4 0x020e061c 0x00000028
+DATA 4 0x020e0620 0x00000028
+
+DATA 4 0x020e02ec 0x00000028
+DATA 4 0x020e02f0 0x00000028
+DATA 4 0x020e02f4 0x00000028
+DATA 4 0x020e02f8 0x00000028
+
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b085c 0x1b4700c7
+
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b0890 0x00380000
+DATA 4 0x021b08b8 0x00000800
+
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+
+DATA 4 0x021b082c 0x51111111
+DATA 4 0x021b0830 0x51111111
+DATA 4 0x021b0834 0x51111111
+DATA 4 0x021b0838 0x51111111
+
+DATA 4 0x021b0848 0x42424244
+
+DATA 4 0x021b0850 0x2E30322E
+DATA 4 0x021b08c0 0x2492244A
+DATA 4 0x021b083c 0x20000000
+DATA 4 0x021b0840 0x0
+
+DATA 4 0x021b08b8 0x00000800
+
+DATA 4 0x021b000c 0x33374133
+DATA 4 0x021b0004 0x00020024
+DATA 4 0x021b0010 0x00100A42
+DATA 4 0x021b0014 0x00000093
+DATA 4 0x021b0018 0x00001748
+DATA 4 0x021b002c 0x0f9f26d2
+DATA 4 0x021b0030 0x0000020e
+DATA 4 0x021b0038 0x00190778
+DATA 4 0x021b0008 0x00000000
+DATA 4 0x021b0040 0x0000004f
+DATA 4 0x021b0000 0xc3110000
+
+DATA 4 0x021b001c 0x00008050
+DATA 4 0x021b001c 0x003f8030
+DATA 4 0x021b001c 0xff0a8030
+DATA 4 0x021b001c 0x82018030
+DATA 4 0x021b001c 0x04028030
+DATA 4 0x021b001c 0x01038030
+
+DATA 4 0x021b001c 0x00008058
+DATA 4 0x021b001c 0x003f8038
+DATA 4 0x021b001c 0xff0a8038
+DATA 4 0x021b001c 0x82018038
+DATA 4 0x021b001c 0x04028038
+DATA 4 0x021b001c 0x01038038
+
+DATA 4 0x021b0020 0x00001800
+DATA 4 0x021b0818 0x00000000
+
+DATA 4 0x021b0800 0xa1310003
+DATA 4 0x021b0004 0x00025576
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
+
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6sx_17x17_arm2/mx6sx_17x17_arm2.c ebf_6ull_uboot/board/freescale/mx6sx_17x17_arm2/mx6sx_17x17_arm2.c
--- u-boot-2016.03/board/freescale/mx6sx_17x17_arm2/mx6sx_17x17_arm2.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sx_17x17_arm2/mx6sx_17x17_arm2.c	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,759 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#include <asm/arch/crm_regs.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include "../common/pfuze.h"
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_MED   |                                   \
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_MED   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define EPDC_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define WEIM_NOR_PAD_CTRL2 (PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define I2C_PMIC 0
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_GPIO1_IO00__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO00__GPIO1_IO_0 | PC,
+		.gp = IMX_GPIO_NR(1, 0),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO1_IO01__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO01__GPIO1_IO_1 | PC,
+		.gp = IMX_GPIO_NR(1, 1),
+	},
+};
+
+/* I2C2 */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_GPIO1_IO02__I2C2_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO02__GPIO1_IO_2 | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO1_IO03__I2C2_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO03__GPIO1_IO_3 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+
+static struct pmic *pfuze;
+int power_init_board(void)
+{
+	unsigned int reg;
+	int ret;
+
+	pfuze = pfuze_common_init(I2C_PMIC);
+	if (!pfuze)
+		return -ENODEV;
+
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	/* set SW1AB staby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE100_SW1ABC_SETP(9750);
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, reg);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, reg);
+
+	/* set SW1C staby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE100_SW1ABC_SETP(9750);
+	pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, reg);
+
+	/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1CCONF, reg);
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	int is_400M;
+	u32 vddarm;
+	struct pmic *p = pfuze;
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(12750);
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		/* decrease VDDSOC to 1.3V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(13000);
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE100_SW1ABC_SETP(10750);
+		else
+			vddarm = PFUZE100_SW1ABC_SETP(11750);
+
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= vddarm;
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(11750);
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+
+}
+#endif
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_GPIO1_IO04__UART1_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_GPIO1_IO05__UART1_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_SD2_CLK__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_CMD__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA0__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA1__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA2__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA3__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6_PAD_SD3_CLK__USDHC3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_CMD__USDHC3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA0__USDHC3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA1__USDHC3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA2__USDHC3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA3__USDHC3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA4__USDHC3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA5__USDHC3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA6__USDHC3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA7__USDHC3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/*CD pin*/
+	MX6_PAD_KEY_COL0__GPIO2_IO_10 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc4_pads[] = {
+	MX6_PAD_SD4_CLK__USDHC4_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_CMD__USDHC4_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA0__USDHC4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA1__USDHC4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA2__USDHC4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA3__USDHC4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA4__USDHC4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA5__USDHC4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA6__USDHC4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA7__USDHC4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_ENET1_MDC__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_MDIO__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_RX_CTL__ENET1_RX_EN | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD0__ENET1_RX_DATA_0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD1__ENET1_RX_DATA_1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD2__ENET1_RX_DATA_2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD3__ENET1_RX_DATA_3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RXC__ENET1_RX_CLK | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_TX_CTL__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD0__ENET1_TX_DATA_0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD1__ENET1_TX_DATA_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD2__ENET1_TX_DATA_2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD3__ENET1_TX_DATA_3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	/* AR8031 PHY Reset. For arm2 board, silder the resistance */
+	MX6_PAD_QSPI1A_SS0_B__GPIO4_IO_22 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_fec1(void)
+{
+	imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+
+	/* Reset AR8031 PHY */
+	gpio_direction_output(IMX_GPIO_NR(4, 22) , 0);
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(4, 22), 1);
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_QSPI
+
+#define QSPI_PAD_CTRL1  \
+		(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+		PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_60ohm)
+
+#define QSPI_PAD_CTRL2 (QSPI_PAD_CTRL1 | PAD_CTL_DSE_34ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6_PAD_NAND_WP_B__QSPI2_A_DATA_0 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_READY_B__QSPI2_A_DATA_1 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE0_B__QSPI2_A_DATA_2 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE1_B__QSPI2_A_DATA_3 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CLE__QSPI2_A_SCLK | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_ALE__QSPI2_A_SS0_B | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA01__QSPI2_B_DATA_0	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA00__QSPI2_B_DATA_1	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_WE_B__QSPI2_B_DATA_2		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_RE_B__QSPI2_B_DATA_3		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA03__QSPI2_B_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA02__QSPI2_B_SCLK		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads, ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(1);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC2_BASE_ADDR, 0, 4},
+	{USDHC3_BASE_ADDR},
+	{USDHC4_BASE_ADDR},
+};
+
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(2, 10)
+
+int board_mmc_get_env_dev(int dev_no)
+{
+#ifdef CONFIG_SYS_USE_SPINOR
+	dev_no -= 2;
+#else
+	dev_no--;
+#endif
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+#ifdef CONFIG_SYS_USE_SPINOR
+	return dev_no + 2;
+#else
+	return dev_no + 1;
+#endif
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC2_BASE_ADDR:
+		ret = 1; /*always present */
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	case USDHC4_BASE_ADDR:
+		ret = 1; /*always present */
+		break;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_SYS_USE_SPINOR
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    SD3 (SDB)
+	 * mmc1                    eMMC
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+		}
+
+		if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+			printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+
+#else
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    SD2 (SDA)
+	 * mmc1                    SD3 (SDB)
+	 * mmc2                    eMMC
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		case 2:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+		}
+
+		if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+			printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+#endif
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+iomux_v3_cfg_t const ecspi4_pads[] = {
+	MX6_PAD_SD2_CLK__ECSPI4_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_SD2_DATA3__ECSPI4_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_SD2_CMD__ECSPI4_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_SD2_DATA2__GPIO6_IO_10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi4_pads,
+					 ARRAY_SIZE(ecspi4_pads));
+	gpio_direction_output(IMX_GPIO_NR(6, 10), 0);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(6, 10)) : -1;
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+iomux_v3_cfg_t eimnor_pads[] = {
+	MX6_PAD_NAND_DATA00__WEIM_AD_0     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA01__WEIM_AD_1     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA02__WEIM_AD_2     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA03__WEIM_AD_3     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA04__WEIM_AD_4     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA05__WEIM_AD_5     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA06__WEIM_AD_6     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA07__WEIM_AD_7     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA08__WEIM_AD_8     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA09__WEIM_AD_9     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA10__WEIM_AD_10    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA11__WEIM_AD_11    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL) ,
+	MX6_PAD_LCD1_DATA12__WEIM_AD_12    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA13__WEIM_AD_13    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA14__WEIM_AD_14    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA15__WEIM_AD_15    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA16__WEIM_ADDR_16  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA17__WEIM_ADDR_17  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA18__WEIM_ADDR_18  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA19__WEIM_ADDR_19  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA20__WEIM_ADDR_20  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA21__WEIM_ADDR_21  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA22__WEIM_ADDR_22  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA23__WEIM_ADDR_23  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA03__WEIM_ADDR_24  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA04__WEIM_ADDR_25  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+
+	MX6_PAD_NAND_CE0_B__WEIM_LBA_B     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_CE1_B__WEIM_OE        | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_RE_B__WEIM_RW         | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_WE_B__WEIM_WAIT       | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	MX6_PAD_NAND_ALE__WEIM_CS0_B       | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+};
+static void eimnor_cs_setup(void)
+{
+	writel(0x00000120, WEIM_BASE_ADDR + 0x090);
+	writel(0x00610089, WEIM_BASE_ADDR + 0x000);
+	writel(0x00000001, WEIM_BASE_ADDR + 0x004);
+	writel(0x1c022000, WEIM_BASE_ADDR + 0x008);
+	writel(0x00000000, WEIM_BASE_ADDR + 0x00c);
+	writel(0x1404a38e, WEIM_BASE_ADDR + 0x010);
+}
+
+static void setup_eimnor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(eimnor_pads,
+			ARRAY_SIZE(eimnor_pads));
+
+	eimnor_cs_setup();
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+iomux_v3_cfg_t gpmi_pads[] = {
+	MX6_PAD_NAND_CLE__RAWNAND_CLE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_ALE__RAWNAND_ALE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL0),
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(gpmi_pads, ARRAY_SIZE(gpmi_pads));
+
+	setup_gpmi_io_clk((MXC_CCM_CS2CDR_QSPI2_CLK_PODF(0) |
+			MXC_CCM_CS2CDR_QSPI2_CLK_PRED(3) |
+			MXC_CCM_CS2CDR_QSPI2_CLK_SEL(3)));
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec1();
+
+	ret = fecmxc_initialize_multi(bis, 0,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC1 MXC: %s:failed\n", __func__);
+
+	return 0;
+}
+
+static int setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+	int ret;
+	unsigned char value = 1;
+
+	/* clear gpr1[13], gpr1[17] to select anatop clock */
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK, 0);
+
+	ret = enable_fec_anatop_clock(0, ENET_125MHZ);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_FEC_ENABLE_MAX7322
+	/* release max7322 from reset */
+	gpio_direction_output(IMX_GPIO_NR(4, 22) , 1);
+
+	/* This is needed to drive the pads to 1.8V instead of 1.5V */
+	i2c_set_bus_num(CONFIG_MAX7322_I2C_BUS);
+
+	if (!i2c_probe(CONFIG_MAX7322_I2C_ADDR)) {
+		/* Write 0x1 to enable O0 output, this device has no addr */
+		/* hence addr length is 0 */
+		value = 0x1;
+		if (i2c_write(CONFIG_MAX7322_I2C_ADDR, 0, 0, &value, 1))
+			printf("MAX7322 write failed\n");
+	} else {
+		printf("MAX7322 Not found\n");
+	}
+#endif
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+#ifdef CONFIG_FEC_ENABLE_MAX7322
+	/* Enable 1.8V(SEL_1P5_1P8_POS_REG) on
+	   Phy control debug reg 0 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
+#endif
+
+	/* rgmii tx clock delay enable */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+iomux_v3_cfg_t const usb_otg_pads[] = {
+	/*Only enable OTG1, the OTG2 has pin conflicts with PWM and WDOG*/
+	MX6_PAD_GPIO1_IO09__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+					 ARRAY_SIZE(usb_otg_pads));
+}
+
+int board_usb_phy_mode(int port)
+{
+	return USB_INIT_HOST;
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port >= 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec();
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+	setup_eimnor();
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	board_qspi_init();
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd2", MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	{"sd3", MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"emmc", MAKE_CFGVAL(0x60, 0x38, 0x00, 0x00)},
+	{"qspi2", MAKE_CFGVAL(0x18, 0x00, 0x00, 0x00)},
+	{"spinor", MAKE_CFGVAL(0x30, 0x00, 0x00, 0x0B)},
+	{"nand", MAKE_CFGVAL(0x80, 0x00, 0x00, 0x00)},
+	{NULL,   0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+#ifdef CONFIG_MX6SX_14x14
+	puts("Board: MX6SX 14x14 ARM2\n");
+#else
+	puts("Board: MX6SX 17x17 ARM2\n");
+#endif
+
+	return 0;
+}
diff -urN u-boot-2016.03/board/freescale/mx6sx_17x17_arm2/plugin.S ebf_6ull_uboot/board/freescale/mx6sx_17x17_arm2/plugin.S
--- u-boot-2016.03/board/freescale/mx6sx_17x17_arm2/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sx_17x17_arm2/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6sx_17x17_ddr3_evk_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x618]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x5fc]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x32c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x300]
+	str r1, [r0, #0x2fc]
+	str r1, [r0, #0x5f4]
+	str r1, [r0, #0x340]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x320]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x310]
+	str r1, [r0, #0x314]
+	str r1, [r0, #0x614]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5f8]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x330]
+	str r1, [r0, #0x334]
+	str r1, [r0, #0x338]
+	str r1, [r0, #0x33c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x608]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x60c]
+	str r1, [r0, #0x610]
+	str r1, [r0, #0x61c]
+	str r1, [r0, #0x620]
+	str r1, [r0, #0x2ec]
+	str r1, [r0, #0x2f0]
+	str r1, [r0, #0x2f4]
+	str r1, [r0, #0x2f8]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00270025
+	str r2, [r0, #0x80c]
+	ldr r2, =0x001B001E
+	str r2, [r0, #0x810]
+	ldr r2, =0x4144013C
+	str r2, [r0, #0x83c]
+	ldr r2, =0x01300128
+	str r2, [r0, #0x840]
+	ldr r2, =0x4044464A
+	str r2, [r0, #0x848]
+	ldr r2, =0x3A383C34
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	ldr r2, =0x0002002d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+	ldr r2, =0x676b52f3
+	str r2, [r0, #0x00c]
+	ldr r2, =0xb66d8b63
+	str r2, [r0, #0x010]
+	ldr r2, =0x01ff00db
+	str r2, [r0, #0x014]
+	ldr r2, =0x00011740
+	str r2, [r0, #0x018]
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x006b1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x0000005f
+	str r2, [r0, #0x040]
+	ldr r2, =0x84190000
+	str r2, [r0, #0x000]
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00068031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	str r1, [r0, #0x06c]
+	str r1, [r0, #0x070]
+	str r1, [r0, #0x074]
+	str r1, [r0, #0x078]
+	str r1, [r0, #0x07c]
+	str r1, [r0, #0x080]
+	str r1, [r0, #0x084]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6sx_14x14_lpddr2_arm2_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x618]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x5fc]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x32c]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x300]
+	str r1, [r0, #0x2fc]
+	str r1, [r0, #0x5f4]
+	str r1, [r0, #0x340]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x320]
+	str r1, [r0, #0x310]
+	str r1, [r0, #0x314]
+	ldr r1, =0x00000028
+	str r1, [r0, #0x614]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5f8]
+	ldr r1, =0x00003028
+	str r1, [r0, #0x330]
+	str r1, [r0, #0x334]
+	str r1, [r0, #0x338]
+	str r1, [r0, #0x33c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x608]
+	ldr r1, =0x00000028
+	str r1, [r0, #0x60c]
+	str r1, [r0, #0x610]
+	str r1, [r0, #0x61c]
+	str r1, [r0, #0x620]
+	str r1, [r0, #0x2ec]
+	str r1, [r0, #0x2f0]
+	str r1, [r0, #0x2f4]
+	str r1, [r0, #0x2f8]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	ldr r2, =0x1b4700c7
+	str r2, [r0, #0x85c]
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00380000
+	str r2, [r0, #0x890]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x51111111
+	str r2, [r0, #0x82c]
+	str r2, [r0, #0x830]
+	str r2, [r0, #0x834]
+	str r2, [r0, #0x838]
+
+	ldr r2, =0x42424244
+	str r2, [r0, #0x848]
+	ldr r2, =0x2E30322E
+	str r2, [r0, #0x850]
+	ldr r2, =0x2492244A
+	str r2, [r0, #0x8c0]
+	ldr r2, =0x20000000
+	str r2, [r0, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x840]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x33374133
+	str r2, [r0, #0x00c]
+	ldr r2, =0x00020024
+	str r2, [r0, #0x004]
+	ldr r2, =0x00100A42
+	str r2, [r0, #0x010]
+	ldr r2, =0x00000093
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001748
+	str r2, [r0, #0x018]
+	ldr r2, =0x0f9f26d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x0000020e
+	str r2, [r0, #0x030]
+	ldr r2, =0x00190778
+	str r2, [r0, #0x038]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x008]
+	ldr r2, =0x0000004f
+	str r2, [r0, #0x040]
+	ldr r2, =0xc3110000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x00008050
+	str r2, [r0, #0x01c]
+	ldr r2, =0x003f8030
+	str r2, [r0, #0x01c]
+	ldr r2, =0xff0a8030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x82018030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04028030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x01038030
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00008058
+	str r2, [r0, #0x01c]
+	ldr r2, =0x003f8038
+	str r2, [r0, #0x01c]
+	ldr r2, =0xff0a8038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x82018038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04028038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x01038038
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00001800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x818]
+	ldr r2, =0xa1310003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6_ddr_setting
+#if defined(CONFIG_MX6SX_14x14) && defined (CONFIG_LPDDR)
+	imx6sx_14x14_lpddr2_arm2_ddr_setting
+#else
+	imx6sx_17x17_ddr3_evk_ddr_setting
+#endif
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6sx_19x19_arm2/imximage.cfg ebf_6ull_uboot/board/freescale/mx6sx_19x19_arm2/imximage.cfg
--- u-boot-2016.03/board/freescale/mx6sx_19x19_arm2/imximage.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sx_19x19_arm2/imximage.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sx_19x19_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+/* IOMUX */
+/* DDR IO TYPE */
+DATA 4 0x020e0618 0x000c0000
+DATA 4 0x020e05fc 0x00000000
+
+/* CLOCK */
+DATA 4 0x020e032c 0x00000030
+
+/* ADDRESS */
+DATA 4 0x020e0300 0x00000030
+DATA 4 0x020e02fc 0x00000030
+DATA 4 0x020e05f4 0x00000030
+
+/* CONTROL */
+DATA 4 0x020e0340 0x00000030
+
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000030
+DATA 4 0x020e0314 0x00000030
+DATA 4 0x020e0614 0x00000030
+
+/* DATA STROBE */
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00000030
+DATA 4 0x020e0334 0x00000030
+DATA 4 0x020e0338 0x00000030
+DATA 4 0x020e033c 0x00000030
+
+/* DATA */
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000030
+DATA 4 0x020e0610 0x00000030
+DATA 4 0x020e061c 0x00000030
+DATA 4 0x020e0620 0x00000030
+DATA 4 0x020e02ec 0x00000030
+DATA 4 0x020e02f0 0x00000030
+DATA 4 0x020e02f4 0x00000030
+DATA 4 0x020e02f8 0x00000030
+
+/* Calibrations */
+/* ZQ */
+DATA 4 0x021b0800 0xa1390003
+/* write leveling */
+DATA 4 0x021b080c 0x002C003D
+DATA 4 0x021b0810 0x00110046
+
+/* DQS Read Gate */
+DATA 4 0x021b083c 0x4160016C
+DATA 4 0x021b0840 0x013C016C
+
+/* Read/Write Delay */
+DATA 4 0x021b0848 0x46424446
+DATA 4 0x021b0850 0x3A3C3C3A
+
+DATA 4 0x021b08c0 0x2492244A
+
+/* read data bit delay */
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+
+/* Complete calibration by forced measurment */
+DATA 4 0x021b08b8 0x00000800
+
+/* MMDC init */
+/* in DDR3, 64-bit mode, only MMDC0 is initiated */
+DATA 4 0x021b0004 0x0002002d
+DATA 4 0x021b0008 0x00333030
+DATA 4 0x021b000c 0x676b52f3
+DATA 4 0x021b0010 0xb66d8b63
+DATA 4 0x021b0014 0x01ff00db
+DATA 4 0x021b0018 0x00011740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
+DATA 4 0x021b0030 0x006b1023
+DATA 4 0x021b0040 0x0000007f
+DATA 4 0x021b0000 0x85190000
+
+/* Initialize CS0: MT41K256M16HA-125 */
+/* MR2 */
+DATA 4 0x021b001c 0x04008032
+/* MR3 */
+DATA 4 0x021b001c 0x00008033
+/* MR1 */
+DATA 4 0x021b001c 0x00068031
+/* MR0 */
+DATA 4 0x021b001c 0x05208030
+/* DDR device ZQ calibration */
+DATA 4 0x021b001c 0x04008040
+
+/* final DDR setup, before operation start */
+DATA 4 0x021b0020 0x00000800
+DATA 4 0x021b0818 0x00022227
+DATA 4 0x021b0004 0x0002556d
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
+
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6sx_19x19_arm2/imximage_lpddr2.cfg ebf_6ull_uboot/board/freescale/mx6sx_19x19_arm2/imximage_lpddr2.cfg
--- u-boot-2016.03/board/freescale/mx6sx_19x19_arm2/imximage_lpddr2.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sx_19x19_arm2/imximage_lpddr2.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sx_19x19_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+DATA 4 0x020e0618 0x00080000
+DATA 4 0x020e05fc 0x00000000
+DATA 4 0x020e032c 0x00000030
+
+DATA 4 0x020e0300 0x00000028
+DATA 4 0x020e02fc 0x00000028
+DATA 4 0x020e05f4 0x00000028
+DATA 4 0x020e0340 0x00000028
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000000
+DATA 4 0x020e0314 0x00000000
+DATA 4 0x020e0614 0x00000028
+
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00003028
+DATA 4 0x020e0334 0x00003028
+DATA 4 0x020e0338 0x00003028
+DATA 4 0x020e033c 0x00003028
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000028
+DATA 4 0x020e0610 0x00000028
+DATA 4 0x020e061c 0x00000028
+DATA 4 0x020e0620 0x00000028
+DATA 4 0x020e02ec 0x00000028
+DATA 4 0x020e02f0 0x00000028
+DATA 4 0x020e02f4 0x00000028
+DATA 4 0x020e02f8 0x00000028
+
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b085c 0x1b4700c7
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b0890 0x00380000
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b082c 0x51111111
+DATA 4 0x021b0830 0x51111111
+DATA 4 0x021b0834 0x51111111
+DATA 4 0x021b0838 0x51111111
+DATA 4 0x021b0848 0x42424244
+DATA 4 0x021b0850 0x2E30322E
+DATA 4 0x021b08c0 0x2492244A
+DATA 4 0x021b083c 0x20000000
+DATA 4 0x021b0840 0x00000000
+DATA 4 0x021b08b8 0x00000800
+
+DATA 4 0x021b000c 0x33374133
+DATA 4 0x021b0004 0x00020024
+DATA 4 0x021b0010 0x00100A42
+DATA 4 0x021b0014 0x00000093
+DATA 4 0x021b0018 0x00001748
+DATA 4 0x021b002c 0x0f9f26d2
+DATA 4 0x021b0030 0x0000020e
+DATA 4 0x021b0038 0x00190778
+DATA 4 0x021b0008 0x00000000
+DATA 4 0x021b0040 0x0000004f
+DATA 4 0x021b0000 0xc3110000
+
+DATA 4 0x021b001c 0x00008050
+DATA 4 0x021b001c 0x003f8030
+DATA 4 0x021b001c 0xff0a8030
+DATA 4 0x021b001c 0x82018030
+DATA 4 0x021b001c 0x04028030
+DATA 4 0x021b001c 0x01038030
+
+DATA 4 0x021b001c 0x00008058
+DATA 4 0x021b001c 0x003f8038
+DATA 4 0x021b001c 0xff0a8038
+DATA 4 0x021b001c 0x82018038
+DATA 4 0x021b001c 0x04028038
+DATA 4 0x021b001c 0x01038038
+
+DATA 4 0x021b0020 0x00001800
+DATA 4 0x021b0818 0x00000000
+DATA 4 0x021b0800 0xa1310003
+DATA 4 0x021b0004 0x00025576
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
+
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6sx_19x19_arm2/Kconfig ebf_6ull_uboot/board/freescale/mx6sx_19x19_arm2/Kconfig
--- u-boot-2016.03/board/freescale/mx6sx_19x19_arm2/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sx_19x19_arm2/Kconfig	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,12 @@
+if TARGET_MX6SX_19X19_ARM2
+
+config SYS_BOARD
+	default "mx6sx_19x19_arm2"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_CONFIG_NAME
+	default "mx6sx_19x19_arm2"
+
+endif
diff -urN u-boot-2016.03/board/freescale/mx6sx_19x19_arm2/Makefile ebf_6ull_uboot/board/freescale/mx6sx_19x19_arm2/Makefile
--- u-boot-2016.03/board/freescale/mx6sx_19x19_arm2/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sx_19x19_arm2/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,10 @@
+# (C) Copyright 2014 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6sx_19x19_arm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6sx_19x19_arm2/mx6sx_19x19_arm2.c ebf_6ull_uboot/board/freescale/mx6sx_19x19_arm2/mx6sx_19x19_arm2.c
--- u-boot-2016.03/board/freescale/mx6sx_19x19_arm2/mx6sx_19x19_arm2.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sx_19x19_arm2/mx6sx_19x19_arm2.c	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,756 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#include <asm/arch/crm_regs.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include "../common/pfuze.h"
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+#include <asm/imx-common/video.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_MED   |                                   \
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_MED   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define WEIM_NOR_PAD_CTRL2 (PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define I2C_PMIC 0
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_GPIO1_IO00__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO00__GPIO1_IO_0 | PC,
+		.gp = IMX_GPIO_NR(1, 0),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO1_IO01__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO01__GPIO1_IO_1 | PC,
+		.gp = IMX_GPIO_NR(1, 1),
+	},
+};
+
+/* I2C2 */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_GPIO1_IO02__I2C2_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO02__GPIO1_IO_2 | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO1_IO03__I2C2_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO03__GPIO1_IO_3 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+
+static struct pmic *pfuze;
+int power_init_board(void)
+{
+	unsigned int reg;
+	int ret;
+
+	pfuze = pfuze_common_init(I2C_PMIC);
+	if (!pfuze)
+		return -ENODEV;
+
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	/* set SW1AB staby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE100_SW1ABC_SETP(9750);
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, reg);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, reg);
+
+	/* set SW1C staby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE100_SW1ABC_SETP(9750);
+	pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, reg);
+
+	/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1CCONF, reg);
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	int is_400M;
+	u32 vddarm;
+	struct pmic *p = pfuze;
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(12750);
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		/* decrease VDDSOC to 1.3V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(13000);
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE100_SW1ABC_SETP(10750);
+		else
+			vddarm = PFUZE100_SW1ABC_SETP(11750);
+
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= vddarm;
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(11750);
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+
+}
+#endif
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_GPIO1_IO04__UART1_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_GPIO1_IO05__UART1_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lvds_ctrl_pads[] = {
+	/* CABC enable */
+	MX6_PAD_KEY_ROW1__GPIO2_IO_16 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6_PAD_GPIO1_IO12__GPIO1_IO_12 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD1_CLK__LCDIF1_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_ENABLE__LCDIF1_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_HSYNC__LCDIF1_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_VSYNC__LCDIF1_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA00__LCDIF1_DATA_0 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA01__LCDIF1_DATA_1 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA02__LCDIF1_DATA_2 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA03__LCDIF1_DATA_3 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA04__LCDIF1_DATA_4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA05__LCDIF1_DATA_5 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA06__LCDIF1_DATA_6 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA07__LCDIF1_DATA_7 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA08__LCDIF1_DATA_8 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA09__LCDIF1_DATA_9 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA10__LCDIF1_DATA_10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA11__LCDIF1_DATA_11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA12__LCDIF1_DATA_12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA13__LCDIF1_DATA_13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA14__LCDIF1_DATA_14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA15__LCDIF1_DATA_15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA16__LCDIF1_DATA_16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA17__LCDIF1_DATA_17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA18__LCDIF1_DATA_18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA19__LCDIF1_DATA_19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA20__LCDIF1_DATA_20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA21__LCDIF1_DATA_21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA22__LCDIF1_DATA_22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA23__LCDIF1_DATA_23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_RESET__GPIO3_IO_27 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6_PAD_GPIO1_IO12__GPIO1_IO_12 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void	(*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void do_enable_lvds(struct display_info_t const *dev)
+{
+	enable_lcdif_clock(dev->bus);
+	enable_lvds_bridge(dev->bus);
+
+	imx_iomux_v3_setup_multiple_pads(lvds_ctrl_pads,
+							ARRAY_SIZE(lvds_ctrl_pads));
+
+	/* Enable CABC */
+	gpio_direction_output(IMX_GPIO_NR(2, 16) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(1, 12) , 1);
+}
+
+void do_enable_parallel_lcd(struct display_info_t const *dev)
+{
+	enable_lcdif_clock(dev->bus);
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(3, 27) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(1, 12) , 1);
+}
+
+struct display_info_t const displays[] = {{
+	.bus = LCDIF2_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 18,
+	.enable	= do_enable_lvds,
+	.detect = NULL,
+	.mode	= {
+		.name			= "Hannstar-XGA",
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus = MX6SX_LCDIF1_BASE_ADDR,
+	.pixfmt = 24,
+	.addr = 0,
+	.detect = NULL,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+#endif
+
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_ENET1_MDC__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_MDIO__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_RX_CTL__ENET1_RX_EN | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD0__ENET1_RX_DATA_0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD1__ENET1_RX_DATA_1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD2__ENET1_RX_DATA_2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD3__ENET1_RX_DATA_3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RXC__ENET1_RX_CLK | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_TX_CTL__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD0__ENET1_TX_DATA_0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD1__ENET1_TX_DATA_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD2__ENET1_TX_DATA_2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD3__ENET1_TX_DATA_3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_CLK__ENET1_TX_CLK | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	/* AR8031 PHY Reset. For arm2 board, silder the resistance */
+	MX6_PAD_SD4_DATA4__GPIO6_IO_18 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_fec1(void)
+{
+	imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_QSPI
+
+#define QSPI_PAD_CTRL1	\
+		(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+		PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_60ohm)
+
+#define QSPI_PAD_CTRL2 (QSPI_PAD_CTRL1 | PAD_CTL_DSE_34ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6_PAD_NAND_WP_B__QSPI2_A_DATA_0 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_READY_B__QSPI2_A_DATA_1 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE0_B__QSPI2_A_DATA_2 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE1_B__QSPI2_A_DATA_3 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CLE__QSPI2_A_SCLK | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_ALE__QSPI2_A_SS0_B | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA01__QSPI2_B_DATA_0	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA00__QSPI2_B_DATA_1	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_WE_B__QSPI2_B_DATA_2		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_RE_B__QSPI2_B_DATA_3		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA03__QSPI2_B_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA02__QSPI2_B_SCLK		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads, ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(1);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[1] = {
+	{USDHC1_BASE_ADDR, 0, 4},
+};
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	return 1;	/* Assume boot SD always present */
+}
+int board_mmc_init(bd_t *bis)
+{
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1 (SDA)
+	 */
+	imx_iomux_v3_setup_multiple_pads(usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+
+	usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+	return fsl_esdhc_initialize(bis, &usdhc_cfg[0]);
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+iomux_v3_cfg_t const ecspi4_pads[] = {
+	MX6_PAD_SD2_CLK__ECSPI4_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_SD2_DATA3__ECSPI4_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_SD2_CMD__ECSPI4_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_SD2_DATA2__GPIO6_IO_10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi4_pads,
+					 ARRAY_SIZE(ecspi4_pads));
+	gpio_direction_output(IMX_GPIO_NR(6, 10), 0);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(6, 10)) : -1;
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+iomux_v3_cfg_t eimnor_pads[] = {
+	MX6_PAD_QSPI1A_SCLK__WEIM_DATA_0   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6_PAD_QSPI1A_SS0_B__WEIM_DATA_1  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6_PAD_QSPI1A_SS1_B__WEIM_DATA_2  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6_PAD_QSPI1A_DATA3__WEIM_DATA_3  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6_PAD_QSPI1A_DATA2__WEIM_DATA_4  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6_PAD_QSPI1A_DATA1__WEIM_DATA_5  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6_PAD_QSPI1A_DATA0__WEIM_DATA_6  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6_PAD_QSPI1A_DQS__WEIM_DATA_7    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6_PAD_QSPI1B_SCLK__WEIM_DATA_8   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6_PAD_QSPI1B_SS0_B__WEIM_DATA_9  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6_PAD_QSPI1B_SS1_B__WEIM_DATA_10 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6_PAD_QSPI1B_DATA3__WEIM_DATA_11 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6_PAD_QSPI1B_DATA2__WEIM_DATA_12 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6_PAD_QSPI1B_DATA1__WEIM_DATA_13 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6_PAD_QSPI1B_DATA0__WEIM_DATA_14 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6_PAD_QSPI1B_DQS__WEIM_DATA_15   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+
+	MX6_PAD_NAND_DATA00__WEIM_AD_0     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA01__WEIM_AD_1     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA02__WEIM_AD_2     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA03__WEIM_AD_3     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA04__WEIM_AD_4     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA05__WEIM_AD_5     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA06__WEIM_AD_6     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA07__WEIM_AD_7     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA08__WEIM_AD_8     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA09__WEIM_AD_9     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA10__WEIM_AD_10    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA11__WEIM_AD_11    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL) ,
+	MX6_PAD_LCD1_DATA12__WEIM_AD_12    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA13__WEIM_AD_13    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA14__WEIM_AD_14    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA15__WEIM_AD_15    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA16__WEIM_ADDR_16  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA17__WEIM_ADDR_17  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA18__WEIM_ADDR_18  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA19__WEIM_ADDR_19  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA20__WEIM_ADDR_20  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA21__WEIM_ADDR_21  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA22__WEIM_ADDR_22  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA23__WEIM_ADDR_23  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA03__WEIM_ADDR_24  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA04__WEIM_ADDR_25  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD1_DATA05__WEIM_ADDR_26  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+
+	MX6_PAD_NAND_CE1_B__WEIM_OE        | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_RE_B__WEIM_RW         | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_WE_B__WEIM_WAIT       | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	MX6_PAD_NAND_ALE__WEIM_CS0_B       | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+};
+static void eimnor_cs_setup(void)
+{
+	writel(0x00000120, WEIM_BASE_ADDR + 0x090);
+	writel(0x00010181, WEIM_BASE_ADDR + 0x000);
+	writel(0x00000001, WEIM_BASE_ADDR + 0x004);
+	writel(0x0a020000, WEIM_BASE_ADDR + 0x008);
+	writel(0x0000c000, WEIM_BASE_ADDR + 0x00c);
+	writel(0x0804a240, WEIM_BASE_ADDR + 0x010);
+}
+
+static void setup_eimnor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(eimnor_pads,
+			ARRAY_SIZE(eimnor_pads));
+
+	eimnor_cs_setup();
+}
+#endif
+
+
+#ifdef CONFIG_SYS_USE_NAND
+iomux_v3_cfg_t gpmi_pads[] = {
+	MX6_PAD_NAND_CLE__RAWNAND_CLE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_ALE__RAWNAND_ALE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL0),
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(gpmi_pads, ARRAY_SIZE(gpmi_pads));
+
+	setup_gpmi_io_clk((MXC_CCM_CS2CDR_QSPI2_CLK_PODF(0) |
+			MXC_CCM_CS2CDR_QSPI2_CLK_PRED(3) |
+			MXC_CCM_CS2CDR_QSPI2_CLK_SEL(3)));
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+static int setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+	int ret;
+	unsigned char value = 1;
+
+	/* clear gpr1[13], gpr1[17] to select anatop clock */
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK, 0);
+
+	ret = enable_fec_anatop_clock(0, ENET_125MHZ);
+	if (ret)
+		return ret;
+
+	/* Reset AR8031 PHY */
+	gpio_direction_output(IMX_GPIO_NR(6, 18) , 0);
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(6, 18), 1);
+
+#ifdef CONFIG_FEC_ENABLE_MAX7322
+	/* This is needed to drive the pads to 1.8V instead of 1.5V */
+	i2c_set_bus_num(CONFIG_MAX7322_I2C_BUS);
+
+	if (!i2c_probe(CONFIG_MAX7322_I2C_ADDR)) {
+		/* Write 0x1 to enable O0 output, this device has no addr */
+		/* hence addr length is 0 */
+		value = 0x1;
+		if (i2c_write(CONFIG_MAX7322_I2C_ADDR, 0, 0, &value, 1))
+			printf("MAX7322 write failed\n");
+	} else {
+		printf("MAX7322 Not found\n");
+	}
+#endif
+
+	return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec1();
+	setup_fec();
+
+	ret = fecmxc_initialize_multi(bis, 0,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC1 MXC: %s:failed\n", __func__);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+#ifdef CONFIG_FEC_ENABLE_MAX7322
+	/* Enable 1.8V(SEL_1P5_1P8_POS_REG) on
+	   Phy control debug reg 0 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
+#endif
+
+	/* rgmii tx clock delay enable */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+iomux_v3_cfg_t const usb_otg_pads[] = {
+	MX6_PAD_GPIO1_IO09__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+	MX6_PAD_GPIO1_IO12__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+					 ARRAY_SIZE(usb_otg_pads));
+}
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port >= 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+	setup_eimnor();
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	board_qspi_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x40, 0x20, 0x00, 0x00)},
+	{"qspi2", MAKE_CFGVAL(0x18, 0x00, 0x00, 0x00)},
+	{"spinor", MAKE_CFGVAL(0x30, 0x00, 0x00, 0x0B)},
+	{"eimnor", MAKE_CFGVAL(0x00, 0x80, 0x00, 0x00)},
+	{NULL,   0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: MX6SX 19x19 ARM2\n");
+
+	return 0;
+}
diff -urN u-boot-2016.03/board/freescale/mx6sx_19x19_arm2/plugin.S ebf_6ull_uboot/board/freescale/mx6sx_19x19_arm2/plugin.S
--- u-boot-2016.03/board/freescale/mx6sx_19x19_arm2/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sx_19x19_arm2/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,289 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6sx_19x19_ddr3_arm2_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x618]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x5fc]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x32c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x300]
+	str r1, [r0, #0x2fc]
+	str r1, [r0, #0x5f4]
+	str r1, [r0, #0x340]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x320]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x310]
+	str r1, [r0, #0x314]
+	str r1, [r0, #0x614]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5f8]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x330]
+	str r1, [r0, #0x334]
+	str r1, [r0, #0x338]
+	str r1, [r0, #0x33c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x608]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x60c]
+	str r1, [r0, #0x610]
+	str r1, [r0, #0x61c]
+	str r1, [r0, #0x620]
+	str r1, [r0, #0x2ec]
+	str r1, [r0, #0x2f0]
+	str r1, [r0, #0x2f4]
+	str r1, [r0, #0x2f8]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x002C003D
+	str r2, [r0, #0x80c]
+	ldr r2, =0x00110046
+	str r2, [r0, #0x810]
+	ldr r2, =0x4160016C
+	str r2, [r0, #0x83c]
+	ldr r2, =0x013C016C
+	str r2, [r0, #0x840]
+	ldr r2, =0x46424446
+	str r2, [r0, #0x848]
+	ldr r2, =0x3A3C3C3A
+	str r2, [r0, #0x850]
+	ldr r2, =0x2492244A
+	str r2, [r0, #0x8c0]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	ldr r2, =0x0002002d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+	ldr r2, =0x676b52f3
+	str r2, [r0, #0x00c]
+	ldr r2, =0xb66d8b63
+	str r2, [r0, #0x010]
+	ldr r2, =0x01ff00db
+	str r2, [r0, #0x014]
+	ldr r2, =0x00011740
+	str r2, [r0, #0x018]
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x006b1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x0000007f
+	str r2, [r0, #0x040]
+	ldr r2, =0x85190000
+	str r2, [r0, #0x000]
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00068031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00022227
+	str r2, [r0, #0x818]
+	ldr r2, =0x0002556d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+
+.endm
+
+.macro imx6sx_19x19_lpddr2_arm2_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x618]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x5fc]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x32c]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x300]
+	str r1, [r0, #0x2fc]
+	str r1, [r0, #0x5f4]
+	str r1, [r0, #0x340]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x320]
+	str r1, [r0, #0x310]
+	str r1, [r0, #0x314]
+	ldr r1, =0x00000028
+	str r1, [r0, #0x614]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5f8]
+	ldr r1, =0x00003028
+	str r1, [r0, #0x330]
+	str r1, [r0, #0x334]
+	str r1, [r0, #0x338]
+	str r1, [r0, #0x33c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x608]
+	ldr r1, =0x00000028
+	str r1, [r0, #0x60c]
+	str r1, [r0, #0x610]
+	str r1, [r0, #0x61c]
+	str r1, [r0, #0x620]
+	str r1, [r0, #0x2ec]
+	str r1, [r0, #0x2f0]
+	str r1, [r0, #0x2f4]
+	str r1, [r0, #0x2f8]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	ldr r2, =0x1b4700c7
+	str r2, [r0, #0x85c]
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00380000
+	str r2, [r0, #0x890]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x51111111
+	str r2, [r0, #0x82c]
+	str r2, [r0, #0x830]
+	str r2, [r0, #0x834]
+	str r2, [r0, #0x838]
+
+	ldr r2, =0x42424244
+	str r2, [r0, #0x848]
+	ldr r2, =0x2E30322E
+	str r2, [r0, #0x850]
+	ldr r2, =0x2492244A
+	str r2, [r0, #0x8c0]
+	ldr r2, =0x20000000
+	str r2, [r0, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x840]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x33374133
+	str r2, [r0, #0x00c]
+	ldr r2, =0x00020024
+	str r2, [r0, #0x004]
+	ldr r2, =0x00100A42
+	str r2, [r0, #0x010]
+	ldr r2, =0x00000093
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001748
+	str r2, [r0, #0x018]
+	ldr r2, =0x0f9f26d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x0000020e
+	str r2, [r0, #0x030]
+	ldr r2, =0x00190778
+	str r2, [r0, #0x038]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x008]
+	ldr r2, =0x0000004f
+	str r2, [r0, #0x040]
+	ldr r2, =0xc3110000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x00008050
+	str r2, [r0, #0x01c]
+	ldr r2, =0x003f8030
+	str r2, [r0, #0x01c]
+	ldr r2, =0xff0a8030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x82018030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04028030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x01038030
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00008058
+	str r2, [r0, #0x01c]
+	ldr r2, =0x003f8038
+	str r2, [r0, #0x01c]
+	ldr r2, =0xff0a8038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x82018038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04028038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x01038038
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00001800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x818]
+	ldr r2, =0xa1310003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	str r1, [r0, #0x06c]
+	str r1, [r0, #0x070]
+	str r1, [r0, #0x074]
+	str r1, [r0, #0x078]
+	str r1, [r0, #0x07c]
+	str r1, [r0, #0x080]
+	str r1, [r0, #0x084]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+#if defined (CONFIG_LPDDR2)
+	imx6sx_19x19_lpddr2_arm2_ddr_setting
+#else
+	imx6sx_19x19_ddr3_arm2_ddr_setting
+#endif
+
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6sxsabreauto/imximage.cfg ebf_6ull_uboot/board/freescale/mx6sxsabreauto/imximage.cfg
--- u-boot-2016.03/board/freescale/mx6sxsabreauto/imximage.cfg	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sxsabreauto/imximage.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -1,7 +1,12 @@
 /*
- * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
  */
 
 #define __ASSEMBLY__
@@ -16,7 +21,22 @@
  * spi/sd/nand/onenand, qspi/nor
  */
 
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
 BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sxsabreauto/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
 
 /*
  * Device Configuration Data (DCD)
@@ -40,19 +60,20 @@
 DATA 4 0x020c4080 0xffffffff
 DATA 4 0x020c4084 0xffffffff
 
-/* IOMUX - DDR IO Type */
+/* IOMUX */
+/* DDR IO TYPE */
 DATA 4 0x020e0618 0x000c0000
 DATA 4 0x020e05fc 0x00000000
 
-/* Clock */
+/* CLOCK */
 DATA 4 0x020e032c 0x00000030
 
-/* Address */
+/* ADDRESS */
 DATA 4 0x020e0300 0x00000030
 DATA 4 0x020e02fc 0x00000030
 DATA 4 0x020e05f4 0x00000030
 
-/* Control */
+/* CONTROL */
 DATA 4 0x020e0340 0x00000030
 
 DATA 4 0x020e0320 0x00000000
@@ -60,14 +81,14 @@
 DATA 4 0x020e0314 0x00000030
 DATA 4 0x020e0614 0x00000030
 
-/* Data Strobe */
+/* DATA STROBE */
 DATA 4 0x020e05f8 0x00020000
 DATA 4 0x020e0330 0x00000030
 DATA 4 0x020e0334 0x00000030
 DATA 4 0x020e0338 0x00000030
 DATA 4 0x020e033c 0x00000030
 
-/* Data */
+/* DATA */
 DATA 4 0x020e0608 0x00020000
 DATA 4 0x020e060c 0x00000030
 DATA 4 0x020e0610 0x00000030
@@ -78,10 +99,10 @@
 DATA 4 0x020e02f4 0x00000030
 DATA 4 0x020e02f8 0x00000030
 
-/* Calibrations - ZQ */
+/* Calibrations */
+/* ZQ */
 DATA 4 0x021b0800 0xa1390003
-
-/* Write leveling */
+/* write leveling */
 DATA 4 0x021b080c 0x002C003D
 DATA 4 0x021b0810 0x00110046
 
@@ -101,10 +122,11 @@
 DATA 4 0x021b0824 0x33333333
 DATA 4 0x021b0828 0x33333333
 
-/* Complete calibration by forced measurement */
+/* Complete calibration by forced measurment */
 DATA 4 0x021b08b8 0x00000800
 
-/* MMDC init - DDR3, 64-bit mode, only MMDC0 is initiated */
+/* MMDC init */
+/* in DDR3, 64-bit mode, only MMDC0 is initiated */
 DATA 4 0x021b0004 0x0002002d
 DATA 4 0x021b0008 0x00333030
 DATA 4 0x021b000c 0x676b52f3
@@ -117,7 +139,8 @@
 DATA 4 0x021b0040 0x0000007f
 DATA 4 0x021b0000 0x85190000
 
-/* Initialize MT41K256M16HA-125 - MR2 */
+/* Initialize CS0: MT41K256M16HA-125 */
+/* MR2 */
 DATA 4 0x021b001c 0x04008032
 /* MR3 */
 DATA 4 0x021b001c 0x00008033
@@ -128,9 +151,11 @@
 /* DDR device ZQ calibration */
 DATA 4 0x021b001c 0x04008040
 
-/* Final DDR setup, before operation start */
+/* final DDR setup, before operation start */
 DATA 4 0x021b0020 0x00000800
 DATA 4 0x021b0818 0x00022227
 DATA 4 0x021b0004 0x0002556d
 DATA 4 0x021b0404 0x00011006
 DATA 4 0x021b001c 0x00000000
+
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6sxsabreauto/Makefile ebf_6ull_uboot/board/freescale/mx6sxsabreauto/Makefile
--- u-boot-2016.03/board/freescale/mx6sxsabreauto/Makefile	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sxsabreauto/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -1,6 +1,10 @@
-# (C) Copyright 2014 Freescale Semiconductor, Inc.
+# (C) Copyright 2014-2016 Freescale Semiconductor, Inc.
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
 obj-y  := mx6sxsabreauto.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6sxsabreauto/mx6sxsabreauto.c ebf_6ull_uboot/board/freescale/mx6sxsabreauto/mx6sxsabreauto.c
--- u-boot-2016.03/board/freescale/mx6sxsabreauto/mx6sxsabreauto.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sxsabreauto/mx6sxsabreauto.c	2021-04-16 14:42:16.960592524 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
  * Author: Ye Li <ye.li@nxp.com>
  *
@@ -30,6 +30,13 @@
 #include <usb.h>
 #include <usb/ehci-fsl.h>
 #include <pca953x.h>
+#include <asm/imx-common/video.h>
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -58,11 +65,21 @@
 
 #define I2C_PMIC	1
 
+#define BUTTON_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE | \
+	PAD_CTL_PUS_22K_UP | PAD_CTL_DSE_40ohm)
+
 #define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
 #define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
 			PAD_CTL_SRE_FAST)
 #define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
 
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
 /*Define for building port exp gpio, pin starts from 0*/
 #define PORTEXP_IO_NR(chip, pin) \
 	((chip << 5) + pin)
@@ -77,6 +94,8 @@
 
 #define CPU_PER_RST_B	PORTEXP_IO_NR(0x30, 4)
 #define STEER_ENET		PORTEXP_IO_NR(0x32, 2)
+#define LVDS_EN_PIN		PORTEXP_IO_NR(0x30, 7)
+
 
 static int port_exp_direction_output(unsigned gpio, int value)
 {
@@ -151,6 +170,23 @@
 	MX6_PAD_USB_H_STROBE__GPIO7_IO_11 | MUX_PAD_CTRL(NO_PAD_CTRL),
 };
 
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_ENET1_MDC__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_MDIO__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_RX_CTL__ENET1_RX_EN | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD0__ENET1_RX_DATA_0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD1__ENET1_RX_DATA_1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD2__ENET1_RX_DATA_2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD3__ENET1_RX_DATA_3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RXC__ENET1_RX_CLK | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_TX_CTL__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD0__ENET1_TX_DATA_0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD1__ENET1_TX_DATA_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD2__ENET1_TX_DATA_2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD3__ENET1_TX_DATA_3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
 static iomux_v3_cfg_t const fec2_pads[] = {
 	MX6_PAD_ENET1_MDC__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
 	MX6_PAD_ENET1_MDIO__ENET2_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
@@ -173,24 +209,32 @@
 	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
 }
 
-static int setup_fec(void)
+static int setup_fec(int fec_id)
 {
 	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
 
-	/* Use 125MHz anatop loopback REF_CLK1 for ENET2 */
-	clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC2_MASK, 0);
+	if (0 == fec_id)
+		/* Use 125M anatop REF_CLK1 for ENET1, clear gpr1[13], gpr1[17]*/
+		clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC1_MASK, 0);
+	else
+		/* Use 125M anatop REF_CLK1 for ENET2, clear gpr1[14], gpr1[18]*/
+		clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC2_MASK, 0);
 
-	return enable_fec_anatop_clock(1, ENET_125MHZ);
+	return enable_fec_anatop_clock(fec_id, ENET_125MHZ);
 }
 
 int board_eth_init(bd_t *bis)
 {
 	int ret;
 
-	imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));
-	setup_fec();
+	if (0 == CONFIG_FEC_ENET_DEV)
+		imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+	else
+		imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));
+
+	setup_fec(CONFIG_FEC_ENET_DEV);
 
-	ret = fecmxc_initialize_multi(bis, 1,
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
 		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
 	if (ret)
 		printf("FEC%d MXC: %s:failed\n", 1, __func__);
@@ -248,15 +292,82 @@
 
 int power_init_board(void)
 {
-	struct pmic *p;
-
-	p = pfuze_common_init(I2C_PMIC);
-	if (!p)
+	struct pmic *pfuze;
+	unsigned int reg;
+	int ret;
+	pfuze = pfuze_common_init(I2C_PMIC);
+	if (!pfuze)
 		return -ENODEV;
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	/* set SW1AB standby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE100_SW1ABC_SETP(9750);
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, reg);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, reg);
+
+	/* set SW1C standby volatage 1.10V */
+	pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE100_SW1ABC_SETP(11000);
+	pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, reg);
+
+	/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1CCONF, reg);
+
+	/* Enable power of VGEN5 3V3, needed for SD3 */
+	pmic_reg_read(pfuze, PFUZE100_VGEN5VOL, &reg);
+	reg &= ~LDO_VOL_MASK;
+	reg |= (LDOB_3_30V | (1 << LDO_EN));
+	pmic_reg_write(pfuze, PFUZE100_VGEN5VOL, reg);
 
 	return 0;
 }
 
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+
+	struct pmic *p = pmic_get("PFUZE100");
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		/* decrease VDDARM to 1.15V */
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(11500);
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		/* decrease VDDSOC to 1.15V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(11500);
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		set_anatop_bypass(1);
+
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+
 #ifdef CONFIG_USB_EHCI_MX6
 #define USB_OTHERREGS_OFFSET	0x800
 #define UCTRL_PWR_POL		(1 << 9)
@@ -264,7 +375,7 @@
 static iomux_v3_cfg_t const usb_otg_pads[] = {
 	/* OGT1 */
 	MX6_PAD_GPIO1_IO09__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
-	MX6_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
 	/* OTG2 */
 	MX6_PAD_GPIO1_IO12__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL)
 };
@@ -316,6 +427,20 @@
 #define USDHC3_RST_GPIO	IMX_GPIO_NR(2, 11)
 #define USDHC4_CD_GPIO	IMX_GPIO_NR(7, 11)
 
+int board_mmc_get_env_dev(int devno)
+{
+	/*
+	 * need subtract 2 to map to the mmc device id
+	 * see the comments in board_mmc_init function
+	 */
+	return devno - 2;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	return devno + 2;
+}
+
 int board_mmc_getcd(struct mmc *mmc)
 {
 	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
@@ -379,6 +504,105 @@
 	return 0;
 }
 
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lvds_ctrl_pads[] = {
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6_PAD_SD1_DATA1__GPIO6_IO_3 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD1_CLK__LCDIF1_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_ENABLE__LCDIF1_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_HSYNC__LCDIF1_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_VSYNC__LCDIF1_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA00__LCDIF1_DATA_0 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA01__LCDIF1_DATA_1 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA02__LCDIF1_DATA_2 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA03__LCDIF1_DATA_3 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA04__LCDIF1_DATA_4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA05__LCDIF1_DATA_5 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA06__LCDIF1_DATA_6 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA07__LCDIF1_DATA_7 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA08__LCDIF1_DATA_8 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA09__LCDIF1_DATA_9 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA10__LCDIF1_DATA_10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA11__LCDIF1_DATA_11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA12__LCDIF1_DATA_12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA13__LCDIF1_DATA_13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA14__LCDIF1_DATA_14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA15__LCDIF1_DATA_15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA16__LCDIF1_DATA_16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA17__LCDIF1_DATA_17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_RESET__GPIO3_IO_27 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void do_enable_lvds(struct display_info_t const *dev)
+{
+	enable_lcdif_clock(dev->bus);
+	enable_lvds_bridge(dev->bus);
+
+	imx_iomux_v3_setup_multiple_pads(lvds_ctrl_pads,
+							ARRAY_SIZE(lvds_ctrl_pads));
+
+	/* LVDS Enable pin */
+	port_exp_direction_output(LVDS_EN_PIN , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(6, 3) , 1);
+}
+
+void do_enable_parallel_lcd(struct display_info_t const *dev)
+{
+	enable_lcdif_clock(dev->bus);
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(3, 27) , 1);
+}
+
+struct display_info_t const displays[] = {{
+	.bus = LCDIF2_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 18,
+	.detect = NULL,
+	.enable	= do_enable_lvds,
+	.mode	= {
+		.name			= "Hannstar-XGA",
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus = MX6SX_LCDIF1_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 18,
+	.detect = NULL,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "Boundary-LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+#endif
+
 #ifdef CONFIG_FSL_QSPI
 
 #define QSPI_PAD_CTRL1	\
@@ -497,6 +721,13 @@
 	add_board_boot_modes(board_boot_modes);
 #endif
 
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	/* set WDOG_B to reset whole system */
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
 	return 0;
 }
 
@@ -506,3 +737,91 @@
 
 	return 0;
 }
+
+#ifdef CONFIG_FSL_FASTBOOT
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD4_BOOT:
+	case MMC4_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "nand");
+		if (!getenv("fbparts"))
+			setenv("fbparts", ANDROID_FASTBOOT_NAND_PARTS);
+		if (!getenv("bootcmd"))
+			setenv("bootcmd",
+				"nand read ${loadaddr} ${boot_nand_offset} "
+				"${boot_nand_size};boota ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+int check_recovery_cmd_file(void)
+{
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	return recovery_mode;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc0 recovery");
+		break;
+	case SD4_BOOT:
+	case MMC4_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc1 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"nand read ${loadaddr} ${recovery_nand_offset} "
+				"${recovery_nand_size};boota ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
+
diff -urN u-boot-2016.03/board/freescale/mx6sxsabreauto/plugin.S ebf_6ull_uboot/board/freescale/mx6sxsabreauto/plugin.S
--- u-boot-2016.03/board/freescale/mx6sxsabreauto/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sxsabreauto/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6sx_sabreauto_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x618]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x5fc]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x32c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x300]
+	str r1, [r0, #0x2fc]
+	str r1, [r0, #0x5f4]
+	str r1, [r0, #0x340]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x320]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x310]
+	str r1, [r0, #0x314]
+	str r1, [r0, #0x614]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5f8]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x330]
+	str r1, [r0, #0x334]
+	str r1, [r0, #0x338]
+	str r1, [r0, #0x33c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x608]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x60c]
+	str r1, [r0, #0x610]
+	str r1, [r0, #0x61c]
+	str r1, [r0, #0x620]
+	str r1, [r0, #0x2ec]
+	str r1, [r0, #0x2f0]
+	str r1, [r0, #0x2f4]
+	str r1, [r0, #0x2f8]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x002C003D
+	str r2, [r0, #0x80c]
+	ldr r2, =0x00110046
+	str r2, [r0, #0x810]
+	ldr r2, =0x4160016C
+	str r2, [r0, #0x83c]
+	ldr r2, =0x013C016C
+	str r2, [r0, #0x840]
+	ldr r2, =0x46424446
+	str r2, [r0, #0x848]
+	ldr r2, =0x3A3C3C3A
+	str r2, [r0, #0x850]
+	ldr r2, =0x2492244A
+	str r2, [r0, #0x8c0]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	ldr r2, =0x0002002d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+	ldr r2, =0x676b52f3
+	str r2, [r0, #0x00c]
+	ldr r2, =0xb66d8b63
+	str r2, [r0, #0x010]
+	ldr r2, =0x01ff00db
+	str r2, [r0, #0x014]
+	ldr r2, =0x00011740
+	str r2, [r0, #0x018]
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x006b1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x0000007f
+	str r2, [r0, #0x040]
+	ldr r2, =0x85190000
+	str r2, [r0, #0x000]
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00068031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00022227
+	str r2, [r0, #0x818]
+	ldr r2, =0x0002556d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+
+.endm
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	str r1, [r0, #0x06c]
+	str r1, [r0, #0x070]
+	str r1, [r0, #0x074]
+	str r1, [r0, #0x078]
+	str r1, [r0, #0x07c]
+	str r1, [r0, #0x080]
+	str r1, [r0, #0x084]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6sx_sabreauto_ddr_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6sxsabresd/imximage.cfg ebf_6ull_uboot/board/freescale/mx6sxsabresd/imximage.cfg
--- u-boot-2016.03/board/freescale/mx6sxsabresd/imximage.cfg	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sxsabresd/imximage.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -16,7 +16,20 @@
  * spi/sd/nand/onenand, qspi/nor
  */
 
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#else
 BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sxsabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
 
 /*
  * Device Configuration Data (DCD)
@@ -130,3 +143,4 @@
 DATA 4 0x021b0020 0x00000800
 DATA 4 0x021b0818 0x00011117
 DATA 4 0x021b001c 0x00000000
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6sxsabresd/Makefile ebf_6ull_uboot/board/freescale/mx6sxsabresd/Makefile
--- u-boot-2016.03/board/freescale/mx6sxsabresd/Makefile	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sxsabresd/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -1,6 +1,10 @@
-# (C) Copyright 2014 Freescale Semiconductor, Inc.
+# (C) Copyright 2014-2016 Freescale Semiconductor, Inc.
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
 obj-y  := mx6sxsabresd.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6sxsabresd/mx6sxsabresd.c ebf_6ull_uboot/board/freescale/mx6sxsabresd/mx6sxsabresd.c
--- u-boot-2016.03/board/freescale/mx6sxsabresd/mx6sxsabresd.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sxsabresd/mx6sxsabresd.c	2021-04-16 14:42:16.960592524 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
  * Author: Fabio Estevam <fabio.estevam@freescale.com>
  *
@@ -13,7 +13,9 @@
 #include <asm/arch/mx6-pins.h>
 #include <asm/arch/sys_proto.h>
 #include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
 #include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
 #include <asm/io.h>
 #include <asm/imx-common/mxc_i2c.h>
 #include <linux/sizes.h>
@@ -28,6 +30,19 @@
 #include "../common/pfuze.h"
 #include <usb.h>
 #include <usb/ehci-fsl.h>
+#include <asm/imx-common/video.h>
+
+#ifdef CONFIG_IMX_RDC
+#include <asm/imx-common/rdc-sema.h>
+#include <asm/arch/imx-rdc.h>
+#endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -62,6 +77,16 @@
 #define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
 	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
 
+#define BUTTON_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE | \
+	PAD_CTL_PUS_22K_UP | PAD_CTL_DSE_40ohm)
+
+#define WDOG_PAD_CTRL (PAD_CTL_PUE | PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
 int dram_init(void)
 {
 	gd->ram_size = PHYS_SDRAM_SIZE;
@@ -112,6 +137,23 @@
 	MX6_PAD_SD4_DATA7__GPIO6_IO_21 | MUX_PAD_CTRL(NO_PAD_CTRL),
 };
 
+static iomux_v3_cfg_t const usdhc4_emmc_pads[] = {
+	MX6_PAD_SD4_CLK__USDHC4_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_CMD__USDHC4_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA0__USDHC4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA1__USDHC4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA2__USDHC4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA3__USDHC4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA4__USDHC4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA5__USDHC4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA6__USDHC4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA7__USDHC4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_RESET_B__USDHC4_RESET_B | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const wdog_b_pad = {
+	MX6_PAD_GPIO1_IO13__GPIO1_IO_13 | MUX_PAD_CTRL(WDOG_PAD_CTRL),
+};
 static iomux_v3_cfg_t const fec1_pads[] = {
 	MX6_PAD_ENET1_MDC__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
 	MX6_PAD_ENET1_MDIO__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
@@ -129,6 +171,23 @@
 	MX6_PAD_RGMII1_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
 };
 
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX6_PAD_ENET1_MDC__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_MDIO__ENET2_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII2_RX_CTL__ENET2_RX_EN | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII2_RD0__ENET2_RX_DATA_0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII2_RD1__ENET2_RX_DATA_1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII2_RD2__ENET2_RX_DATA_2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII2_RD3__ENET2_RX_DATA_3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII2_RXC__ENET2_RX_CLK | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII2_TX_CTL__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII2_TD0__ENET2_TX_DATA_0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII2_TD1__ENET2_TX_DATA_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII2_TD2__ENET2_TX_DATA_2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII2_TD3__ENET2_TX_DATA_3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII2_TXC__ENET2_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
 static iomux_v3_cfg_t const peri_3v3_pads[] = {
 	MX6_PAD_QSPI1A_DATA0__GPIO4_IO_16 | MUX_PAD_CTRL(NO_PAD_CTRL),
 };
@@ -149,16 +208,20 @@
 	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
 }
 
-static int setup_fec(void)
+static int setup_fec(int fec_id)
 {
 	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
 	struct anatop_regs *anatop = (struct anatop_regs *)ANATOP_BASE_ADDR;
 	int reg, ret;
 
-	/* Use 125MHz anatop loopback REF_CLK1 for ENET1 */
-	clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC1_MASK, 0);
+	if (0 == fec_id)
+		/* Use 125M anatop loopback REF_CLK1 for ENET1, clear gpr1[13], gpr1[17]*/
+		clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC1_MASK, 0);
+	else
+		/* Use 125M anatop loopback REF_CLK1 for ENET2, clear gpr1[14], gpr1[18]*/
+		clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC2_MASK, 0);
 
-	ret = enable_fec_anatop_clock(0, ENET_125MHZ);
+	ret = enable_fec_anatop_clock(fec_id, ENET_125MHZ);
 	if (ret)
 		return ret;
 
@@ -182,8 +245,12 @@
 
 int board_eth_init(bd_t *bis)
 {
-	imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
-	setup_fec();
+	if (0 == CONFIG_FEC_ENET_DEV)
+		imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+	else
+		imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));
+
+	setup_fec(CONFIG_FEC_ENET_DEV);
 
 	return cpu_eth_init(bis);
 }
@@ -203,29 +270,119 @@
 	},
 };
 
+/* I2C2 */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_GPIO1_IO02__I2C2_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO02__GPIO1_IO_2 | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO1_IO03__I2C2_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO03__GPIO1_IO_3 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+
+
 int power_init_board(void)
 {
-	struct pmic *p;
+	struct pmic *pfuze;
 	unsigned int reg;
 	int ret;
 
-	p = pfuze_common_init(I2C_PMIC);
-	if (!p)
+	pfuze = pfuze_common_init(I2C_PMIC);
+	if (!pfuze)
 		return -ENODEV;
 
-	ret = pfuze_mode_init(p, APS_PFM);
+	ret = pfuze_mode_init(pfuze, APS_PFM);
 	if (ret < 0)
 		return ret;
 
+	/* set SW1AB standby volatage 1.10V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE100_SW1ABC_SETP(11000);
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, reg);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, reg);
+
+	/* set SW1C standby volatage 1.10V */
+	pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE100_SW1ABC_SETP(11000);
+	pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, reg);
+
+	/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1CCONF, reg);
+
 	/* Enable power of VGEN5 3V3, needed for SD3 */
-	pmic_reg_read(p, PFUZE100_VGEN5VOL, &reg);
+	pmic_reg_read(pfuze, PFUZE100_VGEN5VOL, &reg);
 	reg &= ~LDO_VOL_MASK;
 	reg |= (LDOB_3_30V | (1 << LDO_EN));
-	pmic_reg_write(p, PFUZE100_VGEN5VOL, reg);
+	pmic_reg_write(pfuze, PFUZE100_VGEN5VOL, reg);
 
 	return 0;
 }
 
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	int is_400M;
+	u32 vddarm;
+	struct pmic *p = pmic_get("PFUZE100");
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(12750);
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		/* decrease VDDSOC to 1.3V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(13000);
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE100_SW1ABC_SETP(10750);
+		else
+			vddarm = PFUZE100_SW1ABC_SETP(11750);
+
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= vddarm;
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(11750);
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+
+}
+#endif
+
 #ifdef CONFIG_USB_EHCI_MX6
 #define USB_OTHERREGS_OFFSET	0x800
 #define UCTRL_PWR_POL		(1 << 9)
@@ -233,7 +390,7 @@
 static iomux_v3_cfg_t const usb_otg_pads[] = {
 	/* OGT1 */
 	MX6_PAD_GPIO1_IO09__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
-	MX6_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
 	/* OTG2 */
 	MX6_PAD_GPIO1_IO12__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL)
 };
@@ -288,28 +445,35 @@
 	return 0;
 }
 
+#ifdef CONFIG_IMX_RDC
+static rdc_peri_cfg_t const shared_resources[] = {
+	(RDC_PER_GPIO1 | RDC_DOMAIN(0) | RDC_DOMAIN(1)),
+};
+#endif
+
 int board_early_init_f(void)
 {
-	setup_iomux_uart();
-
-	/* Enable PERI_3V3, which is used by SD2, ENET, LVDS, BT */
-	imx_iomux_v3_setup_multiple_pads(peri_3v3_pads,
-					 ARRAY_SIZE(peri_3v3_pads));
-
-	/* Active high for ncp692 */
-	gpio_direction_output(IMX_GPIO_NR(4, 16) , 1);
+#ifdef CONFIG_IMX_RDC
+	imx_rdc_setup_peripherals(shared_resources, ARRAY_SIZE(shared_resources));
+#endif
 
-#ifdef CONFIG_USB_EHCI_MX6
-	setup_usb();
+#ifdef CONFIG_SYS_AUXCORE_FASTUP
+	arch_auxiliary_core_up(0, CONFIG_SYS_AUXCORE_BOOTDATA);
 #endif
 
+	setup_iomux_uart();
+
 	return 0;
 }
 
 static struct fsl_esdhc_cfg usdhc_cfg[3] = {
 	{USDHC2_BASE_ADDR, 0, 4},
 	{USDHC3_BASE_ADDR},
+#ifdef CONFIG_MX6SXSABRESD_EMMC_REWORK
+	{USDHC4_BASE_ADDR, 0, 8},
+#else
 	{USDHC4_BASE_ADDR},
+#endif
 };
 
 #define USDHC3_CD_GPIO	IMX_GPIO_NR(2, 10)
@@ -321,6 +485,11 @@
 	return devno - 1;
 }
 
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no + 1;
+}
+
 int board_mmc_getcd(struct mmc *mmc)
 {
 	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
@@ -334,7 +503,11 @@
 		ret = !gpio_get_value(USDHC3_CD_GPIO);
 		break;
 	case USDHC4_BASE_ADDR:
+#ifdef CONFIG_MX6SXSABRESD_EMMC_REWORK
+		ret = 1;
+#else
 		ret = !gpio_get_value(USDHC4_CD_GPIO);
+#endif
 		break;
 	}
 
@@ -368,9 +541,14 @@
 			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
 			break;
 		case 2:
+#ifdef CONFIG_MX6SXSABRESD_EMMC_REWORK
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_emmc_pads, ARRAY_SIZE(usdhc4_emmc_pads));
+#else
 			imx_iomux_v3_setup_multiple_pads(
 				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
 			gpio_direction_input(USDHC4_CD_GPIO);
+#endif
 			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
 			break;
 		default:
@@ -466,7 +644,25 @@
 }
 #endif
 
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd3", MAKE_CFGVAL(0x42, 0x30, 0x00, 0x00)},
+	{"sd4", MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{"qspi2", MAKE_CFGVAL(0x18, 0x00, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
 #ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lvds_ctrl_pads[] = {
+	/* CABC enable */
+	MX6_PAD_QSPI1A_DATA2__GPIO4_IO_18 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6_PAD_SD1_DATA1__GPIO6_IO_3 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
 static iomux_v3_cfg_t const lcd_pads[] = {
 	MX6_PAD_LCD1_CLK__LCDIF1_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
 	MX6_PAD_LCD1_ENABLE__LCDIF1_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
@@ -502,9 +698,41 @@
 	MX6_PAD_SD1_DATA2__GPIO6_IO_4 | MUX_PAD_CTRL(NO_PAD_CTRL),
 };
 
-static int setup_lcd(void)
+void do_enable_lvds(struct display_info_t const *dev)
+{
+	int ret;
+
+	ret = enable_lcdif_clock(dev->bus);
+	if (ret) {
+		printf("Enable LCDIF clock failed, %d\n", ret);
+		return;
+	}
+	ret = enable_lvds_bridge(dev->bus);
+	if (ret) {
+		printf("Enable LVDS bridge failed, %d\n", ret);
+		return;
+	}
+
+	imx_iomux_v3_setup_multiple_pads(lvds_ctrl_pads,
+							ARRAY_SIZE(lvds_ctrl_pads));
+
+	/* Enable CABC */
+	gpio_direction_output(IMX_GPIO_NR(4, 18) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(6, 3) , 1);
+}
+
+void do_enable_parallel_lcd(struct display_info_t const *dev)
+
 {
-	enable_lcdif_clock(LCDIF1_BASE_ADDR);
+	int ret;
+
+	ret = enable_lcdif_clock(dev->bus);
+	if (ret) {
+		printf("Enable LCDIF clock failed, %d\n", ret);
+		return;
+	}
 
 	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
 
@@ -515,9 +743,48 @@
 
 	/* Set Brightness to high */
 	gpio_direction_output(IMX_GPIO_NR(6, 4) , 1);
-
-	return 0;
 }
+
+struct display_info_t const displays[] = {{
+	.bus = LCDIF2_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 18,
+	.detect = NULL,
+	.enable	= do_enable_lvds,
+	.mode	= {
+		.name			= "Hannstar-XGA",
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus = MX6SX_LCDIF1_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 24,
+	.detect = NULL,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
 #endif
 
 int board_init(void)
@@ -525,16 +792,46 @@
 	/* Address of boot parameters */
 	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
 
+	/*
+	 * Because kernel set WDOG_B mux before pad with the commone pinctrl
+	 * framwork now and wdog reset will be triggered once set WDOG_B mux
+	 * with default pad setting, we set pad setting here to workaround this.
+	 * Since imx_iomux_v3_setup_pad also set mux before pad setting, we set
+	 * as GPIO mux firstly here to workaround it.
+	 */
+	imx_iomux_v3_setup_pad(wdog_b_pad);
+
+	/* Enable PERI_3V3, which is used by SD2, ENET, LVDS, BT */
+	imx_iomux_v3_setup_multiple_pads(peri_3v3_pads,
+					 ARRAY_SIZE(peri_3v3_pads));
+
+	/* Active high for ncp692 */
+	gpio_direction_output(IMX_GPIO_NR(4, 16) , 1);
+
 #ifdef CONFIG_SYS_I2C_MXC
 	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
 #endif
 
 #ifdef CONFIG_FSL_QSPI
 	board_qspi_init();
 #endif
 
-#ifdef CONFIG_VIDEO_MXS
-	setup_lcd();
+	return 0;
+}
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
 #endif
 
 	return 0;
@@ -547,6 +844,102 @@
 	return 0;
 }
 
+#ifdef CONFIG_FSL_FASTBOOT
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+	case SD4_BOOT:
+	case MMC4_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc2");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc2");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(1, 19)
+iomux_v3_cfg_t const recovery_key_pads[] = {
+	(MX6_PAD_CSI_DATA05__GPIO1_IO_19 | MUX_PAD_CTRL(BUTTON_PAD_CTRL)),
+};
+
+int check_recovery_cmd_file(void)
+{
+	int button_pressed = 0;
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	/* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
+		ARRAY_SIZE(recovery_key_pads));
+
+	gpio_direction_input(GPIO_VOL_DN_KEY);
+
+	if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN key is low assert */
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+	}
+
+	return recovery_mode || button_pressed;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc0 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc1 recovery");
+		break;
+	case SD4_BOOT:
+	case MMC4_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc2 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
+
 #ifdef CONFIG_SPL_BUILD
 #include <libfdt.h>
 #include <spl.h>
diff -urN u-boot-2016.03/board/freescale/mx6sxsabresd/plugin.S ebf_6ull_uboot/board/freescale/mx6sxsabresd/plugin.S
--- u-boot-2016.03/board/freescale/mx6sxsabresd/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sxsabresd/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6sx_sabresd_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x618]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x5fc]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x32c]
+
+	ldr r1, =0x00000020
+	str r1, [r0, #0x300]
+	str r1, [r0, #0x2fc]
+	str r1, [r0, #0x5f4]
+	str r1, [r0, #0x340]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x320]
+	ldr r1, =0x00000020
+	str r1, [r0, #0x310]
+	str r1, [r0, #0x314]
+	str r1, [r0, #0x614]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5f8]
+	ldr r1, =0x00000028
+	str r1, [r0, #0x330]
+	str r1, [r0, #0x334]
+	str r1, [r0, #0x338]
+	str r1, [r0, #0x33c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x608]
+	ldr r1, =0x00000028
+	str r1, [r0, #0x60c]
+	str r1, [r0, #0x610]
+	str r1, [r0, #0x61c]
+	str r1, [r0, #0x620]
+	str r1, [r0, #0x2ec]
+	str r1, [r0, #0x2f0]
+	str r1, [r0, #0x2f4]
+	str r1, [r0, #0x2f8]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00290025
+	str r2, [r0, #0x80c]
+	ldr r2, =0x00220022
+	str r2, [r0, #0x810]
+	ldr r2, =0x41480144
+	str r2, [r0, #0x83c]
+	ldr r2, =0x01340130
+	str r2, [r0, #0x840]
+	ldr r2, =0x3C3E4244
+	str r2, [r0, #0x848]
+	ldr r2, =0x34363638
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	ldr r2, =0x0002002d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+	ldr r2, =0x676b52f3
+	str r2, [r0, #0x00c]
+	ldr r2, =0xb66d8b63
+	str r2, [r0, #0x010]
+	ldr r2, =0x01ff00db
+	str r2, [r0, #0x014]
+	ldr r2, =0x00011740
+	str r2, [r0, #0x018]
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x006b1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x0000005f
+	str r2, [r0, #0x040]
+	ldr r2, =0x84190000
+	str r2, [r0, #0x000]
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	str r1, [r0, #0x06c]
+	str r1, [r0, #0x070]
+	str r1, [r0, #0x074]
+	str r1, [r0, #0x078]
+	str r1, [r0, #0x07c]
+	str r1, [r0, #0x080]
+	str r1, [r0, #0x084]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6sx_sabresd_ddr_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6sxscm/imximage_lpddr2.cfg ebf_6ull_uboot/board/freescale/mx6sxscm/imximage_lpddr2.cfg
--- u-boot-2016.03/board/freescale/mx6sxscm/imximage_lpddr2.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sxscm/imximage_lpddr2.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM       qspi
+#else
+BOOT_FROM       sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sxscm/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+DATA 4 0x020e0618 0x00080000
+DATA 4 0x020e05fc 0x00000000
+DATA 4 0x020e032c 0x00000030
+
+DATA 4 0x020e0300 0x00000028
+DATA 4 0x020e02fc 0x00000028
+DATA 4 0x020e05f4 0x00000028
+DATA 4 0x020e0340 0x00000028
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000000
+DATA 4 0x020e0314 0x00000000
+DATA 4 0x020e0614 0x00000028
+
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00003028
+DATA 4 0x020e0334 0x00003028
+DATA 4 0x020e0338 0x00003028
+DATA 4 0x020e033c 0x00003028
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000028
+DATA 4 0x020e0610 0x00000028
+DATA 4 0x020e061c 0x00000028
+DATA 4 0x020e0620 0x00000028
+DATA 4 0x020e02ec 0x00000028
+DATA 4 0x020e02f0 0x00000028
+DATA 4 0x020e02f4 0x00000028
+DATA 4 0x020e02f8 0x00000028
+
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b085c 0x1b4700c7
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b0890 0x00380000
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b082c 0x51111111
+DATA 4 0x021b0830 0x51111111
+DATA 4 0x021b0834 0x51111111
+DATA 4 0x021b0838 0x51111111
+DATA 4 0x021b0848 0x4244464A
+DATA 4 0x021b0850 0x36343A34
+DATA 4 0x021b08c0 0x2492244A
+DATA 4 0x021b083c 0x20000000
+DATA 4 0x021b0840 0x00000000
+DATA 4 0x021b08b8 0x00000800
+
+DATA 4 0x021b000c 0x33374133
+DATA 4 0x021b0004 0x00020024
+DATA 4 0x021b0010 0x00100A42
+DATA 4 0x021b0014 0x00000093
+DATA 4 0x021b0018 0x00001748
+DATA 4 0x021b002c 0x0f9f26d2
+DATA 4 0x021b0030 0x0000020e
+DATA 4 0x021b0038 0x00190778
+DATA 4 0x021b0008 0x00000000
+DATA 4 0x021b0040 0x0000004f
+#ifdef CONFIG_512MB_LPDDR2
+DATA 4 0x021b0000 0x83110000
+#else
+DATA 4 0x021b0000 0xc3110000
+#endif
+
+DATA 4 0x021b001c 0x003f8030
+DATA 4 0x021b001c 0xff0a8030
+DATA 4 0x021b001c 0x82018030
+DATA 4 0x021b001c 0x04028030
+DATA 4 0x021b001c 0x01038030
+
+DATA 4 0x021b001c 0x003f8038
+DATA 4 0x021b001c 0xff0a8038
+DATA 4 0x021b001c 0x82018038
+DATA 4 0x021b001c 0x04028038
+DATA 4 0x021b001c 0x01038038
+
+DATA 4 0x021b0020 0x00001800
+DATA 4 0x021b0818 0x00000000
+DATA 4 0x021b0800 0xa1310003
+DATA 4 0x021b0004 0x00025576
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
+
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6sxscm/Kconfig ebf_6ull_uboot/board/freescale/mx6sxscm/Kconfig
--- u-boot-2016.03/board/freescale/mx6sxscm/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sxscm/Kconfig	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,12 @@
+if TARGET_MX6SXSCM
+
+config SYS_BOARD
+	default "mx6sxscm"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_CONFIG_NAME
+	default "mx6sxscm"
+
+endif
diff -urN u-boot-2016.03/board/freescale/mx6sxscm/MAINTAINERS ebf_6ull_uboot/board/freescale/mx6sxscm/MAINTAINERS
--- u-boot-2016.03/board/freescale/mx6sxscm/MAINTAINERS	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sxscm/MAINTAINERS	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,10 @@
+MX6SXSCM BOARD
+M:	Alejandro Sierra <alejandro.sierra@nxp.com>
+M:	Juan Gutierrez <juan gutierrez@nxp.com>
+S:	Maintained
+F:	board/freescale/mx6sxscm/
+F:	include/configs/mx6sxscm.h
+F:	configs/mx6sxscm_1gb_evb_defconfig
+F:	configs/mx6sxscm_1gb_evb_m4fastup_defconfig
+F:	configs/mx6sxscm_1gb_evb_qspi2_defconfig
+F:	configs/mx6sxscm_epop_evb_defconfig
diff -urN u-boot-2016.03/board/freescale/mx6sxscm/Makefile ebf_6ull_uboot/board/freescale/mx6sxscm/Makefile
--- u-boot-2016.03/board/freescale/mx6sxscm/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sxscm/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,10 @@
+# (C) Copyright 2016 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6sxscm.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6sxscm/mx6sxscm.c ebf_6ull_uboot/board/freescale/mx6sxscm/mx6sxscm.c
--- u-boot-2016.03/board/freescale/mx6sxscm/mx6sxscm.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sxscm/mx6sxscm.c	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,927 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/io.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include "../common/pfuze.h"
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+#include <asm/imx-common/video.h>
+#include <micrel.h>
+
+#ifdef CONFIG_IMX_RDC
+#include <asm/imx-common/rdc-sema.h>
+#include <asm/arch/imx-rdc.h>
+#endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+DECLARE_GLOBAL_DATA_PTR;
+#define I2C_PMIC 1
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_HIGH   |                                   \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_120ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define BUTTON_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE | \
+	PAD_CTL_PUS_22K_UP | PAD_CTL_DSE_40ohm)
+
+#define WDOG_PAD_CTRL (PAD_CTL_PUE | PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart3_pads[] = {
+	MX6_PAD_QSPI1B_SS0_B__UART3_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_QSPI1B_SCLK__UART3_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_SD2_CLK__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_CMD__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA0__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA1__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA2__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA3__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6_PAD_SD3_CLK__USDHC3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_CMD__USDHC3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA0__USDHC3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA1__USDHC3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA2__USDHC3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA3__USDHC3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA4__USDHC3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA5__USDHC3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA6__USDHC3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA7__USDHC3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* CD pin */
+	MX6_PAD_KEY_COL0__GPIO2_IO_10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* RST_B, used for power reset cycle */
+	MX6_PAD_KEY_COL1__GPIO2_IO_11 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc4_pads[] = {
+	MX6_PAD_SD4_CLK__USDHC4_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_CMD__USDHC4_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA0__USDHC4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA1__USDHC4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA2__USDHC4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA3__USDHC4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA7__GPIO6_IO_21 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc4_emmc_pads[] = {
+	MX6_PAD_SD4_CLK__USDHC4_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_CMD__USDHC4_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA0__USDHC4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA1__USDHC4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA2__USDHC4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA3__USDHC4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA4__USDHC4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA5__USDHC4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA6__USDHC4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA7__USDHC4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_RESET_B__USDHC4_RESET_B | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const wdog_b_pad = {
+	MX6_PAD_GPIO1_IO13__GPIO1_IO_13 | MUX_PAD_CTRL(WDOG_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_GPIO1_IO04__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO1_IO05__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_RX_CTL__ENET1_RX_EN | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD0__ENET1_RX_DATA_0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD1__ENET1_RX_DATA_1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD2__ENET1_RX_DATA_2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD3__ENET1_RX_DATA_3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RXC__ENET1_RX_CLK | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_TX_CTL__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD0__ENET1_TX_DATA_0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD1__ENET1_TX_DATA_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD2__ENET1_TX_DATA_2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD3__ENET1_TX_DATA_3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const peri_3v3_pads[] = {
+	MX6_PAD_QSPI1A_DATA0__GPIO4_IO_16 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+static iomux_v3_cfg_t const phy_control_pads[] = {
+	/* 25MHz Ethernet PHY Clock */
+	MX6_PAD_ENET2_RX_CLK__ENET2_REF_CLK_25M |
+	MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+
+	/* ENET PHY Power */
+	MX6_PAD_QSPI1B_DATA1__GPIO4_IO_25 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* AR8031 PHY Reset */
+	MX6_PAD_QSPI1B_DATA2__GPIO4_IO_26 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart3_pads, ARRAY_SIZE(uart3_pads));
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	struct anatop_regs *anatop = (struct anatop_regs *)ANATOP_BASE_ADDR;
+	int reg, ret;
+
+	/* Use 125M anatop loopback REF_CLK1 for ENET1,
+	 * clear gpr1[13], gpr1[17] */
+	clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC1_MASK, 0);
+
+	ret = enable_fec_anatop_clock(fec_id, ENET_125MHZ);
+	if (ret)
+		return ret;
+
+	imx_iomux_v3_setup_multiple_pads(phy_control_pads,
+					 ARRAY_SIZE(phy_control_pads));
+
+	/* Enable the ENET power, active low */
+	gpio_direction_output(IMX_GPIO_NR(4, 25) , 0);
+
+	/* Reset AR8031 PHY */
+	gpio_direction_output(IMX_GPIO_NR(4, 26) , 0);
+	mdelay(10);
+	gpio_set_value(IMX_GPIO_NR(4, 26), 1);
+
+	reg = readl(&anatop->pll_enet);
+	reg |= BM_ANADIG_PLL_ENET_REF_25M_ENABLE;
+	writel(reg, &anatop->pll_enet);
+
+	return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	imx_iomux_v3_setup_multiple_pads(fec1_pads,
+					 ARRAY_SIZE(fec1_pads));
+
+	setup_fec(CONFIG_FEC_ENET_DEV);
+
+	return cpu_eth_init(bis);
+}
+
+int mx6_rgmii_rework(struct phy_device *phydev)
+{
+	/* add necessary delays for RGMII,
+	 * there are no board skew delays added
+	 * additional rx data delay = 0, rx clk delay = 0.3ns, total = 1.5ns
+	 * additional tx data delay = -0.42ns, tx clk delay = 0.96ns,
+	 * total = 1.38ns
+	 */
+
+	if (ksz9031_phy_extended_write(phydev, 0x2,
+				       MII_KSZ9031_EXT_RGMII_CTRL_SIG_SKEW,
+				       MII_KSZ9031_MOD_DATA_NO_POST_INC,
+				       0x0070))
+		return -EIO;
+
+	if (ksz9031_phy_extended_write(phydev, 0x2,
+				       MII_KSZ9031_EXT_RGMII_RX_DATA_SKEW,
+				       MII_KSZ9031_MOD_DATA_NO_POST_INC,
+				       0x7777))
+		return -EIO;
+
+	if (ksz9031_phy_extended_write(phydev, 0x2,
+				       MII_KSZ9031_EXT_RGMII_TX_DATA_SKEW,
+				       MII_KSZ9031_MOD_DATA_NO_POST_INC,
+				       0x0000))
+		return -EIO;
+
+	if (ksz9031_phy_extended_write(phydev, 0x2,
+				       MII_KSZ9031_EXT_RGMII_CLOCK_SKEW,
+				       MII_KSZ9031_MOD_DATA_NO_POST_INC,
+				       0x03f4))
+		return -EIO;
+
+	return 0;
+}
+
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+static struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_GPIO1_IO00__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO00__GPIO1_IO_0 | PC,
+		.gp = IMX_GPIO_NR(1, 0),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO1_IO01__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO01__GPIO1_IO_1 | PC,
+		.gp = IMX_GPIO_NR(1, 1),
+	},
+};
+
+/* I2C2 */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_GPIO1_IO02__I2C2_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO02__GPIO1_IO_2 | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO1_IO03__I2C2_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO03__GPIO1_IO_3 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+
+/* I2C4 */
+struct i2c_pads_info i2c_pad_info4 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_CSI_DATA06__I2C4_SCL | PC,
+		.gpio_mode = MX6_PAD_CSI_DATA06__GPIO1_IO_20 | PC,
+		.gp = IMX_GPIO_NR(1, 20),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_CSI_DATA07__I2C4_SDA | PC,
+		.gpio_mode = MX6_PAD_CSI_DATA07__GPIO1_IO_21 | PC,
+		.gp = IMX_GPIO_NR(1, 21),
+	},
+};
+
+int power_init_board(void)
+{
+	struct pmic *pfuze;
+	unsigned int reg;
+	int ret;
+
+	pfuze = pfuze_common_init(I2C_PMIC);
+	if (!pfuze)
+		return -ENODEV;
+
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+	/* set SW3A to 1.2V for LPDDR2 */
+	pmic_reg_read(pfuze, PFUZE100_SW3AVOL, &reg);
+	reg &= ~0x3f;
+	reg |= 0x20;
+	pmic_reg_write(pfuze, PFUZE100_SW3AVOL, reg);
+
+	/* set SW3A standby volatage 1.2V */
+	pmic_reg_read(pfuze, PFUZE100_SW3ASTBY, &reg);
+	reg &= ~0x3f;
+	reg |= 0x20;
+	pmic_reg_write(pfuze, PFUZE100_SW3ASTBY, reg);
+
+	/* set SW1AB normal volatage 1.350V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABVOL, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE100_SW1ABC_SETP(13500);
+	pmic_reg_write(pfuze, PFUZE100_SW1ABVOL, reg);
+
+	/* set SW1AB standby volatage 1.10V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE100_SW1ABC_SETP(11000);
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, reg);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, reg);
+
+	pmic_reg_read(pfuze, PFUZE100_VGEN3VOL, &reg);
+	reg &= ~LDO_VOL_MASK;
+	reg |= (LDOB_2_80V | (1 << LDO_EN));
+	pmic_reg_write(pfuze, PFUZE100_VGEN3VOL, reg);
+
+	/* set SWBST boost regulator mode */
+	pmic_reg_read(pfuze, PFUZE100_SWBSTCON1, &reg);
+	reg &= ~SWBST_MODE_MASK;
+	reg |= SWBST_MODE_AUTO << SWBST_MODE_SHIFT;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SWBSTCON1, reg);
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	int is_400M;
+	u32 vddarm;
+	struct pmic *p = pmic_get("PFUZE100");
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(12750);
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		/* decrease VDDSOC to 1.3V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(13000);
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE100_SW1ABC_SETP(10750);
+		else
+			vddarm = PFUZE100_SW1ABC_SETP(11750);
+
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= vddarm;
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(11750);
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+static iomux_v3_cfg_t const usb_otg_pads[] = {
+	/* OGT1 */
+	MX6_PAD_GPIO1_IO09__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+	/* OTG2 */
+	MX6_PAD_GPIO1_IO12__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL)
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+					 ARRAY_SIZE(usb_otg_pads));
+}
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
+
+int board_phy_config(struct phy_device *phydev)
+{
+	mx6_rgmii_rework(phydev);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+int board_early_init_f(void)
+{
+#ifdef CONFIG_IMX_RDC
+	imx_rdc_setup_peripherals(shared_resources,
+				  ARRAY_SIZE(shared_resources));
+#endif
+
+#ifdef CONFIG_SYS_AUXCORE_FASTUP
+	arch_auxiliary_core_up(0, CONFIG_SYS_AUXCORE_BOOTDATA);
+#endif
+
+	setup_iomux_uart();
+
+	return 0;
+}
+
+static struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC2_BASE_ADDR, 0, 4},
+	{USDHC3_BASE_ADDR},
+#ifdef CONFIG_MX6SXSCM_EMMC
+	{USDHC4_BASE_ADDR, 0, 8},
+#else
+	{USDHC4_BASE_ADDR},
+#endif
+};
+
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(2, 10)
+#define USDHC3_PWR_GPIO	IMX_GPIO_NR(2, 11)
+#define USDHC4_CD_GPIO	IMX_GPIO_NR(6, 21)
+
+int board_mmc_get_env_dev(int devno)
+{
+	return devno - 1;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no + 1;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC2_BASE_ADDR:
+		ret = 1; /* Assume uSDHC2 is always present */
+		break;
+	case USDHC3_BASE_ADDR:
+	ret = 1; /* Assume uSDHC3 is always present */
+		break;
+	case USDHC4_BASE_ADDR:
+#ifdef CONFIG_MX6SXSCM_EMMC
+		ret = 1;
+#else
+		ret = !gpio_get_value(USDHC4_CD_GPIO);
+#endif
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i, ret;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    USDHC2
+	 * mmc1                    USDHC3
+	 * mmc2                    USDHC4
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			gpio_direction_output(USDHC3_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		case 2:
+#ifdef CONFIG_MX6SXSCM_EMMC
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_emmc_pads, ARRAY_SIZE(usdhc4_emmc_pads));
+#else
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+			gpio_direction_input(USDHC4_CD_GPIO);
+#endif
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more ");
+			printf("USDHC controllers ");
+			printf("(%d) than supported by the board\n", i + 1);
+			return -EINVAL;
+		}
+
+		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+		if (ret) {
+			printf("Warning: failed to initialize mmc dev %d\n", i);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_FSL_QSPI
+
+#define QSPI_PAD_CTRL1	\
+	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_HIGH | \
+	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_40ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6_PAD_NAND_WP_B__QSPI2_A_DATA_0	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_READY_B__QSPI2_A_DATA_1	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE0_B__QSPI2_A_DATA_2	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE1_B__QSPI2_A_DATA_3	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_ALE__QSPI2_A_SS0_B		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CLE__QSPI2_A_SCLK		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA01__QSPI2_B_DATA_0	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA00__QSPI2_B_DATA_1	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_WE_B__QSPI2_B_DATA_2	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_RE_B__QSPI2_B_DATA_3	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA03__QSPI2_B_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA02__QSPI2_B_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA05__QSPI2_B_DQS	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads,
+					 ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(1);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd3", MAKE_CFGVAL(0x42, 0x30, 0x00, 0x00)},
+	{"sd4", MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{"qspi2", MAKE_CFGVAL(0x18, 0x00, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lvds_ctrl_pads[] = {
+	/* CABC enable */
+	MX6_PAD_QSPI1A_DATA2__GPIO4_IO_18 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6_PAD_NAND_DATA07__GPIO4_IO_11 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD1_CLK__LCDIF1_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_ENABLE__LCDIF1_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_HSYNC__LCDIF1_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_VSYNC__LCDIF1_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA00__LCDIF1_DATA_0 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA01__LCDIF1_DATA_1 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA02__LCDIF1_DATA_2 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA03__LCDIF1_DATA_3 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA04__LCDIF1_DATA_4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA05__LCDIF1_DATA_5 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA06__LCDIF1_DATA_6 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA07__LCDIF1_DATA_7 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA08__LCDIF1_DATA_8 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA09__LCDIF1_DATA_9 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA10__LCDIF1_DATA_10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA11__LCDIF1_DATA_11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA12__LCDIF1_DATA_12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA13__LCDIF1_DATA_13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA14__LCDIF1_DATA_14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA15__LCDIF1_DATA_15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA16__LCDIF1_DATA_16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA17__LCDIF1_DATA_17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA18__LCDIF1_DATA_18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA19__LCDIF1_DATA_19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA20__LCDIF1_DATA_20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA21__LCDIF1_DATA_21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA22__LCDIF1_DATA_22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA23__LCDIF1_DATA_23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_RESET__GPIO3_IO_27 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6_PAD_NAND_DATA06__GPIO4_IO_10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void do_enable_lvds(struct display_info_t const *dev)
+{
+	int ret;
+
+	ret = enable_lcdif_clock(dev->bus);
+	if (ret) {
+		printf("Enable LCDIF clock failed, %d\n", ret);
+		return;
+	}
+	ret = enable_lvds_bridge(dev->bus);
+	if (ret) {
+		printf("Enable LVDS bridge failed, %d\n", ret);
+		return;
+	}
+
+	imx_iomux_v3_setup_multiple_pads(lvds_ctrl_pads,
+					 ARRAY_SIZE(lvds_ctrl_pads));
+
+	/* Enable CABC */
+	gpio_direction_output(IMX_GPIO_NR(4, 18) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(4, 11) , 1);
+}
+
+void do_enable_parallel_lcd(struct display_info_t const *dev)
+
+{
+	int ret;
+
+	ret = enable_lcdif_clock(dev->bus);
+	if (ret) {
+		printf("Enable LCDIF clock failed, %d\n", ret);
+		return;
+	}
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Reset the LCD */
+	gpio_direction_output(IMX_GPIO_NR(3, 27) , 0);
+	udelay(500);
+	gpio_direction_output(IMX_GPIO_NR(3, 27) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(4, 10) , 1);
+}
+
+struct display_info_t const displays[] = {{
+	.bus = LCDIF2_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 18,
+	.detect = NULL,
+	.enable	= do_enable_lvds,
+	.mode	= {
+		.name			= "Hannstar-XGA",
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus = MX6SX_LCDIF1_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 24,
+	.detect = NULL,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+#endif
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	/*
+	 * Because kernel set WDOG_B mux before pad with the commone pinctrl
+	 * framwork now and wdog reset will be triggered once set WDOG_B mux
+	 * with default pad setting, we set pad setting here to workaround this.
+	 * Since imx_iomux_v3_setup_pad also set mux before pad setting, we set
+	 * as GPIO mux firstly here to workaround it.
+	 */
+	imx_iomux_v3_setup_pad(wdog_b_pad);
+
+	/* Enable PERI_3V3, which is used by SD2, ENET, LVDS, BT */
+	imx_iomux_v3_setup_multiple_pads(peri_3v3_pads,
+					 ARRAY_SIZE(peri_3v3_pads));
+
+	/* Active high for ncp692 */
+	gpio_direction_output(IMX_GPIO_NR(4, 16) , 1);
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+	setup_i2c(3, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info4);
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	board_qspi_init();
+#endif
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: MX6SXSCM EVB\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_FSL_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+	case SD4_BOOT:
+	case MMC4_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc2");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc2");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(1, 19)
+iomux_v3_cfg_t const recovery_key_pads[] = {
+	(MX6_PAD_CSI_DATA05__GPIO1_IO_19 | MUX_PAD_CTRL(BUTTON_PAD_CTRL)),
+};
+
+int check_recovery_cmd_file(void)
+{
+	int button_pressed = 0;
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	/* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
+					 ARRAY_SIZE(recovery_key_pads));
+
+	gpio_direction_input(GPIO_VOL_DN_KEY);
+
+	/* VOL_DN key is low assert */
+	if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) {
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+	}
+
+	return recovery_mode || button_pressed;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+			       "boota mmc0 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+			       "boota mmc1 recovery");
+		break;
+	case SD4_BOOT:
+	case MMC4_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+			       "boota mmc2 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+		       bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
diff -urN u-boot-2016.03/board/freescale/mx6sxscm/plugin.S ebf_6ull_uboot/board/freescale/mx6sxscm/plugin.S
--- u-boot-2016.03/board/freescale/mx6sxscm/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sxscm/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6sxscm_lpddr2_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x618]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x5fc]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x32c]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x300]
+	str r1, [r0, #0x2fc]
+	str r1, [r0, #0x5f4]
+	str r1, [r0, #0x340]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x320]
+	str r1, [r0, #0x310]
+	str r1, [r0, #0x314]
+	ldr r1, =0x00000028
+	str r1, [r0, #0x614]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5f8]
+	ldr r1, =0x00003028
+	str r1, [r0, #0x330]
+	str r1, [r0, #0x334]
+	str r1, [r0, #0x338]
+	str r1, [r0, #0x33c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x608]
+	ldr r1, =0x00000028
+	str r1, [r0, #0x60c]
+	str r1, [r0, #0x610]
+	str r1, [r0, #0x61c]
+	str r1, [r0, #0x620]
+	str r1, [r0, #0x2ec]
+	str r1, [r0, #0x2f0]
+	str r1, [r0, #0x2f4]
+	str r1, [r0, #0x2f8]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	ldr r2, =0x1b4700c7
+	str r2, [r0, #0x85c]
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00380000
+	str r2, [r0, #0x890]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x51111111
+	str r2, [r0, #0x82c]
+	str r2, [r0, #0x830]
+	str r2, [r0, #0x834]
+	str r2, [r0, #0x838]
+
+	ldr r2, =0x42424244
+	str r2, [r0, #0x848]
+	ldr r2, =0x36343A34
+	str r2, [r0, #0x850]
+	ldr r2, =0x2492244A
+	str r2, [r0, #0x8c0]
+	ldr r2, =0x20000000
+	str r2, [r0, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x840]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x33374133
+	str r2, [r0, #0x00c]
+	ldr r2, =0x00020024
+	str r2, [r0, #0x004]
+	ldr r2, =0x00100A42
+	str r2, [r0, #0x010]
+	ldr r2, =0x00000093
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001748
+	str r2, [r0, #0x018]
+	ldr r2, =0x0f9f26d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x0000020e
+	str r2, [r0, #0x030]
+	ldr r2, =0x00190778
+	str r2, [r0, #0x038]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x008]
+	ldr r2, =0x0000004f
+	str r2, [r0, #0x040]
+#ifdef CONFIG_512MB_LPDDR2
+	ldr r2, =0x83110000
+#else
+	ldr r2, =0xc3110000
+#endif
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x003f8030
+	str r2, [r0, #0x01c]
+	ldr r2, =0xff0a8030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x82018030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04028030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x01038030
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x003f8038
+	str r2, [r0, #0x01c]
+	ldr r2, =0xff0a8038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x82018038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04028038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x01038038
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00001800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x818]
+	ldr r2, =0xa1310003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	str r1, [r0, #0x06c]
+	str r1, [r0, #0x070]
+	str r1, [r0, #0x074]
+	str r1, [r0, #0x078]
+	str r1, [r0, #0x07c]
+	str r1, [r0, #0x080]
+	str r1, [r0, #0x084]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6sxscm_lpddr2_ddr_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6sxscm/README ebf_6ull_uboot/board/freescale/mx6sxscm/README
--- u-boot-2016.03/board/freescale/mx6sxscm/README	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6sxscm/README	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,47 @@
+How to use U-Boot on Freescale MX6SXSCM boards
+----------------------------------------------
+
+- Build U-Boot for MX6SXSCM EVB board*:
+
+$ make mx6sxscm_1gb_evb_defconfig
+$ make
+
+This will generate the u-boot image u-boot.imx.
+
+- Flash the u-boot image into the micro SD card:
+
+sudo dd if=u-boot.imx of=/dev/sdX bs=1k seek=1; sync
+
+*Other defconfigs availabe are:
+    mx6sxscm_1gb_evb_defconfig
+    mx6sxscm_1gb_evb_m4fastup_defconfig
+    mx6sxscm_1gb_evb_qspi2_defconfig
+
+- Jumper settings for fix mode images to boot from the top SD3:
+
+ SW2: OFF OFF OFF OFF OFF OFF OFF OFF
+ SW3: OFF OFF ON  ON  OFF OFF OFF OFF
+ SW4: OFF ON  OFF OFF OFF OFF ON  OFF
+
+
+Additional configurations
+==========================
+
+For custom configurations like 512MB or ePOP, the CONFIG_SYS_EXTRA_OPTIONS option on the defconfig
+file can be modified according to the customization needed.
+
+Here are some examples for some combinations among the different supported options:
+
+512mb evb
+---------
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxscm/imximage_lpddr2.cfg,MX6SX,512MB_LPDDR2"
+
+
+epop evb:
+---------
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxscm/imximage_lpddr2.cfg,MX6SX,512MB_LPDDR2,MX6SXSCM_EMMC"
+
+
+epop evb qspi2-boot:
+--------------------
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxscm/imximage_lpddr2.cfg,MX6SX,512MB_LPDDR2,MX6SXSCM_EMMC,SYS_BOOT_QSPI"
diff -urN u-boot-2016.03/board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg ebf_6ull_uboot/board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg
--- u-boot-2016.03/board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6ul_14x14_ddr3_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+DATA 4 0x020E04B4 0x000C0000
+DATA 4 0x020E04AC 0x00000000
+DATA 4 0x020E027C 0x00000030
+DATA 4 0x020E0250 0x00000030
+DATA 4 0x020E024C 0x00000030
+DATA 4 0x020E0490 0x00000030
+DATA 4 0x020E0288 0x00000030
+DATA 4 0x020E0270 0x00000000
+DATA 4 0x020E0260 0x00000030
+DATA 4 0x020E0264 0x00000030
+DATA 4 0x020E04A0 0x00000030
+DATA 4 0x020E0494 0x00020000
+DATA 4 0x020E0280 0x00000030
+DATA 4 0x020E0284 0x00000030
+DATA 4 0x020E04B0 0x00020000
+DATA 4 0x020E0498 0x00000030
+DATA 4 0x020E04A4 0x00000030
+DATA 4 0x020E0244 0x00000030
+DATA 4 0x020E0248 0x00000030
+
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B080C 0x0013000F
+DATA 4 0x021B083C 0x415D0159
+DATA 4 0x021B0848 0x4040484F
+DATA 4 0x021B0850 0x40405247
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B08C0 0x00922012
+DATA 4 0x021B08b8 0x00000800
+DATA 4 0x021B0004 0x0002002D
+DATA 4 0x021B0008 0x1B333000
+DATA 4 0x021B000C 0x676B54B3
+DATA 4 0x021B0010 0xB68E0A83
+DATA 4 0x021B0014 0x01FF00DB
+DATA 4 0x021B0018 0x00211740
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B002C 0x000026D2
+DATA 4 0x021B0030 0x006B1023
+DATA 4 0x021B0040 0x0000005F
+DATA 4 0x021B0000 0x85180000
+DATA 4 0x021B001C 0x02008032
+DATA 4 0x021B001C 0x00008033
+DATA 4 0x021B001C 0x00048031
+DATA 4 0x021B001C 0x15208030
+DATA 4 0x021B001C 0x04008040
+DATA 4 0x021B0020 0x00000800
+DATA 4 0x021B0818 0x00000227
+DATA 4 0x021B0004 0x0002552D
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6ul_14x14_ddr3_arm2/Kconfig ebf_6ull_uboot/board/freescale/mx6ul_14x14_ddr3_arm2/Kconfig
--- u-boot-2016.03/board/freescale/mx6ul_14x14_ddr3_arm2/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ul_14x14_ddr3_arm2/Kconfig	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,12 @@
+if TARGET_MX6UL_14X14_DDR3_ARM2
+
+config SYS_BOARD
+       default "mx6ul_14x14_ddr3_arm2"
+
+config SYS_VENDOR
+       default "freescale"
+
+config SYS_CONFIG_NAME
+       default "mx6ul_14x14_ddr3_arm2"
+
+endif
diff -urN u-boot-2016.03/board/freescale/mx6ul_14x14_ddr3_arm2/Makefile ebf_6ull_uboot/board/freescale/mx6ul_14x14_ddr3_arm2/Makefile
--- u-boot-2016.03/board/freescale/mx6ul_14x14_ddr3_arm2/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ul_14x14_ddr3_arm2/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,10 @@
+# (C) Copyright 2015 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6ul_14x14_ddr3_arm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6ul_14x14_ddr3_arm2/mx6ul_14x14_ddr3_arm2.c ebf_6ull_uboot/board/freescale/mx6ul_14x14_ddr3_arm2/mx6ul_14x14_ddr3_arm2.c
--- u-boot-2016.03/board/freescale/mx6ul_14x14_ddr3_arm2/mx6ul_14x14_ddr3_arm2.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ul_14x14_ddr3_arm2/mx6ul_14x14_ddr3_arm2.c	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,954 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <linux/fb.h>
+#include <miiphy.h>
+#include <mmc.h>
+#include <mxsfb.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include "../common/pfuze.h"
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+#include <asm/imx-common/video.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL_WP (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_HIGH   |                                   \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_120ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC and EEPROM */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		/* conflict with usb_otg2_pwr */
+		.i2c_mode = MX6_PAD_GPIO1_IO02__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO02__GPIO1_IO02 | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		/* conflict with usb_otg2_oc */
+		.i2c_mode = MX6_PAD_GPIO1_IO03__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO03__GPIO1_IO03 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+#ifdef CONFIG_MX6UL_DDR3_ARM2_EMMC_REWORK
+static iomux_v3_cfg_t const usdhc1_emmc_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/*
+	 * The following 4 pins conflicts with qspi.
+	 * You can comment out the following 4 pins and  change
+	 * {USDHC1_BASE_ADDR, 0, 8}  -> {USDHC1_BASE_ADDR, 0, 4}
+	 * to make emmc and qspi coexists.
+	 */
+	MX6_PAD_NAND_READY_B__USDHC1_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CE0_B__USDHC1_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CE1_B__USDHC1_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CLE__USDHC1_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* Default NO WP for emmc, since we use pull down */
+	MX6_PAD_UART1_CTS_B__USDHC1_WP  | MUX_PAD_CTRL(USDHC_PAD_CTRL_WP),
+	/* RST_B */
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#else
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_UART1_CTS_B__USDHC1_WP | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* VSELECT */
+	MX6_PAD_GPIO1_IO05__USDHC1_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* CD */
+	MX6_PAD_UART1_RTS_B__GPIO1_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* RST_B */
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#endif
+
+#if !defined(CONFIG_SYS_USE_NAND)
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_CSI_VSYNC__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_HSYNC__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+#ifdef CONFIG_MX6UL_DDR3_ARM2_USDHC2_REWORK
+#if defined(CONFIG_SYS_USE_EIMNOR) || defined(CONFIG_SYS_USE_SPINOR)
+#error "Pin conflicts!"
+#endif
+	/* conflict with eimnor/spinor */
+	MX6_PAD_CSI_DATA04__USDHC2_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA05__USDHC2_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA06__USDHC2_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA07__USDHC2_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+#endif
+	/* VSELECT */
+	MX6_PAD_GPIO1_IO08__USDHC2_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* CD */
+	MX6_PAD_CSI_MCLK__GPIO4_IO17 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/*
+	 * Pin conflicts with NAND ALE, if want to test nand,
+	 * Connect R169(B), disconnect R169(A).
+	 *
+	 * RST_B
+	 */
+	MX6_PAD_NAND_ALE__GPIO4_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+static iomux_v3_cfg_t const nand_pads[] = {
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CLE__RAWNAND_CLE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_ALE__RAWNAND_ALE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_CSI_MCLK__RAWNAND_CE2_B   | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_CSI_PIXCLK__RAWNAND_CE3_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DQS__RAWNAND_DQS | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(nand_pads, ARRAY_SIZE(nand_pads));
+
+	setup_gpmi_io_clk((3 << MXC_CCM_CSCDR1_BCH_PODF_OFFSET) |
+			  (3 << MXC_CCM_CSCDR1_GPMI_PODF_OFFSET));
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+/* pin conflicts with eim nor */
+static iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX6_PAD_CSI_DATA06__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_CSI_DATA04__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_CSI_DATA07__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+
+	/* CS Pin */
+	MX6_PAD_CSI_DATA05__GPIO4_IO26 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(4, 26), 0);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 26)) : -1;
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+/* pin conflicts with nand usdhc2 lcd enet */
+static iomux_v3_cfg_t const eimnor_pads[] = {
+	MX6_PAD_CSI_DATA00__EIM_AD00 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA01__EIM_AD01 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA02__EIM_AD02 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA03__EIM_AD03 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA04__EIM_AD04 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA05__EIM_AD05 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA06__EIM_AD06 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA07__EIM_AD07 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA00__EIM_AD08 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA01__EIM_AD09 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA02__EIM_AD10 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA03__EIM_AD11 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA04__EIM_AD12 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA05__EIM_AD13 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA06__EIM_AD14 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA07__EIM_AD15 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_CLE__EIM_ADDR16 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_ALE__EIM_ADDR17 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_CE1_B__EIM_ADDR18 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_CMD__EIM_ADDR19 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_CLK__EIM_ADDR20 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__EIM_ADDR21 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__EIM_ADDR22 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__EIM_ADDR23 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__EIM_ADDR24 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_ENET2_RX_ER__EIM_ADDR25 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_ENET2_RX_EN__EIM_ADDR26 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+
+	MX6_PAD_CSI_PIXCLK__EIM_OE | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_VSYNC__EIM_RW | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+
+	MX6_PAD_LCD_DATA08__EIM_DATA00 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA09__EIM_DATA01 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA10__EIM_DATA02 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA11__EIM_DATA03 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA12__EIM_DATA04 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA13__EIM_DATA05 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__EIM_DATA06 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__EIM_DATA07 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__EIM_DATA08 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__EIM_DATA09 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA18__EIM_DATA10 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA19__EIM_DATA11 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA20__EIM_DATA12 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA21__EIM_DATA13 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA22__EIM_DATA14 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA23__EIM_DATA15 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+
+	MX6_PAD_CSI_MCLK__EIM_CS0_B | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DQS__EIM_WAIT | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void eimnor_cs_setup(void)
+{
+	writel(0x00000120, WEIM_BASE_ADDR + 0x090);
+	writel(0x00010181, WEIM_BASE_ADDR + 0x000);
+	writel(0x00000001, WEIM_BASE_ADDR + 0x004);
+	writel(0x0a020000, WEIM_BASE_ADDR + 0x008);
+	writel(0x0000c000, WEIM_BASE_ADDR + 0x00c);
+	writel(0x0804a240, WEIM_BASE_ADDR + 0x010);
+}
+
+static void setup_eimnor(void)
+{
+	if (check_module_fused(MX6_MODULE_EIM)) {
+		printf("WEIM@0x%x is fused, disable it\n", WEIM_BASE_ADDR);
+		return;
+	}
+
+	imx_iomux_v3_setup_multiple_pads(eimnor_pads, ARRAY_SIZE(eimnor_pads));
+
+	eimnor_cs_setup();
+}
+
+int board_flash_wp_on(void)
+{
+	if (check_module_fused(MX6_MODULE_EIM))
+		return 1; /* Skip flash init */
+
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FEC_MXC
+/*
+ * pin conflicts for fec1 and fec2, GPIO1_IO06 and GPIO1_IO07 can only
+ * be used for ENET1 or ENET2, cannot be used for both.
+ */
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	/* Pin conflicts with LCD PWM1 */
+	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	/*
+	 * ALT5 mode is only valid when TAMPER pin is used for GPIO.
+	 * This depends on FUSE settings, TAMPER_PIN_DISABLE[1:0].
+	 *
+	 * ENET1_RST
+	 */
+	MX6_PAD_SNVS_TAMPER2__GPIO5_IO02 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART4_TX_DATA__ENET2_TDATA02 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART4_RX_DATA__ENET2_TDATA03 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_CLK__ENET2_TX_CLK | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART3_TX_DATA__ENET2_RDATA02 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART3_RX_DATA__ENET2_RDATA03 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART3_CTS_B__ENET2_RX_CLK | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART5_RX_DATA__ENET2_COL | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART5_TX_DATA__ENET2_CRS | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_SNVS_TAMPER4__GPIO5_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_fec(int fec_id)
+{
+	if (fec_id == 0) {
+		imx_iomux_v3_setup_multiple_pads(fec1_pads,
+						 ARRAY_SIZE(fec1_pads));
+		gpio_direction_output(IMX_GPIO_NR(5, 2), 0);
+		udelay(50);
+		gpio_direction_output(IMX_GPIO_NR(5, 2), 1);
+	} else {
+		imx_iomux_v3_setup_multiple_pads(fec2_pads,
+						 ARRAY_SIZE(fec2_pads));
+		gpio_direction_output(IMX_GPIO_NR(5, 4), 0);
+		udelay(50);
+		gpio_direction_output(IMX_GPIO_NR(5, 4), 1);
+	}
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_SYS_USE_QSPI
+
+#define QSPI_PAD_CTRL1	\
+	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_120ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6_PAD_NAND_WP_B__QSPI_A_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_READY_B__QSPI_A_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CLE__QSPI_A_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DQS__QSPI_A_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA07__QSPI_A_SS1_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+
+	MX6_PAD_NAND_RE_B__QSPI_B_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_WE_B__QSPI_B_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA00__QSPI_B_SS1_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA02__QSPI_B_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA03__QSPI_B_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA04__QSPI_B_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA05__QSPI_B_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads,
+					 ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(0);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+#ifdef CONFIG_MX6UL_DDR3_ARM2_EMMC_REWORK
+	/* If want to use qspi, should change to 4 bit width */
+	{USDHC1_BASE_ADDR, 0, 8},
+#else
+	{USDHC1_BASE_ADDR, 0, 4},
+#endif
+#if !defined(CONFIG_SYS_USE_NAND)
+	{USDHC2_BASE_ADDR, 0, 4},
+#endif
+};
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(1, 19)
+#define USDHC1_PWR_GPIO	IMX_GPIO_NR(1, 9)
+#define USDHC1_VSELECT IMX_GPIO_NR(1, 5)
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(4, 17)
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(4, 10)
+
+int board_mmc_get_env_dev(int devno)
+{
+	if (devno == 1 && mx6_esdhc_fused(USDHC1_BASE_ADDR))
+		devno = 0;
+
+	return devno;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	if (devno == 0 && mx6_esdhc_fused(USDHC1_BASE_ADDR))
+		devno = 1;
+
+	return devno;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+#ifdef CONFIG_MX6UL_DDR3_ARM2_EMMC_REWORK
+		ret = 1;
+#else
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+#endif
+		break;
+#if !defined(CONFIG_SYS_USE_NAND)
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD_GPIO);
+		break;
+#endif
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+#ifdef CONFIG_MX6UL_DDR3_ARM2_EMMC_REWORK
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_emmc_pads, ARRAY_SIZE(usdhc1_emmc_pads));
+#else
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+#endif
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			/* 3.3V */
+			gpio_direction_output(USDHC1_VSELECT, 0);
+			gpio_direction_output(USDHC1_PWR_GPIO, 1);
+			break;
+#if !defined(CONFIG_SYS_USE_NAND)
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_direction_input(USDHC2_CD_GPIO);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+#endif
+		default:
+			printf("Warning: you configured more USDHC controllers (%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+			if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD_CLK__LCDIF_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__LCDIF_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__LCDIF_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA18__LCDIF_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA19__LCDIF_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA20__LCDIF_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA21__LCDIF_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA22__LCDIF_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA23__LCDIF_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_RESET__GPIO3_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/*
+	 * PWM1, pin conflicts with ENET1_RX_DATA0
+	 * Use GPIO for Brightness adjustment, duty cycle = period.
+	 */
+	/* MX6_PAD_ENET1_RX_DATA0__GPIO2_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL),*/
+};
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void (*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void do_enable_parallel_lcd(struct display_info_t const *dev)
+{
+	enable_lcdif_clock(dev->bus);
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(3, 4) , 1);
+
+	/* Set Brightness to high */
+	/* gpio_direction_output(IMX_GPIO_NR(2, 0) , 1); */
+}
+
+struct display_info_t const displays[] = {{
+	.bus = MX6UL_LCDIF1_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 24,
+	.detect = NULL,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name		= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
+
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC%d MXC: %s:failed\n", CONFIG_FEC_ENET_DEV, __func__);
+
+	return 0;
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *)IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	if (0 == fec_id) {
+		if (check_module_fused(MX6_MODULE_ENET1))
+			return -1;
+
+		/*
+		 * Use 50M anatop loopback REF_CLK1 for ENET1,
+		 * clear gpr1[13], set gpr1[17]
+		 */
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK,
+				IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK);
+		ret = enable_fec_anatop_clock(fec_id, ENET_50MHZ);
+		if (ret)
+			return ret;
+
+	} else {
+		if (check_module_fused(MX6_MODULE_ENET2))
+			return -1;
+
+		/* clk from phy, set gpr1[14], clear gpr1[18]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC2_MASK,
+				IOMUX_GPR1_FEC2_CLOCK_MUX2_SEL_MASK);
+	}
+
+	enable_enet_clk(1);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (CONFIG_FEC_ENET_DEV == 0) {
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x16, 0x202);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8190);
+	} else if (CONFIG_FEC_ENET_DEV == 1) {
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x16, 0x201);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8110);
+	}
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+static struct pmic *pfuze;
+int power_init_board(void)
+{
+	int ret;
+	u32 rev_id, value;
+
+	ret = power_pfuze100_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	pfuze = pmic_get("PFUZE100");
+	if (!pfuze)
+		return -ENODEV;
+
+	ret = pmic_probe(pfuze);
+	if (ret)
+		return ret;
+
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	pmic_reg_read(pfuze, PFUZE100_DEVICEID, &value);
+	pmic_reg_read(pfuze, PFUZE100_REVID, &rev_id);
+	printf("PMIC: PFUZE200! DEV_ID=0x%x REV_ID=0x%x\n", value, rev_id);
+
+	/*
+	 * Our PFUZE0200 is PMPF0200X0AEP, the Pre-programmed OTP
+	 * Configuration is F0.
+	 * Default VOLT:
+	 * VSNVS_VOLT	|	3.0V
+	 * SW1AB	|	1.375V
+	 * SW2		|	3.3V
+	 * SW3A		|	1.5V
+	 * SW3B		|	1.5V
+	 * VGEN1	|	1.5V
+	 * VGEN2	|	1.5V
+	 * VGEN3	|	2.5V
+	 * VGEN4	|	1.8V
+	 * VGEN5	|	2.8V
+	 * VGEN6	|	3.3V
+	 *
+	 * According to schematic, we need SW3A 1.35V, SW3B 3.3V,
+	 * VGEN1 1.2V, VGEN2 1.5V, VGEN3 2.8V, VGEN4 1.8V,
+	 * VGEN5 3.3V, VGEN6 3.0V.
+	 *
+	 * Here we just use the default VOLT, but not configure
+	 * them, when needed, configure them to our requested voltage.
+	 */
+
+	/* set SW1AB standby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &value);
+	value &= ~0x3f;
+	value |= PFUZE100_SW1ABC_SETP(9750);
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, value);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &value);
+	value &= ~0xc0;
+	value |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, value);
+
+	/* Enable power of VGEN5 3V3 */
+	pmic_reg_read(pfuze, PFUZE100_VGEN5VOL, &value);
+	value &= ~0x1F;
+	value |= 0x1F;
+	pmic_reg_write(pfuze, PFUZE100_VGEN5VOL, value);
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	int is_400M;
+	u32 vddarm;
+
+	struct pmic *p = pfuze;
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		pmic_reg_read(pfuze, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(12750);
+		pmic_reg_write(pfuze, PFUZE100_SW1ABVOL, value);
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE100_SW1ABC_SETP(10750);
+		else
+			vddarm = PFUZE100_SW1ABC_SETP(11750);
+
+		pmic_reg_read(pfuze, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= vddarm;
+		pmic_reg_write(pfuze, PFUZE100_SW1ABVOL, value);
+
+		finish_anatop_bypass();
+
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	/*
+	 * Because kernel set WDOG_B mux before pad with the commone pinctrl
+	 * framwork now and wdog reset will be triggered once set WDOG_B mux
+	 * with default pad setting, we set pad setting here to workaround this.
+	 * Since imx_iomux_v3_setup_pad also set mux before pad setting, we set
+	 * as GPIO mux firstly here to workaround it.
+	 *
+	 * Here we can not set this, since SD1_RST_B conflicts with GWDOG.
+	 * We use SD1, so will not set WDOG pads, also GWDOG default is
+	 * DNP.
+	 */
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+	setup_eimnor();
+#endif
+
+#ifdef CONFIG_SYS_USE_QSPI
+	board_qspi_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x42, 0x20, 0x00, 0x00)},
+	{"qspi1", MAKE_CFGVAL(0x10, 0x00, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: MX6UL 14X14 DDR3 ARM2\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX6_PAD_GPIO1_IO04__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+/*
+ * Leave it here, but default configuration only supports 1 port now,
+ * because we need sd1 and i2c1
+ */
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	/* conflict with i2c1_scl */
+	MX6_PAD_GPIO1_IO02__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* conflict with sd1_vselect */
+	MX6_PAD_GPIO1_IO05__ANATOP_OTG2_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+int board_usb_phy_mode(int port)
+{
+	return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+						 ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+						 ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6ul_14x14_ddr3_arm2/plugin.S ebf_6ull_uboot/board/freescale/mx6ul_14x14_ddr3_arm2/plugin.S
--- u-boot-2016.03/board/freescale/mx6ul_14x14_ddr3_arm2/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ul_14x14_ddr3_arm2/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6ul_ddr3_arm2_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000C0000
+	str r1, [r0, #0x4B4]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4AC]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x27C]
+	str r1, [r0, #0x250]
+	str r1, [r0, #0x24C]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x288]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x270]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x260]
+	str r1, [r0, #0x264]
+	str r1, [r0, #0x4A0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x280]
+	str r1, [r0, #0x284]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x4B0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x498]
+	str r1, [r0, #0x4A4]
+	str r1, [r0, #0x244]
+	str r1, [r0, #0x248]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x0013000F
+	str r1, [r0, #0x80C]
+	ldr r1, =0x415D0159
+	str r1, [r0, #0x83C]
+	ldr r1, =0x4040484F
+	str r1, [r0, #0x848]
+	ldr r1, =0x40405247
+	str r1, [r0, #0x850]
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	ldr r1, =0xF3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	ldr r1, =0x00922012
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+	ldr r1, =0x0002002D
+	str r1, [r0, #0x004]
+	ldr r1, =0x1B333000
+	str r1, [r0, #0x008]
+	ldr r1, =0x676B54B3
+	str r1, [r0, #0x00C]
+	ldr r1, =0xB68E0A83
+	str r1, [r0, #0x010]
+	ldr r1, =0x01FF00DB
+	str r1, [r0, #0x014]
+	ldr r1, =0x00211740
+	str r1, [r0, #0x018]
+	ldr r1, =0x00008000
+	str r1, [r0, #0x01C]
+	ldr r1, =0x000026D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x006B1023
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000005F
+	str r1, [r0, #0x040]
+	ldr r1, =0x85180000
+	str r1, [r0, #0x000]
+	ldr r1, =0x02008032
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00008033
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00048031
+	str r1, [r0, #0x01C]
+	ldr r1, =0x15208030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04008040
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x020]
+	ldr r1, =0x00000227
+	str r1, [r0, #0x818]
+	ldr r1, =0x0002552D
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xFFFFFFFF
+	str r1, [r0, #0x68]
+	str r1, [r0, #0x6C]
+	str r1, [r0, #0x70]
+	str r1, [r0, #0x74]
+	str r1, [r0, #0x78]
+	str r1, [r0, #0x7C]
+	str r1, [r0, #0x80]
+	str r1, [r0, #0x84]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6ul_ddr3_arm2_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6ul_14x14_evk/imximage.cfg ebf_6ull_uboot/board/freescale/mx6ul_14x14_evk/imximage.cfg
--- u-boot-2016.03/board/freescale/mx6ul_14x14_evk/imximage.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ul_14x14_evk/imximage.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6ul_14x14_evk/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+#ifdef CONFIG_DDR3L_MT41K256M16HA
+
+/* DDR type MT41K256M16HA-125 which is EOL */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+
+DATA 4 0x020E04B4 0x000C0000
+DATA 4 0x020E04AC 0x00000000
+DATA 4 0x020E027C 0x00000030
+DATA 4 0x020E0250 0x00000030
+DATA 4 0x020E024C 0x00000030
+DATA 4 0x020E0490 0x00000030
+DATA 4 0x020E0288 0x00000030
+DATA 4 0x020E0270 0x00000000
+DATA 4 0x020E0260 0x00000030
+DATA 4 0x020E0264 0x00000030
+DATA 4 0x020E04A0 0x00000030
+DATA 4 0x020E0494 0x00020000
+DATA 4 0x020E0280 0x00000030
+DATA 4 0x020E0284 0x00000030
+DATA 4 0x020E04B0 0x00020000
+DATA 4 0x020E0498 0x00000030
+DATA 4 0x020E04A4 0x00000030
+DATA 4 0x020E0244 0x00000030
+DATA 4 0x020E0248 0x00000030
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B080C 0x00000000
+DATA 4 0x021B083C 0x41490145
+DATA 4 0x021B0848 0x40404546
+DATA 4 0x021B0850 0x4040524D
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B08C0 0x00921012
+DATA 4 0x021B08b8 0x00000800
+DATA 4 0x021B0004 0x0002002D
+DATA 4 0x021B0008 0x00333030
+DATA 4 0x021B000C 0x676B52F3
+DATA 4 0x021B0010 0xB66D8B63
+DATA 4 0x021B0014 0x01FF00DB
+DATA 4 0x021B0018 0x00201740
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B002C 0x000026D2
+DATA 4 0x021B0030 0x006B1023
+DATA 4 0x021B0040 0x0000004F
+DATA 4 0x021B0000 0x84180000
+DATA 4 0x021B001C 0x02008032
+DATA 4 0x021B001C 0x00008033
+DATA 4 0x021B001C 0x00048031
+DATA 4 0x021B001C 0x15208030
+DATA 4 0x021B001C 0x04008040
+DATA 4 0x021B0020 0x00000800
+DATA 4 0x021B0818 0x00000227
+DATA 4 0x021B0004 0x0002552D
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+
+#else
+
+/* New DDR type MT41K256M16TW-107 */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+
+DATA 4 0x020E04B4 0x000C0000
+DATA 4 0x020E04AC 0x00000000
+DATA 4 0x020E027C 0x00000030
+DATA 4 0x020E0250 0x00000030
+DATA 4 0x020E024C 0x00000030
+DATA 4 0x020E0490 0x00000030
+DATA 4 0x020E0288 0x00000030
+DATA 4 0x020E0270 0x00000000
+DATA 4 0x020E0260 0x00000030
+DATA 4 0x020E0264 0x00000030
+DATA 4 0x020E04A0 0x00000030
+DATA 4 0x020E0494 0x00020000
+DATA 4 0x020E0280 0x00000030
+DATA 4 0x020E0284 0x00000030
+DATA 4 0x020E04B0 0x00020000
+DATA 4 0x020E0498 0x00000030
+DATA 4 0x020E04A4 0x00000030
+DATA 4 0x020E0244 0x00000030
+DATA 4 0x020E0248 0x00000030
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B080C 0x00000000
+DATA 4 0x021B083C 0x41570155
+DATA 4 0x021B0848 0x4040474A
+DATA 4 0x021B0850 0x40405550
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B08C0 0x00921012
+DATA 4 0x021B08b8 0x00000800
+DATA 4 0x021B0004 0x0002002D
+DATA 4 0x021B0008 0x1B333030
+DATA 4 0x021B000C 0x676B52F3
+DATA 4 0x021B0010 0xB66D0B63
+DATA 4 0x021B0014 0x01FF00DB
+DATA 4 0x021B0018 0x00201740
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B002C 0x000026D2
+DATA 4 0x021B0030 0x006B1023
+DATA 4 0x021B0040 0x0000004F
+DATA 4 0x021B0000 0x84180000
+DATA 4 0x021B0890 0x23400A38
+DATA 4 0x021B001C 0x02008032
+DATA 4 0x021B001C 0x00008033
+DATA 4 0x021B001C 0x00048031
+DATA 4 0x021B001C 0x15208030
+DATA 4 0x021B001C 0x04008040
+DATA 4 0x021B0020 0x00000800
+DATA 4 0x021B0818 0x00000227
+DATA 4 0x021B0004 0x0002552D
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
+
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6ul_14x14_evk/imximage_lpddr2.cfg ebf_6ull_uboot/board/freescale/mx6ul_14x14_evk/imximage_lpddr2.cfg
--- u-boot-2016.03/board/freescale/mx6ul_14x14_evk/imximage_lpddr2.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ul_14x14_evk/imximage_lpddr2.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6ul_14x14_evk/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+DATA 4 0x020E04B4 0x00080000
+DATA 4 0x020E04AC 0x00000000
+DATA 4 0x020E027C 0x00000030
+DATA 4 0x020E0250 0x00000030
+DATA 4 0x020E024C 0x00000030
+DATA 4 0x020E0490 0x00000030
+DATA 4 0x020E0288 0x00000030
+DATA 4 0x020E0270 0x00000000
+DATA 4 0x020E0260 0x00000000
+DATA 4 0x020E0264 0x00000000
+DATA 4 0x020E04A0 0x00000030
+DATA 4 0x020E0494 0x00020000
+DATA 4 0x020E0280 0x00003030
+DATA 4 0x020E0284 0x00003030
+DATA 4 0x020E04B0 0x00020000
+DATA 4 0x020E0498 0x00000030
+DATA 4 0x020E04A4 0x00000030
+DATA 4 0x020E0244 0x00000030
+DATA 4 0x020E0248 0x00000030
+
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B085C 0x1b4700c7
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B0890 0x00470000
+DATA 4 0x021B08b8 0x00000800
+
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B083C 0x20000000
+DATA 4 0x021B0848 0x4040484F
+DATA 4 0x021B0850 0x40405247
+DATA 4 0x021B08C0 0x00922012
+DATA 4 0x021B08b8 0x00000800
+
+DATA 4 0x021B0004 0x00020012
+DATA 4 0x021B0008 0x00000000
+DATA 4 0x021B000C 0x33374133
+DATA 4 0x021B0010 0x00100A82
+DATA 4 0x021B0038 0x00170557
+DATA 4 0x021B0014 0x00000093
+DATA 4 0x021B0018 0x00001748
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B002C 0x0F9F0682
+DATA 4 0x021B0030 0x009F0010
+DATA 4 0x021B0040 0x00000047
+DATA 4 0x021B0000 0x83100000
+DATA 4 0x021B001C 0x00008050
+DATA 4 0x021B001C 0x003F8030
+DATA 4 0x021B001C 0xFF0A8030
+DATA 4 0x021B001C 0x82018030
+DATA 4 0x021B001C 0x04028030
+DATA 4 0x021B001C 0x01038030
+DATA 4 0x021B0020 0x00001800
+DATA 4 0x021B0818 0x00000000
+DATA 4 0x021B0800 0xA1310003
+DATA 4 0x021B0004 0x00025576
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6ul_14x14_evk/Makefile ebf_6ull_uboot/board/freescale/mx6ul_14x14_evk/Makefile
--- u-boot-2016.03/board/freescale/mx6ul_14x14_evk/Makefile	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ul_14x14_evk/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -4,3 +4,7 @@
 #
 
 obj-y  := mx6ul_14x14_evk.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c ebf_6ull_uboot/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c
--- u-boot-2016.03/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c	2021-04-16 14:42:16.960592524 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -22,12 +22,21 @@
 #include <miiphy.h>
 #include <linux/sizes.h>
 #include <mmc.h>
+#include <mxsfb.h>
 #include <netdev.h>
 #include <power/pmic.h>
 #include <power/pfuze3000_pmic.h>
 #include "../common/pfuze.h"
 #include <usb.h>
 #include <usb/ehci-fsl.h>
+#include <asm/imx-common/video.h>
+
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -63,10 +72,27 @@
 #define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
 	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
 
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
 #define IOX_SDI IMX_GPIO_NR(5, 10)
 #define IOX_STCP IMX_GPIO_NR(5, 7)
 #define IOX_SHCP IMX_GPIO_NR(5, 11)
-#define IOX_OE IMX_GPIO_NR(5, 18)
+#define IOX_OE IMX_GPIO_NR(5, 8)
 
 static iomux_v3_cfg_t const iox_pads[] = {
 	/* IOX_SDI */
@@ -117,7 +143,7 @@
 
 static enum qn_func qn_output[8] = {
 	qn_reset, qn_reset, qn_reset, qn_enable, qn_disable, qn_reset,
-	qn_disable, qn_enable
+	qn_disable, qn_disable
 };
 
 static void iox74lv_init(void)
@@ -154,10 +180,48 @@
 	 * shift register will be output to pins
 	 */
 	gpio_direction_output(IOX_STCP, 1);
+};
+
+void iox74lv_set(int index)
+{
+	int i;
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+
+		if (i == index)
+			gpio_direction_output(IOX_SDI, seq[qn_output[i]][0]);
+		else
+			gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+		gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
 
-	gpio_direction_output(IOX_OE, 1);
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
 };
 
+
 #ifdef CONFIG_SYS_I2C_MXC
 #define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
 /* I2C1 for PMIC and EEPROM */
@@ -217,6 +281,43 @@
 
 	return 0;
 }
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	u32 vddarm;
+
+	struct pmic *p = pmic_get("PFUZE3000");
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		pmic_reg_read(p, PFUZE3000_SW1BVOLT, &value);
+		value &= ~0x1f;
+		value |= PFUZE3000_SW1AB_SETP(1275);
+		pmic_reg_write(p, PFUZE3000_SW1BVOLT, value);
+
+		set_anatop_bypass(1);
+		vddarm = PFUZE3000_SW1AB_SETP(1175);
+
+		pmic_reg_read(p, PFUZE3000_SW1BVOLT, &value);
+		value &= ~0x1f;
+		value |= vddarm;
+		pmic_reg_write(p, PFUZE3000_SW1BVOLT, value);
+
+		finish_anatop_bypass();
+
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
 #endif
 #endif
 
@@ -251,10 +352,10 @@
 /*
  * mx6ul_14x14_evk board default supports sd card. If want to use
  * EMMC, need to do board rework for sd2.
- * Introduce CONFIG_MX6UL_14X14_EVK_EMMC_REWORK, if sd2 reworked to support
+ * Introduce CONFIG_MX6UL_EVK_EMMC_REWORK, if sd2 reworked to support
  * emmc, need to define this macro.
  */
-#if defined(CONFIG_MX6UL_14X14_EVK_EMMC_REWORK)
+#if defined(CONFIG_MX6UL_EVK_EMMC_REWORK)
 static iomux_v3_cfg_t const usdhc2_emmc_pads[] = {
 	MX6_PAD_NAND_RE_B__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
 	MX6_PAD_NAND_WE_B__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
@@ -305,7 +406,7 @@
 
 #define QSPI_PAD_CTRL1	\
 	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
-	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_60ohm)
+	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_120ohm)
 
 static iomux_v3_cfg_t const quadspi_pads[] = {
 	MX6_PAD_NAND_WP_B__QSPI_A_SCLK | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
@@ -331,7 +432,7 @@
 #ifdef CONFIG_FSL_ESDHC
 static struct fsl_esdhc_cfg usdhc_cfg[2] = {
 	{USDHC1_BASE_ADDR, 0, 4},
-#if defined(CONFIG_MX6UL_14X14_EVK_EMMC_REWORK)
+#if defined(CONFIG_MX6UL_EVK_EMMC_REWORK)
 	{USDHC2_BASE_ADDR, 0, 8},
 #else
 	{USDHC2_BASE_ADDR, 0, 4},
@@ -343,6 +444,22 @@
 #define USDHC2_CD_GPIO	IMX_GPIO_NR(4, 5)
 #define USDHC2_PWR_GPIO	IMX_GPIO_NR(4, 10)
 
+int board_mmc_get_env_dev(int devno)
+{
+	if (devno == 1 && mx6_esdhc_fused(USDHC1_BASE_ADDR))
+		devno = 0;
+
+	return devno;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	if (devno == 0 && mx6_esdhc_fused(USDHC1_BASE_ADDR))
+		devno = 1;
+
+	return devno;
+}
+
 int board_mmc_getcd(struct mmc *mmc)
 {
 	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
@@ -353,7 +470,7 @@
 		ret = !gpio_get_value(USDHC1_CD_GPIO);
 		break;
 	case USDHC2_BASE_ADDR:
-#if defined(CONFIG_MX6UL_14X14_EVK_EMMC_REWORK)
+#if defined(CONFIG_MX6UL_EVK_EMMC_REWORK)
 		ret = 1;
 #else
 		imx_iomux_v3_setup_multiple_pads(usdhc2_cd_pads,
@@ -378,7 +495,7 @@
 int board_mmc_init(bd_t *bis)
 {
 #ifdef CONFIG_SPL_BUILD
-#if defined(CONFIG_MX6UL_14X14_EVK_EMMC_REWORK)
+#if defined(CONFIG_MX6UL_EVK_EMMC_REWORK)
 	imx_iomux_v3_setup_multiple_pads(usdhc2_emmc_pads,
 					 ARRAY_SIZE(usdhc2_emmc_pads));
 #else
@@ -411,13 +528,15 @@
 			gpio_direction_output(USDHC1_PWR_GPIO, 1);
 			break;
 		case 1:
-#if defined(CONFIG_MX6UL_14X14_EVK_EMMC_REWORK)
+#if defined(CONFIG_MX6UL_EVK_EMMC_REWORK)
 			imx_iomux_v3_setup_multiple_pads(
 				usdhc2_emmc_pads, ARRAY_SIZE(usdhc2_emmc_pads));
 #else
+#ifndef CONFIG_SYS_USE_NAND
 			imx_iomux_v3_setup_multiple_pads(
 				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
 #endif
+#endif
 			gpio_direction_output(USDHC2_PWR_GPIO, 0);
 			udelay(500);
 			gpio_direction_output(USDHC2_PWR_GPIO, 1);
@@ -431,7 +550,6 @@
 			ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
 			if (ret) {
 				printf("Warning: failed to initialize mmc dev %d\n", i);
-				return ret;
 			}
 	}
 #endif
@@ -444,7 +562,7 @@
 #define UCTRL_PWR_POL		(1 << 9)
 
 static iomux_v3_cfg_t const usb_otg_pads[] = {
-	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
 };
 
 /* At default the 3v3 enables the MIC2026 for VBUS power */
@@ -479,6 +597,42 @@
 }
 #endif
 
+#ifdef CONFIG_NAND_MXS
+static iomux_v3_cfg_t const nand_pads[] = {
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CLE__RAWNAND_CLE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_ALE__RAWNAND_ALE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DQS__RAWNAND_DQS | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(nand_pads, ARRAY_SIZE(nand_pads));
+
+	setup_gpmi_io_clk((3 << MXC_CCM_CSCDR1_BCH_PODF_OFFSET) |
+			  (3 << MXC_CCM_CSCDR1_GPMI_PODF_OFFSET));
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
 #ifdef CONFIG_FEC_MXC
 /*
  * pin conflicts for fec1 and fec2, GPIO1_IO06 and GPIO1_IO07 can only
@@ -536,6 +690,9 @@
 	int ret;
 
 	if (fec_id == 0) {
+		if (check_module_fused(MX6_MODULE_ENET1))
+			return -1;
+
 		/*
 		 * Use 50M anatop loopback REF_CLK1 for ENET1,
 		 * clear gpr1[13], set gpr1[17].
@@ -543,6 +700,9 @@
 		clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC1_MASK,
 				IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK);
 	} else {
+		if (check_module_fused(MX6_MODULE_ENET2))
+			return -1;
+
 		/*
 		 * Use 50M anatop loopback REF_CLK2 for ENET2,
 		 * clear gpr1[14], set gpr1[18].
@@ -609,9 +769,9 @@
 	MX6_PAD_GPIO1_IO08__GPIO1_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),
 };
 
-static int setup_lcd(void)
+void do_enable_parallel_lcd(struct display_info_t const *dev)
 {
-	enable_lcdif_clock(LCDIF1_BASE_ADDR);
+	enable_lcdif_clock(dev->bus);
 
 	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
 
@@ -622,9 +782,29 @@
 
 	/* Set Brightness to high */
 	gpio_direction_output(IMX_GPIO_NR(1, 8) , 1);
-
-	return 0;
 }
+
+struct display_info_t const displays[] = {{
+	.bus = MX6UL_LCDIF1_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 24,
+	.detect = NULL,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "TFT43AB",
+		.xres           = 480,
+		.yres           = 272,
+		.pixclock       = 108695,
+		.left_margin    = 8,
+		.right_margin   = 4,
+		.upper_margin   = 2,
+		.lower_margin   = 4,
+		.hsync_len      = 41,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
 #endif
 
 int board_early_init_f(void)
@@ -659,8 +839,8 @@
 	board_qspi_init();
 #endif
 
-#ifdef CONFIG_VIDEO_MXS
-	setup_lcd();
+#ifdef CONFIG_NAND_MXS
+	setup_gpmi_nand();
 #endif
 
 	return 0;
@@ -691,6 +871,12 @@
 		setenv("board_rev", "14X14");
 #endif
 
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
 	return 0;
 }
 
@@ -704,6 +890,94 @@
 	return 0;
 }
 
+#ifdef CONFIG_FSL_FASTBOOT
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "nand");
+		if (!getenv("fbparts"))
+			setenv("fbparts", ANDROID_FASTBOOT_NAND_PARTS);
+		if (!getenv("bootcmd"))
+			setenv("bootcmd",
+				"nand read ${loadaddr} ${boot_nand_offset} "
+				"${boot_nand_size};boota ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+int check_recovery_cmd_file(void)
+{
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	return recovery_mode;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc0 recovery");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc1 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"nand read ${loadaddr} ${recovery_nand_offset} "
+				"${recovery_nand_size};boota ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
+
 #ifdef CONFIG_SPL_BUILD
 #include <libfdt.h>
 #include <spl.h>
diff -urN u-boot-2016.03/board/freescale/mx6ul_14x14_evk/plugin.S ebf_6ull_uboot/board/freescale/mx6ul_14x14_evk/plugin.S
--- u-boot-2016.03/board/freescale/mx6ul_14x14_evk/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ul_14x14_evk/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,366 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6ul_ddr3_evk_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000C0000
+	str r1, [r0, #0x4B4]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4AC]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x27C]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x250]
+	str r1, [r0, #0x24C]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x288]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x270]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x260]
+	str r1, [r0, #0x264]
+	str r1, [r0, #0x4A0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x280]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x284]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x4B0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x498]
+	str r1, [r0, #0x4A4]
+	str r1, [r0, #0x244]
+	str r1, [r0, #0x248]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x80C]
+	ldr r1, =0x41570155
+	str r1, [r0, #0x83C]
+	ldr r1, =0x4040474A
+	str r1, [r0, #0x848]
+	ldr r1, =0x40405550
+	str r1, [r0, #0x850]
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	ldr r1, =0xF3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	ldr r1, =0x00921012
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+	ldr r1, =0x0002002D
+	str r1, [r0, #0x004]
+	ldr r1, =0x1B333030
+	str r1, [r0, #0x008]
+	ldr r1, =0x676B52F3
+	str r1, [r0, #0x00C]
+	ldr r1, =0xB66D0B63
+	str r1, [r0, #0x010]
+	ldr r1, =0x01FF00DB
+	str r1, [r0, #0x014]
+	ldr r1, =0x00201740
+	str r1, [r0, #0x018]
+	ldr r1, =0x00008000
+	str r1, [r0, #0x01C]
+	ldr r1, =0x000026D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x006B1023
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000004F
+	str r1, [r0, #0x040]
+	ldr r1, =0x84180000
+	str r1, [r0, #0x000]
+	ldr r1, =0x23400A38
+	str r1, [r0, #0x890]
+	ldr r1, =0x02008032
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00008033
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00048031
+	str r1, [r0, #0x01C]
+	ldr r1, =0x15208030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04008040
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x020]
+	ldr r1, =0x00000227
+	str r1, [r0, #0x818]
+	ldr r1, =0x0002552D
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6ul_ddr3_eol_evk_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000C0000
+	str r1, [r0, #0x4B4]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4AC]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x27C]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x250]
+	str r1, [r0, #0x24C]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x288]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x270]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x260]
+	str r1, [r0, #0x264]
+	str r1, [r0, #0x4A0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x280]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x284]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x4B0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x498]
+	str r1, [r0, #0x4A4]
+	str r1, [r0, #0x244]
+	str r1, [r0, #0x248]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x80C]
+	ldr r1, =0x41490145
+	str r1, [r0, #0x83C]
+	ldr r1, =0x40404546
+	str r1, [r0, #0x848]
+	ldr r1, =0x4040524D
+	str r1, [r0, #0x850]
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	ldr r1, =0xF3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	ldr r1, =0x00921012
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+	ldr r1, =0x0002002D
+	str r1, [r0, #0x004]
+	ldr r1, =0x00333030
+	str r1, [r0, #0x008]
+	ldr r1, =0x676B52F3
+	str r1, [r0, #0x00C]
+	ldr r1, =0xB66D8B63
+	str r1, [r0, #0x010]
+	ldr r1, =0x01FF00DB
+	str r1, [r0, #0x014]
+	ldr r1, =0x00201740
+	str r1, [r0, #0x018]
+	ldr r1, =0x00008000
+	str r1, [r0, #0x01C]
+	ldr r1, =0x000026D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x006B1023
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000004F
+	str r1, [r0, #0x040]
+	ldr r1, =0x84180000
+	str r1, [r0, #0x000]
+	ldr r1, =0x02008032
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00008033
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00048031
+	str r1, [r0, #0x01C]
+	ldr r1, =0x15208030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04008040
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x020]
+	ldr r1, =0x00000227
+	str r1, [r0, #0x818]
+	ldr r1, =0x0002552D
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6ul_lpddr2_evk_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x4B4]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4AC]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x27C]
+	str r1, [r0, #0x250]
+	str r1, [r0, #0x24C]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x288]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x270]
+	str r1, [r0, #0x260]
+	str r1, [r0, #0x264]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4A0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00003030
+	str r1, [r0, #0x280]
+	ldr r1, =0x00003030
+	str r1, [r0, #0x284]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x4B0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x498]
+	str r1, [r0, #0x4A4]
+	str r1, [r0, #0x244]
+	str r1, [r0, #0x248]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0x1b4700c7
+	str r1, [r0, #0x85c]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00470000
+	str r1, [r0, #0x890]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8b8]
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	ldr r1, =0xF3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	ldr r1, =0x20000000
+	str r1, [r0, #0x83C]
+	ldr r1, =0x4040484F
+	str r1, [r0, #0x848]
+	ldr r1, =0x40405247
+	str r1, [r0, #0x850]
+	ldr r1, =0x00922012
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+
+	ldr r1, =0x00020012
+	str r1, [r0, #0x004]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x008]
+	ldr r1, =0x33374133
+	str r1, [r0, #0x00C]
+	ldr r1, =0x00100A82
+	str r1, [r0, #0x010]
+	ldr r1, =0x00170557
+	str r1, [r0, #0x038]
+	ldr r1, =0x00000093
+	str r1, [r0, #0x014]
+	ldr r1, =0x00001748
+	str r1, [r0, #0x018]
+	ldr r1, =0x00008000
+	str r1, [r0, #0x01C]
+	ldr r1, =0x0F9F0682
+	str r1, [r0, #0x02C]
+	ldr r1, =0x009F0010
+	str r1, [r0, #0x030]
+	ldr r1, =0x00000047
+	str r1, [r0, #0x040]
+	ldr r1, =0x83100000
+	str r1, [r0, #0x000]
+	ldr r1, =0x00008050
+	str r1, [r0, #0x01C]
+	ldr r1, =0x003F8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0xFF0A8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x82018030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04028030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x01038030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00001800
+	str r1, [r0, #0x020]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x818]
+	ldr r1, =0xA1310003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00025576
+	str r1, [r0, #0x004]
+	ldr r1, =0x00010106
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xFFFFFFFF
+	str r1, [r0, #0x68]
+	str r1, [r0, #0x6C]
+	str r1, [r0, #0x70]
+	str r1, [r0, #0x74]
+	str r1, [r0, #0x78]
+	str r1, [r0, #0x7C]
+	str r1, [r0, #0x80]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+#if defined (CONFIG_TARGET_MX6UL_9X9_EVK)
+	imx6ul_lpddr2_evk_setting
+#elif defined(CONFIG_DDR3L_MT41K256M16HA)
+	imx6ul_ddr3_eol_evk_setting
+#else
+	imx6ul_ddr3_evk_setting
+#endif
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6ul_14x14_lpddr2_arm2/imximage.cfg ebf_6ull_uboot/board/freescale/mx6ul_14x14_lpddr2_arm2/imximage.cfg
--- u-boot-2016.03/board/freescale/mx6ul_14x14_lpddr2_arm2/imximage.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ul_14x14_lpddr2_arm2/imximage.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6ul_14x14_lpddr2_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+DATA 4 0x020E04B4 0x00080000
+DATA 4 0x020E04AC 0x00000000
+DATA 4 0x020E027C 0x00000028
+DATA 4 0x020E0250 0x00000028
+DATA 4 0x020E024C 0x00000028
+DATA 4 0x020E0490 0x00000028
+DATA 4 0x020E0288 0x00000028
+DATA 4 0x020E0270 0x00000000
+DATA 4 0x020E0260 0x00000000
+DATA 4 0x020E0264 0x00000000
+DATA 4 0x020E04A0 0x00000028
+DATA 4 0x020E0494 0x00020000
+DATA 4 0x020E0280 0x00003028
+DATA 4 0x020E0284 0x00003028
+DATA 4 0x020E04B0 0x00020000
+DATA 4 0x020E0498 0x00000028
+DATA 4 0x020E04A4 0x00000028
+DATA 4 0x020E0244 0x00000028
+DATA 4 0x020E0248 0x00000028
+
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B085C 0x1b4700c7
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B0890 0x00470000
+DATA 4 0x021B08b8 0x00000800
+
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B083C 0x20000000
+DATA 4 0x021B0848 0x4040484F
+DATA 4 0x021B0850 0x40405247
+DATA 4 0x021B08C0 0x00922012
+DATA 4 0x021B08b8 0x00000800
+
+DATA 4 0x021B0004 0x00020012
+DATA 4 0x021B0008 0x00000000
+DATA 4 0x021B000C 0x33374133
+DATA 4 0x021B0010 0x00100A82
+DATA 4 0x021B0038 0x00170557
+DATA 4 0x021B0014 0x00000093
+DATA 4 0x021B0018 0x00001748
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B002C 0x0F9F0682
+DATA 4 0x021B0030 0x009F0010
+DATA 4 0x021B0040 0x00000047
+DATA 4 0x021B0000 0x83100000
+DATA 4 0x021B001C 0x00008050
+DATA 4 0x021B001C 0x003F8030
+DATA 4 0x021B001C 0xFF0A8030
+DATA 4 0x021B001C 0x82018030
+DATA 4 0x021B001C 0x04028030
+DATA 4 0x021B001C 0x01038030
+DATA 4 0x021B0020 0x00001800
+DATA 4 0x021B0818 0x00000000
+DATA 4 0x021B0800 0xA1310003
+DATA 4 0x021B0004 0x00025576
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6ul_14x14_lpddr2_arm2/Kconfig ebf_6ull_uboot/board/freescale/mx6ul_14x14_lpddr2_arm2/Kconfig
--- u-boot-2016.03/board/freescale/mx6ul_14x14_lpddr2_arm2/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ul_14x14_lpddr2_arm2/Kconfig	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,12 @@
+if TARGET_MX6UL_14X14_LPDDR2_ARM2
+
+config SYS_BOARD
+       default "mx6ul_14x14_lpddr2_arm2"
+
+config SYS_VENDOR
+       default "freescale"
+
+config SYS_CONFIG_NAME
+       default "mx6ul_14x14_lpddr2_arm2"
+
+endif
diff -urN u-boot-2016.03/board/freescale/mx6ul_14x14_lpddr2_arm2/Makefile ebf_6ull_uboot/board/freescale/mx6ul_14x14_lpddr2_arm2/Makefile
--- u-boot-2016.03/board/freescale/mx6ul_14x14_lpddr2_arm2/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ul_14x14_lpddr2_arm2/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,10 @@
+# (C) Copyright 2015 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6ul_14x14_lpddr2_arm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6ul_14x14_lpddr2_arm2/mx6ul_14x14_lpddr2_arm2.c ebf_6ull_uboot/board/freescale/mx6ul_14x14_lpddr2_arm2/mx6ul_14x14_lpddr2_arm2.c
--- u-boot-2016.03/board/freescale/mx6ul_14x14_lpddr2_arm2/mx6ul_14x14_lpddr2_arm2.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ul_14x14_lpddr2_arm2/mx6ul_14x14_lpddr2_arm2.c	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,890 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <linux/fb.h>
+#include <miiphy.h>
+#include <mmc.h>
+#include <mxsfb.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include "../common/pfuze.h"
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+#include <asm/imx-common/video.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL_WP (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_HIGH   |                                   \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_120ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC and EEPROM */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		/* conflict with usb_otg2_pwr */
+		.i2c_mode = MX6_PAD_GPIO1_IO02__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO02__GPIO1_IO02 | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		/* conflict with usb_otg2_oc */
+		.i2c_mode = MX6_PAD_GPIO1_IO03__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO03__GPIO1_IO03 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+#if !defined(CONFIG_SYS_USE_NAND)
+	MX6_PAD_NAND_READY_B__USDHC1_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CE0_B__USDHC1_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CE1_B__USDHC1_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CLE__USDHC1_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+#endif
+
+	MX6_PAD_CSI_DATA04__USDHC1_WP | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* VSELECT */
+	MX6_PAD_GPIO1_IO05__USDHC1_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* CD */
+	MX6_PAD_CSI_DATA05__GPIO4_IO26 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* RST_B */
+	MX6_PAD_NAND_WP_B__GPIO4_IO11 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+#if !defined(CONFIG_SYS_USE_NAND)
+
+#ifdef CONFIG_MX6UL_LPDDR2_ARM2_USDHC2_REWORK
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_NAND_RE_B__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_WE_B__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX6_PAD_UART1_CTS_B__USDHC2_WP | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* VSELECT */
+	MX6_PAD_GPIO1_IO08__USDHC2_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* CD */
+	MX6_PAD_UART1_RTS_B__GPIO1_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* RST_B */
+	MX6_PAD_NAND_ALE__GPIO4_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#else
+static iomux_v3_cfg_t const usdhc2_emmc_pads[] = {
+	MX6_PAD_NAND_RE_B__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_WE_B__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA04__USDHC2_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA05__USDHC2_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA06__USDHC2_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA07__USDHC2_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* Default NO WP for emmc, since we use pull down */
+	MX6_PAD_UART1_CTS_B__USDHC2_WP | MUX_PAD_CTRL(USDHC_PAD_CTRL_WP),
+
+	/* RST_B */
+	MX6_PAD_NAND_ALE__GPIO4_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#endif
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+static iomux_v3_cfg_t const nand_pads[] = {
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CLE__RAWNAND_CLE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_ALE__RAWNAND_ALE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_CSI_MCLK__RAWNAND_CE2_B   | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_CSI_PIXCLK__RAWNAND_CE3_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DQS__RAWNAND_DQS | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(nand_pads, ARRAY_SIZE(nand_pads));
+
+	setup_gpmi_io_clk((3 << MXC_CCM_CSCDR1_BCH_PODF_OFFSET) |
+			  (3 << MXC_CCM_CSCDR1_GPMI_PODF_OFFSET));
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+/* pin conflicts with eim nor */
+static iomux_v3_cfg_t const ecspi2_pads[] = {
+	MX6_PAD_CSI_DATA02__ECSPI2_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_CSI_DATA00__ECSPI2_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_CSI_DATA03__ECSPI2_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+
+	/* CS Pin */
+	MX6_PAD_CSI_DATA01__GPIO4_IO22  | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(4, 22), 0);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 1 && cs == 0) ? (IMX_GPIO_NR(4, 22)) : -1;
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+/* pin conflicts with ECSIP2, USDHC1, USDCH2, NAND, SIM, ENET2 */
+static iomux_v3_cfg_t const eimnor_pads[] = {
+	MX6_PAD_NAND_CLE__EIM_ADDR16 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_ALE__EIM_ADDR17 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_CE1_B__EIM_ADDR18 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_CMD__EIM_ADDR19 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_CLK__EIM_ADDR20 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__EIM_ADDR21 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__EIM_ADDR22 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__EIM_ADDR23 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__EIM_ADDR24 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_ENET2_RX_ER__EIM_ADDR25 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+
+	MX6_PAD_CSI_PIXCLK__EIM_OE   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_VSYNC__EIM_RW    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_HSYNC__EIM_LBA_B | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+
+	MX6_PAD_CSI_DATA00__EIM_AD00 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA01__EIM_AD01 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA02__EIM_AD02 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA03__EIM_AD03 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA04__EIM_AD04 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA05__EIM_AD05 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA06__EIM_AD06 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA07__EIM_AD07 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA00__EIM_AD08 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA01__EIM_AD09 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA02__EIM_AD10 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA03__EIM_AD11 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA04__EIM_AD12 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA05__EIM_AD13 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA06__EIM_AD14 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA07__EIM_AD15 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+
+	MX6_PAD_CSI_MCLK__EIM_CS0_B | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_WP_B__EIM_BCLK | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DQS__EIM_WAIT | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void eimnor_cs_setup(void)
+{
+	writel(0x00000120, WEIM_BASE_ADDR + 0x090);
+	writel(0x00610089, WEIM_BASE_ADDR + 0x000);
+	writel(0x00000001, WEIM_BASE_ADDR + 0x004);
+	writel(0x1c022000, WEIM_BASE_ADDR + 0x008);
+	writel(0x00000000, WEIM_BASE_ADDR + 0x00c);
+	writel(0x1404a38e, WEIM_BASE_ADDR + 0x010);
+}
+
+static void setup_eimnor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(eimnor_pads, ARRAY_SIZE(eimnor_pads));
+
+	eimnor_cs_setup();
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+/*
+ * pin conflicts for fec1 and fec2, GPIO1_IO06 and GPIO1_IO07 can only
+ * be used for ENET1 or ENET2, cannot be used for both.
+ */
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	/*
+	 * ALT5 mode is only valid when TAMPER pin is used for GPIO.
+	 * This depends on FUSE settings, TAMPER_PIN_DISABLE[1:0].
+	 *
+	 * ENET2_RST
+	 */
+	MX6_PAD_SNVS_TAMPER4__GPIO5_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+/* Conflict with UART1 */
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART2_TX_DATA__ENET1_TDATA02 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART2_RX_DATA__ENET1_TDATA03 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_CLK__ENET1_TX_CLK | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART1_TX_DATA__ENET1_RDATA02 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART1_RX_DATA__ENET1_RDATA03 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART1_CTS_B__ENET1_RX_CLK | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART2_RTS_B__ENET1_COL | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART2_CTS_B__ENET1_CRS | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_SNVS_TAMPER2__GPIO5_IO02 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_fec(int fec_id)
+{
+	if (fec_id == 0) {
+		imx_iomux_v3_setup_multiple_pads(fec1_pads,
+						 ARRAY_SIZE(fec1_pads));
+		gpio_direction_output(IMX_GPIO_NR(5, 4), 0);
+		udelay(50);
+		gpio_direction_output(IMX_GPIO_NR(5, 4), 1);
+	} else {
+		imx_iomux_v3_setup_multiple_pads(fec2_pads,
+						 ARRAY_SIZE(fec2_pads));
+		gpio_direction_output(IMX_GPIO_NR(5, 2), 0);
+		udelay(50);
+		gpio_direction_output(IMX_GPIO_NR(5, 2), 1);
+	}
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_SYS_USE_QSPI
+
+#define QSPI_PAD_CTRL1	\
+	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_120ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6_PAD_NAND_WP_B__QSPI_A_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_READY_B__QSPI_A_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CLE__QSPI_A_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DQS__QSPI_A_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA07__QSPI_A_SS1_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+
+	MX6_PAD_NAND_RE_B__QSPI_B_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_WE_B__QSPI_B_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA00__QSPI_B_SS1_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA02__QSPI_B_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA03__QSPI_B_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA04__QSPI_B_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA05__QSPI_B_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads,
+					 ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(0);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+#if !defined(CONFIG_SYS_USE_NAND)
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC1_BASE_ADDR, 0, 1},
+	{USDHC2_BASE_ADDR, 0, 8},
+};
+#else
+static struct fsl_esdhc_cfg usdhc_cfg[1] = {
+	{USDHC1_BASE_ADDR, 0, 4},
+};
+#endif
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(4, 26)
+#define USDHC1_PWR_GPIO	IMX_GPIO_NR(4, 11)
+#define USDHC1_VSELECT IMX_GPIO_NR(1, 5)
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(1, 19)
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(4, 10)
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+#if !defined(CONFIG_SYS_USE_NAND)
+	case USDHC2_BASE_ADDR:
+#ifdef CONFIG_MX6UL_LPDDR2_ARM2_USDHC2_REWORK
+		ret = !gpio_get_value(USDHC2_CD_GPIO);
+#else
+		ret = 1;
+#endif
+		break;
+#endif
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			gpio_direction_output(USDHC1_PWR_GPIO, 1);
+			break;
+#if !defined(CONFIG_SYS_USE_NAND)
+		case 1:
+#ifdef CONFIG_MX6UL_LPDDR2_ARM2_USDHC2_REWORK
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_direction_input(USDHC2_CD_GPIO);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+#else
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_emmc_pads, ARRAY_SIZE(usdhc2_emmc_pads));
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+#endif
+			break;
+#endif
+		default:
+			printf("Warning: you configured more USDHC controllers (%d)"
+				" than supported by the board\n", i + 1);
+			return 0;
+		}
+
+		if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+			printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD_CLK__LCDIF_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__LCDIF_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__LCDIF_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA18__LCDIF_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA19__LCDIF_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA20__LCDIF_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA21__LCDIF_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA22__LCDIF_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA23__LCDIF_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_RESET__GPIO3_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/*
+	 * PWM1, pin conflicts with ENET1_RX_DATA0
+	 * Use GPIO for Brightness adjustment, duty cycle = period.
+	 */
+	MX6_PAD_NAND_DQS__GPIO4_IO16 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void (*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void do_enable_parallel_lcd(struct display_info_t const *dev)
+{
+	enable_lcdif_clock(dev->bus);
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(3, 4) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(4, 16) , 1);
+}
+
+struct display_info_t const displays[] = {{
+	.bus = MX6UL_LCDIF1_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 24,
+	.detect = NULL,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name		= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
+
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC%d MXC: %s:failed\n", CONFIG_FEC_ENET_DEV, __func__);
+
+	return 0;
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *)IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	if (1 == fec_id) {
+		/*
+		 * Use 50M anatop loopback REF_CLK2 for ENET2,
+		 * clear gpr1[14], set gpr1[18]
+		 */
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC2_MASK,
+				IOMUX_GPR1_FEC2_CLOCK_MUX1_SEL_MASK);
+		ret = enable_fec_anatop_clock(fec_id, ENET_50MHZ);
+		if (ret)
+			return ret;
+
+	} else {
+		/* clk from phy, set gpr1[13], clear gpr1[17]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK,
+				IOMUX_GPR1_FEC1_CLOCK_MUX2_SEL_MASK);
+	}
+
+	enable_enet_clk(1);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (CONFIG_FEC_ENET_DEV == 1) {
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x16, 0x202);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8190);
+	} else if (CONFIG_FEC_ENET_DEV == 0) {
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x16, 0x201);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8110);
+	}
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+static struct pmic *pfuze;
+int power_init_board(void)
+{
+	int ret;
+	u32 rev_id, value;
+
+	ret = power_pfuze100_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	pfuze = pmic_get("PFUZE100");
+	if (!pfuze)
+		return -ENODEV;
+
+	ret = pmic_probe(pfuze);
+	if (ret)
+		return ret;
+
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	pmic_reg_read(pfuze, PFUZE100_DEVICEID, &value);
+	pmic_reg_read(pfuze, PFUZE100_REVID, &rev_id);
+	printf("PMIC: PFUZE200! DEV_ID=0x%x REV_ID=0x%x\n", value, rev_id);
+
+	/*
+	 * Our PFUZE0200 is PMPF0200X0AEP, the Pre-programmed OTP
+	 * Configuration is F0.
+	 * Default VOLT:
+	 * VSNVS_VOLT	|	3.0V
+	 * SW1AB	|	1.375V
+	 * SW2		|	3.3V
+	 * SW3A		|	1.5V
+	 * SW3B		|	1.5V
+	 * VGEN1	|	1.5V
+	 * VGEN2	|	1.5V
+	 * VGEN3	|	2.5V
+	 * VGEN4	|	1.8V
+	 * VGEN5	|	2.8V
+	 * VGEN6	|	3.3V
+	 *
+	 * According to schematic, we need SW3A 1.35V, SW3B 3.3V,
+	 * VGEN1 1.2V, VGEN2 1.5V, VGEN3 2.8V, VGEN4 1.8V,
+	 * VGEN5 3.3V, VGEN6 3.0V.
+	 *
+	 * Here we just use the default VOLT, but not configure
+	 * them, when needed, configure them to our requested voltage.
+	 */
+
+	/* set SW1AB standby volatage 1.3V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &value);
+	value &= ~0x3f;
+	value |= PFUZE100_SW1ABC_SETP(13000);
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, value);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &value);
+	value &= ~0xc0;
+	value |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, value);
+
+	/* Enable power of VGEN5 3V3 */
+	pmic_reg_read(pfuze, PFUZE100_VGEN5VOL, &value);
+	value &= ~0x1F;
+	value |= 0x1F;
+	pmic_reg_write(pfuze, PFUZE100_VGEN5VOL, value);
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	int is_400M;
+	u32 vddarm;
+
+	struct pmic *p = pfuze;
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		pmic_reg_read(pfuze, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(12750);
+		pmic_reg_write(pfuze, PFUZE100_SW1ABVOL, value);
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE100_SW1ABC_SETP(10750);
+		else
+			vddarm = PFUZE100_SW1ABC_SETP(11750);
+
+		pmic_reg_read(pfuze, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= vddarm;
+		pmic_reg_write(pfuze, PFUZE100_SW1ABVOL, value);
+
+		finish_anatop_bypass();
+
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+	/*
+	 * This function should be invoked after setup_fec,
+	 * because ENET2_RX_ER conflicts. However, we rarely need
+	 * ENET2_RX_ER for enet, and when use eimnor, we do not
+	 * have sd1/sd2, enet is a must to boot kernel and nfsrootfs.
+	 */
+	setup_eimnor();
+#endif
+
+#ifdef CONFIG_SYS_USE_QSPI
+	board_qspi_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x42, 0x20, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: MX6UL 14X14 LPDDR2 ARM2\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX6_PAD_GPIO1_IO04__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+/*
+ * Leave it here, but default configuration only supports 1 port now,
+ * because we need sd1 and i2c1
+ */
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	/* conflict with i2c1_scl */
+	MX6_PAD_GPIO1_IO02__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* conflict with sd1_vselect */
+	MX6_PAD_GPIO1_IO05__ANATOP_OTG2_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+int board_usb_phy_mode(int port)
+{
+	return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+						 ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+						 ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6ul_14x14_lpddr2_arm2/plugin.S ebf_6ull_uboot/board/freescale/mx6ul_14x14_lpddr2_arm2/plugin.S
--- u-boot-2016.03/board/freescale/mx6ul_14x14_lpddr2_arm2/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ul_14x14_lpddr2_arm2/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6ul_lpddr2_arm2_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x4B4]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4AC]
+	ldr r1, =0x00000028
+	str r1, [r0, #0x27C]
+	str r1, [r0, #0x250]
+	str r1, [r0, #0x24C]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x288]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x270]
+	str r1, [r0, #0x260]
+	str r1, [r0, #0x264]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x4A0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00003028
+	str r1, [r0, #0x280]
+	str r1, [r0, #0x284]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x4B0]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x498]
+	str r1, [r0, #0x4A4]
+	str r1, [r0, #0x244]
+	str r1, [r0, #0x248]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0x1b4700c7
+	str r1, [r0, #0x5C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00470000
+	str r1, [r0, #0x890]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8b8]
+
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	ldr r1, =0xF3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	ldr r1, =0x20000000
+	str r1, [r0, #0x83C]
+	ldr r1, =0x4040484F
+	str r1, [r0, #0x848]
+	ldr r1, =0x40405247
+	str r1, [r0, #0x850]
+	ldr r1, =0x00922012
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8b8]
+
+	ldr r1, =0x00020012
+	str r1, [r0, #0x004]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x008]
+	ldr r1, =0x33374133
+	str r1, [r0, #0x00C]
+	ldr r1, =0x00100A82
+	str r1, [r0, #0x010]
+	ldr r1, =0x00170557
+	str r1, [r0, #0x038]
+	ldr r1, =0x00000093
+	str r1, [r0, #0x014]
+	ldr r1, =0x00001748
+	str r1, [r0, #0x018]
+	ldr r1, =0x00008000
+	str r1, [r0, #0x01C]
+	ldr r1, =0x0F9F0682
+	str r1, [r0, #0x02C]
+	ldr r1, =0x009F0010
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000004F
+	str r1, [r0, #0x040]
+	ldr r1, =0x83100000
+	str r1, [r0, #0x000]
+	ldr r1, =0x00008050
+	str r1, [r0, #0x01C]
+	ldr r1, =0x003F8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0xFF0A8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x82018030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04028030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x01038030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00001800
+	str r1, [r0, #0x020]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x818]
+	ldr r1, =0xA1310003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00025576
+	str r1, [r0, #0x004]
+	ldr r1, =0x00010106
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xFFFFFFFF
+	str r1, [r0, #0x68]
+	str r1, [r0, #0x6C]
+	str r1, [r0, #0x70]
+	str r1, [r0, #0x74]
+	str r1, [r0, #0x78]
+	str r1, [r0, #0x7C]
+	str r1, [r0, #0x80]
+	str r1, [r0, #0x84]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6ul_lpddr2_arm2_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6ull_ddr3_arm2/imximage.cfg ebf_6ull_uboot/board/freescale/mx6ull_ddr3_arm2/imximage.cfg
--- u-boot-2016.03/board/freescale/mx6ull_ddr3_arm2/imximage.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ull_ddr3_arm2/imximage.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6ull_ddr3_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+
+DATA 4 0x020E04B4 0x000C0000
+DATA 4 0x020E04AC 0x00000000
+DATA 4 0x020E027C 0x00000030
+DATA 4 0x020E0250 0x00000030
+DATA 4 0x020E024C 0x00000030
+DATA 4 0x020E0490 0x00000030
+DATA 4 0x020E0288 0x000C0030
+DATA 4 0x020E0270 0x00000000
+DATA 4 0x020E0260 0x00000030
+DATA 4 0x020E0264 0x00000030
+DATA 4 0x020E04A0 0x00000030
+DATA 4 0x020E0494 0x00020000
+DATA 4 0x020E0280 0x00000030
+DATA 4 0x020E0284 0x00000030
+DATA 4 0x020E04B0 0x00020000
+DATA 4 0x020E0498 0x00000030
+DATA 4 0x020E04A4 0x00000030
+DATA 4 0x020E0244 0x00000030
+DATA 4 0x020E0248 0x00000030
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B080C 0x00150019
+DATA 4 0x021B083C 0x41550153
+DATA 4 0x021B0848 0x40403A3E
+DATA 4 0x021B0850 0x40402F2A
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B08C0 0x00944009
+DATA 4 0x021B08b8 0x00000800
+DATA 4 0x021B0004 0x0002002D
+DATA 4 0x021B0008 0x1B333030
+DATA 4 0x021B000C 0x676B52F3
+DATA 4 0x021B0010 0xB66D0B63
+DATA 4 0x021B0014 0x01FF00DB
+DATA 4 0x021B0018 0x00211740
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B002C 0x000026D2
+DATA 4 0x021B0030 0x006B1023
+DATA 4 0x021B0040 0x0000005F
+DATA 4 0x021B0000 0x85180000
+DATA 4 0x021B0890 0x00400000
+DATA 4 0x021B001C 0x02008032
+DATA 4 0x021B001C 0x00008033
+DATA 4 0x021B001C 0x00048031
+DATA 4 0x021B001C 0x15208030
+DATA 4 0x021B001C 0x04008040
+DATA 4 0x021B0020 0x00000800
+DATA 4 0x021B0818 0x00000227
+DATA 4 0x021B0004 0x0002552D
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6ull_ddr3_arm2/Kconfig ebf_6ull_uboot/board/freescale/mx6ull_ddr3_arm2/Kconfig
--- u-boot-2016.03/board/freescale/mx6ull_ddr3_arm2/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ull_ddr3_arm2/Kconfig	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,12 @@
+if TARGET_MX6ULL_DDR3_ARM2
+
+config SYS_BOARD
+       default "mx6ull_ddr3_arm2"
+
+config SYS_VENDOR
+       default "freescale"
+
+config SYS_CONFIG_NAME
+       default "mx6ull_ddr3_arm2"
+
+endif
diff -urN u-boot-2016.03/board/freescale/mx6ull_ddr3_arm2/Makefile ebf_6ull_uboot/board/freescale/mx6ull_ddr3_arm2/Makefile
--- u-boot-2016.03/board/freescale/mx6ull_ddr3_arm2/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ull_ddr3_arm2/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,10 @@
+# (C) Copyright 2016 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6ull_ddr3_arm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6ull_ddr3_arm2/mx6ull_ddr3_arm2.c ebf_6ull_uboot/board/freescale/mx6ull_ddr3_arm2/mx6ull_ddr3_arm2.c
--- u-boot-2016.03/board/freescale/mx6ull_ddr3_arm2/mx6ull_ddr3_arm2.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ull_ddr3_arm2/mx6ull_ddr3_arm2.c	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,1067 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <linux/fb.h>
+#include <miiphy.h>
+#include <mmc.h>
+#include <mxsfb.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include "../common/pfuze.h"
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+#if defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
+#include <asm/imx-common/video.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL_WP (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_HIGH   |                                   \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_120ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define EPDC_PAD_CTRL	0x010b1
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC and EEPROM */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		/* conflict with usb_otg2_pwr */
+		.i2c_mode = MX6_PAD_GPIO1_IO02__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO02__GPIO1_IO02 | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		/* conflict with usb_otg2_oc */
+		.i2c_mode = MX6_PAD_GPIO1_IO03__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO03__GPIO1_IO03 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+#ifdef CONFIG_MX6ULL_DDR3_ARM2_EMMC_REWORK
+static iomux_v3_cfg_t const usdhc1_emmc_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/*
+	 * The following 4 pins conflicts with qspi and nand flash.
+	 * You can comment out the following 4 pins and change
+	 * {USDHC1_BASE_ADDR, 0, 8}  -> {USDHC1_BASE_ADDR, 0, 4}
+	 * to make emmc and qspi coexists.
+	 */
+	MX6_PAD_NAND_READY_B__USDHC1_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CE0_B__USDHC1_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CE1_B__USDHC1_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CLE__USDHC1_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* Default NO WP for emmc, since we use pull down */
+	MX6_PAD_UART1_CTS_B__USDHC1_WP  | MUX_PAD_CTRL(USDHC_PAD_CTRL_WP),
+	/* RST_B */
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#else
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_UART1_CTS_B__USDHC1_WP | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* VSELECT */
+	MX6_PAD_GPIO1_IO05__GPIO1_IO05 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* CD */
+	MX6_PAD_UART1_RTS_B__GPIO1_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* RST_B */
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#endif
+
+#if !defined(CONFIG_SYS_USE_NAND) && !defined(CONFIG_MX6ULL_DDR3_ARM2_QSPIB_REWORK)
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	/* usdhc2_clk, nand_re_b, qspi1b_clk */
+	MX6_PAD_NAND_RE_B__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* usdhc2_cmd, nand_we_b, qspi1b_cs0_b */
+	MX6_PAD_NAND_WE_B__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* usdhc2_data0, nand_data0, qspi1b_cs1_b */
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* usdhc2_data1, nand_data1 */
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* usdhc2_data2, nand_data2, qspi1b_dat0 */
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* usdhc2_data3, nand_data3, qspi1b_dat1 */
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/*
+	 * VSELECT
+	 * Conflicts with WDOG1, so default disabled.
+	 * MX6_PAD_GPIO1_IO08__USDHC2_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	 */
+	/*
+	 * CD
+	 * Share with sdhc1
+	 * MX6_PAD_CSI_MCLK__GPIO4_IO17 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	 */
+	/*
+	 * RST_B
+	 * Pin conflicts with NAND ALE, if want to test nand,
+	 * Connect R169(B), disconnect R169(A).
+	 */
+	MX6_PAD_NAND_ALE__GPIO4_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+static iomux_v3_cfg_t const nand_pads[] = {
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CLE__RAWNAND_CLE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_ALE__RAWNAND_ALE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_CSI_MCLK__RAWNAND_CE2_B   | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_CSI_PIXCLK__RAWNAND_CE3_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DQS__RAWNAND_DQS | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(nand_pads, ARRAY_SIZE(nand_pads));
+
+	setup_gpmi_io_clk((3 << MXC_CCM_CSCDR1_BCH_PODF_OFFSET) |
+			  (3 << MXC_CCM_CSCDR1_GPMI_PODF_OFFSET));
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+static iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX6_PAD_CSI_DATA06__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_CSI_DATA04__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_CSI_DATA07__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+
+	/* CS Pin */
+	MX6_PAD_CSI_DATA05__GPIO4_IO26 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(4, 26), 0);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 26)) : -1;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+/*
+ * pin conflicts for fec1 and fec2, GPIO1_IO06 and GPIO1_IO07 can only
+ * be used for ENET1 or ENET2, cannot be used for both.
+ */
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	/* Pin conflicts with LCD PWM1 */
+	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	/*
+	 * ALT5 mode is only valid when TAMPER pin is used for GPIO.
+	 * This depends on FUSE settings, TAMPER_PIN_DISABLE[1:0].
+	 *
+	 * ENET1_RST
+	 */
+	MX6_PAD_SNVS_TAMPER2__GPIO5_IO02 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART3_TX_DATA__ENET2_RDATA02 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART3_RX_DATA__ENET2_RDATA03 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART3_CTS_B__ENET2_RX_CLK | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART4_TX_DATA__ENET2_TDATA02 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART4_RX_DATA__ENET2_TDATA03 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_CLK__ENET2_TX_CLK | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_UART5_RX_DATA__ENET2_COL | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART5_TX_DATA__ENET2_CRS | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	/*
+	 * ENET2_RST
+	 *
+	 * This depends on FUSE settings, TAMPER_PIN_DISABLE[1:0]
+	 */
+	MX6_PAD_SNVS_TAMPER4__GPIO5_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_fec(int fec_id)
+{
+	if (fec_id == 0) {
+		imx_iomux_v3_setup_multiple_pads(fec1_pads,
+						 ARRAY_SIZE(fec1_pads));
+		gpio_direction_output(IMX_GPIO_NR(5, 2), 0);
+		udelay(50);
+		gpio_direction_output(IMX_GPIO_NR(5, 2), 1);
+	} else {
+		imx_iomux_v3_setup_multiple_pads(fec2_pads,
+						 ARRAY_SIZE(fec2_pads));
+		gpio_direction_output(IMX_GPIO_NR(5, 4), 0);
+		udelay(50);
+		gpio_direction_output(IMX_GPIO_NR(5, 4), 1);
+	}
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_QSPI
+
+#define QSPI_PAD_CTRL1	\
+	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_120ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6_PAD_NAND_WP_B__QSPI_A_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_READY_B__QSPI_A_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CLE__QSPI_A_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DQS__QSPI_A_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA07__QSPI_A_SS1_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+
+#ifdef CONFIG_MX6ULL_DDR3_ARM2_QSPIB_REWORK
+	MX6_PAD_NAND_RE_B__QSPI_B_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_WE_B__QSPI_B_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA00__QSPI_B_SS1_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA02__QSPI_B_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA03__QSPI_B_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA04__QSPI_B_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA05__QSPI_B_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+#endif
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads,
+					 ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(0);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+#ifdef CONFIG_MX6ULL_DDR3_ARM2_EMMC_REWORK
+	/* If want to use qspi, should change to 4 bit width */
+	{USDHC1_BASE_ADDR, 0, 8},
+#else
+	{USDHC1_BASE_ADDR, 0, 4},
+#endif
+#if !defined(CONFIG_SYS_USE_NAND) && !defined(CONFIG_MX6ULL_DDR3_ARM2_QSPIB_REWORK)
+	{USDHC2_BASE_ADDR, 0, 4},
+#endif
+};
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(1, 19)
+#define USDHC1_PWR_GPIO	IMX_GPIO_NR(1, 9)
+#define USDHC1_VSELECT IMX_GPIO_NR(1, 5)
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(4, 10)
+
+int board_mmc_get_env_dev(int devno)
+{
+	return devno;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	return devno;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+#ifdef CONFIG_MX6ULL_DDR3_ARM2_EMMC_REWORK
+		ret = 1;
+#else
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+#endif
+		break;
+#if !defined(CONFIG_SYS_USE_NAND) && !defined(CONFIG_MX6ULL_DDR3_ARM2_QSPIB_REWORK)
+	case USDHC2_BASE_ADDR:
+		ret = 1;
+		break;
+#endif
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+#ifdef CONFIG_MX6ULL_DDR3_ARM2_EMMC_REWORK
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_emmc_pads, ARRAY_SIZE(usdhc1_emmc_pads));
+#else
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+#endif
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			/* 3.3V */
+			gpio_direction_output(USDHC1_VSELECT, 0);
+			gpio_direction_output(USDHC1_PWR_GPIO, 1);
+			break;
+#if !defined(CONFIG_SYS_USE_NAND) && !defined(CONFIG_MX6ULL_DDR3_ARM2_QSPIB_REWORK)
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+#endif
+		default:
+			printf("Warning: you configured more USDHC controllers (%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+			if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD_CLK__LCDIF_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__LCDIF_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__LCDIF_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA18__LCDIF_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA19__LCDIF_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA20__LCDIF_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA21__LCDIF_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA22__LCDIF_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA23__LCDIF_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_RESET__GPIO3_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/*
+	 * PWM1, pin conflicts with ENET1_RX_DATA0
+	 * Use GPIO for Brightness adjustment, duty cycle = period.
+	 */
+	/* MX6_PAD_ENET1_RX_DATA0__GPIO2_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL),*/
+};
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void (*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void do_enable_parallel_lcd(struct display_info_t const *dev)
+{
+	enable_lcdif_clock(dev->bus);
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(3, 4) , 1);
+
+	/* Set Brightness to high */
+	/* gpio_direction_output(IMX_GPIO_NR(2, 0) , 1); */
+}
+
+struct display_info_t const displays[] = {{
+	.bus = MX6ULL_LCDIF1_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 24,
+	.detect = NULL,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name		= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+#endif
+
+#ifdef CONFIG_MXC_EPDC
+static iomux_v3_cfg_t const epdc_enable_pads[] = {
+	MX6_PAD_ENET2_RX_DATA0__EPDC_SDDO08	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_ENET2_RX_DATA1__EPDC_SDDO09	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_ENET2_RX_EN__EPDC_SDDO10	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_ENET2_TX_DATA0__EPDC_SDDO11	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_ENET2_TX_DATA1__EPDC_SDDO12	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_ENET2_TX_EN__EPDC_SDDO13	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_ENET2_TX_CLK__EPDC_SDDO14	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_ENET2_RX_ER__EPDC_SDDO15	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_CLK__EPDC_SDCLK		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_ENABLE__EPDC_SDLE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_HSYNC__EPDC_SDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_VSYNC__EPDC_SDCE0		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_DATA00__EPDC_SDDO00	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_DATA01__EPDC_SDDO01	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_DATA02__EPDC_SDDO02	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_DATA03__EPDC_SDDO03	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_DATA04__EPDC_SDDO04	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_DATA05__EPDC_SDDO05	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_DATA06__EPDC_SDDO06	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_DATA07__EPDC_SDDO07	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__EPDC_SDSHR	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__EPDC_GDRL		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__EPDC_GDCLK	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__EPDC_GDSP		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_LCD_RESET__EPDC_GDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const epdc_disable_pads[] = {
+	MX6_PAD_ENET2_RX_DATA0__GPIO2_IO08,
+	MX6_PAD_ENET2_RX_DATA1__GPIO2_IO09,
+	MX6_PAD_ENET2_RX_EN__GPIO2_IO10,
+	MX6_PAD_ENET2_TX_DATA0__GPIO2_IO11,
+	MX6_PAD_ENET2_TX_DATA1__GPIO2_IO12,
+	MX6_PAD_ENET2_TX_EN__GPIO2_IO13,
+	MX6_PAD_ENET2_TX_CLK__GPIO2_IO14,
+	MX6_PAD_ENET2_RX_ER__GPIO2_IO15,
+	MX6_PAD_LCD_CLK__GPIO3_IO00,
+	MX6_PAD_LCD_ENABLE__GPIO3_IO01,
+	MX6_PAD_LCD_HSYNC__GPIO3_IO02,
+	MX6_PAD_LCD_VSYNC__GPIO3_IO03,
+	MX6_PAD_LCD_DATA00__GPIO3_IO05,
+	MX6_PAD_LCD_DATA01__GPIO3_IO06,
+	MX6_PAD_LCD_DATA02__GPIO3_IO07,
+	MX6_PAD_LCD_DATA03__GPIO3_IO08,
+	MX6_PAD_LCD_DATA04__GPIO3_IO09,
+	MX6_PAD_LCD_DATA05__GPIO3_IO10,
+	MX6_PAD_LCD_DATA06__GPIO3_IO11,
+	MX6_PAD_LCD_DATA07__GPIO3_IO12,
+	MX6_PAD_LCD_DATA14__GPIO3_IO19,
+	MX6_PAD_LCD_DATA15__GPIO3_IO20,
+	MX6_PAD_LCD_DATA16__GPIO3_IO21,
+	MX6_PAD_LCD_DATA17__GPIO3_IO22,
+	MX6_PAD_LCD_RESET__GPIO3_IO04,
+};
+
+vidinfo_t panel_info = {
+	.vl_refresh = 85,
+	.vl_col = 1024,
+	.vl_row = 758,
+	.vl_pixclock = 40000000,
+	.vl_left_margin = 12,
+	.vl_right_margin = 76,
+	.vl_upper_margin = 4,
+	.vl_lower_margin = 5,
+	.vl_hsync = 12,
+	.vl_vsync = 2,
+	.vl_sync = 0,
+	.vl_mode = 0,
+	.vl_flag = 0,
+	.vl_bpix = 3,
+	.cmap = 0,
+};
+
+struct epdc_timing_params panel_timings = {
+	.vscan_holdoff = 4,
+	.sdoed_width = 10,
+	.sdoed_delay = 20,
+	.sdoez_width = 10,
+	.sdoez_delay = 20,
+	.gdclk_hp_offs = 524,
+	.gdsp_offs = 327,
+	.gdoe_offs = 0,
+	.gdclk_offs = 19,
+	.num_ce = 1,
+};
+
+static void setup_epdc_power(void)
+{
+	/* Setup epdc voltage */
+
+	/* EPDC_PWRSTAT - GPIO3[16] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_LCD_DATA11__GPIO3_IO16 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	gpio_direction_input(IMX_GPIO_NR(3, 16));
+
+	/* EPDC_VCOM0 - GPIO3[24] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_LCD_DATA19__GPIO3_IO24 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(3, 24), 1);
+
+	/* EPDC_PWRWAKEUP - GPIO3[14] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_LCD_DATA09__GPIO3_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(3, 14), 1);
+
+	/* EPDC_PWRCTRL0 - GPIO3[17] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_LCD_DATA12__GPIO3_IO17 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(3, 17), 1);
+}
+
+static void epdc_enable_pins(void)
+{
+	/* epdc iomux settings */
+	imx_iomux_v3_setup_multiple_pads(epdc_enable_pads,
+				ARRAY_SIZE(epdc_enable_pads));
+}
+
+static void epdc_disable_pins(void)
+{
+	/* Configure MUX settings for EPDC pins to GPIO  and drive to 0 */
+	imx_iomux_v3_setup_multiple_pads(epdc_disable_pads,
+				ARRAY_SIZE(epdc_disable_pads));
+}
+
+static void setup_epdc(void)
+{
+	/*** epdc Maxim PMIC settings ***/
+
+	/* EPDC_PWRSTAT - GPIO3[16] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_LCD_DATA11__GPIO3_IO16 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_VCOM0 - GPIO3[24] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_LCD_DATA19__GPIO3_IO24 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRWAKEUP - GPIO3[14] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_LCD_DATA09__GPIO3_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRCTRL0 - GPIO3[17] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_LCD_DATA12__GPIO3_IO17 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set pixel clock rates for EPDC in clock.c */
+
+	panel_info.epdc_data.wv_modes.mode_init = 0;
+	panel_info.epdc_data.wv_modes.mode_du = 1;
+	panel_info.epdc_data.wv_modes.mode_gc4 = 3;
+	panel_info.epdc_data.wv_modes.mode_gc8 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc16 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc32 = 2;
+
+	panel_info.epdc_data.epdc_timings = panel_timings;
+
+	setup_epdc_power();
+}
+
+void epdc_power_on(void)
+{
+	unsigned int reg;
+	struct gpio_regs *gpio_regs = (struct gpio_regs *)GPIO3_BASE_ADDR;
+
+	/* Set EPD_PWR_CTL0 to high - enable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(3, 17), 1);
+	udelay(1000);
+
+	/* Enable epdc signal pin */
+	epdc_enable_pins();
+
+	/* Set PMIC Wakeup to high - enable Display power */
+	gpio_set_value(IMX_GPIO_NR(3, 14), 1);
+
+	/* Wait for PWRGOOD == 1 */
+	while (1) {
+		reg = readl(&gpio_regs->gpio_psr);
+		if (!(reg & (1 << 16)))
+			break;
+
+		udelay(100);
+	}
+
+	/* Enable VCOM */
+	gpio_set_value(IMX_GPIO_NR(3, 24), 1);
+
+	udelay(500);
+}
+
+void epdc_power_off(void)
+{
+	/* Set PMIC Wakeup to low - disable Display power */
+	gpio_set_value(IMX_GPIO_NR(3, 14), 0);
+
+	/* Disable VCOM */
+	gpio_set_value(IMX_GPIO_NR(3, 24), 0);
+
+	epdc_disable_pins();
+
+	/* Set EPD_PWR_CTL0 to low - disable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(3, 17), 0);
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
+
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC%d MXC: %s:failed\n", CONFIG_FEC_ENET_DEV, __func__);
+
+	return 0;
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *)IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	if (0 == fec_id) {
+		/*
+		 * Use 50M anatop loopback REF_CLK1 for ENET1,
+		 * clear gpr1[13], set gpr1[17]
+		 */
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK,
+				IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK);
+		ret = enable_fec_anatop_clock(fec_id, ENET_50MHZ);
+		if (ret)
+			return ret;
+
+	} else {
+		/* clk from phy, set gpr1[14], clear gpr1[18]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC2_MASK,
+				IOMUX_GPR1_FEC2_CLOCK_MUX2_SEL_MASK);
+	}
+
+	enable_enet_clk(1);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (CONFIG_FEC_ENET_DEV == 0) {
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x16, 0x202);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8190);
+	} else if (CONFIG_FEC_ENET_DEV == 1) {
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x16, 0x201);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8110);
+	}
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+static struct pmic *pfuze;
+int power_init_board(void)
+{
+	int ret;
+	u32 rev_id, value;
+
+	ret = power_pfuze100_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	pfuze = pmic_get("PFUZE100");
+	if (!pfuze)
+		return -ENODEV;
+
+	ret = pmic_probe(pfuze);
+	if (ret)
+		return ret;
+
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	pmic_reg_read(pfuze, PFUZE100_DEVICEID, &value);
+	pmic_reg_read(pfuze, PFUZE100_REVID, &rev_id);
+	printf("PMIC: PFUZE200! DEV_ID=0x%x REV_ID=0x%x\n", value, rev_id);
+
+	/*
+	 * Our PFUZE0200 is PMPF0200X0AEP, the Pre-programmed OTP
+	 * Configuration is F0.
+	 * Default VOLT:
+	 * VSNVS_VOLT	|	3.0V
+	 * SW1AB	|	1.375V
+	 * SW2		|	3.3V
+	 * SW3A		|	1.5V
+	 * SW3B		|	1.5V
+	 * VGEN1	|	1.5V
+	 * VGEN2	|	1.5V
+	 * VGEN3	|	2.5V
+	 * VGEN4	|	1.8V
+	 * VGEN5	|	2.8V
+	 * VGEN6	|	3.3V
+	 *
+	 * According to schematic, we need SW3A 1.35V, SW3B 3.3V,
+	 * VGEN1 1.2V, VGEN2 1.5V, VGEN3 2.8V, VGEN4 1.8V,
+	 * VGEN5 3.3V, VGEN6 3.0V.
+	 *
+	 * Here we just use the default VOLT, but not configure
+	 * them, when needed, configure them to our requested voltage.
+	 */
+
+	/* set SW1AB standby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &value);
+	value &= ~0x3f;
+	value |= PFUZE100_SW1ABC_SETP(9750);
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, value);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &value);
+	value &= ~0xc0;
+	value |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, value);
+
+	/* Enable power of VGEN5 3V3 */
+	pmic_reg_read(pfuze, PFUZE100_VGEN5VOL, &value);
+	value &= ~0x1F;
+	value |= 0x1F;
+	pmic_reg_write(pfuze, PFUZE100_VGEN5VOL, value);
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	int is_400M;
+	u32 vddarm;
+
+	struct pmic *p = pfuze;
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		pmic_reg_read(pfuze, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(12750);
+		pmic_reg_write(pfuze, PFUZE100_SW1ABVOL, value);
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE100_SW1ABC_SETP(10750);
+		else
+			vddarm = PFUZE100_SW1ABC_SETP(11750);
+
+		pmic_reg_read(pfuze, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= vddarm;
+		pmic_reg_write(pfuze, PFUZE100_SW1ABVOL, value);
+
+		finish_anatop_bypass();
+
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_SYS_USE_QSPI
+	board_qspi_init();
+#endif
+
+#ifdef	CONFIG_MXC_EPDC
+	enable_epdc_clock();
+	setup_epdc();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x42, 0x20, 0x00, 0x00)},
+	{"qspi1", MAKE_CFGVAL(0x10, 0x00, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: MX6ULL 14X14 DDR3 ARM2\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX6_PAD_GPIO1_IO04__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+/*
+ * Leave it here, but default configuration only supports 1 port now,
+ * because we need sd1 and i2c1
+ */
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	/* conflict with i2c1_scl */
+	MX6_PAD_GPIO1_IO02__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* conflict with sd1_vselect */
+	MX6_PAD_GPIO1_IO05__ANATOP_OTG2_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+int board_usb_phy_mode(int port)
+{
+	return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+						 ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+						 ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6ull_ddr3_arm2/plugin.S ebf_6ull_uboot/board/freescale/mx6ull_ddr3_arm2/plugin.S
--- u-boot-2016.03/board/freescale/mx6ull_ddr3_arm2/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ull_ddr3_arm2/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6ull_ddr3_arm2_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000C0000
+	str r1, [r0, #0x4B4]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4AC]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x27C]
+	str r1, [r0, #0x250]
+	str r1, [r0, #0x24C]
+	str r1, [r0, #0x490]
+	ldr r1, =0x000C0030
+	str r1, [r0, #0x288]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x270]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x260]
+	str r1, [r0, #0x264]
+	str r1, [r0, #0x4A0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x280]
+	str r1, [r0, #0x284]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x4B0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x498]
+	str r1, [r0, #0x4A4]
+	str r1, [r0, #0x244]
+	str r1, [r0, #0x248]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00150019
+	str r1, [r0, #0x80C]
+	ldr r1, =0x41550153
+	str r1, [r0, #0x83C]
+	ldr r1, =0x40403A3E
+	str r1, [r0, #0x848]
+	ldr r1, =0x40402F2A
+	str r1, [r0, #0x850]
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	ldr r1, =0xF3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	ldr r1, =0x00944009
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+	ldr r1, =0x0002002D
+	str r1, [r0, #0x004]
+	ldr r1, =0x1B333030
+	str r1, [r0, #0x008]
+	ldr r1, =0x676B52F3
+	str r1, [r0, #0x00C]
+	ldr r1, =0xB66D0B63
+	str r1, [r0, #0x010]
+	ldr r1, =0x01FF00DB
+	str r1, [r0, #0x014]
+	ldr r1, =0x00211740
+	str r1, [r0, #0x018]
+	ldr r1, =0x00008000
+	str r1, [r0, #0x01C]
+	ldr r1, =0x000026D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x006B1023
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000005F
+	str r1, [r0, #0x040]
+	ldr r1, =0x85180000
+	str r1, [r0, #0x000]
+	ldr r1, =0x00400000
+	str r1, [r0, #0x890]
+	ldr r1, =0x02008032
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00008033
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00048031
+	str r1, [r0, #0x01C]
+	ldr r1, =0x15208030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04008040
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x020]
+	ldr r1, =0x00000227
+	str r1, [r0, #0x818]
+	ldr r1, =0x0002552D
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xFFFFFFFF
+	str r1, [r0, #0x68]
+	str r1, [r0, #0x6C]
+	str r1, [r0, #0x70]
+	str r1, [r0, #0x74]
+	str r1, [r0, #0x78]
+	str r1, [r0, #0x7C]
+	str r1, [r0, #0x80]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6ull_ddr3_arm2_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6ullevk/imximage.cfg ebf_6ull_uboot/board/freescale/mx6ullevk/imximage.cfg
--- u-boot-2016.03/board/freescale/mx6ullevk/imximage.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ullevk/imximage.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6ullevk/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+
+DATA 4 0x020E04B4 0x000C0000
+DATA 4 0x020E04AC 0x00000000
+DATA 4 0x020E027C 0x00000030
+DATA 4 0x020E0250 0x00000030
+DATA 4 0x020E024C 0x00000030
+DATA 4 0x020E0490 0x00000030
+DATA 4 0x020E0288 0x000C0030
+DATA 4 0x020E0270 0x00000000
+DATA 4 0x020E0260 0x00000030
+DATA 4 0x020E0264 0x00000030
+DATA 4 0x020E04A0 0x00000030
+DATA 4 0x020E0494 0x00020000
+DATA 4 0x020E0280 0x00000030
+DATA 4 0x020E0284 0x00000030
+DATA 4 0x020E04B0 0x00020000
+DATA 4 0x020E0498 0x00000030
+DATA 4 0x020E04A4 0x00000030
+DATA 4 0x020E0244 0x00000030
+DATA 4 0x020E0248 0x00000030
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B080C 0x00000004
+DATA 4 0x021B083C 0x41640158
+DATA 4 0x021B0848 0x40403237
+DATA 4 0x021B0850 0x40403C33
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B08C0 0x00944009
+DATA 4 0x021B08b8 0x00000800
+DATA 4 0x021B0004 0x0002002D
+DATA 4 0x021B0008 0x1B333030
+DATA 4 0x021B000C 0x676B52F3
+DATA 4 0x021B0010 0xB66D0B63
+DATA 4 0x021B0014 0x01FF00DB
+DATA 4 0x021B0018 0x00201740
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B002C 0x000026D2
+DATA 4 0x021B0030 0x006B1023
+DATA 4 0x021B0040 0x0000004F
+DATA 4 0x021B0000 0x84180000
+DATA 4 0x021B0890 0x00400000
+DATA 4 0x021B001C 0x02008032
+DATA 4 0x021B001C 0x00008033
+DATA 4 0x021B001C 0x00048031
+DATA 4 0x021B001C 0x15208030
+DATA 4 0x021B001C 0x04008040
+DATA 4 0x021B0020 0x00000800
+DATA 4 0x021B0818 0x00000227
+DATA 4 0x021B0004 0x0002552D
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6ullevk/imximage_lpddr2.cfg ebf_6ull_uboot/board/freescale/mx6ullevk/imximage_lpddr2.cfg
--- u-boot-2016.03/board/freescale/mx6ullevk/imximage_lpddr2.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ullevk/imximage_lpddr2.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6ullevk/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+
+DATA 4 0x020E04B4 0x00080000
+DATA 4 0x020E04AC 0x00000000
+DATA 4 0x020E027C 0x00000030
+DATA 4 0x020E0250 0x00000030
+DATA 4 0x020E024C 0x00000030
+DATA 4 0x020E0490 0x00000030
+DATA 4 0x020E0288 0x00000030
+DATA 4 0x020E0270 0x00000000
+DATA 4 0x020E0260 0x00000000
+DATA 4 0x020E0264 0x00000000
+DATA 4 0x020E04A0 0x00000030
+DATA 4 0x020E0494 0x00020000
+DATA 4 0x020E0280 0x00003030
+DATA 4 0x020E0284 0x00003030
+DATA 4 0x020E04B0 0x00020000
+DATA 4 0x020E0498 0x00000030
+DATA 4 0x020E04A4 0x00000030
+DATA 4 0x020E0244 0x00000030
+DATA 4 0x020E0248 0x00000030
+
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B085C 0x1b4700c7
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B0890 0x23400A38
+DATA 4 0x021B08b8 0x00000800
+
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B083C 0x20000000
+DATA 4 0x021B0848 0x40403439
+DATA 4 0x021B0850 0x4040342D
+DATA 4 0x021B08C0 0x00921012
+DATA 4 0x021B08b8 0x00000800
+
+DATA 4 0x021B0004 0x00020052
+DATA 4 0x021B0008 0x00000000
+DATA 4 0x021B000C 0x33374133
+DATA 4 0x021B0010 0x00100A82
+DATA 4 0x021B0038 0x00170557
+DATA 4 0x021B0014 0x00000093
+DATA 4 0x021B0018 0x00201748
+DATA 4 0x021B002C 0x0F9F26D2
+DATA 4 0x021B0030 0x009F0010
+DATA 4 0x021B0040 0x00000047
+DATA 4 0x021B0000 0x83100000
+DATA 4 0x021B001C 0x00008050
+DATA 4 0x021B001C 0x003F8030
+DATA 4 0x021B001C 0xFF0A8030
+DATA 4 0x021B001C 0x82018030
+DATA 4 0x021B001C 0x04028030
+DATA 4 0x021B001C 0x01038030
+DATA 4 0x021B0020 0x00001800
+DATA 4 0x021B0818 0x00000000
+DATA 4 0x021B0800 0xA1310003
+DATA 4 0x021B0004 0x00025552
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6ullevk/Kconfig ebf_6ull_uboot/board/freescale/mx6ullevk/Kconfig
--- u-boot-2016.03/board/freescale/mx6ullevk/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ullevk/Kconfig	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,12 @@
+if TARGET_MX6ULL_14X14_EVK || TARGET_MX6ULL_9X9_EVK
+
+config SYS_BOARD
+	default "mx6ullevk"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_CONFIG_NAME
+	default "mx6ullevk"
+
+endif
diff -urN u-boot-2016.03/board/freescale/mx6ullevk/MAINTAINERS ebf_6ull_uboot/board/freescale/mx6ullevk/MAINTAINERS
--- u-boot-2016.03/board/freescale/mx6ullevk/MAINTAINERS	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ullevk/MAINTAINERS	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,7 @@
+MX6ULLEVK BOARD
+M:	Peng Fan <peng.fan@nxp.com>
+S:	Maintained
+F:	board/freescale/mx6ullevk/
+F:	include/configs/mx6ullevk.h
+F:	configs/mx6ull_14x14_evk_defconfig
+F:	configs/mx6ull_9x9_evk_defconfig
diff -urN u-boot-2016.03/board/freescale/mx6ullevk/Makefile ebf_6ull_uboot/board/freescale/mx6ullevk/Makefile
--- u-boot-2016.03/board/freescale/mx6ullevk/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ullevk/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,10 @@
+# (C) Copyright 2015 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6ullevk.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx6ullevk/mx6ullevk.c ebf_6ull_uboot/board/freescale/mx6ullevk/mx6ullevk.c
--- u-boot-2016.03/board/freescale/mx6ullevk/mx6ullevk.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ullevk/mx6ullevk.c	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,1192 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <linux/sizes.h>
+#include <mmc.h>
+#include <mxsfb.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze3000_pmic.h>
+#include "../common/pfuze.h"
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+#include <asm/imx-common/video.h>
+
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_DAT3_CD_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |	\
+	PAD_CTL_PUS_100K_DOWN  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_HIGH   |                                  \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define MDIO_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST | PAD_CTL_ODE)
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define IOX_SDI IMX_GPIO_NR(5, 10)
+#define IOX_STCP IMX_GPIO_NR(5, 7)
+#define IOX_SHCP IMX_GPIO_NR(5, 11)
+#define IOX_OE IMX_GPIO_NR(5, 8)
+
+static iomux_v3_cfg_t const iox_pads[] = {
+	/* IOX_SDI */
+	MX6_PAD_BOOT_MODE0__GPIO5_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* IOX_SHCP */
+	MX6_PAD_BOOT_MODE1__GPIO5_IO11 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* IOX_STCP */
+	MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* IOX_nOE */
+	MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+/*
+ * HDMI_nRST --> Q0
+ * ENET1_nRST --> Q1
+ * ENET2_nRST --> Q2
+ * CAN1_2_STBY --> Q3
+ * BT_nPWD --> Q4
+ * CSI_RST --> Q5
+ * CSI_PWDN --> Q6
+ * LCD_nPWREN --> Q7
+ */
+enum qn {
+	HDMI_NRST,
+	ENET1_NRST,
+	ENET2_NRST,
+	CAN1_2_STBY,
+	BT_NPWD,
+	CSI_RST,
+	CSI_PWDN,
+	LCD_NPWREN,
+};
+
+enum qn_func {
+	qn_reset,
+	qn_enable,
+	qn_disable,
+};
+
+enum qn_level {
+	qn_low = 0,
+	qn_high = 1,
+};
+
+static enum qn_level seq[3][2] = {
+	{0, 1}, {1, 1}, {0, 0}
+};
+
+static enum qn_func qn_output[8] = {
+	qn_reset, qn_reset, qn_reset, qn_enable, qn_disable, qn_reset,
+	qn_disable, qn_disable
+};
+
+static void iox74lv_init(void)
+{
+	int i;
+
+	gpio_direction_output(IOX_OE, 0);
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+		gpio_direction_output(IOX_SDI, seq[qn_output[i]][0]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	 * shift register will be output to pins
+	 */
+	gpio_direction_output(IOX_STCP, 1);
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+		gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	 * shift register will be output to pins
+	 */
+	gpio_direction_output(IOX_STCP, 1);
+};
+
+void iox74lv_set(int index)
+{
+	int i;
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+
+		if (i == index)
+			gpio_direction_output(IOX_SDI, seq[qn_output[i]][0]);
+		else
+			gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+		gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+};
+
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC and EEPROM */
+static struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode =  MX6_PAD_UART4_TX_DATA__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_UART4_TX_DATA__GPIO1_IO28 | PC,
+		.gp = IMX_GPIO_NR(1, 28),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_UART4_RX_DATA__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_UART4_RX_DATA__GPIO1_IO29 | PC,
+		.gp = IMX_GPIO_NR(1, 29),
+	},
+};
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC       0
+int power_init_board(void)
+{
+	if (is_mx6ull_9x9_evk()) {
+		struct pmic *pfuze;
+		int ret;
+		unsigned int reg, rev_id;
+
+		ret = power_pfuze3000_init(I2C_PMIC);
+		if (ret)
+			return ret;
+
+		pfuze = pmic_get("PFUZE3000");
+		ret = pmic_probe(pfuze);
+		if (ret)
+			return ret;
+
+		pmic_reg_read(pfuze, PFUZE3000_DEVICEID, &reg);
+		pmic_reg_read(pfuze, PFUZE3000_REVID, &rev_id);
+		printf("PMIC: PFUZE3000 DEV_ID=0x%x REV_ID=0x%x\n",
+		       reg, rev_id);
+
+		/* disable Low Power Mode during standby mode */
+		pmic_reg_read(pfuze, PFUZE3000_LDOGCTL, &reg);
+		reg |= 0x1;
+		pmic_reg_write(pfuze, PFUZE3000_LDOGCTL, reg);
+
+		/* SW1B step ramp up time from 2us to 4us/25mV */
+		reg = 0x40;
+		pmic_reg_write(pfuze, PFUZE3000_SW1BCONF, reg);
+
+		/* SW1B mode to APS/PFM */
+		reg = 0xc;
+		pmic_reg_write(pfuze, PFUZE3000_SW1BMODE, reg);
+
+		/* SW1B standby voltage set to 0.975V */
+		reg = 0xb;
+		pmic_reg_write(pfuze, PFUZE3000_SW1BSTBY, reg);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	u32 vddarm;
+
+	struct pmic *p = pmic_get("PFUZE3000");
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		pmic_reg_read(p, PFUZE3000_SW1BVOLT, &value);
+		value &= ~0x1f;
+		value |= PFUZE3000_SW1AB_SETP(1275);
+		pmic_reg_write(p, PFUZE3000_SW1BVOLT, value);
+
+		set_anatop_bypass(1);
+		vddarm = PFUZE3000_SW1AB_SETP(1175);
+
+		pmic_reg_read(p, PFUZE3000_SW1BVOLT, &value);
+		value &= ~0x1f;
+		value |= vddarm;
+		pmic_reg_write(p, PFUZE3000_SW1BVOLT, value);
+
+		finish_anatop_bypass();
+
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+#endif
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = imx_ddr_size();
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* VSELECT */
+	MX6_PAD_GPIO1_IO05__USDHC1_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* CD */
+	MX6_PAD_UART1_RTS_B__GPIO1_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* RST_B */
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+/*
+ * mx6ull_14x14_evk board default supports sd card. If want to use
+ * EMMC, need to do board rework for sd2.
+ * Introduce CONFIG_MX6ULL_EVK_EMMC_REWORK, if sd2 reworked to support
+ * emmc, need to define this macro.
+ */
+#if defined(CONFIG_MX6ULL_EVK_EMMC_REWORK)
+static iomux_v3_cfg_t const usdhc2_emmc_pads[] = {
+	MX6_PAD_NAND_RE_B__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_WE_B__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA04__USDHC2_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA05__USDHC2_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA06__USDHC2_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA07__USDHC2_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/*
+	 * RST_B
+	 */
+	MX6_PAD_NAND_ALE__GPIO4_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#else
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_NAND_RE_B__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_WE_B__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_cd_pads[] = {
+	/*
+	 * The evk board uses DAT3 to detect CD card plugin,
+	 * in u-boot we mux the pin to GPIO when doing board_mmc_getcd.
+	 */
+	MX6_PAD_NAND_DATA03__GPIO4_IO05 | MUX_PAD_CTRL(USDHC_DAT3_CD_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_dat3_pads[] = {
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3 |
+	MUX_PAD_CTRL(USDHC_DAT3_CD_PAD_CTRL),
+};
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_QSPI
+
+#define QSPI_PAD_CTRL1	\
+	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_120ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6_PAD_NAND_WP_B__QSPI_A_SCLK | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_READY_B__QSPI_A_DATA00 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CLE__QSPI_A_DATA03 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DQS__QSPI_A_SS0_B | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+};
+
+static int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads,
+					 ARRAY_SIZE(quadspi_pads));
+	/* Set the clock */
+	enable_qspi_clk(0);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC1_BASE_ADDR, 0, 4},
+#if defined(CONFIG_MX6ULL_EVK_EMMC_REWORK)
+	{USDHC2_BASE_ADDR, 0, 8},
+#else
+	{USDHC2_BASE_ADDR, 0, 4},
+#endif
+};
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(1, 19)
+#define USDHC1_PWR_GPIO	IMX_GPIO_NR(1, 9)
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(4, 5)
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(4, 10)
+
+int board_mmc_get_env_dev(int devno)
+{
+	if (devno == 1 && mx6_esdhc_fused(USDHC1_BASE_ADDR))
+		devno = 0;
+
+	return devno;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	if (devno == 0 && mx6_esdhc_fused(USDHC1_BASE_ADDR))
+		devno = 1;
+
+	return devno;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	case USDHC2_BASE_ADDR:
+#if defined(CONFIG_MX6ULL_EVK_EMMC_REWORK)
+		ret = 1;
+#else
+		imx_iomux_v3_setup_multiple_pads(usdhc2_cd_pads,
+						 ARRAY_SIZE(usdhc2_cd_pads));
+		gpio_direction_input(USDHC2_CD_GPIO);
+
+		/*
+		 * Since it is the DAT3 pin, this pin is pulled to
+		 * low voltage if no card
+		 */
+		ret = gpio_get_value(USDHC2_CD_GPIO);
+
+		imx_iomux_v3_setup_multiple_pads(usdhc2_dat3_pads,
+						 ARRAY_SIZE(usdhc2_dat3_pads));
+#endif
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+#ifdef CONFIG_SPL_BUILD
+#if defined(CONFIG_MX6ULL_EVK_EMMC_REWORK)
+	imx_iomux_v3_setup_multiple_pads(usdhc2_emmc_pads,
+					 ARRAY_SIZE(usdhc2_emmc_pads));
+#else
+	imx_iomux_v3_setup_multiple_pads(usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+#endif
+	gpio_direction_output(USDHC2_PWR_GPIO, 0);
+	udelay(500);
+	gpio_direction_output(USDHC2_PWR_GPIO, 1);
+	usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+	return fsl_esdhc_initialize(bis, &usdhc_cfg[1]);
+#else
+	int i, ret;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+
+			gpio_direction_output(USDHC1_PWR_GPIO, 0);
+			udelay(500);
+			gpio_direction_output(USDHC1_PWR_GPIO, 1);
+			break;
+		case 1:
+#if defined(CONFIG_MX6ULL_EVK_EMMC_REWORK)
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_emmc_pads, ARRAY_SIZE(usdhc2_emmc_pads));
+#else
+#ifndef CONFIG_SYS_USE_NAND
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+#endif
+#endif
+			gpio_direction_output(USDHC2_PWR_GPIO, 0);
+			udelay(500);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers (%d) than supported by the board\n", i + 1);
+			return -EINVAL;
+			}
+
+			ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+			if (ret) {
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+			}
+	}
+#endif
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+static iomux_v3_cfg_t const usb_otg_pads[] = {
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+/* At default the 3v3 enables the MIC2026 for VBUS power */
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+					 ARRAY_SIZE(usb_otg_pads));
+}
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_NAND_MXS
+static iomux_v3_cfg_t const nand_pads[] = {
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CLE__RAWNAND_CLE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_ALE__RAWNAND_ALE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DQS__RAWNAND_DQS | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(nand_pads, ARRAY_SIZE(nand_pads));
+
+	setup_gpmi_io_clk((3 << MXC_CCM_CSCDR1_BCH_PODF_OFFSET) |
+			  (3 << MXC_CCM_CSCDR1_GPMI_PODF_OFFSET));
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+/*
+ * pin conflicts for fec1 and fec2, GPIO1_IO06 and GPIO1_IO07 can only
+ * be used for ENET1 or ENET2, cannot be used for both.
+ */
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static void setup_iomux_fec(int fec_id)
+{
+	if (fec_id == 0)
+		imx_iomux_v3_setup_multiple_pads(fec1_pads,
+						 ARRAY_SIZE(fec1_pads));
+	else
+		imx_iomux_v3_setup_multiple_pads(fec2_pads,
+						 ARRAY_SIZE(fec2_pads));
+}
+
+int board_eth_init(bd_t *bis)
+{
+	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
+
+	return fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
+				       CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc *const iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int ret;
+
+	if (fec_id == 0) {
+		/*
+		 * Use 50M anatop loopback REF_CLK1 for ENET1,
+		 * clear gpr1[13], set gpr1[17].
+		 */
+		clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC1_MASK,
+				IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK);
+	} else {
+		/*
+		 * Use 50M anatop loopback REF_CLK2 for ENET2,
+		 * clear gpr1[14], set gpr1[18].
+		 */
+		clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC2_MASK,
+				IOMUX_GPR1_FEC2_CLOCK_MUX1_SEL_MASK);
+	}
+
+	ret = enable_fec_anatop_clock(fec_id, ENET_50MHZ);
+	if (ret)
+		return ret;
+
+	enable_enet_clk(1);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8190);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD_CLK__LCDIF_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__LCDIF_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__LCDIF_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA18__LCDIF_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA19__LCDIF_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA20__LCDIF_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA21__LCDIF_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA22__LCDIF_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA23__LCDIF_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+
+	/* LCD_RST */
+	//MX6_PAD_SNVS_TAMPER9__GPIO5_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),// pengjie 0717
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period. */
+	MX6_PAD_GPIO1_IO08__GPIO1_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void do_enable_parallel_lcd(struct display_info_t const *dev)
+{
+	//enable_lcdif_clock(dev->bus);
+
+	//imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Reset the LCD */
+	//gpio_direction_output(IMX_GPIO_NR(5, 9) , 0);// pengjie 0717
+	//udelay(500);
+	//gpio_direction_output(IMX_GPIO_NR(5, 9) , 1);// pengjie 0717
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(1, 8) , 0);
+}
+
+struct display_info_t const displays[] = {{
+        .bus = MX6UL_LCDIF1_BASE_ADDR,
+        .addr = 0,
+        .pixfmt = 24,
+        .detect = NULL,
+        .enable = do_enable_parallel_lcd,
+        .mode   = {
+                .name                   = "TFT43AB",
+                .xres           = 480,
+                .yres           = 272,
+                .pixclock       = 108695,
+                .left_margin    = 8,
+                .right_margin   = 4,
+                .upper_margin   = 2,
+                .lower_margin   = 4,
+                .hsync_len      = 41,
+                .vsync_len      = 10,
+                .sync           = 0,
+                .vmode          = FB_VMODE_NONINTERLACED
+                   }
+        },
+
+        {
+        .bus = MX6UL_LCDIF1_BASE_ADDR,
+        .addr = 0,
+        .pixfmt = 24,
+        .detect = NULL,
+        .enable = do_enable_parallel_lcd,
+        .mode   = {
+                .name           = "TFT50AB",
+                .xres           = 800,
+                .yres           = 480,
+                .pixclock       = 108695,
+                .left_margin    = 46,
+                .right_margin   = 22,
+                .upper_margin   = 23,
+                .lower_margin   = 22,
+                .hsync_len      = 1,
+                .vsync_len      = 1,
+                .sync           = 0,
+                .vmode          = FB_VMODE_NONINTERLACED
+                   }
+        },
+
+        {
+        .bus = MX6UL_LCDIF1_BASE_ADDR,
+        .addr = 0,
+        .pixfmt = 24,
+        .detect = NULL,
+        .enable = do_enable_parallel_lcd,
+        .mode   = {
+                .name           = "TFT70AB",
+                .xres           = 800,
+                .yres           = 480,
+                .pixclock       = 108695,
+                .left_margin    = 46,
+                .right_margin   = 22,
+                .upper_margin   = 23,
+                .lower_margin   = 22,
+                .hsync_len      = 1,
+                .vsync_len      = 1,
+                .sync           = 0,
+                .vmode          = FB_VMODE_NONINTERLACED
+                   }
+        }
+
+};
+
+size_t display_count = ARRAY_SIZE(displays);
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	imx_iomux_v3_setup_multiple_pads(iox_pads, ARRAY_SIZE(iox_pads));
+
+	iox74lv_init();
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+#endif
+
+#ifdef	CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	board_qspi_init();
+#endif
+
+#ifdef CONFIG_NAND_MXS
+	setup_gpmi_nand();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x42, 0x20, 0x00, 0x00)},
+	{"sd2", MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	{"qspi1", MAKE_CFGVAL(0x10, 0x00, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	setenv("board_name", "EVK");
+
+	if (is_mx6ull_9x9_evk())
+		setenv("board_rev", "9X9");
+	else
+		setenv("board_rev", "14X14");
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	if (is_mx6ull_9x9_evk())
+		puts("Board: MX6ULL 9x9 EVK\n");
+	else
+		puts("Board: MX6ULL 14x14 EVK\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_FSL_FASTBOOT
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "nand");
+		if (!getenv("fbparts"))
+			setenv("fbparts", ANDROID_FASTBOOT_NAND_PARTS);
+		if (!getenv("bootcmd"))
+			setenv("bootcmd",
+				"nand read ${loadaddr} ${boot_nand_offset} "
+				"${boot_nand_size};boota ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+int check_recovery_cmd_file(void)
+{
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	return recovery_mode;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc0 recovery");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc1 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"nand read ${loadaddr} ${recovery_nand_offset} "
+				"${recovery_nand_size};boota ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+#ifdef CONFIG_SPL_BUILD
+#include <libfdt.h>
+#include <spl.h>
+#include <asm/arch/mx6-ddr.h>
+
+
+static struct mx6ul_iomux_grp_regs mx6_grp_ioregs = {
+	.grp_addds = 0x00000030,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_b0ds = 0x00000030,
+	.grp_ctlds = 0x00000030,
+	.grp_b1ds = 0x00000030,
+	.grp_ddrpke = 0x00000000,
+	.grp_ddrmode = 0x00020000,
+#ifdef CONFIG_TARGET_MX6UL_9X9_EVK
+	.grp_ddr_type = 0x00080000,
+#else
+	.grp_ddr_type = 0x000c0000,
+#endif
+};
+
+#ifdef CONFIG_TARGET_MX6UL_9X9_EVK
+static struct mx6ul_iomux_ddr_regs mx6_ddr_ioregs = {
+	.dram_dqm0 = 0x00000030,
+	.dram_dqm1 = 0x00000030,
+	.dram_ras = 0x00000030,
+	.dram_cas = 0x00000030,
+	.dram_odt0 = 0x00000000,
+	.dram_odt1 = 0x00000000,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdclk_0 = 0x00000030,
+	.dram_sdqs0 = 0x00003030,
+	.dram_sdqs1 = 0x00003030,
+	.dram_reset = 0x00000030,
+};
+
+static struct mx6_mmdc_calibration mx6_mmcd_calib = {
+	.p0_mpwldectrl0 = 0x00000000,
+	.p0_mpdgctrl0 = 0x20000000,
+	.p0_mprddlctl = 0x4040484f,
+	.p0_mpwrdlctl = 0x40405247,
+	.mpzqlp2ctl = 0x1b4700c7,
+};
+
+static struct mx6_lpddr2_cfg mem_ddr = {
+	.mem_speed = 800,
+	.density = 2,
+	.width = 16,
+	.banks = 4,
+	.rowaddr = 14,
+	.coladdr = 10,
+	.trcd_lp = 1500,
+	.trppb_lp = 1500,
+	.trpab_lp = 2000,
+	.trasmin = 4250,
+};
+
+struct mx6_ddr_sysinfo ddr_sysinfo = {
+	.dsize = 0,
+	.cs_density = 18,
+	.ncs = 1,
+	.cs1_mirror = 0,
+	.walat = 0,
+	.ralat = 5,
+	.mif3_mode = 3,
+	.bi_on = 1,
+	.rtt_wr = 0,        /* LPDDR2 does not need rtt_wr rtt_nom */
+	.rtt_nom = 0,
+	.sde_to_rst = 0,    /* LPDDR2 does not need this field */
+	.rst_to_cke = 0x10, /* JEDEC value for LPDDR2: 200us */
+	.ddr_type = DDR_TYPE_LPDDR2,
+};
+
+#else
+static struct mx6ul_iomux_ddr_regs mx6_ddr_ioregs = {
+	.dram_dqm0 = 0x00000030,
+	.dram_dqm1 = 0x00000030,
+	.dram_ras = 0x00000030,
+	.dram_cas = 0x00000030,
+	.dram_odt0 = 0x00000030,
+	.dram_odt1 = 0x00000030,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdclk_0 = 0x00000008,
+	.dram_sdqs0 = 0x00000038,
+	.dram_sdqs1 = 0x00000030,
+	.dram_reset = 0x00000030,
+};
+
+static struct mx6_mmdc_calibration mx6_mmcd_calib = {
+	.p0_mpwldectrl0 = 0x00070007,
+	.p0_mpdgctrl0 = 0x41490145,
+	.p0_mprddlctl = 0x40404546,
+	.p0_mpwrdlctl = 0x4040524D,
+};
+
+struct mx6_ddr_sysinfo ddr_sysinfo = {
+	.dsize = 0,
+	.cs_density = 20,
+	.ncs = 1,
+	.cs1_mirror = 0,
+	.rtt_wr = 2,
+	.rtt_nom = 1,		/* RTT_Nom = RZQ/2 */
+	.walat = 1,		/* Write additional latency */
+	.ralat = 5,		/* Read additional latency */
+	.mif3_mode = 3,		/* Command prediction working mode */
+	.bi_on = 1,		/* Bank interleaving enabled */
+	.sde_to_rst = 0x10,	/* 14 cycles, 200us (JEDEC default) */
+	.rst_to_cke = 0x23,	/* 33 cycles, 500us (JEDEC default) */
+	.ddr_type = DDR_TYPE_DDR3,
+};
+
+static struct mx6_ddr3_cfg mem_ddr = {
+	.mem_speed = 800,
+	.density = 4,
+	.width = 16,
+	.banks = 8,
+	.rowaddr = 15,
+	.coladdr = 10,
+	.pagesz = 2,
+	.trcd = 1375,
+	.trcmin = 4875,
+	.trasmin = 3500,
+};
+#endif
+
+static void ccgr_init(void)
+{
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	writel(0xFFFFFFFF, &ccm->CCGR0);
+	writel(0xFFFFFFFF, &ccm->CCGR1);
+	writel(0xFFFFFFFF, &ccm->CCGR2);
+	writel(0xFFFFFFFF, &ccm->CCGR3);
+	writel(0xFFFFFFFF, &ccm->CCGR4);
+	writel(0xFFFFFFFF, &ccm->CCGR5);
+	writel(0xFFFFFFFF, &ccm->CCGR6);
+	writel(0xFFFFFFFF, &ccm->CCGR7);
+}
+
+static void spl_dram_init(void)
+{
+	mx6ul_dram_iocfg(mem_ddr.width, &mx6_ddr_ioregs, &mx6_grp_ioregs);
+	mx6_dram_cfg(&ddr_sysinfo, &mx6_mmcd_calib, &mem_ddr);
+}
+
+void board_init_f(ulong dummy)
+{
+	/* setup AIPS and disable watchdog */
+	arch_cpu_init();
+
+	ccgr_init();
+
+	/* iomux and setup of i2c */
+	board_early_init_f();
+
+	/* setup GP timer */
+	timer_init();
+
+	/* UART clocks enabled and gd valid - init serial console */
+	preloader_console_init();
+
+	/* DDR initialization */
+	spl_dram_init();
+
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	/* load/boot image from boot device */
+	board_init_r(NULL, 0);
+}
+#endif
diff -urN u-boot-2016.03/board/freescale/mx6ullevk/plugin.S ebf_6ull_uboot/board/freescale/mx6ullevk/plugin.S
--- u-boot-2016.03/board/freescale/mx6ullevk/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ullevk/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,257 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6ull_ddr3_evk_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000C0000
+	str r1, [r0, #0x4B4]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4AC]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x27C]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x250]
+	str r1, [r0, #0x24C]
+	str r1, [r0, #0x490]
+	ldr r1, =0x000C0030
+	str r1, [r0, #0x288]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x270]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x260]
+	str r1, [r0, #0x264]
+	str r1, [r0, #0x4A0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x280]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x284]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x4B0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x498]
+	str r1, [r0, #0x4A4]
+	str r1, [r0, #0x244]
+	str r1, [r0, #0x248]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00000004
+	str r1, [r0, #0x80C]
+	ldr r1, =0x41640158
+	str r1, [r0, #0x83C]
+	ldr r1, =0x40403237
+	str r1, [r0, #0x848]
+	ldr r1, =0x40403C33
+	str r1, [r0, #0x850]
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	ldr r1, =0xF3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	ldr r1, =0x00944009
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+	ldr r1, =0x0002002D
+	str r1, [r0, #0x004]
+	ldr r1, =0x1B333030
+	str r1, [r0, #0x008]
+	ldr r1, =0x676B52F3
+	str r1, [r0, #0x00C]
+	ldr r1, =0xB66D0B63
+	str r1, [r0, #0x010]
+	ldr r1, =0x01FF00DB
+	str r1, [r0, #0x014]
+	ldr r1, =0x00201740
+	str r1, [r0, #0x018]
+	ldr r1, =0x00008000
+	str r1, [r0, #0x01C]
+	ldr r1, =0x000026D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x006B1023
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000004F
+	str r1, [r0, #0x040]
+	ldr r1, =0x84180000
+	str r1, [r0, #0x000]
+	ldr r1, =0x00400000
+	str r1, [r0, #0x890]
+	ldr r1, =0x02008032
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00008033
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00048031
+	str r1, [r0, #0x01C]
+	ldr r1, =0x15208030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04008040
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x020]
+	ldr r1, =0x00000227
+	str r1, [r0, #0x818]
+	ldr r1, =0x0002552D
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6ull_lpddr2_evk_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x4B4]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4AC]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x27C]
+	str r1, [r0, #0x250]
+	str r1, [r0, #0x24C]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x288]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x270]
+	str r1, [r0, #0x260]
+	str r1, [r0, #0x264]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4A0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00003030
+	str r1, [r0, #0x280]
+	ldr r1, =0x00003030
+	str r1, [r0, #0x284]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x4B0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x498]
+	str r1, [r0, #0x4A4]
+	str r1, [r0, #0x244]
+	str r1, [r0, #0x248]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0x1b4700c7
+	str r1, [r0, #0x85c]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x23400A38
+	str r1, [r0, #0x890]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8b8]
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	ldr r1, =0xF3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	ldr r1, =0x20000000
+	str r1, [r0, #0x83C]
+	ldr r1, =0x40403439
+	str r1, [r0, #0x848]
+	ldr r1, =0x4040342D
+	str r1, [r0, #0x850]
+	ldr r1, =0x00921012
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+
+	ldr r1, =0x00020052
+	str r1, [r0, #0x004]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x008]
+	ldr r1, =0x33374133
+	str r1, [r0, #0x00C]
+	ldr r1, =0x00100A82
+	str r1, [r0, #0x010]
+	ldr r1, =0x00170557
+	str r1, [r0, #0x038]
+	ldr r1, =0x00000093
+	str r1, [r0, #0x014]
+	ldr r1, =0x00201748
+	str r1, [r0, #0x018]
+	ldr r1, =0x0F9F26D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x009F0010
+	str r1, [r0, #0x030]
+	ldr r1, =0x00000047
+	str r1, [r0, #0x040]
+	ldr r1, =0x83100000
+	str r1, [r0, #0x000]
+	ldr r1, =0x00008050
+	str r1, [r0, #0x01C]
+	ldr r1, =0x003F8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0xFF0A8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x82018030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04028030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x01038030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00001800
+	str r1, [r0, #0x020]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x818]
+	ldr r1, =0xA1310003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00025552
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xFFFFFFFF
+	str r1, [r0, #0x68]
+	str r1, [r0, #0x6C]
+	str r1, [r0, #0x70]
+	str r1, [r0, #0x74]
+	str r1, [r0, #0x78]
+	str r1, [r0, #0x7C]
+	str r1, [r0, #0x80]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+#if defined (CONFIG_TARGET_MX6ULL_9X9_EVK)
+	imx6ull_lpddr2_evk_setting
+#else
+	imx6ull_ddr3_evk_setting
+#endif
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx6ullevk/README ebf_6ull_uboot/board/freescale/mx6ullevk/README
--- u-boot-2016.03/board/freescale/mx6ullevk/README	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx6ullevk/README	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,28 @@
+How to use U-Boot on Freescale MX6ULL 14x14 EVK
+-----------------------------------------------
+
+- Build U-Boot for MX6ULL 14x14 EVK:
+
+$ make mrproper
+$ make mx6ull_14x14_evk_defconfig
+$ make
+
+This will generate the u-boot image u-boot.imx.
+
+- Flash the u-boot image into the micro SD card:
+
+sudo dd if=u-boot.imx of=/dev/mmcblk0 bs=1k seek=1; sync
+
+- Jumper settings:
+
+SW601: 0 0 1 0
+Sw602: 1 0
+
+where 0 means bottom position and 1 means top position (from the
+switch label numbers reference).
+
+- Connect the USB cable between the EVK and the PC for the console.
+(The USB console connector is the one close the push buttons)
+
+- Insert the micro SD card in the board, power it up and U-Boot messages should
+come up.
diff -urN u-boot-2016.03/board/freescale/mx7d_12x12_ddr3_arm2/imximage.cfg ebf_6ull_uboot/board/freescale/mx7d_12x12_ddr3_arm2/imximage.cfg
--- u-boot-2016.03/board/freescale/mx7d_12x12_ddr3_arm2/imximage.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_12x12_ddr3_arm2/imximage.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * sd/onenand, nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_EIMNOR
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx7d_12x12_ddr3_arm2/plugin.bin 0x00910000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x30340004 0x4F400005
+
+DATA 4 0x30391000 0x00000002
+DATA 4 0x307a0000 0x03040001
+DATA 4 0x307a01a0 0x80400003
+DATA 4 0x307a01a4 0x00100020
+DATA 4 0x307a01a8 0x80100004
+DATA 4 0x307a0064 0x0040005e
+DATA 4 0x307a0490 0x00000001
+DATA 4 0x307a00d0 0x00020001
+DATA 4 0x307a00d4 0x00010000
+DATA 4 0x307a00dc 0x09300004
+DATA 4 0x307a00e0 0x04080000
+DATA 4 0x307a00e4 0x00090004
+DATA 4 0x307a00f4 0x0000033f
+DATA 4 0x307a0100 0x0908120a
+DATA 4 0x307a0104 0x0002020e
+DATA 4 0x307a0108 0x03040407
+DATA 4 0x307a010c 0x00002006
+DATA 4 0x307a0110 0x04020204
+DATA 4 0x307a0114 0x03030202
+DATA 4 0x307a0120 0x03030803
+DATA 4 0x307a0180 0x00800020
+DATA 4 0x307a0190 0x02098204
+DATA 4 0x307a0194 0x00030303
+DATA 4 0x307a0200 0x00000016
+DATA 4 0x307a0204 0x00171717
+DATA 4 0x307a0214 0x04040404
+DATA 4 0x307a0218 0x00040404
+DATA 4 0x307a0240 0x06000601
+DATA 4 0x307a0244 0x00001323
+DATA 4 0x30391000 0x00000000
+DATA 4 0x30790000 0x17420f40
+DATA 4 0x30790004 0x10210100
+DATA 4 0x30790010 0x00060807
+DATA 4 0x3079009c 0x00000d6e
+DATA 4 0x30790020 0x08080808
+DATA 4 0x30790030 0x08080808
+DATA 4 0x30790050 0x01000010
+DATA 4 0x30790050 0x00000010
+
+DATA 4 0x307900c0 0x0e407304
+DATA 4 0x307900c0 0x0e447304
+DATA 4 0x307900c0 0x0e447306
+
+CHECK_BITS_SET 4 0x307900c4 0x1
+
+DATA 4 0x307900c0 0x0e447304
+DATA 4 0x307900c0 0x0e407304
+
+DATA 4 0x30384130 0x00000000
+DATA 4 0x30340020 0x00000178
+DATA 4 0x30384130 0x00000002
+DATA 4 0x30790018 0x0000000f
+
+CHECK_BITS_SET 4 0x307a0004 0x1
+#endif
diff -urN u-boot-2016.03/board/freescale/mx7d_12x12_ddr3_arm2/imximage_TO_1_1.cfg ebf_6ull_uboot/board/freescale/mx7d_12x12_ddr3_arm2/imximage_TO_1_1.cfg
--- u-boot-2016.03/board/freescale/mx7d_12x12_ddr3_arm2/imximage_TO_1_1.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_12x12_ddr3_arm2/imximage_TO_1_1.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * sd/onenand, nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_EIMNOR
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx7d_12x12_ddr3_arm2/plugin.bin 0x00910000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x30360070 0x00703021
+DATA 4 0x30360090 0x0
+DATA 4 0x30360070 0x00603021
+CHECK_BITS_SET 4 0x30360070 0x80000000
+DATA 4 0x30389880 0x1
+
+DATA 4 0x30340004 0x4F400005
+
+DATA 4 0x30391000 0x00000002
+DATA 4 0x307a0000 0x03040001
+DATA 4 0x307a01a0 0x80400003
+DATA 4 0x307a01a4 0x00100020
+DATA 4 0x307a01a8 0x80100004
+DATA 4 0x307a0064 0x0040005e
+DATA 4 0x307a0490 0x00000001
+DATA 4 0x307a00d0 0x00020001
+DATA 4 0x307a00d4 0x00010000
+DATA 4 0x307a00dc 0x09300004
+DATA 4 0x307a00e0 0x04080000
+DATA 4 0x307a00e4 0x00090004
+DATA 4 0x307a00f4 0x0000033f
+DATA 4 0x307a0100 0x0908120a
+DATA 4 0x307a0104 0x0002020e
+DATA 4 0x307a0108 0x03040407
+DATA 4 0x307a010c 0x00002006
+DATA 4 0x307a0110 0x04020204
+DATA 4 0x307a0114 0x03030202
+DATA 4 0x307a0120 0x03030803
+DATA 4 0x307a0180 0x00800020
+DATA 4 0x307a0190 0x02098204
+DATA 4 0x307a0194 0x00030303
+DATA 4 0x307a0200 0x00000016
+DATA 4 0x307a0204 0x00171717
+DATA 4 0x307a0214 0x04040404
+DATA 4 0x307a0218 0x00040404
+DATA 4 0x307a0240 0x06000601
+DATA 4 0x307a0244 0x00001323
+DATA 4 0x30391000 0x00000000
+DATA 4 0x30790000 0x17420f40
+DATA 4 0x30790004 0x10210100
+DATA 4 0x30790010 0x00060807
+DATA 4 0x3079009c 0x00000dee
+DATA 4 0x3079007c 0x18181818
+DATA 4 0x30790080 0x18181818
+DATA 4 0x30790084 0x40401818
+DATA 4 0x30790088 0x00000040
+DATA 4 0x3079006c 0x40404040
+DATA 4 0x30790020 0x08080808
+DATA 4 0x30790030 0x08080808
+DATA 4 0x30790050 0x01000010
+DATA 4 0x30790050 0x00000010
+
+DATA 4 0x307900c0 0x0e407304
+DATA 4 0x307900c0 0x0e447304
+DATA 4 0x307900c0 0x0e447306
+
+CHECK_BITS_SET 4 0x307900c4 0x1
+
+DATA 4 0x307900c0 0x0e447304
+DATA 4 0x307900c0 0x0e407304
+
+DATA 4 0x30384130 0x00000000
+DATA 4 0x30340020 0x00000178
+DATA 4 0x30384130 0x00000002
+DATA 4 0x30790018 0x0000000f
+
+CHECK_BITS_SET 4 0x307a0004 0x1
+#endif
diff -urN u-boot-2016.03/board/freescale/mx7d_12x12_ddr3_arm2/Kconfig ebf_6ull_uboot/board/freescale/mx7d_12x12_ddr3_arm2/Kconfig
--- u-boot-2016.03/board/freescale/mx7d_12x12_ddr3_arm2/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_12x12_ddr3_arm2/Kconfig	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,12 @@
+if TARGET_MX7D_12X12_DDR3_ARM2
+
+config SYS_BOARD
+	default "mx7d_12x12_ddr3_arm2"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_CONFIG_NAME
+	default "mx7d_12x12_ddr3_arm2"
+
+endif
diff -urN u-boot-2016.03/board/freescale/mx7d_12x12_ddr3_arm2/Makefile ebf_6ull_uboot/board/freescale/mx7d_12x12_ddr3_arm2/Makefile
--- u-boot-2016.03/board/freescale/mx7d_12x12_ddr3_arm2/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_12x12_ddr3_arm2/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,10 @@
+# (C) Copyright 2015 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx7d_12x12_ddr3_arm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx7d_12x12_ddr3_arm2/mx7d_12x12_ddr3_arm2.c ebf_6ull_uboot/board/freescale/mx7d_12x12_ddr3_arm2/mx7d_12x12_ddr3_arm2.c
--- u-boot-2016.03/board/freescale/mx7d_12x12_ddr3_arm2/mx7d_12x12_ddr3_arm2.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_12x12_ddr3_arm2/mx7d_12x12_ddr3_arm2.c	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,343 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx7-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze3000_pmic.h>
+#include "../common/pfuze.h"
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#include <asm/arch/crm_regs.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_DSE_3P3V_49OHM | \
+	PAD_CTL_PUS_PU100KOHM | PAD_CTL_HYS)
+#define USDHC_PAD_CTRL (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+	PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU47KOHM)
+#define I2C_PAD_CTRL    (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+	PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU100KOHM)
+#define SPI_PAD_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_SRE_SLOW | PAD_CTL_HYS)
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX7D_PAD_GPIO1_IO04__I2C1_SCL | PC,
+		.gpio_mode = MX7D_PAD_GPIO1_IO04__GPIO1_IO4 | PC,
+		.gp = IMX_GPIO_NR(1, 4),
+	},
+	.sda = {
+		.i2c_mode = MX7D_PAD_GPIO1_IO05__I2C1_SDA | PC,
+		.gpio_mode = MX7D_PAD_GPIO1_IO05__GPIO1_IO5 | PC,
+		.gp = IMX_GPIO_NR(1, 5),
+	},
+};
+
+/* I2C2 */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX7D_PAD_GPIO1_IO06__I2C2_SCL | PC,
+		.gpio_mode = MX7D_PAD_GPIO1_IO06__GPIO1_IO6 | PC,
+		.gp = IMX_GPIO_NR(1, 6),
+	},
+	.sda = {
+		.i2c_mode = MX7D_PAD_GPIO1_IO07__I2C2_SDA | PC,
+		.gpio_mode = MX7D_PAD_GPIO1_IO07__GPIO1_IO7 | PC,
+		.gp = IMX_GPIO_NR(1, 7),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX7D_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX7D_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_emmc_pads[] = {
+	MX7D_PAD_SD2_CLK__SD2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_CMD__SD2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_DATA0__SD2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_DATA1__SD2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_DATA2__SD2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_DATA3__SD2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_ECSPI1_SCLK__SD2_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_ECSPI1_MOSI__SD2_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_ECSPI1_MISO__SD2_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_ECSPI1_SS0__SD2_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_SD2_RESET_B__GPIO5_IO11 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX7D_PAD_SD3_CLK__SD3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_CMD__SD3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_GPIO1_IO14__GPIO1_IO14  | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_GPIO1_IO15__GPIO1_IO15  | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const wdog_pads[] = {
+	MX7D_PAD_GPIO1_IO00__WDOG1_WDOG_B | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_ESDHC
+
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(1, 14)
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(5, 11)
+
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC2_BASE_ADDR},
+	{USDHC3_BASE_ADDR, 0, 4},
+};
+
+int board_mmc_get_env_dev(int devno)
+{
+	return devno - 1;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no + 1;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC2_BASE_ADDR:
+		ret = 1; /* uSDHC2 emmc always present */
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	}
+
+	return ret;
+}
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC2 (eMMC)
+	 * mmc1                    USDHC3
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_emmc_pads, ARRAY_SIZE(usdhc2_emmc_pads));
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+			if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX7D_PAD_SD1_RESET_B__ECSPI4_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX7D_PAD_SD1_WP__ECSPI4_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX7D_PAD_SD1_CD_B__ECSPI4_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	/* Chip selects CS0:CS3 */
+	MX7D_PAD_SD1_CLK__GPIO5_IO3 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX7D_PAD_SD1_CMD__GPIO5_IO4 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX7D_PAD_SD1_DATA0__GPIO5_IO5 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX7D_PAD_SD1_DATA1__GPIO5_IO6 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
+					 ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(5, 3), 0);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 3 && cs == 0) ? (IMX_GPIO_NR(5, 3)) : -1;
+}
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX7
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX7D_PAD_UART3_TX_DATA__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	MX7D_PAD_UART3_CTS_B__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg1_pads, ARRAY_SIZE(usb_otg1_pads));
+	imx_iomux_v3_setup_multiple_pads(usb_otg2_pads, ARRAY_SIZE(usb_otg2_pads));
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX7
+	setup_usb();
+#endif
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"emmc", MAKE_CFGVAL(0x10, 0x22, 0x00, 0x00)},
+	{"sd3", MAKE_CFGVAL(0x10, 0x1a, 0x00, 0x00)},
+	{NULL,   0},
+};
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+int power_init_board(void)
+{
+	struct pmic *p;
+	int ret;
+	unsigned int reg, rev_id;
+
+	ret = power_pfuze3000_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	p = pmic_get("PFUZE3000");
+	ret = pmic_probe(p);
+	if (ret)
+		return ret;
+
+	pmic_reg_read(p, PFUZE3000_DEVICEID, &reg);
+	pmic_reg_read(p, PFUZE3000_REVID, &rev_id);
+	printf("PMIC: PFUZE3000 DEV_ID=0x%x REV_ID=0x%x\n", reg, rev_id);
+
+	/* disable Low Power Mode during standby mode */
+	pmic_reg_read(p, PFUZE3000_LDOGCTL, &reg);
+	reg |= 0x1;
+	pmic_reg_write(p, PFUZE3000_LDOGCTL, reg);
+
+	/* SW1A/1B mode set to APS/APS */
+	reg = 0x8;
+	pmic_reg_write(p, PFUZE3000_SW1AMODE, reg);
+	pmic_reg_write(p, PFUZE3000_SW1BMODE, reg);
+
+	/* SW1A/1B standby voltage set to 0.975V */
+	reg = 0xb;
+	pmic_reg_write(p, PFUZE3000_SW1ASTBY, reg);
+	pmic_reg_write(p, PFUZE3000_SW1BSTBY, reg);
+
+	/* set SW1B normal voltage to 0.975V */
+	pmic_reg_read(p, PFUZE3000_SW1BVOLT, &reg);
+	reg &= ~0x1f;
+	reg |= PFUZE3000_SW1AB_SETP(975);
+	pmic_reg_write(p, PFUZE3000_SW1BVOLT, reg);
+
+	return 0;
+}
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	imx_iomux_v3_setup_multiple_pads(wdog_pads, ARRAY_SIZE(wdog_pads));
+
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: MX7D 12x12 DDR3 ARM2\n");
+
+	return 0;
+}
diff -urN u-boot-2016.03/board/freescale/mx7d_12x12_ddr3_arm2/plugin.S ebf_6ull_uboot/board/freescale/mx7d_12x12_ddr3_arm2/plugin.S
--- u-boot-2016.03/board/freescale/mx7d_12x12_ddr3_arm2/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_12x12_ddr3_arm2/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,217 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx7d_ddrphy_latency_setting
+	ldr r2, =ANATOP_BASE_ADDR
+	ldr r3, [r2, #0x800]
+	and r3, r3, #0xFF
+	cmp r3, #0x11
+	bne NO_DELAY
+
+	/*TO 1.1*/
+	ldr r1, =0x00000dee
+	str r1, [r0, #0x9c]
+	ldr r1, =0x18181818
+	str r1, [r0, #0x7c]
+	ldr r1, =0x18181818
+	str r1, [r0, #0x80]
+	ldr r1, =0x40401818
+	str r1, [r0, #0x84]
+	ldr r1, =0x00000040
+	str r1, [r0, #0x88]
+	ldr r1, =0x40404040
+	str r1, [r0, #0x6c]
+	b TUNE_END
+
+NO_DELAY:
+	/*TO 1.0*/
+	ldr r1, =0x00000d6e
+	str r1, [r0, #0x9c]
+
+TUNE_END:
+.endm
+
+.macro imx7d_ddr_freq_setting
+	ldr r2, =ANATOP_BASE_ADDR
+	ldr r3, [r2, #0x800]
+	and r3, r3, #0xFF
+	cmp r3, #0x11
+	bne FREQ_DEFAULT_533
+
+	/* Change to 400Mhz for TO1.1 */
+	ldr r0, =ANATOP_BASE_ADDR
+	ldr r1, =0x70
+	ldr r2, =0x00703021
+	str r2, [r0, r1]
+	ldr r1, =0x90
+	ldr r2, =0x0
+	str r2, [r0, r1]
+	ldr r1, =0x70
+	ldr r2, =0x00603021
+	str r2, [r0, r1]
+
+	ldr r3, =0x80000000
+wait_lock:
+	ldr r2, [r0, r1]
+	and r2, r3
+	cmp r2, r3
+	bne wait_lock
+
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x9880
+	ldr r2, =0x1
+	str r2, [r0, r1]
+
+FREQ_DEFAULT_533:
+.endm
+
+.macro imx7d_12x12_ddr3_arm2_ddr_setting
+	imx7d_ddr_freq_setting
+
+	/* Configure ocram_epdc */
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	ldr r1, =0x4f400005
+	str r1, [r0, #0x4]
+
+	ldr r0, =SRC_BASE_ADDR
+	ldr r1, =0x2
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+	ldr r1, =0x03040001
+	str r1, [r0]
+	ldr r1, =0x80400003
+	str r1, [r0, #0x1a0]
+	ldr r1, =0x00100020
+	str r1, [r0, #0x1a4]
+	ldr r1, =0x80100004
+	str r1, [r0, #0x1a8]
+	ldr r1, =0x0040005e
+	str r1, [r0, #0x64]
+	ldr r1, =0x1
+	str r1, [r0, #0x490]
+	ldr r1, =0x00020001
+	str r1, [r0, #0xd0]
+	ldr r1, =0x00010000
+	str r1, [r0, #0xd4]
+	ldr r1, =0x09300004
+	str r1, [r0, #0xdc]
+	ldr r1, =0x04080000
+	str r1, [r0, #0xe0]
+	ldr r1, =0x00090004
+	str r1, [r0, #0xe4]
+	ldr r1, =0x33f
+	str r1, [r0, #0xf4]
+	ldr r1, =0x0908120a
+	str r1, [r0, #0x100]
+	ldr r1, =0x0002020e
+	str r1, [r0, #0x104]
+	ldr r1, =0x03040407
+	str r1, [r0, #0x108]
+	ldr r1, =0x00002006
+	str r1, [r0, #0x10c]
+	ldr r1, =0x04020204
+	str r1, [r0, #0x110]
+	ldr r1, =0x03030202
+	str r1, [r0, #0x114]
+	ldr r1, =0x03030803
+	str r1, [r0, #0x120]
+	ldr r1, =0x00800020
+	str r1, [r0, #0x180]
+	ldr r1, =0x02098204
+	str r1, [r0, #0x190]
+	ldr r1, =0x00030303
+	str r1, [r0, #0x194]
+
+	ldr r1, =0x00000016
+	str r1, [r0, #0x200]
+	ldr r1, =0x00171717
+	str r1, [r0, #0x204]
+	ldr r1, =0x04040404
+	str r1, [r0, #0x214]
+	ldr r1, =0x00040404
+	str r1, [r0, #0x218]
+
+	ldr r1, =0x06000601
+	str r1, [r0, #0x240]
+	ldr r1, =0x00001323
+	str r1, [r0, #0x244]
+
+	ldr r0, =SRC_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRPHY_IPS_BASE_ADDR
+	ldr r1, =0x17420f40
+	str r1, [r0]
+	ldr r1, =0x10210100
+	str r1, [r0, #0x4]
+	ldr r1, =0x00060807
+	str r1, [r0, #0x10]
+	imx7d_ddrphy_latency_setting
+	ldr r1, =0x08080808
+	str r1, [r0, #0x20]
+	ldr r1, =0x08080808
+	str r1, [r0, #0x30]
+	ldr r1, =0x01000010
+	str r1, [r0, #0x50]
+
+	ldr r1, =0x0e407304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e447304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e447306
+	str r1, [r0, #0xc0]
+
+wait_zq:
+	ldr r1, [r0, #0xc4]
+	tst r1, #0x1
+	beq wait_zq
+
+	ldr r1, =0x0e447304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e407304
+	str r1, [r0, #0xc0]
+
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	mov r1, #0x178
+	str r1, [r0, #0x20]
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x2
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+	ldr r0, =DDRPHY_IPS_BASE_ADDR
+	ldr r1, =0x0000000f
+	str r1, [r0, #0x18]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+wait_stat:
+	ldr r1, [r0, #0x4]
+	tst r1, #0x1
+	beq wait_stat
+.endm
+
+.macro imx7_clock_gating
+.endm
+
+.macro imx7_qos_setting
+.endm
+
+.macro imx7_ddr_setting
+	imx7d_12x12_ddr3_arm2_ddr_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx7_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx7d_12x12_lpddr3_arm2/imximage.cfg ebf_6ull_uboot/board/freescale/mx7d_12x12_lpddr3_arm2/imximage.cfg
--- u-boot-2016.03/board/freescale/mx7d_12x12_lpddr3_arm2/imximage.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_12x12_lpddr3_arm2/imximage.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx7d_12x12_lpddr3_arm2/plugin.bin 0x00910000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x30340004 0x4F400005
+/* Clear then set bit30 to ensure exit from DDR retention */
+DATA 4 0x30360388 0x40000000
+DATA 4 0x30360384 0x40000000
+
+DATA 4 0x30391000 0x00000002
+DATA 4 0x307a0000 0x03040008
+DATA 4 0x307a0064 0x00200038
+DATA 4 0x307a0490 0x00000001
+DATA 4 0x307a00d0 0x00350001
+DATA 4 0x307a00dc 0x00c3000a
+DATA 4 0x307a00e0 0x00010000
+DATA 4 0x307a00e4 0x00110006
+DATA 4 0x307a00f4 0x0000033f
+DATA 4 0x307a0100 0x0a0e110b
+DATA 4 0x307a0104 0x00020211
+DATA 4 0x307a0108 0x03060708
+DATA 4 0x307a010c 0x00a0500c
+DATA 4 0x307a0110 0x05020307
+DATA 4 0x307a0114 0x02020404
+DATA 4 0x307a0118 0x02020003
+DATA 4 0x307a011c 0x00000202
+DATA 4 0x307a0120 0x00000202
+
+DATA 4 0x307a0180 0x00600018
+DATA 4 0x307a0184 0x00e00100
+DATA 4 0x307a0190 0x02098205
+DATA 4 0x307a0194 0x00060303
+DATA 4 0x307a01a0 0x80400003
+DATA 4 0x307a01a4 0x00100020
+DATA 4 0x307a01a8 0x80100004
+
+DATA 4 0x307a0200 0x00000016
+DATA 4 0x307a0204 0x00171717
+DATA 4 0x307a0210 0x00000f00
+DATA 4 0x307a0214 0x05050505
+DATA 4 0x307a0218 0x0f0f0505
+
+DATA 4 0x307a0240 0x06000601
+DATA 4 0x307a0244 0x00000000
+DATA 4 0x30391000 0x00000000
+DATA 4 0x30790000 0x17421e40
+DATA 4 0x30790004 0x10210100
+DATA 4 0x30790008 0x00010000
+DATA 4 0x30790010 0x0007080c
+DATA 4 0x307900b0 0x1010007e
+
+DATA 4 0x3079001C 0x01010000
+DATA 4 0x3079009c 0x0db60d6e
+
+DATA 4 0x30790030 0x06060606
+DATA 4 0x30790020 0x0a0a0a0a
+DATA 4 0x30790050 0x01000008
+DATA 4 0x30790050 0x00000008
+DATA 4 0x30790018 0x0000000f
+DATA 4 0x307900c0 0x1e487304
+DATA 4 0x307900c0 0x1e487304
+DATA 4 0x307900c0 0x1e487306
+DATA 4 0x307900c0 0x1e4c7304
+CHECK_BITS_SET 4 0x307900c4 0x1
+
+DATA 4 0x307900c0 0x1e487304
+
+DATA 4 0x30384130 0x00000000
+DATA 4 0x30340020 0x00000178
+DATA 4 0x30384130 0x00000002
+
+CHECK_BITS_SET 4 0x307a0004 0x1
+#endif
diff -urN u-boot-2016.03/board/freescale/mx7d_12x12_lpddr3_arm2/imximage_TO_1_1.cfg ebf_6ull_uboot/board/freescale/mx7d_12x12_lpddr3_arm2/imximage_TO_1_1.cfg
--- u-boot-2016.03/board/freescale/mx7d_12x12_lpddr3_arm2/imximage_TO_1_1.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_12x12_lpddr3_arm2/imximage_TO_1_1.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx7d_12x12_lpddr3_arm2/plugin.bin 0x00910000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x30340004 0x4F400005
+/* Clear then set bit30 to ensure exit from DDR retention */
+DATA 4 0x30360388 0x40000000
+DATA 4 0x30360384 0x40000000
+
+DATA 4 0x30391000 0x00000002
+DATA 4 0x307a0000 0x03040008
+DATA 4 0x307a0064 0x00200038
+DATA 4 0x307a0490 0x00000001
+DATA 4 0x307a00d0 0x00350001
+DATA 4 0x307a00dc 0x00c3000a
+DATA 4 0x307a00e0 0x00010000
+DATA 4 0x307a00e4 0x00110006
+DATA 4 0x307a00f4 0x0000033f
+DATA 4 0x307a0100 0x0a0e110b
+DATA 4 0x307a0104 0x00020211
+DATA 4 0x307a0108 0x03060708
+DATA 4 0x307a010c 0x00a0500c
+DATA 4 0x307a0110 0x05020307
+DATA 4 0x307a0114 0x02020404
+DATA 4 0x307a0118 0x02020003
+DATA 4 0x307a011c 0x00000202
+DATA 4 0x307a0120 0x00000202
+
+DATA 4 0x307a0180 0x00600018
+DATA 4 0x307a0184 0x00e00100
+DATA 4 0x307a0190 0x02098205
+DATA 4 0x307a0194 0x00060303
+DATA 4 0x307a01a0 0x80400003
+DATA 4 0x307a01a4 0x00100020
+DATA 4 0x307a01a8 0x80100004
+
+DATA 4 0x307a0200 0x00000016
+DATA 4 0x307a0204 0x00171717
+DATA 4 0x307a0210 0x00000f00
+DATA 4 0x307a0214 0x05050505
+DATA 4 0x307a0218 0x0f0f0505
+
+DATA 4 0x307a0240 0x06000601
+DATA 4 0x307a0244 0x00000000
+DATA 4 0x30391000 0x00000000
+DATA 4 0x30790000 0x17421e40
+DATA 4 0x30790004 0x10210100
+DATA 4 0x30790008 0x00010000
+DATA 4 0x30790010 0x0007080c
+DATA 4 0x3079007c 0x1c1c1c1c
+DATA 4 0x30790080 0x1c1c1c1c
+DATA 4 0x30790084 0x30301c1c
+DATA 4 0x30790088 0x00000030
+DATA 4 0x3079006c 0x30303030
+DATA 4 0x307900b0 0x1010007e
+
+DATA 4 0x3079001C 0x01010000
+DATA 4 0x3079009c 0x0db60d6e
+
+DATA 4 0x30790030 0x06060606
+DATA 4 0x30790020 0x0a0a0a0a
+DATA 4 0x30790050 0x01000008
+DATA 4 0x30790050 0x00000008
+DATA 4 0x30790018 0x0000000f
+DATA 4 0x307900c0 0x1e487304
+DATA 4 0x307900c0 0x1e487304
+DATA 4 0x307900c0 0x1e487306
+DATA 4 0x307900c0 0x1e4c7304
+CHECK_BITS_SET 4 0x307900c4 0x1
+
+DATA 4 0x307900c0 0x1e487304
+
+DATA 4 0x30384130 0x00000000
+DATA 4 0x30340020 0x00000178
+DATA 4 0x30384130 0x00000002
+
+CHECK_BITS_SET 4 0x307a0004 0x1
+#endif
diff -urN u-boot-2016.03/board/freescale/mx7d_12x12_lpddr3_arm2/Kconfig ebf_6ull_uboot/board/freescale/mx7d_12x12_lpddr3_arm2/Kconfig
--- u-boot-2016.03/board/freescale/mx7d_12x12_lpddr3_arm2/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_12x12_lpddr3_arm2/Kconfig	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,12 @@
+if TARGET_MX7D_12X12_LPDDR3_ARM2
+
+config SYS_BOARD
+	default "mx7d_12x12_lpddr3_arm2"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_CONFIG_NAME
+	default "mx7d_12x12_lpddr3_arm2"
+
+endif
diff -urN u-boot-2016.03/board/freescale/mx7d_12x12_lpddr3_arm2/Makefile ebf_6ull_uboot/board/freescale/mx7d_12x12_lpddr3_arm2/Makefile
--- u-boot-2016.03/board/freescale/mx7d_12x12_lpddr3_arm2/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_12x12_lpddr3_arm2/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,10 @@
+# (C) Copyright 2015 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx7d_12x12_lpddr3_arm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx7d_12x12_lpddr3_arm2/mx7d_12x12_lpddr3_arm2.c ebf_6ull_uboot/board/freescale/mx7d_12x12_lpddr3_arm2/mx7d_12x12_lpddr3_arm2.c
--- u-boot-2016.03/board/freescale/mx7d_12x12_lpddr3_arm2/mx7d_12x12_lpddr3_arm2.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_12x12_lpddr3_arm2/mx7d_12x12_lpddr3_arm2.c	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,822 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx7-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze3000_pmic.h>
+#include "../common/pfuze.h"
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#include <asm/arch/crm_regs.h>
+#include <asm/imx-common/video.h>
+#if defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_DSE_3P3V_49OHM | \
+	PAD_CTL_PUS_PU100KOHM | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+	PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU47KOHM)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_98OHM)
+#define ENET_PAD_CTRL_MII  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_98OHM)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_98OHM)
+
+#define I2C_PAD_CTRL    (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+	PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU100KOHM)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_PU100KOHM | \
+	PAD_CTL_DSE_3P3V_49OHM)
+
+#define QSPI_PAD_CTRL	\
+		(PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_PUE | PAD_CTL_PUS_PU47KOHM)
+
+#define SPI_PAD_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_SRE_SLOW | PAD_CTL_HYS)
+
+#define EPDC_PAD_CTRL	0x0
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX7D_PAD_I2C1_SCL__I2C1_SCL | PC,
+		.gpio_mode = MX7D_PAD_I2C1_SCL__GPIO4_IO8 | PC,
+		.gp = IMX_GPIO_NR(4, 8),
+	},
+	.sda = {
+		.i2c_mode = MX7D_PAD_I2C1_SDA__I2C1_SDA | PC,
+		.gpio_mode = MX7D_PAD_I2C1_SDA__GPIO4_IO9 | PC,
+		.gp = IMX_GPIO_NR(4, 9),
+	},
+};
+
+/* I2C2 */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX7D_PAD_I2C2_SCL__I2C2_SCL | PC,
+		.gpio_mode = MX7D_PAD_I2C2_SCL__GPIO4_IO10 | PC,
+		.gp = IMX_GPIO_NR(4, 10),
+	},
+	.sda = {
+		.i2c_mode = MX7D_PAD_I2C2_SDA__I2C2_SDA | PC,
+		.gpio_mode = MX7D_PAD_I2C2_SDA__GPIO4_IO11 | PC,
+		.gp = IMX_GPIO_NR(4, 11),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX7D_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX7D_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX7D_PAD_SD1_CLK__SD1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_CMD__SD1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA0__SD1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA1__SD1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA2__SD1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA3__SD1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_GPIO1_IO08__SD1_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_SD1_CD_B__GPIO5_IO0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_RESET_B__GPIO5_IO2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX7D_PAD_SD2_CLK__SD2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_CMD__SD2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_DATA0__SD2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_DATA1__SD2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_DATA2__SD2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_DATA3__SD2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_GPIO1_IO12__SD2_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_SD2_CD_B__GPIO5_IO9 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_RESET_B__GPIO5_IO11 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc3_emmc_pads[] = {
+	MX7D_PAD_SD3_CLK__SD3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_CMD__SD3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA4__SD3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA5__SD3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA6__SD3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA7__SD3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_SD3_RESET_B__GPIO6_IO11 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX7D_PAD_LCD_CLK__LCD_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_ENABLE__LCD_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_HSYNC__LCD_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_VSYNC__LCD_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA00__LCD_DATA0 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA01__LCD_DATA1 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA02__LCD_DATA2 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA03__LCD_DATA3 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA04__LCD_DATA4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA05__LCD_DATA5 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA06__LCD_DATA6 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA07__LCD_DATA7 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA08__LCD_DATA8 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA09__LCD_DATA9 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA10__LCD_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA11__LCD_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA12__LCD_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA13__LCD_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA14__LCD_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA15__LCD_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA16__LCD_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA17__LCD_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA18__LCD_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA19__LCD_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA20__LCD_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA21__LCD_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA22__LCD_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA23__LCD_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+
+	MX7D_PAD_LCD_RESET__GPIO3_IO4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const pwm_pads[] = {
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX7D_PAD_GPIO1_IO01__GPIO1_IO1 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void do_enable_parallel_lcd(struct display_info_t const *dev)
+{
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	imx_iomux_v3_setup_multiple_pads(pwm_pads, ARRAY_SIZE(pwm_pads));
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(3, 4) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(1, 1) , 1);
+}
+
+struct display_info_t const displays[] = {{
+	.bus = ELCDIF1_IPS_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 24,
+	.detect = NULL,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+#endif
+
+static iomux_v3_cfg_t const per_rst_pads[] = {
+	MX7D_PAD_GPIO1_IO03__GPIO1_IO3 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const wdog_pads[] = {
+	MX7D_PAD_GPIO1_IO00__WDOG1_WDOG_B | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX7D_PAD_GPIO1_IO11__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL_MII),
+	MX7D_PAD_GPIO1_IO10__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL_MII),
+	MX7D_PAD_ENET1_RGMII_RX_CTL__ENET1_RGMII_RX_CTL | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD0__ENET1_RGMII_RD0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD1__ENET1_RGMII_RD1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD2__ENET1_RGMII_RD2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD3__ENET1_RGMII_RD3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RXC__ENET1_RGMII_RXC | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TX_CTL__ENET1_RGMII_TX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD0__ENET1_RGMII_TD0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD1__ENET1_RGMII_TD1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD2__ENET1_RGMII_TD2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD3__ENET1_RGMII_TD3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_TX_CLK__CCM_ENET_REF_CLK1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static void setup_iomux_fec1(void)
+{
+	imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_QSPI
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX7D_PAD_EPDC_DATA00__QSPI_A_DATA0 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA01__QSPI_A_DATA1 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA02__QSPI_A_DATA2 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA03__QSPI_A_DATA3 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA04__QSPI_A_DQS   | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA05__QSPI_A_SCLK  | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA06__QSPI_A_SS0_B | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA07__QSPI_A_SS1_B | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+
+	MX7D_PAD_EPDC_DATA08__QSPI_B_DATA0 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA09__QSPI_B_DATA1 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA10__QSPI_B_DATA2 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA11__QSPI_B_DATA3 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA12__QSPI_B_DQS   | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA13__QSPI_B_SCLK  | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA14__QSPI_B_SS0_B | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA15__QSPI_B_SS1_B | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads, ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	set_clk_qspi();
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(5, 0)
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(5, 9)
+
+#define USDHC1_PWR_GPIO	IMX_GPIO_NR(5, 2)
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(5, 11)
+
+static struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC1_BASE_ADDR, 0, 4},
+	{USDHC2_BASE_ADDR, 0, 4},
+	{USDHC3_BASE_ADDR},
+};
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD_GPIO);
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = 1; /* Assume uSDHC3 emmc is always present */
+		break;
+	}
+
+	return ret;
+}
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 * mmc2                    USDHC3 (eMMC)
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+			gpio_direction_output(USDHC1_PWR_GPIO, 1);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_direction_input(USDHC2_CD_GPIO);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		case 2:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_emmc_pads, ARRAY_SIZE(usdhc3_emmc_pads));
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+			if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec1();
+
+	ret = fecmxc_initialize_multi(bis, 0,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC1 MXC: %s:failed\n", __func__);
+
+	return 0;
+}
+
+static int setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	/* Use 125M anatop REF_CLK1 for ENET1, clear gpr1[13], gpr1[17]*/
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
+		(IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_MASK |
+		 IOMUXC_GPR_GPR1_GPR_ENET1_CLK_DIR_MASK), 0);
+
+	ret = set_clk_enet(ENET_125MHz);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+
+int board_phy_config(struct phy_device *phydev)
+{
+	/* Enable 1.8V(SEL_1P5_1P8_POS_REG) on
+	   Phy control debug reg 0 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
+
+	/* rgmii tx clock delay enable */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX7D_PAD_ECSPI1_SCLK__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX7D_PAD_ECSPI1_MOSI__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX7D_PAD_ECSPI1_MISO__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+
+	/* CS0 */
+	MX7D_PAD_ECSPI1_SS0__GPIO4_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
+					 ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(4, 19), 0);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 19)) : -1;
+}
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX7
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX7D_PAD_GPIO1_IO05__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	MX7D_PAD_GPIO1_IO07__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg1_pads, ARRAY_SIZE(usb_otg1_pads));
+	imx_iomux_v3_setup_multiple_pads(usb_otg2_pads, ARRAY_SIZE(usb_otg2_pads));
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX7
+	setup_usb();
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_MXC_EPDC
+static iomux_v3_cfg_t const epdc_enable_pads[] = {
+	MX7D_PAD_EPDC_DATA00__EPDC_DATA0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA01__EPDC_DATA1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA02__EPDC_DATA2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA03__EPDC_DATA3	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA04__EPDC_DATA4	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA05__EPDC_DATA5	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA06__EPDC_DATA6	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA07__EPDC_DATA7	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCLK__EPDC_SDCLK		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDLE__EPDC_SDLE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDOE__EPDC_SDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDSHR__EPDC_SDSHR		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE0__EPDC_SDCE0		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE1__EPDC_SDCE1		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE2__EPDC_SDCE2		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE3__EPDC_SDCE3		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDCLK__EPDC_GDCLK		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDOE__EPDC_GDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDRL__EPDC_GDRL		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDSP__EPDC_GDSP		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_BDR0__EPDC_BDR0		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_BDR1__EPDC_BDR1		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const epdc_disable_pads[] = {
+	MX7D_PAD_EPDC_DATA00__GPIO2_IO0,
+	MX7D_PAD_EPDC_DATA01__GPIO2_IO1,
+	MX7D_PAD_EPDC_DATA02__GPIO2_IO2,
+	MX7D_PAD_EPDC_DATA03__GPIO2_IO3,
+	MX7D_PAD_EPDC_DATA04__GPIO2_IO4,
+	MX7D_PAD_EPDC_DATA05__GPIO2_IO5,
+	MX7D_PAD_EPDC_DATA06__GPIO2_IO6,
+	MX7D_PAD_EPDC_DATA07__GPIO2_IO7,
+	MX7D_PAD_EPDC_SDCLK__GPIO2_IO16,
+	MX7D_PAD_EPDC_SDLE__GPIO2_IO17,
+	MX7D_PAD_EPDC_SDOE__GPIO2_IO18,
+	MX7D_PAD_EPDC_SDSHR__GPIO2_IO19,
+	MX7D_PAD_EPDC_SDCE0__GPIO2_IO20,
+	MX7D_PAD_EPDC_SDCE1__GPIO2_IO21,
+	MX7D_PAD_EPDC_SDCE2__GPIO2_IO22,
+	MX7D_PAD_EPDC_SDCE3__GPIO2_IO23,
+	MX7D_PAD_EPDC_GDCLK__GPIO2_IO24,
+	MX7D_PAD_EPDC_GDOE__GPIO2_IO25,
+	MX7D_PAD_EPDC_GDRL__GPIO2_IO26,
+	MX7D_PAD_EPDC_GDSP__GPIO2_IO27,
+	MX7D_PAD_EPDC_BDR0__GPIO2_IO28,
+	MX7D_PAD_EPDC_BDR1__GPIO2_IO29,
+};
+
+vidinfo_t panel_info = {
+	.vl_refresh = 85,
+	.vl_col = 1024,
+	.vl_row = 758,
+	.vl_pixclock = 40000000,
+	.vl_left_margin = 12,
+	.vl_right_margin = 76,
+	.vl_upper_margin = 4,
+	.vl_lower_margin = 5,
+	.vl_hsync = 12,
+	.vl_vsync = 2,
+	.vl_sync = 0,
+	.vl_mode = 0,
+	.vl_flag = 0,
+	.vl_bpix = 3,
+	.cmap = 0,
+};
+
+struct epdc_timing_params panel_timings = {
+	.vscan_holdoff = 4,
+	.sdoed_width = 10,
+	.sdoed_delay = 20,
+	.sdoez_width = 10,
+	.sdoez_delay = 20,
+	.gdclk_hp_offs = 524,
+	.gdsp_offs = 327,
+	.gdoe_offs = 0,
+	.gdclk_offs = 19,
+	.num_ce = 1,
+};
+
+static void setup_epdc_power(void)
+{
+	/* IOMUX_GPR1: bit30: Disable On-chip RAM EPDC Function */
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
+		IOMUXC_GPR_GPR1_GPR_ENABLE_OCRAM_EPDC_MASK, 0);
+
+	/* Setup epdc voltage */
+
+	/* EPDC_PWRSTAT - GPIO2[31] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_PWR_STAT__GPIO2_IO31 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	gpio_direction_input(IMX_GPIO_NR(2, 31));
+
+	/* EPDC_VCOM0 - GPIO4[14] for VCOM control */
+	imx_iomux_v3_setup_pad(MX7D_PAD_I2C4_SCL__GPIO4_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(4, 14), 1);
+
+	/* EPDC_PWRWAKEUP - GPIO4[23] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX7D_PAD_ECSPI2_SS0__GPIO4_IO23 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(4, 23), 1);
+
+	/* EPDC_PWRCTRL0 - GPIO4[20] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX7D_PAD_ECSPI2_SCLK__GPIO4_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(4, 20), 1);
+}
+
+static void epdc_enable_pins(void)
+{
+	/* epdc iomux settings */
+	imx_iomux_v3_setup_multiple_pads(epdc_enable_pads,
+				ARRAY_SIZE(epdc_enable_pads));
+}
+
+static void epdc_disable_pins(void)
+{
+	/* Configure MUX settings for EPDC pins to GPIO  and drive to 0 */
+	imx_iomux_v3_setup_multiple_pads(epdc_disable_pads,
+				ARRAY_SIZE(epdc_disable_pads));
+}
+
+static void setup_epdc(void)
+{
+	/*** epdc Maxim PMIC settings ***/
+
+	/* EPDC_PWRSTAT - GPIO2[31] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_PWR_STAT__GPIO2_IO31 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_VCOM0 - GPIO4[14] for VCOM control */
+	imx_iomux_v3_setup_pad(MX7D_PAD_I2C4_SCL__GPIO4_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRWAKEUP - GPIO4[23] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX7D_PAD_ECSPI2_SS0__GPIO4_IO23 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRCTRL0 - GPIO4[20] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX7D_PAD_ECSPI2_SCLK__GPIO4_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set pixel clock rates for EPDC in clock.c */
+
+	panel_info.epdc_data.wv_modes.mode_init = 0;
+	panel_info.epdc_data.wv_modes.mode_du = 1;
+	panel_info.epdc_data.wv_modes.mode_gc4 = 3;
+	panel_info.epdc_data.wv_modes.mode_gc8 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc16 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc32 = 2;
+
+	panel_info.epdc_data.epdc_timings = panel_timings;
+
+	setup_epdc_power();
+}
+
+void epdc_power_on(void)
+{
+	unsigned int reg;
+	struct gpio_regs *gpio_regs = (struct gpio_regs *)GPIO2_BASE_ADDR;
+
+	/* Set EPD_PWR_CTL0 to high - enable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(4, 20), 1);
+	udelay(1000);
+
+	/* Enable epdc signal pin */
+	epdc_enable_pins();
+
+	/* Set PMIC Wakeup to high - enable Display power */
+	gpio_set_value(IMX_GPIO_NR(4, 23), 1);
+
+	/* Wait for PWRGOOD == 1 */
+	while (1) {
+		reg = readl(&gpio_regs->gpio_psr);
+		if (!(reg & (1 << 31)))
+			break;
+
+		udelay(100);
+	}
+
+	/* Enable VCOM */
+	gpio_set_value(IMX_GPIO_NR(4, 14), 1);
+
+	udelay(500);
+}
+
+void epdc_power_off(void)
+{
+	/* Set PMIC Wakeup to low - disable Display power */
+	gpio_set_value(IMX_GPIO_NR(4, 23), 0);
+
+	/* Disable VCOM */
+	gpio_set_value(IMX_GPIO_NR(4, 14), 0);
+
+	epdc_disable_pins();
+
+	/* Set EPD_PWR_CTL0 to low - disable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(4, 20), 0);
+}
+#endif
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	/* Reset peripherals */
+	imx_iomux_v3_setup_multiple_pads(per_rst_pads, ARRAY_SIZE(per_rst_pads));
+
+	gpio_direction_output(IMX_GPIO_NR(1, 3) , 0);
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(1, 3), 1);
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec();
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	board_qspi_init();
+#endif
+
+#ifdef	CONFIG_MXC_EPDC
+	setup_epdc();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x10, 0x12, 0x00, 0x00)},
+	{"sd2", MAKE_CFGVAL(0x10, 0x16, 0x00, 0x00)},
+	{"emmc", MAKE_CFGVAL(0x10, 0x2a, 0x00, 0x00)},
+	{"qspi", MAKE_CFGVAL(0x00, 0x40, 0x00, 0x00)},
+	{NULL,   0},
+};
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+int power_init_board(void)
+{
+	struct pmic *p;
+	int ret;
+	unsigned int reg, rev_id;
+
+	ret = power_pfuze3000_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	p = pmic_get("PFUZE3000");
+	ret = pmic_probe(p);
+	if (ret)
+		return ret;
+
+	pmic_reg_read(p, PFUZE3000_DEVICEID, &reg);
+	pmic_reg_read(p, PFUZE3000_REVID, &rev_id);
+	printf("PMIC: PFUZE3000 DEV_ID=0x%x REV_ID=0x%x\n", reg, rev_id);
+
+	/* disable Low Power Mode during standby mode */
+	pmic_reg_read(p, PFUZE3000_LDOGCTL, &reg);
+	reg |= 0x1;
+	pmic_reg_write(p, PFUZE3000_LDOGCTL, reg);
+
+	/* SW1A/1B mode set to APS/APS */
+	reg = 0x8;
+	pmic_reg_write(p, PFUZE3000_SW1AMODE, reg);
+	pmic_reg_write(p, PFUZE3000_SW1BMODE, reg);
+
+	/* SW1A/1B standby voltage set to 0.975V */
+	reg = 0xb;
+	pmic_reg_write(p, PFUZE3000_SW1ASTBY, reg);
+	pmic_reg_write(p, PFUZE3000_SW1BSTBY, reg);
+
+	/* below are for LPSR mode support */
+	pmic_reg_read(p, PFUZE3000_SW3MODE, &reg);
+	reg |= 0x20;
+	pmic_reg_write(p, PFUZE3000_SW3MODE, reg);
+
+	pmic_reg_read(p, PFUZE3000_VLDO1CTL, &reg);
+	reg |= 0x80;
+	pmic_reg_write(p, PFUZE3000_VLDO1CTL, reg);
+
+	pmic_reg_read(p, PFUZE3000_VLDO3CTL, &reg);
+	reg |= 0x80;
+	pmic_reg_write(p, PFUZE3000_VLDO3CTL, reg);
+
+	pmic_reg_read(p, PFUZE3000_SW2MODE, &reg);
+	reg |= 0x20;
+	pmic_reg_write(p, PFUZE3000_SW2MODE, reg);
+
+	/* set SW1B normal voltage to 0.975V */
+	pmic_reg_read(p, PFUZE3000_SW1BVOLT, &reg);
+	reg &= ~0x1f;
+	reg |= PFUZE3000_SW1AB_SETP(975);
+	pmic_reg_write(p, PFUZE3000_SW1BVOLT, reg);
+
+	return 0;
+}
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	imx_iomux_v3_setup_multiple_pads(wdog_pads, ARRAY_SIZE(wdog_pads));
+
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: MX7D 12x12 LPDDR3 ARM2\n");
+
+	return 0;
+}
diff -urN u-boot-2016.03/board/freescale/mx7d_12x12_lpddr3_arm2/plugin.S ebf_6ull_uboot/board/freescale/mx7d_12x12_lpddr3_arm2/plugin.S
--- u-boot-2016.03/board/freescale/mx7d_12x12_lpddr3_arm2/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_12x12_lpddr3_arm2/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,577 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx7d_ddrphy_latency_setting
+	ldr r2, =ANATOP_BASE_ADDR
+	ldr r3, [r2, #0x800]
+	and r3, r3, #0xFF
+	cmp r3, #0x11
+	bne TUNE_END
+
+	/*TO 1.1*/
+	ldr r1, =0x1c1c1c1c
+	str r1, [r0, #0x7c]
+	ldr r1, =0x1c1c1c1c
+	str r1, [r0, #0x80]
+	ldr r1, =0x30301c1c
+	str r1, [r0, #0x84]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x88]
+	ldr r1, =0x30303030
+	str r1, [r0, #0x6c]
+
+TUNE_END:
+.endm
+
+.macro imx7d_12x12_lpddr3_arm2_setting
+
+	/* check whether it is a LPSR resume */
+	ldr	r1, =0x30270000
+	ldr	r7, [r1]
+	cmp	r7, #0
+	beq	16f
+
+	/* disable wdog powerdown counter */
+	ldr	r0, =0x30280000
+	ldrh	r1, =0x0
+	strh	r1, [r0, #0x8]
+
+	/* initialize AIPs 1-3 port */
+	ldr	r0, =0x301f0000
+	ldr	r1, =0x77777777
+	str	r1, [r0]
+	str	r1, [r0, #0x4]
+	ldr	r1, =0x0
+	str	r1, [r0, #0x40]
+	str	r1, [r0, #0x44]
+	str	r1, [r0, #0x48]
+	str	r1, [r0, #0x4c]
+	str	r1, [r0, #0x50]
+
+	ldr	r0, =0x305f0000
+	ldr	r1, =0x77777777
+	str	r1, [r0]
+	str	r1, [r0, #0x4]
+	ldr	r1, =0x0
+	str	r1, [r0, #0x40]
+	str	r1, [r0, #0x44]
+	str	r1, [r0, #0x48]
+	str	r1, [r0, #0x4c]
+	str	r1, [r0, #0x50]
+
+	ldr	r0, =0x309f0000
+	ldr	r1, =0x77777777
+	str	r1, [r0]
+	str	r1, [r0, #0x4]
+	ldr	r1, =0x0
+	str	r1, [r0, #0x40]
+	str	r1, [r0, #0x44]
+	str	r1, [r0, #0x48]
+	str	r1, [r0, #0x4c]
+	str	r1, [r0, #0x50]
+
+	ldr	r1, =0x30360000
+	ldr	r2, =0x30390000
+	ldr	r3, =0x307a0000
+	ldr	r4, =0x30790000
+	ldr	r10, =0x30380000
+	ldr	r11, =0x30340000
+
+	/* turn on ddr power */
+	ldr	r7, =(0x1 << 29)
+	str	r7, [r1, #0x388]
+
+	ldr	r6, =50
+1:
+	subs	r6, r6, #0x1
+	bne	1b
+
+	/* clear ddr_phy reset */
+	ldr	r6, =0x1000
+	ldr	r7, [r2, r6]
+	orr	r7, r7, #0x3
+	str	r7, [r2, r6]
+	ldr	r7, [r2, r6]
+	bic	r7, r7, #0x1
+	str	r7, [r2, r6]
+
+	/* restore DDRC */
+	ldr	r6, =0x0
+	ldr	r7, =0x03040008
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x1a0
+	ldr	r7, =0x80400003
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x1a4
+	ldr	r7, =0x00100020
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x1a8
+	ldr	r7, =0x80100004
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x64
+	ldr	r7, =0x00200038
+	str	r7, [r3, r6]
+
+	ldr	r6, =0xd0
+	ldr	r7, =0xc0350001
+	str	r7, [r3, r6]
+
+	ldr	r6, =0xdc
+	ldr	r7, =0x00C3000A
+	str	r7, [r3, r6]
+
+	ldr	r6, =0xe0
+	ldr	r7, =0x00010000
+	str	r7, [r3, r6]
+
+	ldr	r6, =0xe4
+	ldr	r7, =0x00110006
+	str	r7, [r3, r6]
+
+	ldr	r6, =0xf4
+	ldr	r7, =0x0000033F
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x100
+	ldr	r7, =0x0A0E110B
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x104
+	ldr	r7, =0x00020211
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x108
+	ldr	r7, =0x03060708
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x10c
+	ldr	r7, =0x00A0500C
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x110
+	ldr	r7, =0x05020307
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x114
+	ldr	r7, =0x02020404
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x118
+	ldr	r7, =0x02020003
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x11c
+	ldr	r7, =0x00000202
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x120
+	ldr	r7, =0x00000202
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x180
+	ldr	r7, =0x00600018
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x184
+	ldr	r7, =0x00e00100
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x190
+	ldr	r7, =0x02098205
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x194
+	ldr	r7, =0x00060303
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x200
+	ldr	r7, =0x00000016
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x204
+	ldr	r7, =0x00171717
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x210
+	ldr	r7, =0xF00
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x214
+	ldr	r7, =0x05050505
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x218
+	ldr	r7, =0x0F0F0505
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x240
+	ldr	r7, =0x06000601
+	str	r7, [r3, r6]
+
+	ldr	r6, =0x244
+	ldr	r7, =0x00000000
+	str	r7, [r3, r6]
+
+	ldr	r7, =0x20
+	str	r7, [r3, #0x30]
+	ldr	r7, =0x0
+	str	r7, [r3, #0x1b0]
+
+	/* do PHY, clear ddr_phy reset */
+	ldr	r6, =0x1000
+	ldr	r7, [r2, r6]
+	bic	r7, r7, #0x2
+	str	r7, [r2, r6]
+
+	ldr	r7, [r1, #0x800]
+	and	r7, r7, #0xFF
+	cmp	r7, #0x11
+	bne	2f
+
+	/* for TO1.1 */
+	ldr	r7, [r11]
+	bic	r7, r7, #(1 << 27)
+	str	r7, [r11]
+	ldr	r7, [r11]
+	bic	r7, r7, #(1 << 29)
+	str	r7, [r11]
+2:
+	/* clear/set bit30 of SNVS_MISC_CTRL to ensure exit from ddr retention */
+	ldr	r7, =(0x1 << 30)
+	str	r7, [r1, #0x388]
+	ldr	r7, =(0x1 << 30)
+	str	r7, [r1, #0x384]
+
+	/* need to delay ~5mS */
+	ldr	r6, =0x100000
+3:
+	subs	r6, r6, #0x1
+	bne	3b
+
+	/* restore DDR PHY */
+	ldr	r6, =0x0
+	ldr	r7, =0x17421E40
+	str	r7, [r4, r6]
+
+	ldr	r6, =0x4
+	ldr	r7, =0x10210100
+	str	r7, [r4, r6]
+
+	ldr	r6, =0x8
+	ldr	r7, =0x00010000
+	str	r7, [r4, r6]
+
+	ldr	r6, =0x10
+	ldr	r7, =0x0007080C
+	str	r7, [r4, r6]
+
+	ldr	r6, =0xb0
+	ldr	r7, =0x1010007e
+	str	r7, [r4, r6]
+
+	ldr     r7, [r1, #0x800]
+	and     r7, r7, #0xFF
+	cmp     r7, #0x11
+	bne     4f
+
+	ldr	r6, =0x7c
+	ldr	r7, =0x1c1c1c1c
+	str	r7, [r4, r6]
+
+	ldr	r6, =0x80
+	ldr	r7, =0x1c1c1c1c
+	str	r7, [r4, r6]
+
+	ldr	r6, =0x84
+	ldr	r7, =0x30301c1c
+	str	r7, [r4, r6]
+
+	ldr	r6, =0x88
+	ldr	r7, =0x00000030
+	str	r7, [r4, r6]
+
+	ldr	r6, =0x6c
+	ldr	r7, =0x30303030
+	str	r7, [r4, r6]
+
+4:
+	ldr	r6, =0x1c
+	ldr	r7, =0x01010000
+	str	r7, [r4, r6]
+
+	ldr	r6, =0x9c
+	ldr	r7, =0x0DB60D6E
+	str	r7, [r4, r6]
+
+	ldr	r6, =0x20
+	ldr	r7, =0x0a0a0a0a
+	str	r7, [r4, r6]
+
+	ldr	r6, =0x30
+	ldr	r7, =0x06060606
+	str	r7, [r4, r6]
+
+	ldr	r6, =0x50
+	ldr	r7, =0x01000008
+	str	r7, [r4, r6]
+
+	ldr	r6, =0x50
+	ldr	r7, =0x00000008
+	str	r7, [r4, r6]
+
+	ldr	r6, =0xc0
+	ldr	r7, =0x0e407304
+	str	r7, [r4, r6]
+
+	ldr	r6, =0xc0
+	ldr	r7, =0x0e447304
+	str	r7, [r4, r6]
+
+	ldr	r6, =0xc0
+	ldr	r7, =0x0e447306
+	str	r7, [r4, r6]
+
+	ldr	r6, =0xc0
+	ldr	r7, =0x0e4c7304
+	str	r7, [r4, r6]
+
+	ldr	r6, =0xc0
+	ldr	r7, =0x0e487306
+	str	r7, [r4, r6]
+
+	ldr	r7, =0x0
+	add	r9, r10, #0x4000
+	str	r7, [r9, #0x130]
+
+	ldr	r7, =0x170
+	orr	r7, r7, #0x8
+	str	r7, [r11, #0x20]
+
+	ldr	r7, =0x2
+	add	r9, r10, #0x4000
+	str	r7, [r9, #0x130]
+
+	ldr	r7, =0xf
+	str	r7, [r4, #0x18]
+
+	/* wait until self-refresh mode entered */
+11:
+	ldr	r7, [r3, #0x4]
+	and	r7, r7, #0x3
+	cmp	r7, #0x3
+	bne	11b
+	ldr	r7, =0x0
+	str	r7, [r3, #0x320]
+	ldr	r7, =0x1
+	str	r7, [r3, #0x1b0]
+	ldr	r7, =0x1
+	str	r7, [r3, #0x320]
+12:
+	ldr	r7, [r3, #0x324]
+	and	r7, r7, #0x1
+	cmp	r7, #0x1
+	bne	12b
+13:
+	ldr	r7, [r3, #0x4]
+	and	r7, r7, #0x20
+	cmp	r7, #0x20
+	bne	13b
+
+	/* let DDR out of self-refresh */
+	ldr	r7, =0x0
+	str	r7, [r3, #0x30]
+14:
+	ldr	r7, [r3, #0x4]
+	and	r7, r7, #0x30
+	cmp	r7, #0x0
+	bne	14b
+
+15:
+	ldr	r7, [r3, #0x4]
+	and	r7, r7, #0x3
+	cmp	r7, #0x1
+	bne	15b
+
+	/* enable port */
+	ldr	r7, =0x1
+	str	r7, [r3, #0x490]
+
+	/* jump to kernel resume */
+	ldr	r1, =0x30270000
+	ldr	r7, [r1]
+
+	mov	pc, r7
+16:
+	/* Configure ocram_epdc */
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	ldr r1, =0x4f400005
+	str r1, [r0, #0x4]
+
+	/* clear/set bit30 of SNVS_MISC_CTRL to ensure exit from ddr retention */
+	ldr r0, =ANATOP_BASE_ADDR
+	ldr r1, =(0x1 << 30)
+	str r1, [r0, #0x388]
+	str r1, [r0, #0x384]
+
+	ldr r0, =SRC_BASE_ADDR
+	ldr r1, =0x2
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+	ldr r1, =0x03040008
+	str r1, [r0]
+	ldr r1, =0x00200038
+	str r1, [r0, #0x64]
+	ldr r1, =0x1
+	str r1, [r0, #0x490]
+	ldr r1, =0x00350001
+	str r1, [r0, #0xd0]
+	ldr r1, =0x00c3000a
+	str r1, [r0, #0xdc]
+	ldr r1, =0x00010000
+	str r1, [r0, #0xe0]
+	ldr r1, =0x00110006
+	str r1, [r0, #0xe4]
+	ldr r1, =0x33f
+	str r1, [r0, #0xf4]
+	ldr r1, =0x0a0e110b
+	str r1, [r0, #0x100]
+	ldr r1, =0x00020211
+	str r1, [r0, #0x104]
+	ldr r1, =0x03060708
+	str r1, [r0, #0x108]
+	ldr r1, =0x00a0500c
+	str r1, [r0, #0x10c]
+	ldr r1, =0x05020307
+	str r1, [r0, #0x110]
+	ldr r1, =0x02020404
+	str r1, [r0, #0x114]
+	ldr r1, =0x02020003
+	str r1, [r0, #0x118]
+	ldr r1, =0x00000202
+	str r1, [r0, #0x11c]
+	ldr r1, =0x00000202
+	str r1, [r0, #0x120]
+	ldr r1, =0x00600018
+	str r1, [r0, #0x180]
+	ldr r1, =0x00e00100
+	str r1, [r0, #0x184]
+	ldr r1, =0x02098205
+	str r1, [r0, #0x190]
+	ldr r1, =0x00060303
+	str r1, [r0, #0x194]
+	ldr r1, =0x80400003
+	str r1, [r0, #0x1a0]
+	ldr r1, =0x00100020
+	str r1, [r0, #0x1a4]
+	ldr r1, =0x80100004
+	str r1, [r0, #0x1a8]
+
+	ldr r1, =0x00000016
+	str r1, [r0, #0x200]
+	ldr r1, =0x00171717
+	str r1, [r0, #0x204]
+	ldr r1, =0x00000f00
+	str r1, [r0, #0x210]
+	ldr r1, =0x05050505
+	str r1, [r0, #0x214]
+	ldr r1, =0x0f0f0505
+	str r1, [r0, #0x218]
+
+	ldr r1, =0x06000601
+	str r1, [r0, #0x240]
+	mov r1, #0x0
+	str r1, [r0, #0x244]
+
+	ldr r0, =SRC_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRPHY_IPS_BASE_ADDR
+	ldr r1, =0x17421e40
+	str r1, [r0]
+	ldr r1, =0x10210100
+	str r1, [r0, #0x4]
+	ldr r1, =0x00010000
+	str r1, [r0, #0x8]
+	ldr r1, =0x0007080c
+	str r1, [r0, #0x10]
+	imx7d_ddrphy_latency_setting
+	ldr r1, =0x1010007e
+	str r1, [r0, #0xb0]
+	ldr r1, =0x01010000
+	str r1, [r0, #0x1c]
+	ldr r1, =0x0db60d6e
+	str r1, [r0, #0x9c]
+
+	ldr r1, =0x06060606
+	str r1, [r0, #0x30]
+	ldr r1, =0x0a0a0a0a
+	str r1, [r0, #0x20]
+	ldr r1, =0x01000008
+	str r1, [r0, #0x50]
+	ldr r1, =0x00000008
+	str r1, [r0, #0x50]
+
+	ldr r1, =0x0000000f
+	str r1, [r0, #0x18]
+	ldr r1, =0x1e487304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x1e487304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x1e487306
+	str r1, [r0, #0xc0]
+	ldr r1, =0x1e4c7304
+	str r1, [r0, #0xc0]
+
+wait_zq:
+	ldr r1, [r0, #0xc4]
+	tst r1, #0x1
+	beq wait_zq
+
+	ldr r1, =0x1e487304
+	str r1, [r0, #0xc0]
+
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	mov r1, #0x178
+	str r1, [r0, #0x20]
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x2
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+wait_stat:
+	ldr r1, [r0, #0x4]
+	tst r1, #0x1
+	beq wait_stat
+.endm
+
+.macro imx7_clock_gating
+.endm
+
+.macro imx7_qos_setting
+.endm
+
+.macro imx7_ddr_setting
+	imx7d_12x12_lpddr3_arm2_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx7_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx7d_19x19_ddr3_arm2/imximage.cfg ebf_6ull_uboot/board/freescale/mx7d_19x19_ddr3_arm2/imximage.cfg
--- u-boot-2016.03/board/freescale/mx7d_19x19_ddr3_arm2/imximage.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_19x19_ddr3_arm2/imximage.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx7d_19x19_ddr3_arm2/plugin.bin 0x00910000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x30340004 0x4F400005
+
+DATA 4 0x30391000 0x00000002
+DATA 4 0x307a0000 0x03040001
+DATA 4 0x307a01a0 0x80400003
+DATA 4 0x307a01a4 0x00100020
+DATA 4 0x307a01a8 0x80100004
+DATA 4 0x307a0064 0x0040005e
+DATA 4 0x307a0490 0x00000001
+DATA 4 0x307a00d0 0x00020001
+DATA 4 0x307a00d4 0x00010000
+DATA 4 0x307a00dc 0x09300004
+DATA 4 0x307a00e0 0x04080000
+DATA 4 0x307a00e4 0x00090004
+DATA 4 0x307a00f4 0x0000033f
+DATA 4 0x307a0100 0x0908120a
+DATA 4 0x307a0104 0x0002020e
+DATA 4 0x307a0108 0x03040407
+DATA 4 0x307a010c 0x00002006
+DATA 4 0x307a0110 0x04020204
+DATA 4 0x307a0114 0x03030202
+DATA 4 0x307a0120 0x03030803
+DATA 4 0x307a0180 0x00800020
+DATA 4 0x307a0190 0x02098204
+DATA 4 0x307a0194 0x00030303
+DATA 4 0x307a0200 0x00000016
+DATA 4 0x307a0204 0x00171717
+DATA 4 0x307a0214 0x04040404
+DATA 4 0x307a0218 0x00040404
+DATA 4 0x307a0240 0x06000601
+DATA 4 0x307a0244 0x00001323
+DATA 4 0x30391000 0x00000000
+DATA 4 0x30790000 0x17420f40
+DATA 4 0x30790004 0x10210100
+DATA 4 0x30790010 0x00060807
+DATA 4 0x3079009c 0x00000d6e
+DATA 4 0x30790020 0x08080808
+DATA 4 0x30790030 0x08080808
+DATA 4 0x30790050 0x01000010
+DATA 4 0x30790050 0x00000010
+
+DATA 4 0x307900c0 0x0e407304
+DATA 4 0x307900c0 0x0e447304
+DATA 4 0x307900c0 0x0e447306
+
+CHECK_BITS_SET 4 0x307900c4 0x1
+
+DATA 4 0x307900c0 0x0e447304
+DATA 4 0x307900c0 0x0e407304
+
+
+DATA 4 0x30384130 0x00000000
+DATA 4 0x30340020 0x00000178
+DATA 4 0x30384130 0x00000002
+DATA 4 0x30790018 0x0000000f
+
+CHECK_BITS_SET 4 0x307a0004 0x1
+#endif
diff -urN u-boot-2016.03/board/freescale/mx7d_19x19_ddr3_arm2/imximage_TO_1_1.cfg ebf_6ull_uboot/board/freescale/mx7d_19x19_ddr3_arm2/imximage_TO_1_1.cfg
--- u-boot-2016.03/board/freescale/mx7d_19x19_ddr3_arm2/imximage_TO_1_1.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_19x19_ddr3_arm2/imximage_TO_1_1.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx7d_19x19_ddr3_arm2/plugin.bin 0x00910000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x30360070 0x00703021
+DATA 4 0x30360090 0x0
+DATA 4 0x30360070 0x00603021
+CHECK_BITS_SET 4 0x30360070 0x80000000
+DATA 4 0x30389880 0x1
+
+DATA 4 0x30340004 0x4F400005
+
+DATA 4 0x30391000 0x00000002
+DATA 4 0x307a0000 0x03040001
+DATA 4 0x307a01a0 0x80400003
+DATA 4 0x307a01a4 0x00100020
+DATA 4 0x307a01a8 0x80100004
+DATA 4 0x307a0064 0x0040005e
+DATA 4 0x307a0490 0x00000001
+DATA 4 0x307a00d0 0x00020001
+DATA 4 0x307a00d4 0x00010000
+DATA 4 0x307a00dc 0x09300004
+DATA 4 0x307a00e0 0x04080000
+DATA 4 0x307a00e4 0x00090004
+DATA 4 0x307a00f4 0x0000033f
+DATA 4 0x307a0100 0x0908120a
+DATA 4 0x307a0104 0x0002020e
+DATA 4 0x307a0108 0x03040407
+DATA 4 0x307a010c 0x00002006
+DATA 4 0x307a0110 0x04020204
+DATA 4 0x307a0114 0x03030202
+DATA 4 0x307a0120 0x03030803
+DATA 4 0x307a0180 0x00800020
+DATA 4 0x307a0190 0x02098204
+DATA 4 0x307a0194 0x00030303
+DATA 4 0x307a0200 0x00000016
+DATA 4 0x307a0204 0x00171717
+DATA 4 0x307a0214 0x04040404
+DATA 4 0x307a0218 0x00040404
+DATA 4 0x307a0240 0x06000601
+DATA 4 0x307a0244 0x00001323
+DATA 4 0x30391000 0x00000000
+DATA 4 0x30790000 0x17420f40
+DATA 4 0x30790004 0x10210100
+DATA 4 0x30790010 0x00060807
+DATA 4 0x3079009c 0x00000dee
+DATA 4 0x3079007c 0x18181818
+DATA 4 0x30790080 0x18181818
+DATA 4 0x30790084 0x40401818
+DATA 4 0x30790088 0x00000040
+DATA 4 0x3079006c 0x40404040
+DATA 4 0x30790020 0x08080808
+DATA 4 0x30790030 0x08080808
+DATA 4 0x30790050 0x01000010
+DATA 4 0x30790050 0x00000010
+
+DATA 4 0x307900c0 0x0e407304
+DATA 4 0x307900c0 0x0e447304
+DATA 4 0x307900c0 0x0e447306
+
+CHECK_BITS_SET 4 0x307900c4 0x1
+
+DATA 4 0x307900c0 0x0e447304
+DATA 4 0x307900c0 0x0e407304
+
+
+DATA 4 0x30384130 0x00000000
+DATA 4 0x30340020 0x00000178
+DATA 4 0x30384130 0x00000002
+DATA 4 0x30790018 0x0000000f
+
+CHECK_BITS_SET 4 0x307a0004 0x1
+#endif
diff -urN u-boot-2016.03/board/freescale/mx7d_19x19_ddr3_arm2/Kconfig ebf_6ull_uboot/board/freescale/mx7d_19x19_ddr3_arm2/Kconfig
--- u-boot-2016.03/board/freescale/mx7d_19x19_ddr3_arm2/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_19x19_ddr3_arm2/Kconfig	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,12 @@
+if TARGET_MX7D_19X19_DDR3_ARM2
+
+config SYS_BOARD
+	default "mx7d_19x19_ddr3_arm2"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_CONFIG_NAME
+	default "mx7d_19x19_ddr3_arm2"
+
+endif
diff -urN u-boot-2016.03/board/freescale/mx7d_19x19_ddr3_arm2/Makefile ebf_6ull_uboot/board/freescale/mx7d_19x19_ddr3_arm2/Makefile
--- u-boot-2016.03/board/freescale/mx7d_19x19_ddr3_arm2/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_19x19_ddr3_arm2/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,10 @@
+# (C) Copyright 2014 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx7d_19x19_ddr3_arm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx7d_19x19_ddr3_arm2/mx7d_19x19_ddr3_arm2.c ebf_6ull_uboot/board/freescale/mx7d_19x19_ddr3_arm2/mx7d_19x19_ddr3_arm2.c
--- u-boot-2016.03/board/freescale/mx7d_19x19_ddr3_arm2/mx7d_19x19_ddr3_arm2.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_19x19_ddr3_arm2/mx7d_19x19_ddr3_arm2.c	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,593 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx7-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze3000_pmic.h>
+#include "../common/pfuze.h"
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#include <asm/arch/crm_regs.h>
+#include <asm/imx-common/video.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_DSE_3P3V_49OHM | \
+	PAD_CTL_PUS_PU100KOHM | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+	PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU47KOHM)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_98OHM)
+#define ENET_PAD_CTRL_MII  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_98OHM)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_98OHM)
+
+#define I2C_PAD_CTRL    (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+	PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU100KOHM)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_PU100KOHM | \
+	PAD_CTL_DSE_3P3V_49OHM)
+
+#define QSPI_PAD_CTRL	\
+		(PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_PUE | PAD_CTL_PUS_PU47KOHM)
+
+#define SPI_PAD_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_SRE_SLOW | PAD_CTL_HYS)
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX7D_PAD_I2C1_SCL__I2C1_SCL | PC,
+		.gpio_mode = MX7D_PAD_I2C1_SCL__GPIO4_IO8 | PC,
+		.gp = IMX_GPIO_NR(4, 8),
+	},
+	.sda = {
+		.i2c_mode = MX7D_PAD_I2C1_SDA__I2C1_SDA | PC,
+		.gpio_mode = MX7D_PAD_I2C1_SDA__GPIO4_IO9 | PC,
+		.gp = IMX_GPIO_NR(4, 9),
+	},
+};
+
+/* I2C2 */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX7D_PAD_I2C2_SCL__I2C2_SCL | PC,
+		.gpio_mode = MX7D_PAD_I2C2_SCL__GPIO4_IO10 | PC,
+		.gp = IMX_GPIO_NR(4, 10),
+	},
+	.sda = {
+		.i2c_mode = MX7D_PAD_I2C2_SDA__I2C2_SDA | PC,
+		.gpio_mode = MX7D_PAD_I2C2_SDA__GPIO4_IO11 | PC,
+		.gp = IMX_GPIO_NR(4, 11),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX7D_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX7D_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc1_emmc_pads[] = {
+	MX7D_PAD_SD1_CLK__SD1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_CMD__SD1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA0__SD1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA1__SD1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA2__SD1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA3__SD1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_ECSPI2_SCLK__SD1_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_ECSPI2_MOSI__SD1_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_ECSPI2_MISO__SD1_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_ECSPI2_SS0__SD1_DATA7  | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_SD1_CD_B__GPIO5_IO0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_RESET_B__GPIO5_IO2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX7D_PAD_SD2_CLK__SD2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_CMD__SD2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_DATA0__SD2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_DATA1__SD2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_DATA2__SD2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_DATA3__SD2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_GPIO1_IO12__SD2_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_SD2_CD_B__GPIO5_IO9 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD2_RESET_B__GPIO5_IO11 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX7D_PAD_SD3_CLK__SD3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_CMD__SD3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA4__SD3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA5__SD3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA6__SD3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA7__SD3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_GPIO1_IO13__SD3_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_GPIO1_IO14__GPIO1_IO14  | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_RESET_B__GPIO6_IO11 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX7D_PAD_LCD_CLK__LCD_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_ENABLE__LCD_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_HSYNC__LCD_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_VSYNC__LCD_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA00__LCD_DATA0 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA01__LCD_DATA1 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA02__LCD_DATA2 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA03__LCD_DATA3 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA04__LCD_DATA4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA05__LCD_DATA5 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA06__LCD_DATA6 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA07__LCD_DATA7 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA08__LCD_DATA8 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA09__LCD_DATA9 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA10__LCD_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA11__LCD_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA12__LCD_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA13__LCD_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA14__LCD_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA15__LCD_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA16__LCD_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA17__LCD_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA18__LCD_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA19__LCD_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA20__LCD_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA21__LCD_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA22__LCD_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA23__LCD_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+
+	MX7D_PAD_LCD_RESET__GPIO3_IO4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const pwm_pads[] = {
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX7D_PAD_GPIO1_IO01__GPIO1_IO1 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void do_enable_parallel_lcd(struct display_info_t const *dev)
+{
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	imx_iomux_v3_setup_multiple_pads(pwm_pads, ARRAY_SIZE(pwm_pads));
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(3, 4) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(1, 1) , 1);
+}
+
+struct display_info_t const displays[] = {{
+	.bus = ELCDIF1_IPS_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 24,
+	.detect = NULL,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+#endif
+
+static iomux_v3_cfg_t const per_rst_pads[] = {
+	MX7D_PAD_GPIO1_IO03__GPIO1_IO3 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const wdog_pads[] = {
+	MX7D_PAD_GPIO1_IO00__WDOG1_WDOG_B | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX7D_PAD_GPIO1_IO11__ENET1_MDC  | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_GPIO1_IO10__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE0__ENET2_RGMII_RX_CTL | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCLK__ENET2_RGMII_RD0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_SDLE__ENET2_RGMII_RD1  | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_SDOE__ENET2_RGMII_RD2  | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_SDSHR__ENET2_RGMII_RD3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE1__ENET2_RGMII_RXC | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_GDRL__ENET2_RGMII_TX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE2__ENET2_RGMII_TD0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE3__ENET2_RGMII_TD1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_GDCLK__ENET2_RGMII_TD2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_GDOE__ENET2_RGMII_TD3  | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_GDSP__ENET2_RGMII_TXC  | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static void setup_iomux_fec2(void)
+{
+	imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_QSPI
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX7D_PAD_EPDC_DATA00__QSPI_A_DATA0 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA01__QSPI_A_DATA1 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA02__QSPI_A_DATA2 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA03__QSPI_A_DATA3 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA04__QSPI_A_DQS   | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA05__QSPI_A_SCLK  | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA06__QSPI_A_SS0_B | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA07__QSPI_A_SS1_B | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+
+	MX7D_PAD_EPDC_DATA08__QSPI_B_DATA0 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA09__QSPI_B_DATA1 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA10__QSPI_B_DATA2 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA11__QSPI_B_DATA3 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA12__QSPI_B_DQS   | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA13__QSPI_B_SCLK  | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA14__QSPI_B_SS0_B | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA15__QSPI_B_SS1_B | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads, ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	set_clk_qspi();
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(5, 9)
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(1, 14)
+
+#define USDHC1_PWR_GPIO	IMX_GPIO_NR(5, 2)
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(5, 11)
+#define USDHC3_PWR_GPIO	IMX_GPIO_NR(6, 11)
+
+
+static struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC1_BASE_ADDR},
+	{USDHC2_BASE_ADDR, 0, 4},
+	{USDHC3_BASE_ADDR},
+};
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = 1; /* Assume uSDHC1 emmc is always present */
+		break;
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD_GPIO);
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	}
+
+	return ret;
+}
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1 (eMMC)
+	 * mmc1                    USDHC2
+	 * mmc2                    USDHC3
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_emmc_pads, ARRAY_SIZE(usdhc1_emmc_pads));
+			gpio_direction_output(USDHC1_PWR_GPIO, 1);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_direction_input(USDHC2_CD_GPIO);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		case 2:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			gpio_direction_output(USDHC3_PWR_GPIO, 1);
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+			if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec2();
+
+	ret = fecmxc_initialize_multi(bis, 0,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC1 MXC: %s:failed\n", __func__);
+
+	return 0;
+}
+
+static int setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	/* Use 125M anatop REF_CLK for ENET2, clear gpr1[14], gpr1[18]*/
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
+		(IOMUXC_GPR_GPR1_GPR_ENET2_TX_CLK_SEL_MASK |
+		 IOMUXC_GPR_GPR1_GPR_ENET2_CLK_DIR_MASK), 0);
+
+	ret = set_clk_enet(ENET_125MHz);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+
+int board_phy_config(struct phy_device *phydev)
+{
+	/* Enable 1.8V(SEL_1P5_1P8_POS_REG) on
+	   Phy control debug reg 0 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
+
+	/* rgmii tx clock delay enable */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX7D_PAD_ECSPI1_SCLK__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX7D_PAD_ECSPI1_MOSI__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX7D_PAD_ECSPI1_MISO__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+
+	/* CS0 */
+	MX7D_PAD_ECSPI1_SS0__GPIO4_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
+					 ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(4, 19), 0);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 19)) : -1;
+}
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX7
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX7D_PAD_GPIO1_IO05__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	MX7D_PAD_GPIO1_IO07__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg1_pads, ARRAY_SIZE(usb_otg1_pads));
+	imx_iomux_v3_setup_multiple_pads(usb_otg2_pads, ARRAY_SIZE(usb_otg2_pads));
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX7
+	setup_usb();
+#endif
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	/* Reset peripherals */
+	imx_iomux_v3_setup_multiple_pads(per_rst_pads, ARRAY_SIZE(per_rst_pads));
+
+	gpio_direction_output(IMX_GPIO_NR(1, 3) , 0);
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(1, 3), 1);
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec();
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	board_qspi_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"emmc", MAKE_CFGVAL(0x10, 0x22, 0x00, 0x00)},
+	{"sd2", MAKE_CFGVAL(0x10, 0x16, 0x00, 0x00)},
+	{"sd3", MAKE_CFGVAL(0x10, 0x1a, 0x00, 0x00)},
+	{"qspi", MAKE_CFGVAL(0x00, 0x40, 0x00, 0x00)},
+	{NULL,   0},
+};
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+int power_init_board(void)
+{
+	struct pmic *p;
+	int ret;
+	unsigned int reg, rev_id;
+
+	ret = power_pfuze3000_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	p = pmic_get("PFUZE3000");
+	ret = pmic_probe(p);
+	if (ret)
+		return ret;
+
+	pmic_reg_read(p, PFUZE3000_DEVICEID, &reg);
+	pmic_reg_read(p, PFUZE3000_REVID, &rev_id);
+	printf("PMIC: PFUZE3000 DEV_ID=0x%x REV_ID=0x%x\n", reg, rev_id);
+
+	/* disable Low Power Mode during standby mode */
+	pmic_reg_read(p, PFUZE3000_LDOGCTL, &reg);
+	reg |= 0x1;
+	pmic_reg_write(p, PFUZE3000_LDOGCTL, reg);
+
+	/* SW1A/1B mode set to APS/APS */
+	reg = 0x8;
+	pmic_reg_write(p, PFUZE3000_SW1AMODE, reg);
+	pmic_reg_write(p, PFUZE3000_SW1BMODE, reg);
+
+	/* SW1A/1B standby voltage set to 0.975V */
+	reg = 0xb;
+	pmic_reg_write(p, PFUZE3000_SW1ASTBY, reg);
+	pmic_reg_write(p, PFUZE3000_SW1BSTBY, reg);
+
+	/* set SW1B normal voltage to 0.975V */
+	pmic_reg_read(p, PFUZE3000_SW1BVOLT, &reg);
+	reg &= ~0x1f;
+	reg |= PFUZE3000_SW1AB_SETP(975);
+	pmic_reg_write(p, PFUZE3000_SW1BVOLT, reg);
+
+	return 0;
+}
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	imx_iomux_v3_setup_multiple_pads(wdog_pads, ARRAY_SIZE(wdog_pads));
+
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: MX7D 19x19 DDR3 ARM2\n");
+
+	return 0;
+}
diff -urN u-boot-2016.03/board/freescale/mx7d_19x19_ddr3_arm2/plugin.S ebf_6ull_uboot/board/freescale/mx7d_19x19_ddr3_arm2/plugin.S
--- u-boot-2016.03/board/freescale/mx7d_19x19_ddr3_arm2/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_19x19_ddr3_arm2/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,217 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx7d_ddrphy_latency_setting
+	ldr r2, =ANATOP_BASE_ADDR
+	ldr r3, [r2, #0x800]
+	and r3, r3, #0xFF
+	cmp r3, #0x11
+	bne NO_DELAY
+
+	/*TO 1.1*/
+	ldr r1, =0x00000dee
+	str r1, [r0, #0x9c]
+	ldr r1, =0x18181818
+	str r1, [r0, #0x7c]
+	ldr r1, =0x18181818
+	str r1, [r0, #0x80]
+	ldr r1, =0x40401818
+	str r1, [r0, #0x84]
+	ldr r1, =0x00000040
+	str r1, [r0, #0x88]
+	ldr r1, =0x40404040
+	str r1, [r0, #0x6c]
+	b TUNE_END
+
+NO_DELAY:
+	/*TO 1.0*/
+	ldr r1, =0x00000d6e
+	str r1, [r0, #0x9c]
+
+TUNE_END:
+.endm
+
+.macro imx7d_ddr_freq_setting
+	ldr r2, =ANATOP_BASE_ADDR
+	ldr r3, [r2, #0x800]
+	and r3, r3, #0xFF
+	cmp r3, #0x11
+	bne FREQ_DEFAULT_533
+
+	/* Change to 400Mhz for TO1.1 */
+	ldr r0, =ANATOP_BASE_ADDR
+	ldr r1, =0x70
+	ldr r2, =0x00703021
+	str r2, [r0, r1]
+	ldr r1, =0x90
+	ldr r2, =0x0
+	str r2, [r0, r1]
+	ldr r1, =0x70
+	ldr r2, =0x00603021
+	str r2, [r0, r1]
+
+	ldr r3, =0x80000000
+wait_lock:
+	ldr r2, [r0, r1]
+	and r2, r3
+	cmp r2, r3
+	bne wait_lock
+
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x9880
+	ldr r2, =0x1
+	str r2, [r0, r1]
+
+FREQ_DEFAULT_533:
+.endm
+
+.macro imx7d_19x19_ddr3_arm2_ddr_setting
+	imx7d_ddr_freq_setting
+
+	/* Configure ocram_epdc */
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	ldr r1, =0x4f400005
+	str r1, [r0, #0x4]
+
+	ldr r0, =SRC_BASE_ADDR
+	ldr r1, =0x2
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+	ldr r1, =0x03040001
+	str r1, [r0]
+	ldr r1, =0x80400003
+	str r1, [r0, #0x1a0]
+	ldr r1, =0x00100020
+	str r1, [r0, #0x1a4]
+	ldr r1, =0x80100004
+	str r1, [r0, #0x1a8]
+	ldr r1, =0x0040005e
+	str r1, [r0, #0x64]
+	ldr r1, =0x1
+	str r1, [r0, #0x490]
+	ldr r1, =0x00020001
+	str r1, [r0, #0xd0]
+	ldr r1, =0x00010000
+	str r1, [r0, #0xd4]
+	ldr r1, =0x09300004
+	str r1, [r0, #0xdc]
+	ldr r1, =0x04080000
+	str r1, [r0, #0xe0]
+	ldr r1, =0x00090004
+	str r1, [r0, #0xe4]
+	ldr r1, =0x33f
+	str r1, [r0, #0xf4]
+	ldr r1, =0x0908120a
+	str r1, [r0, #0x100]
+	ldr r1, =0x0002020e
+	str r1, [r0, #0x104]
+	ldr r1, =0x03040407
+	str r1, [r0, #0x108]
+	ldr r1, =0x00002006
+	str r1, [r0, #0x10c]
+	ldr r1, =0x04020204
+	str r1, [r0, #0x110]
+	ldr r1, =0x03030202
+	str r1, [r0, #0x114]
+	ldr r1, =0x03030803
+	str r1, [r0, #0x120]
+	ldr r1, =0x00800020
+	str r1, [r0, #0x180]
+	ldr r1, =0x02098204
+	str r1, [r0, #0x190]
+	ldr r1, =0x00030303
+	str r1, [r0, #0x194]
+
+	ldr r1, =0x00000016
+	str r1, [r0, #0x200]
+	ldr r1, =0x00171717
+	str r1, [r0, #0x204]
+	ldr r1, =0x04040404
+	str r1, [r0, #0x214]
+	ldr r1, =0x00040404
+	str r1, [r0, #0x218]
+
+	ldr r1, =0x06000601
+	str r1, [r0, #0x240]
+	ldr r1, =0x00001323
+	str r1, [r0, #0x244]
+
+	ldr r0, =SRC_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRPHY_IPS_BASE_ADDR
+	ldr r1, =0x17420f40
+	str r1, [r0]
+	ldr r1, =0x10210100
+	str r1, [r0, #0x4]
+	ldr r1, =0x00060807
+	str r1, [r0, #0x10]
+	imx7d_ddrphy_latency_setting
+	ldr r1, =0x08080808
+	str r1, [r0, #0x20]
+	ldr r1, =0x08080808
+	str r1, [r0, #0x30]
+	ldr r1, =0x01000010
+	str r1, [r0, #0x50]
+
+	ldr r1, =0x0e407304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e447304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e447306
+	str r1, [r0, #0xc0]
+
+wait_zq:
+	ldr r1, [r0, #0xc4]
+	tst r1, #0x1
+	beq wait_zq
+
+	ldr r1, =0x0e447304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e407304
+	str r1, [r0, #0xc0]
+
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	mov r1, #0x178
+	str r1, [r0, #0x20]
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x2
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+	ldr r0, =DDRPHY_IPS_BASE_ADDR
+	ldr r1, =0x0000000f
+	str r1, [r0, #0x18]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+wait_stat:
+	ldr r1, [r0, #0x4]
+	tst r1, #0x1
+	beq wait_stat
+.endm
+
+.macro imx7_clock_gating
+.endm
+
+.macro imx7_qos_setting
+.endm
+
+.macro imx7_ddr_setting
+	imx7d_19x19_ddr3_arm2_ddr_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx7_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/imximage.cfg ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/imximage.cfg
--- u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/imximage.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/imximage.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx7d_19x19_lpddr3_arm2/plugin.bin 0x00910000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x30340004 0x4F400005
+
+DATA 4 0x30391000 0x00000002
+DATA 4 0x307a0000 0x03040008
+DATA 4 0x307a0064 0x00200038
+DATA 4 0x307a0490 0x00000001
+DATA 4 0x307a00d0 0x00350001
+DATA 4 0x307a00dc 0x00c3000a
+DATA 4 0x307a00e0 0x00010000
+DATA 4 0x307a00e4 0x00110006
+DATA 4 0x307a00f4 0x0000033f
+DATA 4 0x307a0100 0x0a0e110b
+DATA 4 0x307a0104 0x00020211
+DATA 4 0x307a0108 0x03060708
+DATA 4 0x307a010c 0x00a0500c
+DATA 4 0x307a0110 0x05020307
+DATA 4 0x307a0114 0x02020404
+DATA 4 0x307a0118 0x02020003
+DATA 4 0x307a011c 0x00000202
+DATA 4 0x307a0120 0x00000202
+
+DATA 4 0x307a0180 0x00600018
+DATA 4 0x307a0184 0x00e00100
+DATA 4 0x307a0190 0x02098205
+DATA 4 0x307a0194 0x00060303
+DATA 4 0x307a01a0 0x80400003
+DATA 4 0x307a01a4 0x00100020
+DATA 4 0x307a01a8 0x80100004
+
+DATA 4 0x307a0200 0x00000016
+DATA 4 0x307a0204 0x00171717
+DATA 4 0x307a0210 0x00000f00
+DATA 4 0x307a0214 0x05050505
+DATA 4 0x307a0218 0x0f0f0505
+
+DATA 4 0x307a0240 0x06000601
+DATA 4 0x307a0244 0x00000000
+DATA 4 0x30391000 0x00000000
+DATA 4 0x30790000 0x17421e40
+DATA 4 0x30790004 0x10210100
+DATA 4 0x30790008 0x00010000
+DATA 4 0x30790010 0x0007080c
+DATA 4 0x307900b0 0x1010007e
+
+DATA 4 0x3079001C 0x01010000
+DATA 4 0x3079009c 0x0db60d6e
+
+DATA 4 0x30790030 0x06060606
+DATA 4 0x30790020 0x0a0a0a0a
+DATA 4 0x30790050 0x01000008
+DATA 4 0x30790050 0x00000008
+DATA 4 0x30790018 0x0000000f
+DATA 4 0x307900c0 0x1e487304
+DATA 4 0x307900c0 0x1e487304
+DATA 4 0x307900c0 0x1e487306
+DATA 4 0x307900c0 0x1e4c7304
+CHECK_BITS_SET 4 0x307900c4 0x1
+
+DATA 4 0x307900c0 0x1e487304
+
+DATA 4 0x30384130 0x00000000
+DATA 4 0x30340020 0x00000178
+DATA 4 0x30384130 0x00000002
+
+CHECK_BITS_SET 4 0x307a0004 0x1
+#endif
diff -urN u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/imximage_lpddr2.cfg ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/imximage_lpddr2.cfg
--- u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/imximage_lpddr2.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/imximage_lpddr2.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx7d_19x19_lpddr3_arm2/plugin.bin 0x00910000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x30340004 0x4F400005
+
+DATA 4 0x30391000 0x00000002
+DATA 4 0x307a0000 0x03020004
+DATA 4 0x307a01a0 0x80400003
+DATA 4 0x307a01a4 0x00100020
+DATA 4 0x307a01a8 0x80100004
+DATA 4 0x307a0064 0x00200023
+DATA 4 0x307a0490 0x00000001
+DATA 4 0x307a00d0 0x00350001
+DATA 4 0x307a00d8 0x00001105
+DATA 4 0x307a00dc 0x00c20006
+DATA 4 0x307a00e0 0x00020000
+DATA 4 0x307a00e4 0x00110006
+DATA 4 0x307a00f4 0x0000033f
+DATA 4 0x307a0100 0x080e110b
+DATA 4 0x307a0104 0x00020211
+DATA 4 0x307a0108 0x02040706
+DATA 4 0x307a010c 0x00504000
+DATA 4 0x307a0110 0x05010307
+DATA 4 0x307a0114 0x02020404
+DATA 4 0x307a0118 0x02020003
+DATA 4 0x307a011c 0x00000202
+DATA 4 0x307a0120 0x00000202
+
+DATA 4 0x307a0180 0x00600018
+DATA 4 0x307a0184 0x00e00100
+DATA 4 0x307a0190 0x02098203
+DATA 4 0x307a0194 0x00060303
+
+DATA 4 0x307a0200 0x00000015
+DATA 4 0x307a0204 0x00161616
+DATA 4 0x307a0210 0x00000f0f
+DATA 4 0x307a0214 0x04040404
+DATA 4 0x307a0218 0x0f0f0404
+
+DATA 4 0x307a0240 0x06000600
+DATA 4 0x307a0244 0x00000000
+DATA 4 0x30391000 0x00000000
+DATA 4 0x30790000 0x17421640
+DATA 4 0x30790004 0x10210100
+DATA 4 0x30790008 0x00010000
+DATA 4 0x30790010 0x00050408
+DATA 4 0x307900b0 0x1010007e
+
+DATA 4 0x3079001C 0x01010000
+DATA 4 0x3079009C 0x00000d6e
+DATA 4 0x30790018 0x0000000f
+
+DATA 4 0x30790030 0x06060606
+DATA 4 0x30790020 0x0a0a0a0a
+DATA 4 0x30790050 0x01000008
+DATA 4 0x30790050 0x00000008
+DATA 4 0x307900c0 0x0e487304
+DATA 4 0x307900c0 0x0e4c7304
+DATA 4 0x307900c0 0x0e4c7306
+CHECK_BITS_SET 4 0x307900c4 0x1
+
+DATA 4 0x307900c0 0x0e4c7304
+DATA 4 0x307900c0 0x0e487304
+
+DATA 4 0x30384130 0x00000000
+DATA 4 0x30340020 0x000001f8
+DATA 4 0x30384130 0x00000002
+
+CHECK_BITS_SET 4 0x307a0004 0x1
+#endif
diff -urN u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/imximage_lpddr2_TO_1_1.cfg ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/imximage_lpddr2_TO_1_1.cfg
--- u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/imximage_lpddr2_TO_1_1.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/imximage_lpddr2_TO_1_1.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx7d_19x19_lpddr3_arm2/plugin.bin 0x00910000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x30340004 0x4F400005
+
+DATA 4 0x30391000 0x00000002
+DATA 4 0x307a0000 0x03020004
+DATA 4 0x307a01a0 0x80400003
+DATA 4 0x307a01a4 0x00100020
+DATA 4 0x307a01a8 0x80100004
+DATA 4 0x307a0064 0x00200023
+DATA 4 0x307a0490 0x00000001
+DATA 4 0x307a00d0 0x00350001
+DATA 4 0x307a00d8 0x00001105
+DATA 4 0x307a00dc 0x00c20006
+DATA 4 0x307a00e0 0x00020000
+DATA 4 0x307a00e4 0x00110006
+DATA 4 0x307a00f4 0x0000033f
+DATA 4 0x307a0100 0x080e110b
+DATA 4 0x307a0104 0x00020211
+DATA 4 0x307a0108 0x02040706
+DATA 4 0x307a010c 0x00504000
+DATA 4 0x307a0110 0x05010307
+DATA 4 0x307a0114 0x02020404
+DATA 4 0x307a0118 0x02020003
+DATA 4 0x307a011c 0x00000202
+DATA 4 0x307a0120 0x00000202
+
+DATA 4 0x307a0180 0x00600018
+DATA 4 0x307a0184 0x00e00100
+DATA 4 0x307a0190 0x02098203
+DATA 4 0x307a0194 0x00060303
+
+DATA 4 0x307a0200 0x00000015
+DATA 4 0x307a0204 0x00161616
+DATA 4 0x307a0210 0x00000f0f
+DATA 4 0x307a0214 0x04040404
+DATA 4 0x307a0218 0x0f0f0404
+
+DATA 4 0x307a0240 0x06000600
+DATA 4 0x307a0244 0x00000000
+DATA 4 0x30391000 0x00000000
+DATA 4 0x30790000 0x17421640
+DATA 4 0x30790004 0x10210100
+DATA 4 0x30790008 0x00010000
+DATA 4 0x30790010 0x00050408
+DATA 4 0x307900b0 0x1010007e
+
+DATA 4 0x3079001C 0x01010000
+DATA 4 0x3079009C 0x00000dee
+DATA 4 0x3079007c 0x08080808
+DATA 4 0x30790080 0x08080808
+DATA 4 0x30790084 0x0a0a0808
+DATA 4 0x30790088 0x0000000a
+DATA 4 0x3079006c 0x0a0a0a0a
+DATA 4 0x30790018 0x0000000f
+
+DATA 4 0x30790030 0x06060606
+DATA 4 0x30790020 0x0a0a0a0a
+DATA 4 0x30790050 0x01000008
+DATA 4 0x30790050 0x00000008
+DATA 4 0x307900c0 0x0e487304
+DATA 4 0x307900c0 0x0e4c7304
+DATA 4 0x307900c0 0x0e4c7306
+CHECK_BITS_SET 4 0x307900c4 0x1
+
+DATA 4 0x307900c0 0x0e4c7304
+DATA 4 0x307900c0 0x0e487304
+
+DATA 4 0x30384130 0x00000000
+DATA 4 0x30340020 0x000001f8
+DATA 4 0x30384130 0x00000002
+
+CHECK_BITS_SET 4 0x307a0004 0x1
+#endif
diff -urN u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/imximage_TO_1_1.cfg ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/imximage_TO_1_1.cfg
--- u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/imximage_TO_1_1.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/imximage_TO_1_1.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx7d_19x19_lpddr3_arm2/plugin.bin 0x00910000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x30340004 0x4F400005
+
+DATA 4 0x30391000 0x00000002
+DATA 4 0x307a0000 0x03040008
+DATA 4 0x307a0064 0x00200038
+DATA 4 0x307a0490 0x00000001
+DATA 4 0x307a00d0 0x00350001
+DATA 4 0x307a00dc 0x00c3000a
+DATA 4 0x307a00e0 0x00010000
+DATA 4 0x307a00e4 0x00110006
+DATA 4 0x307a00f4 0x0000033f
+DATA 4 0x307a0100 0x0a0e110b
+DATA 4 0x307a0104 0x00020211
+DATA 4 0x307a0108 0x03060708
+DATA 4 0x307a010c 0x00a0500c
+DATA 4 0x307a0110 0x05020307
+DATA 4 0x307a0114 0x02020404
+DATA 4 0x307a0118 0x02020003
+DATA 4 0x307a011c 0x00000202
+DATA 4 0x307a0120 0x00000202
+
+DATA 4 0x307a0180 0x00600018
+DATA 4 0x307a0184 0x00e00100
+DATA 4 0x307a0190 0x02098205
+DATA 4 0x307a0194 0x00060303
+DATA 4 0x307a01a0 0x80400003
+DATA 4 0x307a01a4 0x00100020
+DATA 4 0x307a01a8 0x80100004
+
+DATA 4 0x307a0200 0x00000016
+DATA 4 0x307a0204 0x00171717
+DATA 4 0x307a0210 0x00000f00
+DATA 4 0x307a0214 0x05050505
+DATA 4 0x307a0218 0x0f0f0505
+
+DATA 4 0x307a0240 0x06000601
+DATA 4 0x307a0244 0x00000000
+DATA 4 0x30391000 0x00000000
+DATA 4 0x30790000 0x17421e40
+DATA 4 0x30790004 0x10210100
+DATA 4 0x30790008 0x00010000
+DATA 4 0x30790010 0x0007080c
+DATA 4 0x3079007c 0x1c1c1c1c
+DATA 4 0x30790080 0x1c1c1c1c
+DATA 4 0x30790084 0x30301c1c
+DATA 4 0x30790088 0x00000030
+DATA 4 0x3079006c 0x30303030
+DATA 4 0x307900b0 0x1010007e
+
+DATA 4 0x3079001C 0x01010000
+DATA 4 0x3079009c 0x0db60d6e
+
+DATA 4 0x30790030 0x06060606
+DATA 4 0x30790020 0x0a0a0a0a
+DATA 4 0x30790050 0x01000008
+DATA 4 0x30790050 0x00000008
+DATA 4 0x30790018 0x0000000f
+DATA 4 0x307900c0 0x1e487304
+DATA 4 0x307900c0 0x1e487304
+DATA 4 0x307900c0 0x1e487306
+DATA 4 0x307900c0 0x1e4c7304
+CHECK_BITS_SET 4 0x307900c4 0x1
+
+DATA 4 0x307900c0 0x1e487304
+
+DATA 4 0x30384130 0x00000000
+DATA 4 0x30340020 0x00000178
+DATA 4 0x30384130 0x00000002
+
+CHECK_BITS_SET 4 0x307a0004 0x1
+#endif
diff -urN u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/Kconfig ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/Kconfig
--- u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/Kconfig	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,12 @@
+if TARGET_MX7D_19X19_LPDDR3_ARM2 || TARGET_MX7D_19X19_LPDDR2_ARM2
+
+config SYS_BOARD
+	default "mx7d_19x19_lpddr3_arm2"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_CONFIG_NAME
+	default "mx7d_19x19_lpddr3_arm2"
+
+endif
diff -urN u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/Makefile ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/Makefile
--- u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,10 @@
+# (C) Copyright 2015 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx7d_19x19_lpddr3_arm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/mx7d_19x19_lpddr3_arm2.c ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/mx7d_19x19_lpddr3_arm2.c
--- u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/mx7d_19x19_lpddr3_arm2.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/mx7d_19x19_lpddr3_arm2.c	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,596 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx7-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze3000_pmic.h>
+#include "../common/pfuze.h"
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#include <asm/arch/crm_regs.h>
+
+#ifdef CONFIG_VIDEO_MXS
+#include <linux/fb.h>
+#include <mxsfb.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_DSE_3P3V_49OHM | \
+	PAD_CTL_PUS_PU100KOHM | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+	PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU47KOHM)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_98OHM)
+#define ENET_PAD_CTRL_MII  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_98OHM)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_98OHM)
+
+#define I2C_PAD_CTRL    (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+	PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU100KOHM)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_PU100KOHM | \
+	PAD_CTL_DSE_3P3V_49OHM)
+
+#define QSPI_PAD_CTRL	\
+		(PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_PUE | PAD_CTL_PUS_PU47KOHM)
+
+#define SPI_PAD_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_SRE_SLOW | PAD_CTL_HYS)
+
+#define NAND_PAD_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_SRE_SLOW | PAD_CTL_HYS)
+
+#define NAND_PAD_READY0_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_PUS_PU5KOHM)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_SRE_SLOW | \
+	PAD_CTL_PUS_PU100KOHM)
+
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX7D_PAD_I2C1_SCL__I2C1_SCL | PC,
+		.gpio_mode = MX7D_PAD_I2C1_SCL__GPIO4_IO8 | PC,
+		.gp = IMX_GPIO_NR(4, 8),
+	},
+	.sda = {
+		.i2c_mode = MX7D_PAD_I2C1_SDA__I2C1_SDA | PC,
+		.gpio_mode = MX7D_PAD_I2C1_SDA__GPIO4_IO9 | PC,
+		.gp = IMX_GPIO_NR(4, 9),
+	},
+};
+
+/* I2C2 */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX7D_PAD_I2C2_SCL__I2C2_SCL | PC,
+		.gpio_mode = MX7D_PAD_I2C2_SCL__GPIO4_IO10 | PC,
+		.gp = IMX_GPIO_NR(4, 10),
+	},
+	.sda = {
+		.i2c_mode = MX7D_PAD_I2C2_SDA__I2C2_SDA | PC,
+		.gpio_mode = MX7D_PAD_I2C2_SDA__GPIO4_IO11 | PC,
+		.gp = IMX_GPIO_NR(4, 11),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX7D_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX7D_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX7D_PAD_SD1_CLK__SD1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_CMD__SD1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA0__SD1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA1__SD1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA2__SD1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA3__SD1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_GPIO1_IO08__SD1_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_SD1_CD_B__GPIO5_IO0    | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_RESET_B__GPIO5_IO2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+static iomux_v3_cfg_t const eimnor_pads[] = {
+	MX7D_PAD_LCD_DATA00__EIM_DATA0 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA01__EIM_DATA1 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA02__EIM_DATA2 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA03__EIM_DATA3 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA04__EIM_DATA4 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA05__EIM_DATA5 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA06__EIM_DATA6 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA07__EIM_DATA7 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA08__EIM_DATA8 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA09__EIM_DATA9 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA10__EIM_DATA10 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA11__EIM_DATA11 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA12__EIM_DATA12 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA13__EIM_DATA13 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA14__EIM_DATA14 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA15__EIM_DATA15 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+
+	MX7D_PAD_EPDC_DATA00__EIM_AD0   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA01__EIM_AD1   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA02__EIM_AD2   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA03__EIM_AD3   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA04__EIM_AD4   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA05__EIM_AD5   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA06__EIM_AD6   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA07__EIM_AD7   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_BDR1__EIM_AD8     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_PWR_COM__EIM_AD9  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCLK__EIM_AD10   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_SDLE__EIM_AD11    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_SDOE__EIM_AD12    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_SDSHR__EIM_AD13   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE0__EIM_AD14   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE1__EIM_AD15   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE2__EIM_ADDR16 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE3__EIM_ADDR17 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_GDCLK__EIM_ADDR18 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_GDOE__EIM_ADDR19  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_GDRL__EIM_ADDR20  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_GDSP__EIM_ADDR21  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_BDR0__EIM_ADDR22  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA20__EIM_ADDR23 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA21__EIM_ADDR24 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_LCD_DATA22__EIM_ADDR25 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+
+	MX7D_PAD_EPDC_DATA08__EIM_OE    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA09__EIM_RW    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA10__EIM_CS0_B | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA12__EIM_LBA_B | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA13__EIM_WAIT  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+};
+
+static void eimnor_cs_setup(void)
+{
+	writel(0x00000120, WEIM_IPS_BASE_ADDR + 0x090);
+	writel(0x00210081, WEIM_IPS_BASE_ADDR + 0x000);
+	writel(0x00000001, WEIM_IPS_BASE_ADDR + 0x004);
+	writel(0x0e020000, WEIM_IPS_BASE_ADDR + 0x008);
+	writel(0x00000000, WEIM_IPS_BASE_ADDR + 0x00c);
+	writel(0x0704a040, WEIM_IPS_BASE_ADDR + 0x010);
+}
+
+static void setup_eimnor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(eimnor_pads,
+			ARRAY_SIZE(eimnor_pads));
+
+	eimnor_cs_setup();
+}
+#endif
+
+static iomux_v3_cfg_t const per_rst_pads[] = {
+	MX7D_PAD_GPIO1_IO03__GPIO1_IO3 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const wdog_pads[] = {
+	MX7D_PAD_ENET1_COL__WDOG1_WDOG_ANY | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX7D_PAD_GPIO1_IO11__ENET1_MDC  | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_GPIO1_IO10__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE0__ENET2_RGMII_RX_CTL | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCLK__ENET2_RGMII_RD0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_SDLE__ENET2_RGMII_RD1  | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_SDOE__ENET2_RGMII_RD2  | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_SDSHR__ENET2_RGMII_RD3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE1__ENET2_RGMII_RXC | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_GDRL__ENET2_RGMII_TX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE2__ENET2_RGMII_TD0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE3__ENET2_RGMII_TD1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_GDCLK__ENET2_RGMII_TD2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_GDOE__ENET2_RGMII_TD3  | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_GDSP__ENET2_RGMII_TXC  | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static void setup_iomux_fec2(void)
+{
+	imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_QSPI
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX7D_PAD_EPDC_DATA00__QSPI_A_DATA0 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA01__QSPI_A_DATA1 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA02__QSPI_A_DATA2 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA03__QSPI_A_DATA3 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA04__QSPI_A_DQS   | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA05__QSPI_A_SCLK  | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA06__QSPI_A_SS0_B | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA07__QSPI_A_SS1_B | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+
+	MX7D_PAD_EPDC_DATA08__QSPI_B_DATA0 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA09__QSPI_B_DATA1 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA10__QSPI_B_DATA2 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA11__QSPI_B_DATA3 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA12__QSPI_B_DQS   | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA13__QSPI_B_SCLK  | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA14__QSPI_B_SS0_B | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA15__QSPI_B_SS1_B | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads, ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	set_clk_qspi();
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+static iomux_v3_cfg_t const gpmi_pads[] = {
+	MX7D_PAD_SD3_DATA0__NAND_DATA00 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA1__NAND_DATA01 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA2__NAND_DATA02 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA3__NAND_DATA03 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA4__NAND_DATA04 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA5__NAND_DATA05 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA6__NAND_DATA06 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA7__NAND_DATA07 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_CLK__NAND_CLE	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_CMD__NAND_ALE	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_STROBE__NAND_RE_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_RESET_B__NAND_WE_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_MCLK__NAND_WP_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_RX_BCLK__NAND_CE3_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_RX_SYNC__NAND_CE2_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_RX_DATA__NAND_CE1_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_TX_BCLK__NAND_CE0_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_TX_SYNC__NAND_DQS	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_TX_DATA__NAND_READY_B	| MUX_PAD_CTRL(NAND_PAD_READY0_CTRL),
+};
+
+static void setup_gpmi_nand(void)
+{
+	imx_iomux_v3_setup_multiple_pads(gpmi_pads, ARRAY_SIZE(gpmi_pads));
+
+	/*
+	 * NAND_USDHC_BUS_CLK is set in rom
+	 */
+
+	set_clk_nand();
+
+	/*
+	 * APBH clock root is set in init_esdhc, USDHC3_CLK.
+	 * There is no clk gate for APBHDMA.
+	 * No touch here.
+	 */
+}
+#endif
+
+
+#ifdef CONFIG_FSL_ESDHC
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(5, 0)
+#define USDHC1_PWR_GPIO	IMX_GPIO_NR(5, 2)
+
+
+static struct fsl_esdhc_cfg usdhc_cfg[1] = {
+	{USDHC1_BASE_ADDR, 0, 4},
+};
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	}
+
+	return ret;
+}
+int board_mmc_init(bd_t *bis)
+{
+	int i, ret;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+			gpio_direction_output(USDHC1_PWR_GPIO, 0);
+			udelay(500);
+			gpio_direction_output(USDHC1_PWR_GPIO, 1);
+			usdhc_cfg[i].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return -EINVAL;
+			}
+
+			ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+			if (ret) {
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+				return ret;
+			}
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec2();
+
+	ret = fecmxc_initialize_multi(bis, 0,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC1 MXC: %s:failed\n", __func__);
+
+	return 0;
+}
+
+static int setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	/* Use 125M anatop REF_CLK for ENET2, clear gpr1[14], gpr1[18]*/
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
+		(IOMUXC_GPR_GPR1_GPR_ENET2_TX_CLK_SEL_MASK |
+		 IOMUXC_GPR_GPR1_GPR_ENET2_CLK_DIR_MASK), 0);
+
+	ret = set_clk_enet(ENET_125MHz);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+
+int board_phy_config(struct phy_device *phydev)
+{
+	/* Enable 1.8V(SEL_1P5_1P8_POS_REG) on
+	   Phy control debug reg 0 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
+
+	/* rgmii tx clock delay enable */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX7D_PAD_UART3_RX_DATA__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX7D_PAD_UART3_TX_DATA__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX7D_PAD_UART3_RTS_B__ECSPI1_SCLK   | MUX_PAD_CTRL(SPI_PAD_CTRL),
+
+	/* CS0 */
+	MX7D_PAD_UART3_CTS_B__GPIO4_IO7   | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
+					 ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(4, 7), 0);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 7)) : -1;
+}
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX7
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX7D_PAD_GPIO1_IO05__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	MX7D_PAD_GPIO1_IO07__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg1_pads, ARRAY_SIZE(usb_otg1_pads));
+	imx_iomux_v3_setup_multiple_pads(usb_otg2_pads, ARRAY_SIZE(usb_otg2_pads));
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX7
+	setup_usb();
+#endif
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	/* Reset peripherals */
+	imx_iomux_v3_setup_multiple_pads(per_rst_pads, ARRAY_SIZE(per_rst_pads));
+
+	gpio_direction_output(IMX_GPIO_NR(1, 3) , 0);
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(1, 3), 1);
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+	setup_eimnor();
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec();
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	board_qspi_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x10, 0x12, 0x00, 0x00)},
+	{"qspi", MAKE_CFGVAL(0x00, 0x40, 0x00, 0x00)},
+	{NULL,   0},
+};
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+int power_init_board(void)
+{
+	struct pmic *p;
+	int ret;
+	unsigned int reg, rev_id;
+
+	ret = power_pfuze3000_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	p = pmic_get("PFUZE3000");
+	ret = pmic_probe(p);
+	if (ret)
+		return ret;
+
+	pmic_reg_read(p, PFUZE3000_DEVICEID, &reg);
+	pmic_reg_read(p, PFUZE3000_REVID, &rev_id);
+	printf("PMIC: PFUZE3000 DEV_ID=0x%x REV_ID=0x%x\n", reg, rev_id);
+
+	/* disable Low Power Mode during standby mode */
+	pmic_reg_read(p, PFUZE3000_LDOGCTL, &reg);
+	reg |= 0x1;
+	pmic_reg_write(p, PFUZE3000_LDOGCTL, reg);
+
+	/* SW1A/1B mode set to APS/APS */
+	reg = 0x8;
+	pmic_reg_write(p, PFUZE3000_SW1AMODE, reg);
+	pmic_reg_write(p, PFUZE3000_SW1BMODE, reg);
+
+	/* SW1A/1B standby voltage set to 0.975V */
+	reg = 0xb;
+	pmic_reg_write(p, PFUZE3000_SW1ASTBY, reg);
+	pmic_reg_write(p, PFUZE3000_SW1BSTBY, reg);
+
+	/* set SW1B normal voltage to 0.975V */
+	pmic_reg_read(p, PFUZE3000_SW1BVOLT, &reg);
+	reg &= ~0x1f;
+	reg |= PFUZE3000_SW1AB_SETP(975);
+	pmic_reg_write(p, PFUZE3000_SW1BVOLT, reg);
+
+	return 0;
+}
+#endif
+
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	imx_iomux_v3_setup_multiple_pads(wdog_pads, ARRAY_SIZE(wdog_pads));
+
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+#ifdef CONFIG_TARGET_MX7D_19X19_LPDDR2_ARM2
+	puts("Board: MX7D 19x19 LPDDR2 ARM2\n");
+#else
+	puts("Board: MX7D 19x19 LPDDR3 ARM2\n");
+#endif
+	return 0;
+}
diff -urN u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/plugin.S ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/plugin.S
--- u-boot-2016.03/board/freescale/mx7d_19x19_lpddr3_arm2/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7d_19x19_lpddr3_arm2/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,369 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx7d_ddrphy_lpddr3_latency_setting
+	ldr r2, =ANATOP_BASE_ADDR
+	ldr r3, [r2, #0x800]
+	and r3, r3, #0xFF
+	cmp r3, #0x11
+	bne TUNE_END
+
+	/*TO 1.1*/
+	ldr r1, =0x1c1c1c1c
+	str r1, [r0, #0x7c]
+	ldr r1, =0x1c1c1c1c
+	str r1, [r0, #0x80]
+	ldr r1, =0x30301c1c
+	str r1, [r0, #0x84]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x88]
+	ldr r1, =0x30303030
+	str r1, [r0, #0x6c]
+
+TUNE_END:
+.endm
+
+.macro imx7d_ddrphy_lpddr2_latency_setting
+	ldr r2, =ANATOP_BASE_ADDR
+	ldr r3, [r2, #0x800]
+	and r3, r3, #0xFF
+	cmp r3, #0x11
+	bne NO_DELAY
+
+	/*TO 1.1*/
+	ldr r1, =0x00000dee
+	str r1, [r0, #0x9c]
+	ldr r1, =0x08080808
+	str r1, [r0, #0x7c]
+	ldr r1, =0x08080808
+	str r1, [r0, #0x80]
+	ldr r1, =0x0a0a0808
+	str r1, [r0, #0x84]
+	ldr r1, =0x0000000a
+	str r1, [r0, #0x88]
+	ldr r1, =0x0a0a0a0a
+	str r1, [r0, #0x6c]
+	b TUNE_END
+
+NO_DELAY:
+	/*TO 1.0*/
+	ldr r1, =0x00000d6e
+	str r1, [r0, #0x9c]
+
+TUNE_END:
+.endm
+
+.macro imx7d_19x19_lpddr3_arm2_setting
+	/* Configure ocram_epdc */
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	ldr r1, =0x4f400005
+	str r1, [r0, #0x4]
+
+	ldr r0, =SRC_BASE_ADDR
+	ldr r1, =0x2
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+	ldr r1, =0x03040008
+	str r1, [r0]
+	ldr r1, =0x00200038
+	str r1, [r0, #0x64]
+	ldr r1, =0x1
+	str r1, [r0, #0x490]
+	ldr r1, =0x00350001
+	str r1, [r0, #0xd0]
+	ldr r1, =0x00c3000a
+	str r1, [r0, #0xdc]
+	ldr r1, =0x00010000
+	str r1, [r0, #0xe0]
+	ldr r1, =0x00110006
+	str r1, [r0, #0xe4]
+	ldr r1, =0x33f
+	str r1, [r0, #0xf4]
+	ldr r1, =0x0a0e110b
+	str r1, [r0, #0x100]
+	ldr r1, =0x00020211
+	str r1, [r0, #0x104]
+	ldr r1, =0x03060708
+	str r1, [r0, #0x108]
+	ldr r1, =0x00a0500c
+	str r1, [r0, #0x10c]
+	ldr r1, =0x05020307
+	str r1, [r0, #0x110]
+	ldr r1, =0x02020404
+	str r1, [r0, #0x114]
+	ldr r1, =0x02020003
+	str r1, [r0, #0x118]
+	ldr r1, =0x00000202
+	str r1, [r0, #0x11c]
+	ldr r1, =0x00000202
+	str r1, [r0, #0x120]
+	ldr r1, =0x00600018
+	str r1, [r0, #0x180]
+	ldr r1, =0x00e00100
+	str r1, [r0, #0x184]
+	ldr r1, =0x02098205
+	str r1, [r0, #0x190]
+	ldr r1, =0x00060303
+	str r1, [r0, #0x194]
+	ldr r1, =0x80400003
+	str r1, [r0, #0x1a0]
+	ldr r1, =0x00100020
+	str r1, [r0, #0x1a4]
+	ldr r1, =0x80100004
+	str r1, [r0, #0x1a8]
+
+	ldr r1, =0x00000016
+	str r1, [r0, #0x200]
+	ldr r1, =0x00171717
+	str r1, [r0, #0x204]
+	ldr r1, =0x00000f00
+	str r1, [r0, #0x210]
+	ldr r1, =0x05050505
+	str r1, [r0, #0x214]
+	ldr r1, =0x0f0f0505
+	str r1, [r0, #0x218]
+
+	ldr r1, =0x06000601
+	str r1, [r0, #0x240]
+	mov r1, #0x0
+	str r1, [r0, #0x244]
+
+	ldr r0, =SRC_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRPHY_IPS_BASE_ADDR
+	ldr r1, =0x17421e40
+	str r1, [r0]
+	ldr r1, =0x10210100
+	str r1, [r0, #0x4]
+	ldr r1, =0x00010000
+	str r1, [r0, #0x8]
+	ldr r1, =0x0007080c
+	str r1, [r0, #0x10]
+	imx7d_ddrphy_lpddr3_latency_setting
+	ldr r1, =0x1010007e
+	str r1, [r0, #0xb0]
+	ldr r1, =0x01010000
+	str r1, [r0, #0x1c]
+	ldr r1, =0x0db60d6e
+	str r1, [r0, #0x9c]
+
+	ldr r1, =0x06060606
+	str r1, [r0, #0x30]
+	ldr r1, =0x0a0a0a0a
+	str r1, [r0, #0x20]
+	ldr r1, =0x01000008
+	str r1, [r0, #0x50]
+	ldr r1, =0x00000008
+	str r1, [r0, #0x50]
+
+	ldr r1, =0x0000000f
+	str r1, [r0, #0x18]
+	ldr r1, =0x1e487304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x1e487304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x1e487306
+	str r1, [r0, #0xc0]
+	ldr r1, =0x1e4c7304
+	str r1, [r0, #0xc0]
+
+wait_zq:
+	ldr r1, [r0, #0xc4]
+	tst r1, #0x1
+	beq wait_zq
+
+	ldr r1, =0x1e487304
+	str r1, [r0, #0xc0]
+
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	mov r1, #0x178
+	str r1, [r0, #0x20]
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x2
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+wait_stat:
+	ldr r1, [r0, #0x4]
+	tst r1, #0x1
+	beq wait_stat
+.endm
+
+.macro imx7d_19x19_lpddr2_arm2_setting
+	/* Configure ocram_epdc */
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	ldr r1, =0x4f400005
+	str r1, [r0, #0x4]
+
+	ldr r0, =SRC_BASE_ADDR
+	ldr r1, =0x2
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+	ldr r1, =0x03020004
+	str r1, [r0]
+	ldr r1, =0x80400003
+	str r1, [r0, #0x1a0]
+	ldr r1, =0x00100020
+	str r1, [r0, #0x1a4]
+	ldr r1, =0x80100004
+	str r1, [r0, #0x1a8]
+	ldr r1, =0x00200023
+	str r1, [r0, #0x64]
+	ldr r1, =0x1
+	str r1, [r0, #0x490]
+	ldr r1, =0x00350001
+	str r1, [r0, #0xd0]
+	ldr r1, =0x00001105
+	str r1, [r0, #0xd8]
+	ldr r1, =0x00c20006
+	str r1, [r0, #0xdc]
+	ldr r1, =0x00020000
+	str r1, [r0, #0xe0]
+	ldr r1, =0x00110006
+	str r1, [r0, #0xe4]
+	ldr r1, =0x33f
+	str r1, [r0, #0xf4]
+	ldr r1, =0x080e110b
+	str r1, [r0, #0x100]
+	ldr r1, =0x00020211
+	str r1, [r0, #0x104]
+	ldr r1, =0x02040706
+	str r1, [r0, #0x108]
+	ldr r1, =0x00504000
+	str r1, [r0, #0x10c]
+	ldr r1, =0x05010307
+	str r1, [r0, #0x110]
+	ldr r1, =0x02020404
+	str r1, [r0, #0x114]
+	ldr r1, =0x02020003
+	str r1, [r0, #0x118]
+	ldr r1, =0x00000202
+	str r1, [r0, #0x11c]
+	ldr r1, =0x00000202
+	str r1, [r0, #0x120]
+	ldr r1, =0x00600018
+	str r1, [r0, #0x180]
+	ldr r1, =0x00e00100
+	str r1, [r0, #0x184]
+	ldr r1, =0x02098203
+	str r1, [r0, #0x190]
+	ldr r1, =0x00060303
+	str r1, [r0, #0x194]
+
+	ldr r1, =0x00000015
+	str r1, [r0, #0x200]
+	ldr r1, =0x00161616
+	str r1, [r0, #0x204]
+	ldr r1, =0x00000f0f
+	str r1, [r0, #0x210]
+	ldr r1, =0x04040404
+	str r1, [r0, #0x214]
+	ldr r1, =0x0f0f0404
+	str r1, [r0, #0x218]
+
+	ldr r1, =0x06000600
+	str r1, [r0, #0x240]
+	mov r1, #0x0
+	str r1, [r0, #0x244]
+
+	ldr r0, =SRC_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRPHY_IPS_BASE_ADDR
+	ldr r1, =0x17421640
+	str r1, [r0]
+	ldr r1, =0x10210100
+	str r1, [r0, #0x4]
+	ldr r1, =0x00010000
+	str r1, [r0, #0x8]
+	ldr r1, =0x00050408
+	str r1, [r0, #0x10]
+	ldr r1, =0x1010007e
+	str r1, [r0, #0xb0]
+	ldr r1, =0x01010000
+	str r1, [r0, #0x1c]
+	imx7d_ddrphy_lpddr2_latency_setting
+	ldr r1, =0x0000000f
+	str r1, [r0, #0x18]
+
+	ldr r1, =0x06060606
+	str r1, [r0, #0x30]
+	ldr r1, =0x0a0a0a0a
+	str r1, [r0, #0x20]
+	ldr r1, =0x01000008
+	str r1, [r0, #0x50]
+	ldr r1, =0x00000008
+	str r1, [r0, #0x50]
+
+	ldr r1, =0x0e487304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e4c7304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e4c7306
+	str r1, [r0, #0xc0]
+
+wait_zq:
+	ldr r1, [r0, #0xc4]
+	tst r1, #0x1
+	beq wait_zq
+
+	ldr r1, =0x0e4c7304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e487304
+	str r1, [r0, #0xc0]
+
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	mov r1, #0x1f8
+	str r1, [r0, #0x20]
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x2
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+wait_stat:
+	ldr r1, [r0, #0x4]
+	tst r1, #0x1
+	beq wait_stat
+.endm
+
+.macro imx7_clock_gating
+.endm
+
+.macro imx7_qos_setting
+.endm
+
+.macro imx7_ddr_setting
+#if defined (TARGET_MX7D_19X19_LPDDR2_ARM2)
+	imx7d_19x19_lpddr2_arm2_setting
+#else
+	imx7d_19x19_lpddr3_arm2_setting
+#endif
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx7_plugin.S>
diff -urN u-boot-2016.03/board/freescale/mx7dsabresd/imximage.cfg ebf_6ull_uboot/board/freescale/mx7dsabresd/imximage.cfg
--- u-boot-2016.03/board/freescale/mx7dsabresd/imximage.cfg	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7dsabresd/imximage.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  *
@@ -17,14 +17,23 @@
 IMAGE_VERSION 2
 
 /*
- * Boot Device : sd
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
  */
 
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
 BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx7dsabresd/plugin.bin 0x00910000
+#else
 
-/*
- * Secure boot support
- */
 #ifdef CONFIG_SECURE_BOOT
 CSF CONFIG_CSF_SIZE
 #endif
@@ -42,6 +51,9 @@
  */
 
 DATA 4 0x30340004 0x4F400005
+/* Clear then set bit30 to ensure exit from DDR retention */
+DATA 4 0x30360388 0x40000000
+DATA 4 0x30360384 0x40000000
 
 DATA 4 0x30391000 0x00000002
 DATA 4 0x307a0000 0x01040001
@@ -93,9 +105,12 @@
 DATA 4 0x307900c0 0x0e447304
 DATA 4 0x307900c0 0x0e407304
 
+
 DATA 4 0x30384130 0x00000000
 DATA 4 0x30340020 0x00000178
 DATA 4 0x30384130 0x00000002
 DATA 4 0x30790018 0x0000000f
 
 CHECK_BITS_SET 4 0x307a0004 0x1
+
+#endif
diff -urN u-boot-2016.03/board/freescale/mx7dsabresd/imximage_TO_1_1.cfg ebf_6ull_uboot/board/freescale/mx7dsabresd/imximage_TO_1_1.cfg
--- u-boot-2016.03/board/freescale/mx7dsabresd/imximage_TO_1_1.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7dsabresd/imximage_TO_1_1.cfg	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx7dsabresd/plugin.bin 0x00910000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x30360070 0x00703021
+DATA 4 0x30360090 0x0
+DATA 4 0x30360070 0x00603021
+CHECK_BITS_SET 4 0x30360070 0x80000000
+DATA 4 0x30389880 0x1
+
+DATA 4 0x30340004 0x4F400005
+/* Clear then set bit30 to ensure exit from DDR retention */
+DATA 4 0x30360388 0x40000000
+DATA 4 0x30360384 0x40000000
+
+DATA 4 0x30391000 0x00000002
+DATA 4 0x307a0000 0x01040001
+DATA 4 0x307a01a0 0x80400003
+DATA 4 0x307a01a4 0x00100020
+DATA 4 0x307a01a8 0x80100004
+DATA 4 0x307a0064 0x00400046
+DATA 4 0x307a0490 0x00000001
+DATA 4 0x307a00d0 0x00020083
+DATA 4 0x307a00d4 0x00690000
+DATA 4 0x307a00dc 0x09300004
+DATA 4 0x307a00e0 0x04080000
+DATA 4 0x307a00e4 0x00100004
+DATA 4 0x307a00f4 0x0000033f
+DATA 4 0x307a0100 0x09081109
+DATA 4 0x307a0104 0x0007020d
+DATA 4 0x307a0108 0x03040407
+DATA 4 0x307a010c 0x00002006
+DATA 4 0x307a0110 0x04020205
+DATA 4 0x307a0114 0x03030202
+DATA 4 0x307a0120 0x00000803
+DATA 4 0x307a0180 0x00800020
+DATA 4 0x307a0184 0x02000100
+DATA 4 0x307a0190 0x02098204
+DATA 4 0x307a0194 0x00030303
+DATA 4 0x307a0200 0x00000016
+DATA 4 0x307a0204 0x00171717
+DATA 4 0x307a0214 0x04040404
+DATA 4 0x307a0218 0x0f040404
+DATA 4 0x307a0240 0x06000604
+DATA 4 0x307a0244 0x00000001
+DATA 4 0x30391000 0x00000000
+DATA 4 0x30790000 0x17420f40
+DATA 4 0x30790004 0x10210100
+DATA 4 0x30790010 0x00060807
+DATA 4 0x307900b0 0x1010007e
+DATA 4 0x3079009c 0x00000dee
+DATA 4 0x3079007c 0x18181818
+DATA 4 0x30790080 0x18181818
+DATA 4 0x30790084 0x40401818
+DATA 4 0x30790088 0x00000040
+DATA 4 0x3079006c 0x40404040
+DATA 4 0x30790020 0x08080808
+DATA 4 0x30790030 0x08080808
+DATA 4 0x30790050 0x01000010
+DATA 4 0x30790050 0x00000010
+
+DATA 4 0x307900c0 0x0e407304
+DATA 4 0x307900c0 0x0e447304
+DATA 4 0x307900c0 0x0e447306
+
+CHECK_BITS_SET 4 0x307900c4 0x1
+
+DATA 4 0x307900c0 0x0e447304
+DATA 4 0x307900c0 0x0e407304
+
+
+DATA 4 0x30384130 0x00000000
+DATA 4 0x30340020 0x00000178
+DATA 4 0x30384130 0x00000002
+DATA 4 0x30790018 0x0000000f
+
+CHECK_BITS_SET 4 0x307a0004 0x1
+
+#endif
diff -urN u-boot-2016.03/board/freescale/mx7dsabresd/Makefile ebf_6ull_uboot/board/freescale/mx7dsabresd/Makefile
--- u-boot-2016.03/board/freescale/mx7dsabresd/Makefile	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7dsabresd/Makefile	2021-04-16 14:42:16.960592524 +0800
@@ -1,6 +1,10 @@
-# (C) Copyright 2015 Freescale Semiconductor, Inc.
+# (C) Copyright 2015-2016 Freescale Semiconductor, Inc.
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
 obj-y  := mx7dsabresd.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff -urN u-boot-2016.03/board/freescale/mx7dsabresd/mx7dsabresd.c ebf_6ull_uboot/board/freescale/mx7dsabresd/mx7dsabresd.c
--- u-boot-2016.03/board/freescale/mx7dsabresd/mx7dsabresd.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7dsabresd/mx7dsabresd.c	2021-04-16 14:42:16.960592524 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -10,6 +10,7 @@
 #include <asm/arch/sys_proto.h>
 #include <asm/gpio.h>
 #include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
 #include <asm/io.h>
 #include <linux/sizes.h>
 #include <common.h>
@@ -25,6 +26,18 @@
 #include <asm/arch/crm_regs.h>
 #include <usb.h>
 #include <usb/ehci-fsl.h>
+#if defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
+#include <asm/imx-common/video.h>
+
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -48,9 +61,16 @@
 #define QSPI_PAD_CTRL	\
 	(PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_PUE | PAD_CTL_PUS_PU47KOHM)
 
+#define SPI_PAD_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_SRE_SLOW | PAD_CTL_HYS)
+
+#define BUTTON_PAD_CTRL    (PAD_CTL_PUS_PU5KOHM | PAD_CTL_DSE_3P3V_98OHM)
+
 #define NAND_PAD_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_SRE_SLOW | PAD_CTL_HYS)
 
 #define NAND_PAD_READY0_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_PUS_PU5KOHM)
+
+#define EPDC_PAD_CTRL	0x0
+
 #ifdef CONFIG_SYS_I2C_MXC
 #define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
 /* I2C1 for PMIC */
@@ -66,6 +86,20 @@
 		.gp = IMX_GPIO_NR(4, 9),
 	},
 };
+
+/* I2C3 */
+static struct i2c_pads_info i2c_pad_info3 = {
+	.scl = {
+		.i2c_mode = MX7D_PAD_I2C3_SCL__I2C3_SCL | PC,
+		.gpio_mode = MX7D_PAD_I2C3_SCL__GPIO4_IO12 | PC,
+		.gp = IMX_GPIO_NR(4, 12),
+	},
+	.sda = {
+		.i2c_mode = MX7D_PAD_I2C3_SDA__I2C3_SDA | PC,
+		.gpio_mode = MX7D_PAD_I2C3_SDA__GPIO4_IO13 | PC,
+		.gp = IMX_GPIO_NR(4, 13),
+	},
+};
 #endif
 
 int dram_init(void)
@@ -112,14 +146,6 @@
 	MX7D_PAD_SD3_RESET_B__GPIO6_IO11 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
 };
 
-static iomux_v3_cfg_t const usb_otg1_pads[] = {
-	MX7D_PAD_GPIO1_IO05__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-static iomux_v3_cfg_t const usb_otg2_pads[] = {
-	MX7D_PAD_UART3_CTS_B__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
 #define IOX_SDI IMX_GPIO_NR(1, 9)
 #define IOX_STCP IMX_GPIO_NR(1, 12)
 #define IOX_SHCP IMX_GPIO_NR(1, 13)
@@ -171,7 +197,7 @@
 
 static enum qn_func qn_output[8] = {
 	qn_disable, qn_reset, qn_reset, qn_reset, qn_reset, qn_reset, qn_enable,
-	qn_enable
+	qn_disable
 };
 
 static void iox74lv_init(void)
@@ -208,6 +234,93 @@
 	gpio_direction_output(IOX_STCP, 1);
 };
 
+void iox74lv_set(int index)
+{
+	int i;
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+
+		if (i == index)
+			gpio_direction_output(IOX_SDI, seq[qn_output[i]][0]);
+		else
+			gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+		gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+};
+
+#define BOARD_REV_C  0x300
+#define BOARD_REV_B  0x200
+#define BOARD_REV_A  0x100
+
+static int mx7sabre_rev(void)
+{
+	/*
+	 * Get Board ID information from OCOTP_GP1[15:8]
+	 * i.MX7D SDB RevA: 0x41
+	 * i.MX7D SDB RevB: 0x42
+	 */
+	struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
+	struct fuse_bank *bank = &ocotp->bank[14];
+	int reg = readl(&bank->fuse_regs[0]);
+	int ret;
+
+	if (reg != 0) {
+		switch (reg >> 8 & 0x0F) {
+		case 0x3:
+			ret = BOARD_REV_C;
+			break;
+		case 0x02:
+			ret = BOARD_REV_B;
+			break;
+		case 0x01:
+		default:
+			ret = BOARD_REV_A;
+			break;
+		}
+	} else {
+		/* If the gp1 fuse is not burn, we have to use TO rev for the board rev */
+		if (is_soc_rev(CHIP_REV_1_0))
+			ret = BOARD_REV_A;
+		else if (is_soc_rev(CHIP_REV_1_1))
+			ret = BOARD_REV_B;
+		else
+			ret = BOARD_REV_C;
+	}
+
+	return ret;
+}
+
+u32 get_board_rev(void)
+{
+	int rev = mx7sabre_rev();
+
+	return (get_cpu_rev() & ~(0xF << 8)) | rev;
+}
+
 #ifdef CONFIG_NAND_MXS
 static iomux_v3_cfg_t const gpmi_pads[] = {
 	MX7D_PAD_SD3_DATA0__NAND_DATA00 | MUX_PAD_CTRL(NAND_PAD_CTRL),
@@ -279,7 +392,7 @@
 	MX7D_PAD_GPIO1_IO01__GPIO1_IO1 | MUX_PAD_CTRL(NO_PAD_CTRL),
 };
 
-static int setup_lcd(void)
+void do_enable_parallel_lcd(struct display_info_t const *dev)
 {
 	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
 
@@ -292,33 +405,29 @@
 
 	/* Set Brightness to high */
 	gpio_direction_output(IMX_GPIO_NR(1, 1) , 1);
-
-	return 0;
 }
-#endif
 
-#ifdef CONFIG_FEC_MXC
-static iomux_v3_cfg_t const fec1_pads[] = {
-	MX7D_PAD_ENET1_RGMII_RX_CTL__ENET1_RGMII_RX_CTL | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
-	MX7D_PAD_ENET1_RGMII_RD0__ENET1_RGMII_RD0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
-	MX7D_PAD_ENET1_RGMII_RD1__ENET1_RGMII_RD1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
-	MX7D_PAD_ENET1_RGMII_RD2__ENET1_RGMII_RD2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
-	MX7D_PAD_ENET1_RGMII_RD3__ENET1_RGMII_RD3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
-	MX7D_PAD_ENET1_RGMII_RXC__ENET1_RGMII_RXC | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
-	MX7D_PAD_ENET1_RGMII_TX_CTL__ENET1_RGMII_TX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX7D_PAD_ENET1_RGMII_TD0__ENET1_RGMII_TD0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX7D_PAD_ENET1_RGMII_TD1__ENET1_RGMII_TD1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX7D_PAD_ENET1_RGMII_TD2__ENET1_RGMII_TD2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX7D_PAD_ENET1_RGMII_TD3__ENET1_RGMII_TD3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX7D_PAD_ENET1_RGMII_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX7D_PAD_GPIO1_IO10__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL_MII),
-	MX7D_PAD_GPIO1_IO11__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL_MII),
-};
-
-static void setup_iomux_fec(void)
-{
-	imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
-}
+struct display_info_t const displays[] = {{
+	.bus = ELCDIF1_IPS_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 24,
+	.detect = NULL,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "TFT43AB",
+		.xres           = 480,
+		.yres           = 272,
+		.pixclock       = 108695,
+		.left_margin    = 8,
+		.right_margin   = 4,
+		.upper_margin   = 2,
+		.lower_margin   = 4,
+		.hsync_len      = 41,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
 #endif
 
 static void setup_iomux_uart(void)
@@ -345,7 +454,7 @@
 	return devno;
 }
 
-static int mmc_map_to_kernel_blk(int dev_no)
+int mmc_map_to_kernel_blk(int dev_no)
 {
 	if (dev_no == 1)
 		dev_no++;
@@ -414,49 +523,70 @@
 
 	return 0;
 }
+#endif
 
-static int check_mmc_autodetect(void)
-{
-	char *autodetect_str = getenv("mmcautodetect");
-
-	if ((autodetect_str != NULL) &&
-		(strcmp(autodetect_str, "yes") == 0)) {
-		return 1;
-	}
+iomux_v3_cfg_t const fec2_en_pads[] = {
+	MX7D_PAD_GPIO1_IO04__GPIO1_IO4 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX7D_PAD_ENET1_RGMII_RX_CTL__ENET1_RGMII_RX_CTL | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD0__ENET1_RGMII_RD0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD1__ENET1_RGMII_RD1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD2__ENET1_RGMII_RD2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD3__ENET1_RGMII_RD3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RXC__ENET1_RGMII_RXC | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TX_CTL__ENET1_RGMII_TX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD0__ENET1_RGMII_TD0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD1__ENET1_RGMII_TD1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD2__ENET1_RGMII_TD2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD3__ENET1_RGMII_TD3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_GPIO1_IO10__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL_MII),
+	MX7D_PAD_GPIO1_IO11__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL_MII),
+};
 
-	return 0;
-}
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX7D_PAD_EPDC_SDCE0__ENET2_RGMII_RX_CTL | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCLK__ENET2_RGMII_RD0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_SDLE__ENET2_RGMII_RD1  | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_SDOE__ENET2_RGMII_RD2  | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_SDSHR__ENET2_RGMII_RD3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE1__ENET2_RGMII_RXC | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_EPDC_GDRL__ENET2_RGMII_TX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE2__ENET2_RGMII_TD0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE3__ENET2_RGMII_TD1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_GDCLK__ENET2_RGMII_TD2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_GDOE__ENET2_RGMII_TD3  | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_GDSP__ENET2_RGMII_TXC  | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_GPIO1_IO10__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL_MII),
+	MX7D_PAD_GPIO1_IO11__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL_MII),
+};
 
-static void mmc_late_init(void)
+static void setup_iomux_fec(void)
 {
-	char cmd[32];
-	char mmcblk[32];
-	u32 dev_no = mmc_get_env_dev();
-
-	if (!check_mmc_autodetect())
-		return;
-
-	setenv_ulong("mmcdev", dev_no);
-
-	/* Set mmcblk env */
-	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
-		mmc_map_to_kernel_blk(dev_no));
-	setenv("mmcroot", mmcblk);
-
-	sprintf(cmd, "mmc dev %d", dev_no);
-	run_command(cmd, 0);
+	if (0 == CONFIG_FEC_ENET_DEV) {
+		imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+	} else {
+		if (mx7sabre_rev() >= BOARD_REV_B) {
+			/*  On RevB, GPIO1_IO04 is used for ENET2 EN,
+			*  so set its output to low to enable ENET2 signals
+			*/
+			imx_iomux_v3_setup_multiple_pads(fec2_en_pads,
+				ARRAY_SIZE(fec2_en_pads));
+			gpio_direction_output(IMX_GPIO_NR(1, 4), 0);
+		}
+		imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));
+	}
 }
 
-#endif
-
-#ifdef CONFIG_FEC_MXC
 int board_eth_init(bd_t *bis)
 {
 	int ret;
 
 	setup_iomux_fec();
 
-	ret = fecmxc_initialize_multi(bis, 0,
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
 		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
 	if (ret)
 		printf("FEC1 MXC: %s:failed\n", __func__);
@@ -464,17 +594,25 @@
 	return ret;
 }
 
-static int setup_fec(void)
+static int setup_fec(int fec_id)
 {
 	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
 		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
 
-	/* Use 125M anatop REF_CLK1 for ENET1, clear gpr1[13], gpr1[17]*/
-	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
-		(IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_MASK |
-		 IOMUXC_GPR_GPR1_GPR_ENET1_CLK_DIR_MASK), 0);
+	if (0 == fec_id) {
+		/* Use 125M anatop REF_CLK1 for ENET1, clear gpr1[13], gpr1[17]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
+			(IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_MASK |
+			 IOMUXC_GPR_GPR1_GPR_ENET1_CLK_DIR_MASK), 0);
+	} else {
+		/* Use 125M anatop REF_CLK2 for ENET2, clear gpr1[14], gpr1[18]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
+			(IOMUXC_GPR_GPR1_GPR_ENET2_TX_CLK_SEL_MASK |
+			 IOMUXC_GPR_GPR1_GPR_ENET2_CLK_DIR_MASK), 0);
+	}
 
 	return set_clk_enet(ENET_125MHz);
+
 }
 
 
@@ -515,15 +653,261 @@
 }
 #endif
 
+#ifdef CONFIG_MXC_EPDC
+static iomux_v3_cfg_t const epdc_enable_pads[] = {
+	MX7D_PAD_EPDC_DATA00__EPDC_DATA0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA01__EPDC_DATA1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA02__EPDC_DATA2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA03__EPDC_DATA3	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA04__EPDC_DATA4	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA05__EPDC_DATA5	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA06__EPDC_DATA6	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA07__EPDC_DATA7	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCLK__EPDC_SDCLK		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDLE__EPDC_SDLE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDOE__EPDC_SDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDSHR__EPDC_SDSHR		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE0__EPDC_SDCE0		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE1__EPDC_SDCE1		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDCLK__EPDC_GDCLK		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDOE__EPDC_GDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDRL__EPDC_GDRL		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDSP__EPDC_GDSP		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_BDR0__EPDC_BDR0		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_BDR1__EPDC_BDR1		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const epdc_disable_pads[] = {
+	MX7D_PAD_EPDC_DATA00__GPIO2_IO0,
+	MX7D_PAD_EPDC_DATA01__GPIO2_IO1,
+	MX7D_PAD_EPDC_DATA02__GPIO2_IO2,
+	MX7D_PAD_EPDC_DATA03__GPIO2_IO3,
+	MX7D_PAD_EPDC_DATA04__GPIO2_IO4,
+	MX7D_PAD_EPDC_DATA05__GPIO2_IO5,
+	MX7D_PAD_EPDC_DATA06__GPIO2_IO6,
+	MX7D_PAD_EPDC_DATA07__GPIO2_IO7,
+	MX7D_PAD_EPDC_SDCLK__GPIO2_IO16,
+	MX7D_PAD_EPDC_SDLE__GPIO2_IO17,
+	MX7D_PAD_EPDC_SDOE__GPIO2_IO18,
+	MX7D_PAD_EPDC_SDSHR__GPIO2_IO19,
+	MX7D_PAD_EPDC_SDCE0__GPIO2_IO20,
+	MX7D_PAD_EPDC_SDCE1__GPIO2_IO21,
+	MX7D_PAD_EPDC_GDCLK__GPIO2_IO24,
+	MX7D_PAD_EPDC_GDOE__GPIO2_IO25,
+	MX7D_PAD_EPDC_GDRL__GPIO2_IO26,
+	MX7D_PAD_EPDC_GDSP__GPIO2_IO27,
+	MX7D_PAD_EPDC_BDR0__GPIO2_IO28,
+	MX7D_PAD_EPDC_BDR1__GPIO2_IO29,
+};
+
+vidinfo_t panel_info = {
+	.vl_refresh = 85,
+	.vl_col = 1024,
+	.vl_row = 758,
+	.vl_pixclock = 40000000,
+	.vl_left_margin = 12,
+	.vl_right_margin = 76,
+	.vl_upper_margin = 4,
+	.vl_lower_margin = 5,
+	.vl_hsync = 12,
+	.vl_vsync = 2,
+	.vl_sync = 0,
+	.vl_mode = 0,
+	.vl_flag = 0,
+	.vl_bpix = 3,
+	.cmap = 0,
+};
+
+struct epdc_timing_params panel_timings = {
+	.vscan_holdoff = 4,
+	.sdoed_width = 10,
+	.sdoed_delay = 20,
+	.sdoez_width = 10,
+	.sdoez_delay = 20,
+	.gdclk_hp_offs = 524,
+	.gdsp_offs = 327,
+	.gdoe_offs = 0,
+	.gdclk_offs = 19,
+	.num_ce = 1,
+};
+
+static void setup_epdc_power(void)
+{
+	/* IOMUX_GPR1: bit30: Disable On-chip RAM EPDC Function */
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
+		IOMUXC_GPR_GPR1_GPR_ENABLE_OCRAM_EPDC_MASK, 0);
+
+	/* Setup epdc voltage */
+
+	/* EPDC_PWRSTAT - GPIO2[31] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_PWR_STAT__GPIO2_IO31 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	gpio_direction_input(IMX_GPIO_NR(2, 31));
+
+	/* EPDC_VCOM0 - GPIO4[14] for VCOM control */
+	imx_iomux_v3_setup_pad(MX7D_PAD_I2C4_SCL__GPIO4_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(4, 14), 1);
+
+	/* EPDC_PWRWAKEUP - GPIO2[23] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_SDCE3__GPIO2_IO23 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 23), 1);
+
+	/* EPDC_PWRCTRL0 - GPIO2[30] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_PWR_COM__GPIO2_IO30 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 30), 1);
+}
+
+static void epdc_enable_pins(void)
+{
+	/* epdc iomux settings */
+	imx_iomux_v3_setup_multiple_pads(epdc_enable_pads,
+				ARRAY_SIZE(epdc_enable_pads));
+}
+
+static void epdc_disable_pins(void)
+{
+	/* Configure MUX settings for EPDC pins to GPIO  and drive to 0 */
+	imx_iomux_v3_setup_multiple_pads(epdc_disable_pads,
+				ARRAY_SIZE(epdc_disable_pads));
+}
+
+static void setup_epdc(void)
+{
+	/*** epdc Maxim PMIC settings ***/
+
+	/* EPDC_PWRSTAT - GPIO2[31] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_PWR_STAT__GPIO2_IO31 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_VCOM0 - GPIO4[14] for VCOM control */
+	imx_iomux_v3_setup_pad(MX7D_PAD_I2C4_SCL__GPIO4_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRWAKEUP - GPIO4[23] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_SDCE3__GPIO2_IO23 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRCTRL0 - GPIO4[20] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_PWR_COM__GPIO2_IO30 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set pixel clock rates for EPDC in clock.c */
+
+	panel_info.epdc_data.wv_modes.mode_init = 0;
+	panel_info.epdc_data.wv_modes.mode_du = 1;
+	panel_info.epdc_data.wv_modes.mode_gc4 = 3;
+	panel_info.epdc_data.wv_modes.mode_gc8 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc16 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc32 = 2;
+
+	panel_info.epdc_data.epdc_timings = panel_timings;
+
+	setup_epdc_power();
+}
+
+void epdc_power_on(void)
+{
+	unsigned int reg;
+	struct gpio_regs *gpio_regs = (struct gpio_regs *)GPIO2_BASE_ADDR;
+
+	/* Set EPD_PWR_CTL0 to high - enable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 30), 1);
+	udelay(1000);
+
+	/* Enable epdc signal pin */
+	epdc_enable_pins();
+
+	/* Set PMIC Wakeup to high - enable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 23), 1);
+
+	/* Wait for PWRGOOD == 1 */
+	while (1) {
+		reg = readl(&gpio_regs->gpio_psr);
+		if (!(reg & (1 << 31)))
+			break;
+
+		udelay(100);
+	}
+
+	/* Enable VCOM */
+	gpio_set_value(IMX_GPIO_NR(4, 14), 1);
+
+	udelay(500);
+}
+
+void epdc_power_off(void)
+{
+	/* Set PMIC Wakeup to low - disable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 23), 0);
+
+	/* Disable VCOM */
+	gpio_set_value(IMX_GPIO_NR(4, 14), 0);
+
+	epdc_disable_pins();
+
+	/* Set EPD_PWR_CTL0 to low - disable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 30), 0);
+}
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX7
+static iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX7D_PAD_GPIO1_IO05__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usb_otg2_pads[] = {
+	MX7D_PAD_UART3_CTS_B__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+/* On RevB board, the GPIO_IO07 is muxed for OTG2 PWR */
+iomux_v3_cfg_t const usb_otg2_revB_pads[] = {
+	MX7D_PAD_GPIO1_IO07__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+						 ARRAY_SIZE(usb_otg1_pads));
+
+	if (mx7sabre_rev() >= BOARD_REV_B)
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_revB_pads,
+						 ARRAY_SIZE(usb_otg2_revB_pads));
+	else
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+						 ARRAY_SIZE(usb_otg2_pads));
+}
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 0)
+		return usb_phy_mode(port);
+	else
+		return USB_INIT_HOST;
+}
+#endif
+
 int board_early_init_f(void)
 {
 	setup_iomux_uart();
 
+#ifdef CONFIG_SYS_I2C_MXC
 	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
-	imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
-					 ARRAY_SIZE(usb_otg1_pads));
-	imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
-					 ARRAY_SIZE(usb_otg2_pads));
+	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info3);
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX7
+	setup_usb();
+#endif
 
 	return 0;
 }
@@ -538,24 +922,46 @@
 	iox74lv_init();
 
 #ifdef CONFIG_FEC_MXC
-	setup_fec();
+	setup_fec(CONFIG_FEC_ENET_DEV);
 #endif
 
 #ifdef CONFIG_NAND_MXS
 	setup_gpmi_nand();
 #endif
 
-#ifdef CONFIG_VIDEO_MXS
-	setup_lcd();
-#endif
-
 #ifdef CONFIG_FSL_QSPI
 	board_qspi_init();
 #endif
 
+#ifdef CONFIG_MXC_EPDC
+	if (mx7sabre_rev() >= BOARD_REV_B) {
+		/*  On RevB, GPIO1_IO04 is used for ENET2 EN,
+		*  so set its output to high to isolate the ENET2 signals for EPDC
+		*/
+		imx_iomux_v3_setup_multiple_pads(fec2_en_pads,
+			ARRAY_SIZE(fec2_en_pads));
+		gpio_direction_output(IMX_GPIO_NR(1, 4), 1);
+	} else {
+		qn_output[5] = qn_disable;
+		iox74lv_set(5);
+	}
+	setup_epdc();
+#endif
+
 	return 0;
 }
 
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x10, 0x10, 0x00, 0x00)},
+	{"emmc", MAKE_CFGVAL(0x10, 0x2a, 0x00, 0x00)},
+	/* TODO: Nand */
+	{"qspi", MAKE_CFGVAL(0x00, 0x40, 0x00, 0x00)},
+	{NULL,   0},
+};
+#endif
+
 #ifdef CONFIG_POWER
 #define I2C_PMIC	0
 int power_init_board(void)
@@ -582,6 +988,22 @@
 	reg |= 0x1;
 	pmic_reg_write(p, PFUZE3000_LDOGCTL, reg);
 
+	/* SW1A/1B mode set to APS/APS */
+	reg = 0x8;
+	pmic_reg_write(p, PFUZE3000_SW1AMODE, reg);
+	pmic_reg_write(p, PFUZE3000_SW1BMODE, reg);
+
+	/* SW1A/1B standby voltage set to 0.975V */
+	reg = 0xb;
+	pmic_reg_write(p, PFUZE3000_SW1ASTBY, reg);
+	pmic_reg_write(p, PFUZE3000_SW1BSTBY, reg);
+
+	/* decrease SW1B normal voltage to 0.975V */
+	pmic_reg_read(p, PFUZE3000_SW1BVOLT, &reg);
+	reg &= ~0x1f;
+	reg |= PFUZE3000_SW1AB_SETP(975);
+	pmic_reg_write(p, PFUZE3000_SW1BVOLT, reg);
+
 	return 0;
 }
 #endif
@@ -589,37 +1011,126 @@
 int board_late_init(void)
 {
 	struct wdog_regs *wdog = (struct wdog_regs *)WDOG1_BASE_ADDR;
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
 
 #ifdef CONFIG_ENV_IS_IN_MMC
-	mmc_late_init();
+	board_late_mmc_env_init();
 #endif
 
 	imx_iomux_v3_setup_multiple_pads(wdog_pads, ARRAY_SIZE(wdog_pads));
 
 	set_wdog_reset(wdog);
 
-	/*
-	 * Do not assert internal WDOG_RESET_B_DEB(controlled by bit 4),
-	 * since we use PMIC_PWRON to reset the board.
-	 */
-	clrsetbits_le16(&wdog->wcr, 0, 0x10);
-
 	return 0;
 }
 
 int checkboard(void)
 {
-	puts("Board: i.MX7D SABRESD\n");
+	int rev = mx7sabre_rev();
+	char *revname;
+
+	switch (rev) {
+	case BOARD_REV_C:
+		revname = "C";
+		break;
+	case BOARD_REV_B:
+		revname = "B";
+		break;
+	case BOARD_REV_A:
+	default:
+		revname = "A";
+		break;
+	}
+
+	printf("Board: i.MX7D SABRESD Rev%s\n", revname);
 
 	return 0;
 }
 
-#ifdef CONFIG_USB_EHCI_MX7
-int board_usb_phy_mode(int port)
+#ifdef CONFIG_FSL_FASTBOOT
+void board_fastboot_setup(void)
 {
-	if (port == 0)
-		return USB_INIT_DEVICE;
-	else
-		return USB_INIT_HOST;
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
 }
-#endif
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+/* Use S3 button for recovery key */
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(5, 10)
+iomux_v3_cfg_t const recovery_key_pads[] = {
+	(MX7D_PAD_SD2_WP__GPIO5_IO10 | MUX_PAD_CTRL(BUTTON_PAD_CTRL)),
+};
+
+int check_recovery_cmd_file(void)
+{
+	int button_pressed = 0;
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	/* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
+		ARRAY_SIZE(recovery_key_pads));
+
+	gpio_direction_input(GPIO_VOL_DN_KEY);
+
+	if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN key is low assert */
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+	}
+
+	return recovery_mode || button_pressed;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc0 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc1 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
+
diff -urN u-boot-2016.03/board/freescale/mx7dsabresd/plugin.S ebf_6ull_uboot/board/freescale/mx7dsabresd/plugin.S
--- u-boot-2016.03/board/freescale/mx7dsabresd/plugin.S	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/freescale/mx7dsabresd/plugin.S	2021-04-16 14:42:16.960592524 +0800
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx7d_ddrphy_latency_setting
+	ldr r2, =ANATOP_BASE_ADDR
+	ldr r3, [r2, #0x800]
+	and r3, r3, #0xFF
+	cmp r3, #0x11
+	bne NO_DELAY
+
+	/*TO 1.1*/
+	ldr r1, =0x00000dee
+	str r1, [r0, #0x9c]
+	ldr r1, =0x18181818
+	str r1, [r0, #0x7c]
+	ldr r1, =0x18181818
+	str r1, [r0, #0x80]
+	ldr r1, =0x40401818
+	str r1, [r0, #0x84]
+	ldr r1, =0x00000040
+	str r1, [r0, #0x88]
+	ldr r1, =0x40404040
+	str r1, [r0, #0x6c]
+	b TUNE_END
+
+NO_DELAY:
+	/*TO 1.0*/
+	ldr r1, =0x00000d6e
+	str r1, [r0, #0x9c]
+
+TUNE_END:
+.endm
+
+.macro imx7d_ddr_freq_setting
+	ldr r2, =ANATOP_BASE_ADDR
+	ldr r3, [r2, #0x800]
+	and r3, r3, #0xFF
+	cmp r3, #0x11
+	bne FREQ_DEFAULT_533
+
+	/* Change to 400Mhz for TO1.1 */
+	ldr r0, =ANATOP_BASE_ADDR
+	ldr r1, =0x70
+	ldr r2, =0x00703021
+	str r2, [r0, r1]
+	ldr r1, =0x90
+	ldr r2, =0x0
+	str r2, [r0, r1]
+	ldr r1, =0x70
+	ldr r2, =0x00603021
+	str r2, [r0, r1]
+
+	ldr r3, =0x80000000
+wait_lock:
+	ldr r2, [r0, r1]
+	and r2, r3
+	cmp r2, r3
+	bne wait_lock
+
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x9880
+	ldr r2, =0x1
+	str r2, [r0, r1]
+
+FREQ_DEFAULT_533:
+.endm
+
+.macro imx7d_sabresd_ddr_setting
+	imx7d_ddr_freq_setting
+
+	/* Configure ocram_epdc */
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	ldr r1, =0x4f400005
+	str r1, [r0, #0x4]
+
+	/* clear/set bit30 of SNVS_MISC_CTRL to ensure exit from ddr retention */
+	ldr r0, =ANATOP_BASE_ADDR
+	ldr r1, =(0x1 << 30)
+	str r1, [r0, #0x388]
+	str r1, [r0, #0x384]
+
+	ldr r0, =SRC_BASE_ADDR
+	ldr r1, =0x2
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+	ldr r1, =0x01040001
+	str r1, [r0]
+	ldr r1, =0x80400003
+	str r1, [r0, #0x1a0]
+	ldr r1, =0x00100020
+	str r1, [r0, #0x1a4]
+	ldr r1, =0x80100004
+	str r1, [r0, #0x1a8]
+	ldr r1, =0x00400046
+	str r1, [r0, #0x64]
+	ldr r1, =0x1
+	str r1, [r0, #0x490]
+	ldr r1, =0x00020001
+	str r1, [r0, #0xd0]
+	ldr r1, =0x00690000
+	str r1, [r0, #0xd4]
+	ldr r1, =0x09300004
+	str r1, [r0, #0xdc]
+	ldr r1, =0x04080000
+	str r1, [r0, #0xe0]
+	ldr r1, =0x00100004
+	str r1, [r0, #0xe4]
+	ldr r1, =0x33f
+	str r1, [r0, #0xf4]
+	ldr r1, =0x09081109
+	str r1, [r0, #0x100]
+	ldr r1, =0x0007020d
+	str r1, [r0, #0x104]
+	ldr r1, =0x03040407
+	str r1, [r0, #0x108]
+	ldr r1, =0x00002006
+	str r1, [r0, #0x10c]
+	ldr r1, =0x04020205
+	str r1, [r0, #0x110]
+	ldr r1, =0x03030202
+	str r1, [r0, #0x114]
+	ldr r1, =0x00000803
+	str r1, [r0, #0x120]
+	ldr r1, =0x00800020
+	str r1, [r0, #0x180]
+	ldr r1, =0x02000100
+	str r1, [r0, #0x184]
+	ldr r1, =0x02098204
+	str r1, [r0, #0x190]
+	ldr r1, =0x00030303
+	str r1, [r0, #0x194]
+
+	ldr r1, =0x00000016
+	str r1, [r0, #0x200]
+	ldr r1, =0x00171717
+	str r1, [r0, #0x204]
+	ldr r1, =0x04040404
+	str r1, [r0, #0x214]
+	ldr r1, =0x0f040404
+	str r1, [r0, #0x218]
+
+	ldr r1, =0x06000604
+	str r1, [r0, #0x240]
+	ldr r1, =0x00000001
+	str r1, [r0, #0x244]
+
+	ldr r0, =SRC_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRPHY_IPS_BASE_ADDR
+	ldr r1, =0x17420f40
+	str r1, [r0]
+	ldr r1, =0x10210100
+	str r1, [r0, #0x4]
+	ldr r1, =0x00060807
+	str r1, [r0, #0x10]
+	ldr r1, =0x1010007e
+	str r1, [r0, #0xb0]
+	imx7d_ddrphy_latency_setting
+	ldr r1, =0x08080808
+	str r1, [r0, #0x20]
+	ldr r1, =0x08080808
+	str r1, [r0, #0x30]
+	ldr r1, =0x01000010
+	str r1, [r0, #0x50]
+
+	ldr r1, =0x0e407304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e447304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e447306
+	str r1, [r0, #0xc0]
+
+wait_zq:
+	ldr r1, [r0, #0xc4]
+	tst r1, #0x1
+	beq wait_zq
+
+	ldr r1, =0x0e447304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e407304
+	str r1, [r0, #0xc0]
+
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	mov r1, #0x178
+	str r1, [r0, #0x20]
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x2
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+	ldr r0, =DDRPHY_IPS_BASE_ADDR
+	ldr r1, =0x0000000f
+	str r1, [r0, #0x18]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+wait_stat:
+	ldr r1, [r0, #0x4]
+	tst r1, #0x1
+	beq wait_stat
+.endm
+
+.macro imx7_clock_gating
+.endm
+
+.macro imx7_qos_setting
+.endm
+
+.macro imx7_ddr_setting
+	imx7d_sabresd_ddr_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx7_plugin.S>
diff -urN u-boot-2016.03/board/technexion/picosom-imx6ul/imximage.cfg ebf_6ull_uboot/board/technexion/picosom-imx6ul/imximage.cfg
--- u-boot-2016.03/board/technexion/picosom-imx6ul/imximage.cfg	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/technexion/picosom-imx6ul/imximage.cfg	2021-04-16 14:42:17.748596599 +0800
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6ul_14x14_evk/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+
+DATA 4 0x020E04B4 0x000C0000
+DATA 4 0x020E04AC 0x00000000
+DATA 4 0x020E027C 0x00000030
+DATA 4 0x020E0250 0x00000030
+DATA 4 0x020E024C 0x00000030
+DATA 4 0x020E0490 0x00000030
+DATA 4 0x020E0288 0x00000030
+DATA 4 0x020E0270 0x00000000
+DATA 4 0x020E0260 0x00000030
+DATA 4 0x020E0264 0x00000030
+DATA 4 0x020E04A0 0x00000030
+DATA 4 0x020E0494 0x00020000
+DATA 4 0x020E0280 0x00000030
+DATA 4 0x020E0284 0x00000030
+DATA 4 0x020E04B0 0x00020000
+DATA 4 0x020E0498 0x00000030
+DATA 4 0x020E04A4 0x00000030
+DATA 4 0x020E0244 0x00000030
+DATA 4 0x020E0248 0x00000030
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B080C 0x00000000
+DATA 4 0x021B083C 0x01380134
+DATA 4 0x021B0848 0x40404244
+DATA 4 0x021B0850 0x40405050
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B08C0 0x00921012
+DATA 4 0x021B08b8 0x00000800
+DATA 4 0x021B0004 0x0002002D
+DATA 4 0x021B0008 0x00333030
+DATA 4 0x021B000C 0x676B52F3
+DATA 4 0x021B0010 0xB66D8B63
+DATA 4 0x021B0014 0x01FF00DB
+DATA 4 0x021B0018 0x00201740
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B002C 0x000026D2
+DATA 4 0x021B0030 0x006B1023
+DATA 4 0x021B0040 0x00000047
+DATA 4 0x021B0000 0x83180000
+DATA 4 0x021B001C 0x02008032
+DATA 4 0x021B001C 0x00008033
+DATA 4 0x021B001C 0x00048031
+DATA 4 0x021B001C 0x15208030
+DATA 4 0x021B001C 0x04008040
+DATA 4 0x021B0020 0x00000800
+DATA 4 0x021B0818 0x00000227
+DATA 4 0x021B0004 0x0002552D
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff -urN u-boot-2016.03/board/technexion/picosom-imx6ul/Kconfig ebf_6ull_uboot/board/technexion/picosom-imx6ul/Kconfig
--- u-boot-2016.03/board/technexion/picosom-imx6ul/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/technexion/picosom-imx6ul/Kconfig	2021-04-16 14:42:17.036592917 +0800
@@ -0,0 +1,12 @@
+if TARGET_PICOSOM_IMX6UL
+
+config SYS_BOARD
+	default "picosom-imx6ul"
+
+config SYS_VENDOR
+	default "technexion"
+
+config SYS_CONFIG_NAME
+	default "picosom-imx6ul"
+
+endif
diff -urN u-boot-2016.03/board/technexion/picosom-imx6ul/MAINTAINERS ebf_6ull_uboot/board/technexion/picosom-imx6ul/MAINTAINERS
--- u-boot-2016.03/board/technexion/picosom-imx6ul/MAINTAINERS	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/technexion/picosom-imx6ul/MAINTAINERS	2021-04-16 14:42:17.036592917 +0800
@@ -0,0 +1,6 @@
+Technexion PICOSOM-IMX6UL board
+M:	Richard Hu <richard.hu@technexion.com>
+S:	Maintained
+F:	board/picosom-imx6ul/
+F:	include/configs/picosom-imx6ul.h
+F:	configs/picosom-imx6ul_defconfig
diff -urN u-boot-2016.03/board/technexion/picosom-imx6ul/Makefile ebf_6ull_uboot/board/technexion/picosom-imx6ul/Makefile
--- u-boot-2016.03/board/technexion/picosom-imx6ul/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/technexion/picosom-imx6ul/Makefile	2021-04-16 14:42:17.744596580 +0800
@@ -0,0 +1,7 @@
+# (C) Copyright 2015 Technexion Ltd.
+# (C) Copyright 2015 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := picosom-imx6ul.o
diff -urN u-boot-2016.03/board/technexion/picosom-imx6ul/picosom-imx6ul.c ebf_6ull_uboot/board/technexion/picosom-imx6ul/picosom-imx6ul.c
--- u-boot-2016.03/board/technexion/picosom-imx6ul/picosom-imx6ul.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/board/technexion/picosom-imx6ul/picosom-imx6ul.c	2021-04-16 14:42:17.748596599 +0800
@@ -0,0 +1,748 @@
+/*
+ * Copyright (C) 2015 Technexion Ltd.
+ *
+ * Author: Richard Hu <richard.hu@technexion.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <linux/fb.h>
+#include <miiphy.h>
+#include <mmc.h>
+#include <mxsfb.h>
+#include <netdev.h>
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+
+#ifdef CONFIG_POWER
+#include <power/pmic.h>
+#include <power/pfuze3000_pmic.h>
+#include "../../freescale/common/pfuze.h"
+#endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_SD_CD_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_DOWN  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_HIGH   |                                   \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+#define MDIO_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST | PAD_CTL_ODE)
+
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C2 for PMIC */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode =  MX6_PAD_GPIO1_IO02__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO02__GPIO1_IO02  | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO1_IO03__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO03__GPIO1_IO03 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart6_pads[] = {
+	MX6_PAD_CSI_MCLK__UART6_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSI_PIXCLK__UART6_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* CD */
+	MX6_PAD_UART1_CTS_B__GPIO1_IO18 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+#ifdef CONFIG_SYS_USE_NAND
+static iomux_v3_cfg_t const nand_pads[] = {
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CLE__RAWNAND_CLE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_ALE__RAWNAND_ALE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DQS__RAWNAND_DQS | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(nand_pads, ARRAY_SIZE(nand_pads));
+
+	clrbits_le32(&mxc_ccm->CCGR4,
+		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK);
+
+	/*
+	 * config gpmi and bch clock to 100 MHz
+	 * bch/gpmi select PLL2 PFD2 400M
+	 * 100M = 400M / 4
+	 */
+	clrbits_le32(&mxc_ccm->cscmr1,
+		     MXC_CCM_CSCMR1_BCH_CLK_SEL |
+		     MXC_CCM_CSCMR1_GPMI_CLK_SEL);
+	clrsetbits_le32(&mxc_ccm->cscdr1,
+			MXC_CCM_CSCDR1_BCH_PODF_MASK |
+			MXC_CCM_CSCDR1_GPMI_PODF_MASK,
+			(3 << MXC_CCM_CSCDR1_BCH_PODF_OFFSET) |
+			(3 << MXC_CCM_CSCDR1_GPMI_PODF_OFFSET));
+
+	/* enable gpmi and bch clock gating */
+	setbits_le32(&mxc_ccm->CCGR4,
+		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK);
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec_pads[] = {
+	MX6_PAD_ENET1_TX_EN__ENET2_MDC | MUX_PAD_CTRL(MDIO_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA1__ENET2_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
+
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_UART4_TX_DATA__GPIO1_IO28 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+#define RMII_PHY_RESET IMX_GPIO_NR(1, 28)
+
+static void setup_iomux_fec(int fec_id)
+{
+	imx_iomux_v3_setup_multiple_pads(fec_pads, ARRAY_SIZE(fec_pads));
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart6_pads, ARRAY_SIZE(uart6_pads));
+}
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC1_BASE_ADDR, 0, 4},
+};
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(1, 18)
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	int dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	}
+
+	return ret;
+
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i, ret;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return -EINVAL;
+			}
+
+			ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+			if (ret) {
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+				return ret;
+			}
+	}
+
+	return 0;
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD_CLK__LCDIF_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__LCDIF_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__LCDIF_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA18__LCDIF_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA19__LCDIF_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA20__LCDIF_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA21__LCDIF_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA22__LCDIF_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA23__LCDIF_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+
+	/* LCD_RST */
+	MX6_PAD_SNVS_TAMPER9__GPIO5_IO09	| MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/*
+	 * Use GPIO for Brightness adjustment, duty cycle = period.
+	 */
+	MX6_PAD_GPIO1_IO08__GPIO1_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void do_enable_parallel_lcd(struct display_info_t const *dev)
+{
+	enable_lcdif_clock(dev->bus);
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Reset the LCD */
+	gpio_direction_output(IMX_GPIO_NR(5, 9) , 0);
+	udelay(500);
+	gpio_direction_output(IMX_GPIO_NR(5, 9) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(1, 8) , 1);
+}
+
+static struct display_info_t const displays[] = {{
+	.lcdif_base_addr = MX6UL_LCDIF1_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 24,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "TFT43AB",
+		.xres           = 480,
+		.yres           = 272,
+		.pixclock       = 108695,
+		.left_margin    = 8,
+		.right_margin   = 4,
+		.upper_margin   = 2,
+		.lower_margin   = 4,
+		.hsync_len      = 41,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
+
+	gpio_direction_output(RMII_PHY_RESET, 0);
+	udelay(500);
+	gpio_direction_output(RMII_PHY_RESET, 1);
+
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC%d MXC: %s:failed\n", CONFIG_FEC_ENET_DEV, __func__);
+
+	return 0;
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	if (0 == fec_id) {
+		/* Use 50M anatop loopback REF_CLK1 for ENET1, clear gpr1[13], set gpr1[17]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK,
+				IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK);
+	} else {
+		/* Use 50M anatop loopback REF_CLK2 for ENET2, clear gpr1[14], set gpr1[18]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC2_MASK,
+				IOMUX_GPR1_FEC2_CLOCK_MUX1_SEL_MASK);
+	}
+
+	ret = enable_fec_anatop_clock(fec_id, ENET_50MHZ);
+	if (ret)
+		return ret;
+
+	enable_enet_clk(1);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8190);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+static iomux_v3_cfg_t const usb_otg_pads[] = {
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+/* At default the 3v3 enables the MIC2026 for VBUS power */
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+					 ARRAY_SIZE(usb_otg_pads));
+}
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+	return 0;
+}
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+static struct pmic *pfuze;
+int power_init_board(void)
+{
+	int ret;
+	unsigned int reg, rev_id;
+
+	ret = power_pfuze3000_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	pfuze = pmic_get("PFUZE3000");
+	ret = pmic_probe(pfuze);
+	if (ret)
+		return ret;
+
+	pmic_reg_read(pfuze, PFUZE3000_DEVICEID, &reg);
+	pmic_reg_read(pfuze, PFUZE3000_REVID, &rev_id);
+	printf("PMIC: PFUZE3000 DEV_ID=0x%x REV_ID=0x%x\n", reg, rev_id);
+
+	/* disable Low Power Mode during standby mode */
+	pmic_reg_read(pfuze, PFUZE3000_LDOGCTL, &reg);
+	reg |= 0x1;
+	pmic_reg_write(pfuze, PFUZE3000_LDOGCTL, reg);
+
+	/* SW1B step ramp up time from 2us to 4us/25mV */
+	reg = 0x40;
+	pmic_reg_write(pfuze, PFUZE3000_SW1BCONF, reg);
+
+	/* SW1B mode to APS/PFM */
+	reg = 0xc;
+	pmic_reg_write(pfuze, PFUZE3000_SW1BMODE, reg);
+
+	/* SW1B standby voltage set to 0.975V */
+	reg = 0xb;
+	pmic_reg_write(pfuze, PFUZE3000_SW1BSTBY, reg);
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	u32 vddarm;
+
+	struct pmic *p = pfuze;
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		pmic_reg_read(pfuze, PFUZE3000_SW1BVOLT, &value);
+		value &= ~0x1f;
+		value |= PFUZE3000_SW1AB_SETP(1275);
+		pmic_reg_write(pfuze, PFUZE3000_SW1BVOLT, value);
+
+		set_anatop_bypass(1);
+		vddarm = PFUZE3000_SW1AB_SETP(1175);
+
+		pmic_reg_read(pfuze, PFUZE3000_SW1BVOLT, &value);
+		value &= ~0x1f;
+		value |= vddarm;
+		pmic_reg_write(pfuze, PFUZE3000_SW1BVOLT, value);
+
+		finish_anatop_bypass();
+
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+#endif
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+#endif
+
+#ifdef	CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x42, 0x20, 0x00, 0x00)},
+	{"sd2", MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_init();
+#endif
+
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+    puts("Board: PicoSOM i.mx6UL\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_FSL_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "nand");
+		if (!getenv("fbparts"))
+			setenv("fbparts", ANDROID_FASTBOOT_NAND_PARTS);
+		if (!getenv("bootcmd"))
+			setenv("bootcmd",
+				"nand read ${loadaddr} ${boot_nand_offset} "
+				"${boot_nand_size};boota ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+int check_recovery_cmd_file(void)
+{
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	return recovery_mode;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc0 recovery");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc1 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"nand read ${loadaddr} ${recovery_nand_offset} "
+				"${recovery_nand_size};boota ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
diff -urN u-boot-2016.03/board/warp/warp.c ebf_6ull_uboot/board/warp/warp.c
--- u-boot-2016.03/board/warp/warp.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/board/warp/warp.c	2021-04-16 14:42:17.760596663 +0800
@@ -62,7 +62,7 @@
 }
 
 static struct fsl_esdhc_cfg usdhc_cfg[1] = {
-	{USDHC2_BASE_ADDR},
+	{USDHC2_BASE_ADDR, 0, 8, 0, 1}, /* fixed 1.8v IO voltage for eMMC chip */
 };
 
 int board_mmc_getcd(struct mmc *mmc)
diff -urN u-boot-2016.03/.checkpatch.conf ebf_6ull_uboot/.checkpatch.conf
--- u-boot-2016.03/.checkpatch.conf	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/.checkpatch.conf	1970-01-01 08:00:00.000000000 +0800
@@ -1,27 +0,0 @@
-# Not Linux, so don't expect a Linux tree.
---no-tree
-
-# Temporary for false positive in checkpatch
---ignore COMPLEX_MACRO
-
-# For CONFIG_SYS_I2C_NOPROBES
---ignore MULTISTATEMENT_MACRO_USE_DO_WHILE
-
-# For simple_strtoul
---ignore CONSIDER_KSTRTO
-
-# For min/max
---ignore MINMAX
-
-# enable more tests
---strict
-
-# Not Linux, so we don't recommend usleep_range() over udelay()
---ignore USLEEP_RANGE
-
-# Ignore networking block comment style
---ignore NETWORKING_BLOCK_COMMENT_STYLE
-
-# Ignore "WARNING: Prefer ether_addr_copy() over memcpy() if the Ethernet
-# addresses are __aligned(2)".
---ignore PREFER_ETHER_ADDR_COPY
diff -urN u-boot-2016.03/cmd/bootm.c ebf_6ull_uboot/cmd/bootm.c
--- u-boot-2016.03/cmd/bootm.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/cmd/bootm.c	2021-04-16 14:42:17.768596704 +0800
@@ -128,6 +128,31 @@
 			return do_bootm_subcommand(cmdtp, flag, argc, argv);
 	}
 
+#ifdef CONFIG_SECURE_BOOT
+	extern uint32_t authenticate_image(
+			uint32_t ddr_start, uint32_t image_size);
+
+	switch (genimg_get_format((const void *)load_addr)) {
+#if defined(CONFIG_IMAGE_FORMAT_LEGACY)
+	case IMAGE_FORMAT_LEGACY:
+		if (authenticate_image(load_addr,
+			image_get_image_size((image_header_t *)load_addr)) == 0) {
+			printf("Authenticate uImage Fail, Please check\n");
+			return 1;
+		}
+		break;
+#endif
+#ifdef CONFIG_ANDROID_BOOT_IMAGE
+	case IMAGE_FORMAT_ANDROID:
+		/* Do this authentication in boota command */
+		break;
+#endif
+	default:
+		printf("Not valid image format for Authentication, Please check\n");
+		return 1;
+	}
+#endif
+
 	return do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START |
 		BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |
 		BOOTM_STATE_LOADOS |
@@ -583,6 +608,14 @@
 	if (bootm_find_images(flag, argc, argv))
 		return 1;
 
+#ifdef CONFIG_SECURE_BOOT
+	extern uint32_t authenticate_image(
+			uint32_t ddr_start, uint32_t image_size);
+	if (authenticate_image(images->ep, zi_end - zi_start) == 0) {
+		printf("Authenticate zImage Fail, Please check\n");
+		return 1;
+	}
+#endif
 	return 0;
 }
 
diff -urN u-boot-2016.03/cmd/fdt.c ebf_6ull_uboot/cmd/fdt.c
--- u-boot-2016.03/cmd/fdt.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/cmd/fdt.c	2021-04-16 14:42:17.768596704 +0800
@@ -244,7 +244,7 @@
 	/*
 	 * Set the value of a property in the working_fdt.
 	 */
-	} else if (argv[1][0] == 's') {
+	} else if (strncmp(argv[1], "set", 3) == 0) {
 		char *pathp;		/* path */
 		char *prop;		/* property */
 		int  nodeoffset;	/* node offset from libfdt */
diff -urN u-boot-2016.03/cmd/nvedit.c ebf_6ull_uboot/cmd/nvedit.c
--- u-boot-2016.03/cmd/nvedit.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/cmd/nvedit.c	2021-04-16 14:42:17.768596704 +0800
@@ -5,7 +5,7 @@
  * (C) Copyright 2001 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
  * Andreas Heppel <aheppel@sysgo.de>
  *
- * Copyright 2011 Freescale Semiconductor, Inc.
+ * Copyright 2011-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -51,9 +51,10 @@
 	!defined(CONFIG_ENV_IS_IN_SPI_FLASH)	&& \
 	!defined(CONFIG_ENV_IS_IN_REMOTE)	&& \
 	!defined(CONFIG_ENV_IS_IN_UBI)		&& \
+	!defined(CONFIG_ENV_IS_IN_SATA)		&& \
 	!defined(CONFIG_ENV_IS_NOWHERE)
 # error Define one of CONFIG_ENV_IS_IN_{EEPROM|FLASH|DATAFLASH|ONENAND|\
-SPI_FLASH|NVRAM|MMC|FAT|REMOTE|UBI} or CONFIG_ENV_IS_NOWHERE
+SPI_FLASH|NVRAM|MMC|FAT|REMOTE|UBI|SATA} or CONFIG_ENV_IS_NOWHERE
 #endif
 
 /*
diff -urN u-boot-2016.03/cmd/sata.c ebf_6ull_uboot/cmd/sata.c
--- u-boot-2016.03/cmd/sata.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/cmd/sata.c	2021-04-16 14:42:17.768596704 +0800
@@ -4,7 +4,7 @@
  * Copyright (C) Procsys. All rights reserved.
  *		Mushtaq Khan <mushtaq_k@procsys.com>
  *			<mushtaqk_921@yahoo.co.in>
- * Copyright (C) 2008 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008-2016 Freescale Semiconductor, Inc.
  *		Dave Liu <daveliu@freescale.com>
  *
  * SPDX-License-Identifier:	GPL-2.0+
@@ -15,7 +15,7 @@
 #include <part.h>
 #include <sata.h>
 
-static int sata_curr_device = -1;
+int sata_curr_device = -1;
 block_dev_desc_t sata_dev_desc[CONFIG_SYS_SATA_MAX_DEVICE];
 
 static unsigned long sata_bread(block_dev_desc_t *block_dev, lbaint_t start,
diff -urN u-boot-2016.03/common/autoboot.c ebf_6ull_uboot/common/autoboot.c
--- u-boot-2016.03/common/autoboot.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/common/autoboot.c	2021-04-16 14:42:17.772596724 +0800
@@ -15,6 +15,10 @@
 #include <post.h>
 #include <u-boot/sha256.h>
 
+#ifdef is_boot_from_usb
+#include <environment.h>
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #define MAX_DELAY_STOP_STR 32
@@ -322,6 +326,18 @@
 	s = getenv("bootdelay");
 	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
 
+#if !defined(CONFIG_FSL_FASTBOOT) && defined(is_boot_from_usb)
+	if (is_boot_from_usb()) {
+		disconnect_from_pc();
+		printf("Boot from USB for mfgtools\n");
+		bootdelay = 0;
+		set_default_env("Use default environment for \
+				 mfgtools\n");
+	} else {
+		printf("Normal Boot\n");
+	}
+#endif
+
 #ifdef CONFIG_OF_CONTROL
 	bootdelay = fdtdec_get_config_int(gd->fdt_blob, "bootdelay",
 			bootdelay);
@@ -348,6 +364,13 @@
 #endif /* CONFIG_BOOTCOUNT_LIMIT */
 		s = getenv("bootcmd");
 
+#if !defined(CONFIG_FSL_FASTBOOT) && defined(is_boot_from_usb)
+	if (is_boot_from_usb()) {
+		s = getenv("bootcmd_mfg");
+		printf("Run bootcmd_mfg: %s\n", s);
+	}
+#endif
+
 	process_fdt_options(gd->fdt_blob);
 	stored_bootdelay = bootdelay;
 
diff -urN u-boot-2016.03/common/board_r.c ebf_6ull_uboot/common/board_r.c
--- u-boot-2016.03/common/board_r.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/common/board_r.c	2021-04-16 14:42:17.772596724 +0800
@@ -7,6 +7,8 @@
  * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
  * Marius Groeger <mgroeger@sysgo.de>
  *
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -65,6 +67,9 @@
 #ifdef CONFIG_AVR32
 #include <asm/arch/mmu.h>
 #endif
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#endif
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -731,6 +736,20 @@
 }
 #endif
 
+#ifdef CONFIG_FSL_FASTBOOT
+static int initr_fastboot_setup(void)
+{
+	fastboot_setup();
+	return 0;
+}
+
+static int initr_check_fastboot(void)
+{
+	check_fastboot();
+	return 0;
+}
+#endif
+
 static int run_main_loop(void)
 {
 #ifdef CONFIG_SANDBOX
@@ -908,6 +927,9 @@
 #ifdef CONFIG_BOARD_LATE_INIT
 	board_late_init,
 #endif
+#ifdef CONFIG_FSL_FASTBOOT
+	initr_fastboot_setup,
+#endif
 #if defined(CONFIG_CMD_AMBAPP)
 	ambapp_init_reloc,
 #if defined(CONFIG_SYS_AMBAPP_PRINT_ON_STARTUP)
@@ -960,6 +982,9 @@
 #if defined(CONFIG_SPARC)
 	prom_init,
 #endif
+#ifdef CONFIG_FSL_FASTBOOT
+	initr_check_fastboot,
+#endif
 	run_main_loop,
 };
 
diff -urN u-boot-2016.03/common/env_sata.c ebf_6ull_uboot/common/env_sata.c
--- u-boot-2016.03/common/env_sata.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/common/env_sata.c	2021-04-16 14:42:17.772596724 +0800
@@ -0,0 +1,169 @@
+/*
+ * (C) Copyright 2010-2016 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* #define DEBUG */
+
+#include <common.h>
+
+#include <command.h>
+#include <environment.h>
+#include <linux/stddef.h>
+#include <errno.h>
+#include <sata.h>
+
+char *env_name_spec = "SATA";
+
+#ifdef ENV_IS_EMBEDDED
+extern uchar environment[];
+env_t *env_ptr = (env_t *)(&environment[0]);
+#else /* ! ENV_IS_EMBEDDED */
+env_t *env_ptr;
+#endif /* ENV_IS_EMBEDDED */
+
+extern int sata_curr_device;
+
+/* local functions */
+#if !defined(ENV_IS_EMBEDDED)
+static void use_default(void);
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+uchar env_get_char_spec(int index)
+{
+	return *((uchar *)(gd->env_addr + index));
+}
+
+int env_init(void)
+{
+	/* use default */
+	gd->env_addr = (ulong)&default_environment[0];
+	gd->env_valid = 1;
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_SAVEENV
+
+inline int write_env(block_dev_desc_t *sata, unsigned long size,
+			unsigned long offset, const void *buffer)
+{
+	uint blk_start, blk_cnt, n;
+
+	blk_start = ALIGN(offset, sata->blksz) / sata->blksz;
+	blk_cnt   = ALIGN(size, sata->blksz) / sata->blksz;
+
+	n = sata->block_write(sata, blk_start, blk_cnt, (u_char *)buffer);
+
+	return (n == blk_cnt) ? 0 : -1;
+}
+
+int saveenv(void)
+{
+	block_dev_desc_t *sata = NULL;
+	env_t	env_new;
+	ssize_t	len;
+	char *res;
+
+	if (sata_curr_device == -1) {
+		if (sata_initialize())
+			return 1;
+		sata_curr_device = CONFIG_SATA_ENV_DEV;
+	}
+
+	if (sata_curr_device >= CONFIG_SYS_SATA_MAX_DEVICE) {
+		printf("Unknown SATA(%d) device for environment!\n",
+			sata_curr_device);
+		return 1;
+	}
+
+	sata = sata_get_dev(sata_curr_device);
+
+	res = (char *)&env_new.data;
+	len = hexport_r(&env_htab, '\0', 0, &res, ENV_SIZE, 0, NULL);
+	if (len < 0) {
+		error("Cannot export environment: errno = %d\n", errno);
+		return 1;
+	}
+	env_new.crc = crc32(0, env_new.data, ENV_SIZE);
+
+	printf("Writing to SATA(%d)...", sata_curr_device);
+	if (write_env(sata, CONFIG_ENV_SIZE, CONFIG_ENV_OFFSET, &env_new)) {
+		puts("failed\n");
+		return 1;
+	}
+
+	puts("done\n");
+	return 0;
+}
+#endif /* CONFIG_CMD_SAVEENV */
+
+inline int read_env(block_dev_desc_t *sata, unsigned long size,
+			unsigned long offset, const void *buffer)
+{
+	uint blk_start, blk_cnt, n;
+
+	blk_start = ALIGN(offset, sata->blksz) / sata->blksz;
+	blk_cnt   = ALIGN(size, sata->blksz) / sata->blksz;
+
+	n = sata->block_read(sata, blk_start, blk_cnt, (uchar *)buffer);
+
+	return (n == blk_cnt) ? 0 : -1;
+}
+
+void env_relocate_spec(void)
+{
+#if !defined(ENV_IS_EMBEDDED)
+	block_dev_desc_t *sata = NULL;
+	char buf[CONFIG_ENV_SIZE];
+	int ret;
+
+	if (sata_curr_device == -1) {
+		if (sata_initialize())
+			return;
+		sata_curr_device = CONFIG_SATA_ENV_DEV;
+	}
+
+	if (sata_curr_device >= CONFIG_SYS_SATA_MAX_DEVICE) {
+		printf("Unknown SATA(%d) device for environment!\n",
+			sata_curr_device);
+		return;
+	}
+	sata = sata_get_dev(sata_curr_device);
+
+	if (read_env(sata, CONFIG_ENV_SIZE, CONFIG_ENV_OFFSET, buf))
+		return use_default();
+
+	ret = env_import(buf, 1);
+	if (ret)
+		gd->env_valid = 1;
+
+#endif
+}
+
+#if !defined(ENV_IS_EMBEDDED)
+static void use_default()
+{
+	puts("*** Warning - bad CRC or MMC, using default environment\n\n");
+	set_default_env(NULL);
+}
+#endif
diff -urN u-boot-2016.03/common/image-android.c ebf_6ull_uboot/common/image-android.c
--- u-boot-2016.03/common/image-android.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/common/image-android.c	2021-04-16 14:42:17.772596724 +0800
@@ -1,6 +1,8 @@
 /*
  * Copyright (c) 2011 Sebastian Andrzej Siewior <bigeasy@linutronix.de>
  *
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -9,6 +11,7 @@
 #include <android_image.h>
 #include <malloc.h>
 #include <errno.h>
+#include <asm/bootm.h>
 
 #define ANDROID_IMAGE_DEFAULT_KERNEL_ADDR	0x10008000
 
@@ -68,7 +71,6 @@
 
 	int len = 0;
 	if (*hdr->cmdline) {
-		printf("Kernel command line: %s\n", hdr->cmdline);
 		len += strlen(hdr->cmdline);
 	}
 
@@ -85,12 +87,25 @@
 
 	if (bootargs) {
 		strcpy(newbootargs, bootargs);
-		strcat(newbootargs, " ");
-	}
-	if (*hdr->cmdline)
+	} else if (*hdr->cmdline) {
 		strcat(newbootargs, hdr->cmdline);
+	}
 
+	printf("Kernel command line: %s\n", newbootargs);
+#ifdef CONFIG_SERIAL_TAG
+	struct tag_serialnr serialnr;
+	char commandline[ANDR_BOOT_ARGS_SIZE];
+	get_board_serial(&serialnr);
+
+	sprintf(commandline,
+					"%s androidboot.serialno=%08x%08x",
+					newbootargs,
+					serialnr.high,
+					serialnr.low);
+	setenv("bootargs", commandline);
+#else
 	setenv("bootargs", newbootargs);
+#endif
 
 	if (os_data) {
 		*os_data = (ulong)hdr;
@@ -145,3 +160,21 @@
 	*rd_len = hdr->ramdisk_size;
 	return 0;
 }
+
+int android_image_get_fdt(const struct andr_img_hdr *hdr,
+			      ulong *fdt_data, ulong *fdt_len)
+{
+	if (!hdr->second_size)
+		return -1;
+
+	printf("FDT load addr 0x%08x size %u KiB\n",
+	       hdr->second_addr, DIV_ROUND_UP(hdr->second_size, 1024));
+
+	*fdt_data = (unsigned long)hdr;
+	*fdt_data += hdr->page_size;
+	*fdt_data += ALIGN(hdr->kernel_size, hdr->page_size);
+	*fdt_data += ALIGN(hdr->ramdisk_size, hdr->page_size);
+
+	*fdt_len = hdr->second_size;
+	return 0;
+}
diff -urN u-boot-2016.03/common/image-fdt.c ebf_6ull_uboot/common/image-fdt.c
--- u-boot-2016.03/common/image-fdt.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/common/image-fdt.c	2021-04-16 14:42:17.772596724 +0800
@@ -6,6 +6,8 @@
  * (C) Copyright 2000-2006
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -417,7 +419,34 @@
 			debug("## No Flattened Device Tree\n");
 			goto no_fdt;
 		}
-	} else {
+	}
+#ifdef CONFIG_ANDROID_BOOT_IMAGE
+	else if (genimg_get_format((void *)images->os.start) ==
+		IMAGE_FORMAT_ANDROID) {
+		ulong fdt_data, fdt_len;
+		android_image_get_fdt((void *)images->os.start,
+		 &fdt_data, &fdt_len);
+
+		if (fdt_len) {
+			fdt_blob = (char *)fdt_data;
+			printf("   Booting using the fdt at 0x%p\n", fdt_blob);
+
+			if (fdt_check_header(fdt_blob) != 0) {
+				fdt_error("image is not a fdt");
+				goto error;
+			}
+
+			if (fdt_totalsize(fdt_blob) != fdt_len) {
+				fdt_error("fdt size != image size");
+				goto error;
+			}
+		} else {
+			debug("## No Flattened Device Tree\n");
+			goto no_fdt;
+		}
+	}
+#endif
+	else {
 		debug("## No Flattened Device Tree\n");
 		goto no_fdt;
 	}
diff -urN u-boot-2016.03/common/lcd.c ebf_6ull_uboot/common/lcd.c
--- u-boot-2016.03/common/lcd.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/common/lcd.c	2021-04-16 14:42:17.772596724 +0800
@@ -35,11 +35,6 @@
 #define CONFIG_LCD_ALIGNMENT PAGE_SIZE
 #endif
 
-#if (LCD_BPP != LCD_COLOR8) && (LCD_BPP != LCD_COLOR16) && \
-	(LCD_BPP != LCD_COLOR32)
-#error Unsupported LCD BPP.
-#endif
-
 DECLARE_GLOBAL_DATA_PTR;
 
 static int lcd_init(void *lcdbase);
@@ -171,11 +166,14 @@
 
 void lcd_clear(void)
 {
-	int bg_color;
 	char *s;
 	ulong addr;
 	static int do_splash = 1;
-#if LCD_BPP == LCD_COLOR8
+#if LCD_BPP == LCD_MONOCHROME
+	/* Setting the palette */
+	lcd_initcolregs();
+
+#elif LCD_BPP == LCD_COLOR8
 	/* Setting the palette */
 	lcd_setcolreg(CONSOLE_COLOR_BLACK, 0, 0, 0);
 	lcd_setcolreg(CONSOLE_COLOR_RED, 0xFF, 0, 0);
@@ -191,11 +189,9 @@
 #ifndef CONFIG_SYS_WHITE_ON_BLACK
 	lcd_setfgcolor(CONSOLE_COLOR_BLACK);
 	lcd_setbgcolor(CONSOLE_COLOR_WHITE);
-	bg_color = CONSOLE_COLOR_WHITE;
 #else
 	lcd_setfgcolor(CONSOLE_COLOR_WHITE);
 	lcd_setbgcolor(CONSOLE_COLOR_BLACK);
-	bg_color = CONSOLE_COLOR_BLACK;
 #endif	/* CONFIG_SYS_WHITE_ON_BLACK */
 
 #ifdef	LCD_TEST_PATTERN
@@ -203,14 +199,15 @@
 #else
 	/* set framebuffer to background color */
 #if (LCD_BPP != LCD_COLOR32)
-	memset((char *)lcd_base, bg_color, lcd_line_length * panel_info.vl_row);
+	memset((char *)lcd_base, COLOR_MASK(lcd_getbgcolor()),
+	       lcd_line_length * panel_info.vl_row);
 #else
 	u32 *ppix = lcd_base;
 	u32 i;
 	for (i = 0;
 	   i < (lcd_line_length * panel_info.vl_row)/NBYTES(panel_info.vl_bpix);
 	   i++) {
-		*ppix++ = bg_color;
+		*ppix++ = COLOR_MASK(lcd_getbgcolor());
 	}
 #endif
 #endif
@@ -295,7 +292,7 @@
 	ulong size;
 	int line_length;
 
-	debug("LCD panel info: %d x %d, %d bit/pix\n", panel_info.vl_col,
+	debug("LCD panel info: %lu x %lu, %d bit/pix\n", panel_info.vl_col,
 		panel_info.vl_row, NBITS(panel_info.vl_bpix));
 
 	size = lcd_get_size(&line_length);
diff -urN u-boot-2016.03/common/lcd_console.c ebf_6ull_uboot/common/lcd_console.c
--- u-boot-2016.03/common/lcd_console.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/common/lcd_console.c	2021-04-16 14:42:17.772596724 +0800
@@ -47,16 +47,31 @@
 	int fg_color = lcd_getfgcolor();
 	int bg_color = lcd_getbgcolor();
 	int i, row;
+#if LCD_BPP == LCD_MONOCHROME
+	ushort off  = x * (1 << LCD_BPP) % 8;
+#endif
+
 	fbptr_t *dst = (fbptr_t *)pcons->fbbase +
 				  y * pcons->lcdsizex +
 				  x;
 
 	for (row = 0; row < VIDEO_FONT_HEIGHT; row++) {
 		uchar bits = video_fontdata[c * VIDEO_FONT_HEIGHT + row];
+#if LCD_BPP == LCD_MONOCHROME
+		uchar rest = *dst & -(1 << (8 - off));
+		uchar sym;
+
+		sym  = (COLOR_MASK(fg_color) & bits) |
+			(COLOR_MASK(bg_color) & ~bits);
+		*dst++ = rest | (sym >> off);
+		rest = sym << (8 - off);
+		*dst  = rest | (*dst & ((1 << (8 - off)) - 1));
+#else /* LCD_BPP == LCD_COLOR8 or LCD_COLOR16 or LCD_COLOR32 */
 		for (i = 0; i < VIDEO_FONT_WIDTH; ++i) {
 			*dst++ = (bits & 0x80) ? fg_color : bg_color;
 			bits <<= 1;
 		}
+#endif
 		dst += (pcons->lcdsizex - VIDEO_FONT_WIDTH);
 	}
 }
@@ -114,7 +129,7 @@
 		for (i = 0; i < cons.rows-rows; i++)
 			cons.fp_console_moverow(&cons, i, i+rows);
 		for (i = 0; i < rows; i++)
-			cons.fp_console_setrow(&cons, cons.rows-i-1, bg_color);
+			cons.fp_console_setrow(&cons, cons.rows-i-1, COLOR_MASK(bg_color));
 		cons.curr_row -= rows;
 	}
 	lcd_sync();
diff -urN u-boot-2016.03/common/Makefile ebf_6ull_uboot/common/Makefile
--- u-boot-2016.03/common/Makefile	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/common/Makefile	2021-04-16 14:42:17.772596724 +0800
@@ -49,6 +49,7 @@
 obj-$(CONFIG_ENV_IS_IN_NAND) += env_nand.o
 obj-$(CONFIG_ENV_IS_IN_NVRAM) += env_nvram.o
 obj-$(CONFIG_ENV_IS_IN_ONENAND) += env_onenand.o
+obj-$(CONFIG_ENV_IS_IN_SATA) += env_sata.o
 obj-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o
 obj-$(CONFIG_ENV_IS_IN_REMOTE) += env_remote.o
 obj-$(CONFIG_ENV_IS_IN_UBI) += env_ubi.o
diff -urN u-boot-2016.03/common/usb_storage.c ebf_6ull_uboot/common/usb_storage.c
--- u-boot-2016.03/common/usb_storage.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/common/usb_storage.c	2021-04-16 14:42:17.772596724 +0800
@@ -18,6 +18,8 @@
  * BBB support based on /sys/dev/usb/umass.c from
  * FreeBSD.
  *
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -103,7 +105,7 @@
  * enough free heap space left, but the SCSI READ(10) and WRITE(10) commands are
  * limited to 65535 blocks.
  */
-#define USB_MAX_XFER_BLK	65535
+#define USB_MAX_XFER_BLK	256
 #else
 #define USB_MAX_XFER_BLK	20
 #endif
diff -urN u-boot-2016.03/.config ebf_6ull_uboot/.config
--- u-boot-2016.03/.config	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.config	2021-04-16 14:42:15.704586022 +0800
@@ -0,0 +1,561 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2016.03 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+CONFIG_HAVE_GENERIC_BOARD=y
+CONFIG_SYS_GENERIC_BOARD=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_AVR32 is not set
+# CONFIG_BLACKFIN is not set
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_OPENRISC is not set
+# CONFIG_PPC is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_SPARC is not set
+# CONFIG_X86 is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_SOC="mx6"
+CONFIG_SYS_VENDOR="freescale"
+CONFIG_SYS_BOARD="mx6ullevk"
+CONFIG_SYS_CONFIG_NAME="mx6ullevk"
+
+#
+# ARM architecture
+#
+CONFIG_HAS_VBAR=y
+CONFIG_HAS_THUMB2=y
+CONFIG_CPU_V7=y
+# CONFIG_SEMIHOSTING is not set
+CONFIG_SYS_L2CACHE_OFF=y
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_VCMA9 is not set
+# CONFIG_TARGET_SMDK2410 is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_MX25PDK is not set
+# CONFIG_TARGET_ZMX25 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_TARGET_APX4DEVKIT is not set
+# CONFIG_TARGET_XFI3 is not set
+# CONFIG_TARGET_M28EVK is not set
+# CONFIG_TARGET_MX23EVK is not set
+# CONFIG_TARGET_MX28EVK is not set
+# CONFIG_TARGET_MX23_OLINUXINO is not set
+# CONFIG_TARGET_BG0900 is not set
+# CONFIG_TARGET_SANSA_FUZE_PLUS is not set
+# CONFIG_TARGET_SC_SPS_1 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_KWB is not set
+# CONFIG_TARGET_TSERIES is not set
+# CONFIG_TARGET_CM_T335 is not set
+# CONFIG_TARGET_PEPPER is not set
+# CONFIG_TARGET_AM335X_IGEP0033 is not set
+# CONFIG_TARGET_PCM051 is not set
+# CONFIG_TARGET_DRACO is not set
+# CONFIG_TARGET_THUBAN is not set
+# CONFIG_TARGET_RASTABAN is not set
+# CONFIG_TARGET_PXM2 is not set
+# CONFIG_TARGET_RUT is not set
+# CONFIG_TARGET_PENGWYN is not set
+# CONFIG_TARGET_AM335X_BALTOS is not set
+# CONFIG_TARGET_AM335X_EVM is not set
+# CONFIG_TARGET_AM335X_SL50 is not set
+# CONFIG_TARGET_AM43XX_EVM is not set
+# CONFIG_TARGET_BAV335X is not set
+# CONFIG_TARGET_TI814X_EVM is not set
+# CONFIG_TARGET_TI816X_EVM is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MX7 is not set
+CONFIG_ARCH_MX6=y
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_TARGET_M53EVK is not set
+# CONFIG_TARGET_MX51EVK is not set
+# CONFIG_TARGET_MX53ARD is not set
+# CONFIG_TARGET_MX53EVK is not set
+# CONFIG_TARGET_MX53LOCO is not set
+# CONFIG_TARGET_MX53SMD is not set
+# CONFIG_OMAP34XX is not set
+# CONFIG_OMAP44XX is not set
+# CONFIG_OMAP54XX is not set
+# CONFIG_RMOBILE is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_TARGET_CM_T43 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_TARGET_TS4800 is not set
+# CONFIG_TARGET_VF610TWR is not set
+# CONFIG_TARGET_COLIBRI_VF is not set
+# CONFIG_TARGET_PCM052 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_MX6=y
+CONFIG_MX6UL=y
+CONFIG_MX6ULL=y
+# CONFIG_TARGET_ARISTAINETOS is not set
+# CONFIG_TARGET_ARISTAINETOS2 is not set
+# CONFIG_TARGET_ARISTAINETOS2B is not set
+# CONFIG_TARGET_CGTQMX6EVAL is not set
+# CONFIG_TARGET_CM_FX6 is not set
+# CONFIG_TARGET_EMBESTMX6BOARDS is not set
+# CONFIG_TARGET_GW_VENTANA is not set
+# CONFIG_TARGET_KOSAGI_NOVENA is not set
+# CONFIG_TARGET_MX6CUBOXI is not set
+# CONFIG_TARGET_MX6QARM2 is not set
+# CONFIG_TARGET_MX6QSABREAUTO is not set
+# CONFIG_TARGET_MX6SABRESD is not set
+# CONFIG_TARGET_MX6SLEVK is not set
+# CONFIG_TARGET_MX6SLLEVK is not set
+# CONFIG_TARGET_MX6SLL_ARM2 is not set
+# CONFIG_TARGET_MX6SXSABRESD is not set
+# CONFIG_TARGET_MX6SXSABREAUTO is not set
+# CONFIG_TARGET_MX6UL_9X9_EVK is not set
+# CONFIG_TARGET_MX6UL_14X14_EVK is not set
+# CONFIG_TARGET_MX6UL_14X14_DDR3_ARM2 is not set
+# CONFIG_TARGET_MX6UL_14X14_LPDDR2_ARM2 is not set
+# CONFIG_TARGET_MX6SX_17X17_ARM2 is not set
+# CONFIG_TARGET_MX6SX_19X19_ARM2 is not set
+# CONFIG_TARGET_PICOSOM_IMX6UL is not set
+# CONFIG_TARGET_NITROGEN6X is not set
+# CONFIG_TARGET_OT1200 is not set
+# CONFIG_TARGET_PLATINUM_PICON is not set
+# CONFIG_TARGET_PLATINUM_TITANIUM is not set
+# CONFIG_TARGET_MX6ULL_DDR3_ARM2 is not set
+CONFIG_TARGET_MX6ULL_14X14_EVK=y
+# CONFIG_TARGET_MX6ULL_9X9_EVK is not set
+# CONFIG_TARGET_SECOMX6 is not set
+# CONFIG_TARGET_TBS2910 is not set
+# CONFIG_TARGET_TITANIUM is not set
+# CONFIG_TARGET_TQMA6 is not set
+# CONFIG_TARGET_UDOO is not set
+# CONFIG_TARGET_WANDBOARD is not set
+# CONFIG_TARGET_WARP is not set
+# CONFIG_TARGET_MX6DQSCM is not set
+# CONFIG_TARGET_MX6SXSCM is not set
+CONFIG_SYS_MALLOC_F=y
+# CONFIG_DM_SERIAL is not set
+# CONFIG_DM_SPI is not set
+# CONFIG_DM_I2C is not set
+# CONFIG_DM_GPIO is not set
+CONFIG_ROM_UNIFIED_SECTIONS=y
+# CONFIG_IMX_RDC is not set
+# CONFIG_IMX_BOOTAUX is not set
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+# CONFIG_DM_KEYBOARD is not set
+CONFIG_DEFAULT_DEVICE_TREE=""
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_EXPERT=y
+CONFIG_SYS_MALLOC_CLEAR_ON_INIT=y
+
+#
+# Boot images
+#
+# CONFIG_FIT is not set
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ullevk/imximage.cfg,SYS_BOOT_NAND"
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_USER_COUNT=20
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=4096
+# CONFIG_CONSOLE_RECORD is not set
+
+#
+# Command line interface
+#
+# CONFIG_HUSH_PARSER is not set
+CONFIG_SYS_PROMPT="=> "
+
+#
+# Autoboot options
+#
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+CONFIG_CMD_BDI=y
+CONFIG_CMD_CONSOLE=y
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_BOOTM=y
+CONFIG_CMD_ELF=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_RUN=y
+CONFIG_CMD_IMI=y
+CONFIG_CMD_IMLS=y
+CONFIG_CMD_XIMG=y
+
+#
+# Environment commands
+#
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_ENV_EXISTS=y
+
+#
+# Memory commands
+#
+CONFIG_CMD_MEMORY=y
+CONFIG_CMD_CRC32=y
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_MEMINFO is not set
+
+#
+# Device access commands
+#
+CONFIG_CMD_DM=y
+# CONFIG_CMD_DEMO is not set
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADS=y
+CONFIG_CMD_FLASH=y
+# CONFIG_CMD_NAND is not set
+# CONFIG_CMD_SF is not set
+# CONFIG_CMD_SPI is not set
+# CONFIG_CMD_I2C is not set
+# CONFIG_CMD_USB is not set
+CONFIG_CMD_FPGA=y
+CONFIG_CMD_GPIO=y
+
+#
+# Shell scripting commands
+#
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_ITEST=y
+CONFIG_CMD_SOURCE=y
+CONFIG_CMD_SETEXPR=y
+
+#
+# Network commands
+#
+CONFIG_CMD_NET=y
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+# CONFIG_CMD_DHCP is not set
+CONFIG_CMD_NFS=y
+# CONFIG_CMD_PING is not set
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+
+#
+# Misc commands
+#
+# CONFIG_CMD_TIME is not set
+CONFIG_CMD_MISC=y
+# CONFIG_CMD_TIMER is not set
+
+#
+# Power commands
+#
+
+#
+# Security commands
+#
+CONFIG_SUPPORT_OF_CONTROL=y
+
+#
+# Device Tree Control
+#
+# CONFIG_OF_CONTROL is not set
+CONFIG_NET=y
+# CONFIG_NET_RANDOM_ETHADDR is not set
+# CONFIG_NETCONSOLE is not set
+CONFIG_NET_TFTP_VARS=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_DM=y
+CONFIG_DM_WARN=y
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_DM_STDIO=y
+CONFIG_DM_SEQ_ALIAS=y
+# CONFIG_SPL_DM_SEQ_ALIAS is not set
+# CONFIG_REGMAP is not set
+# CONFIG_SPL_REGMAP is not set
+# CONFIG_DEVRES is not set
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+CONFIG_DISK=y
+
+#
+# Clock
+#
+# CONFIG_CLK is not set
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+
+#
+# Demo for driver model
+#
+# CONFIG_DM_DEMO is not set
+
+#
+# DFU support
+#
+# CONFIG_DFU_TFTP is not set
+
+#
+# DMA Support
+#
+# CONFIG_DMA is not set
+# CONFIG_TI_EDMA3 is not set
+
+#
+# GPIO Support
+#
+# CONFIG_ATMEL_PIO4 is not set
+# CONFIG_LPC32XX_GPIO is not set
+# CONFIG_VYBRID_GPIO is not set
+
+#
+# I2C support
+#
+# CONFIG_DM_I2C_COMPAT is not set
+# CONFIG_CROS_EC_KEYB is not set
+
+#
+# LED Support
+#
+# CONFIG_LED is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MISC is not set
+# CONFIG_CROS_EC is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_PWRSEQ is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_RESET is not set
+# CONFIG_WINBOND_W83627 is not set
+
+#
+# MMC Host controller Support
+#
+# CONFIG_DM_MMC is not set
+
+#
+# MTD Support
+#
+# CONFIG_MTD is not set
+
+#
+# NAND Device Support
+#
+# CONFIG_NAND_DENALI is not set
+# CONFIG_NAND_VF610_NFC is not set
+# CONFIG_NAND_PXA3XX is not set
+# CONFIG_NAND_ARASAN is not set
+
+#
+# Generic NAND options
+#
+
+#
+# SPI Flash Support
+#
+# CONFIG_SPI_FLASH is not set
+# CONFIG_DM_ETH is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_NETDEVICES is not set
+
+#
+# PCI
+#
+# CONFIG_DM_PCI is not set
+
+#
+# Pin controllers
+#
+# CONFIG_PINCTRL is not set
+
+#
+# Power
+#
+# CONFIG_DM_PMIC is not set
+# CONFIG_DM_REGULATOR is not set
+# CONFIG_DM_PWM is not set
+# CONFIG_RAM is not set
+
+#
+# Remote Processor drivers
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_DM_RTC is not set
+
+#
+# Serial drivers
+#
+# CONFIG_DEBUG_UART is not set
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_SYS_NS16550 is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+# CONFIG_FSL_ESPI is not set
+# CONFIG_TI_QSPI is not set
+CONFIG_DM_THERMAL=y
+
+#
+# Timer Support
+#
+# CONFIG_TIMER is not set
+
+#
+# TPM support
+#
+# CONFIG_USB is not set
+
+#
+# Graphics support
+#
+# CONFIG_DM_VIDEO is not set
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_DISPLAY is not set
+# CONFIG_VIDEO_BRIDGE is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+
+#
+# Library routines
+#
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+# CONFIG_USE_PRIVATE_LIBGCC is not set
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+CONFIG_REGEX=y
+# CONFIG_LIB_RAND is not set
+# CONFIG_CMD_DHRYSTONE is not set
+# CONFIG_RSA is not set
+# CONFIG_TPM is not set
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+# CONFIG_ERRNO_STR is not set
+# CONFIG_UNIT_TEST is not set
diff -urN u-boot-2016.03/configs/mx6dlarm2_defconfig ebf_6ull_uboot/configs/mx6dlarm2_defconfig
--- u-boot-2016.03/configs/mx6dlarm2_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dlarm2_defconfig	2021-04-16 14:42:15.588585423 +0800
@@ -2,7 +2,4 @@
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6QARM2=y
 CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qarm2/imximage_mx6dl.cfg,MX6DL,DDR_MB=2048"
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_FLASH is not set
 CONFIG_CMD_GPIO=y
-# CONFIG_CMD_SETEXPR is not set
diff -urN u-boot-2016.03/configs/mx6dlarm2_lpddr2_defconfig ebf_6ull_uboot/configs/mx6dlarm2_lpddr2_defconfig
--- u-boot-2016.03/configs/mx6dlarm2_lpddr2_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dlarm2_lpddr2_defconfig	2021-04-16 14:42:15.588585423 +0800
@@ -2,7 +2,4 @@
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6QARM2=y
 CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qarm2/imximage_mx6dl.cfg,MX6DL,MX6DL_LPDDR2,DDR_MB=512"
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_FLASH is not set
 CONFIG_CMD_GPIO=y
-# CONFIG_CMD_SETEXPR is not set
diff -urN u-boot-2016.03/configs/mx6dlsabreautoandroid_defconfig ebf_6ull_uboot/configs/mx6dlsabreautoandroid_defconfig
--- u-boot-2016.03/configs/mx6dlsabreautoandroid_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dlsabreautoandroid_defconfig	2021-04-16 14:42:15.588585423 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6dl.cfg,MX6DL,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6dlsabreautoandroid_nand_defconfig ebf_6ull_uboot/configs/mx6dlsabreautoandroid_nand_defconfig
--- u-boot-2016.03/configs/mx6dlsabreautoandroid_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dlsabreautoandroid_nand_defconfig	2021-04-16 14:42:15.588585423 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6dl.cfg,MX6DL,SYS_BOOT_NAND,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6dlsabreauto_defconfig ebf_6ull_uboot/configs/mx6dlsabreauto_defconfig
--- u-boot-2016.03/configs/mx6dlsabreauto_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dlsabreauto_defconfig	2021-04-16 14:42:15.588585423 +0800
@@ -2,8 +2,4 @@
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6QSABREAUTO=y
 CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6dl.cfg,MX6DL"
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_FLASH is not set
 CONFIG_CMD_GPIO=y
-CONFIG_SPI_FLASH=y
-CONFIG_SPI_FLASH_STMICRO=y
diff -urN u-boot-2016.03/configs/mx6dlsabreauto_eimnor_defconfig ebf_6ull_uboot/configs/mx6dlsabreauto_eimnor_defconfig
--- u-boot-2016.03/configs/mx6dlsabreauto_eimnor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dlsabreauto_eimnor_defconfig	2021-04-16 14:42:15.588585423 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6dl.cfg,MX6DL,SYS_BOOT_EIMNOR"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6dlsabreauto_nand_defconfig ebf_6ull_uboot/configs/mx6dlsabreauto_nand_defconfig
--- u-boot-2016.03/configs/mx6dlsabreauto_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dlsabreauto_nand_defconfig	2021-04-16 14:42:15.588585423 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6dl.cfg,MX6DL,SYS_BOOT_NAND"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6dlsabreauto_spinor_defconfig ebf_6ull_uboot/configs/mx6dlsabreauto_spinor_defconfig
--- u-boot-2016.03/configs/mx6dlsabreauto_spinor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dlsabreauto_spinor_defconfig	2021-04-16 14:42:15.588585423 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6dl.cfg,MX6DL,SYS_BOOT_SPINOR"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6dlsabresdandroid_defconfig ebf_6ull_uboot/configs/mx6dlsabresdandroid_defconfig
--- u-boot-2016.03/configs/mx6dlsabresdandroid_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dlsabresdandroid_defconfig	2021-04-16 14:42:15.588585423 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SABRESD=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sabresd/mx6dlsabresd.cfg,MX6DL,SYS_USE_SPINOR,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6dlsabresd_defconfig ebf_6ull_uboot/configs/mx6dlsabresd_defconfig
--- u-boot-2016.03/configs/mx6dlsabresd_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dlsabresd_defconfig	2021-04-16 14:42:15.588585423 +0800
@@ -1,9 +1,5 @@
 CONFIG_ARM=y
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6SABRESD=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sabresd/mx6dlsabresd.cfg,MX6DL"
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_FLASH is not set
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sabresd/mx6dlsabresd.cfg,MX6DL,SYS_USE_SPINOR"
 CONFIG_CMD_GPIO=y
-CONFIG_SPI_FLASH=y
-CONFIG_SPI_FLASH_STMICRO=y
diff -urN u-boot-2016.03/configs/mx6dlsabresd_epdc_defconfig ebf_6ull_uboot/configs/mx6dlsabresd_epdc_defconfig
--- u-boot-2016.03/configs/mx6dlsabresd_epdc_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dlsabresd_epdc_defconfig	2021-04-16 14:42:15.588585423 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SABRESD=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sabresd/mx6dlsabresd.cfg,MX6DL,MXC_EPDC"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6dqscm_1gb_fix_evb_defconfig ebf_6ull_uboot/configs/mx6dqscm_1gb_fix_evb_defconfig
--- u-boot-2016.03/configs/mx6dqscm_1gb_fix_evb_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dqscm_1gb_fix_evb_defconfig	2021-04-16 14:42:15.588585423 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6DQSCM=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg,MX6Q,DDR_MB=1024,SYS_USE_SPINOR,DEFAULT_FDT_FILE=\"imx6dqscm-1gb-evb-fix-ldo.dtb\",SCMEVB"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6dqscm_1gb_fix_qwks_rev2_defconfig ebf_6ull_uboot/configs/mx6dqscm_1gb_fix_qwks_rev2_defconfig
--- u-boot-2016.03/configs/mx6dqscm_1gb_fix_qwks_rev2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dqscm_1gb_fix_qwks_rev2_defconfig	2021-04-16 14:42:15.588585423 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6DQSCM=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg,MX6Q,DDR_MB=1024,SYS_USE_SPINOR,DEFAULT_FDT_FILE=\"imx6dqscm-1gb-qwks-rev2-fix-ldo.dtb\""
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6dqscm_1gb_fix_qwks_rev2_spinor_defconfig ebf_6ull_uboot/configs/mx6dqscm_1gb_fix_qwks_rev2_spinor_defconfig
--- u-boot-2016.03/configs/mx6dqscm_1gb_fix_qwks_rev2_spinor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dqscm_1gb_fix_qwks_rev2_spinor_defconfig	2021-04-16 14:42:15.588585423 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6DQSCM=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg,MX6Q,DDR_MB=1024,SYS_BOOT_SPINOR,DEFAULT_FDT_FILE=\"imx6dqscm-1gb-qwks-rev2-fix-ldo.dtb\""
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6dqscm_1gb_fix_qwks_rev3_defconfig ebf_6ull_uboot/configs/mx6dqscm_1gb_fix_qwks_rev3_defconfig
--- u-boot-2016.03/configs/mx6dqscm_1gb_fix_qwks_rev3_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dqscm_1gb_fix_qwks_rev3_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6DQSCM=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg,MX6Q,DDR_MB=1024,SYS_USE_SPINOR,QWKS_REV3,DEFAULT_FDT_FILE=\"imx6dqscm-1gb-qwks-rev3-fix-ldo.dtb\""
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6dqscm_1gb_fix_qwks_rev3_spinor_defconfig ebf_6ull_uboot/configs/mx6dqscm_1gb_fix_qwks_rev3_spinor_defconfig
--- u-boot-2016.03/configs/mx6dqscm_1gb_fix_qwks_rev3_spinor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dqscm_1gb_fix_qwks_rev3_spinor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6DQSCM=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg,MX6Q,DDR_MB=1024,QWKS_REV3,SYS_BOOT_SPINOR,DEFAULT_FDT_FILE=\"imx6dqscm-1gb-qwks-rev3-fix-ldo.dtb\""
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6dqscm_1gb_interleaving_evb_android_defconfig ebf_6ull_uboot/configs/mx6dqscm_1gb_interleaving_evb_android_defconfig
--- u-boot-2016.03/configs/mx6dqscm_1gb_interleaving_evb_android_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dqscm_1gb_interleaving_evb_android_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6DQSCM=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg,MX6Q,DDR_MB=1024,SYS_USE_SPINOR,DEFAULT_FDT_FILE=\"imx6dqscm-1gb-evb-interleave-ldo.dtb\",INTERLEAVING_MODE,SCMEVB,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6dqscm_1gb_interleaving_qwks_rev2_android_defconfig ebf_6ull_uboot/configs/mx6dqscm_1gb_interleaving_qwks_rev2_android_defconfig
--- u-boot-2016.03/configs/mx6dqscm_1gb_interleaving_qwks_rev2_android_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6dqscm_1gb_interleaving_qwks_rev2_android_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6DQSCM=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6dqscm/imximage_scm_lpddr2.cfg,MX6Q,DDR_MB=1024,SYS_USE_SPINOR,DEFAULT_FDT_FILE=\"imx6dqscm-1gb-qwks-rev2-interleave-ldo.dtb\",INTERLEAVING_MODE,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qarm2android_pop_lpddr2_revb_defconfig ebf_6ull_uboot/configs/mx6qarm2android_pop_lpddr2_revb_defconfig
--- u-boot-2016.03/configs/mx6qarm2android_pop_lpddr2_revb_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qarm2android_pop_lpddr2_revb_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qarm2/mt128x64mx32.cfg,MX6Q,MX6DQ_POP_LPDDR2,DDR_MB=512,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qarm2_defconfig ebf_6ull_uboot/configs/mx6qarm2_defconfig
--- u-boot-2016.03/configs/mx6qarm2_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qarm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -2,7 +2,4 @@
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6QARM2=y
 CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qarm2/imximage.cfg,MX6Q,DDR_MB=2048"
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_FLASH is not set
 CONFIG_CMD_GPIO=y
-# CONFIG_CMD_SETEXPR is not set
diff -urN u-boot-2016.03/configs/mx6qarm2_lpddr2_defconfig ebf_6ull_uboot/configs/mx6qarm2_lpddr2_defconfig
--- u-boot-2016.03/configs/mx6qarm2_lpddr2_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qarm2_lpddr2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -2,7 +2,4 @@
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6QARM2=y
 CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qarm2/imximage.cfg,MX6Q,MX6DQ_LPDDR2,DDR_MB=512"
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_FLASH is not set
 CONFIG_CMD_GPIO=y
-# CONFIG_CMD_SETEXPR is not set
diff -urN u-boot-2016.03/configs/mx6qarm2_pop_lpddr2_defconfig ebf_6ull_uboot/configs/mx6qarm2_pop_lpddr2_defconfig
--- u-boot-2016.03/configs/mx6qarm2_pop_lpddr2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qarm2_pop_lpddr2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qarm2/imximage.cfg,MX6Q,MX6DQ_POP_LPDDR2,DDR_MB=256"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qarm2_pop_lpddr2_revb_defconfig ebf_6ull_uboot/configs/mx6qarm2_pop_lpddr2_revb_defconfig
--- u-boot-2016.03/configs/mx6qarm2_pop_lpddr2_revb_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qarm2_pop_lpddr2_revb_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qarm2/mt128x64mx32.cfg,MX6Q,MX6DQ_POP_LPDDR2,DDR_MB=512"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qpsabreautoandroid_defconfig ebf_6ull_uboot/configs/mx6qpsabreautoandroid_defconfig
--- u-boot-2016.03/configs/mx6qpsabreautoandroid_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qpsabreautoandroid_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6qp.cfg,MX6QP,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qpsabreautoandroid_nand_defconfig ebf_6ull_uboot/configs/mx6qpsabreautoandroid_nand_defconfig
--- u-boot-2016.03/configs/mx6qpsabreautoandroid_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qpsabreautoandroid_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6qp.cfg,MX6QP,SYS_BOOT_NAND,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qpsabreauto_defconfig ebf_6ull_uboot/configs/mx6qpsabreauto_defconfig
--- u-boot-2016.03/configs/mx6qpsabreauto_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qpsabreauto_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -1,7 +1,5 @@
 CONFIG_ARM=y
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6QSABREAUTO=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6qp.cfg,MX6Q"
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6qp.cfg,MX6QP"
 CONFIG_CMD_GPIO=y
-CONFIG_SPI_FLASH=y
-CONFIG_SPI_FLASH_STMICRO=y
diff -urN u-boot-2016.03/configs/mx6qpsabreauto_eimnor_defconfig ebf_6ull_uboot/configs/mx6qpsabreauto_eimnor_defconfig
--- u-boot-2016.03/configs/mx6qpsabreauto_eimnor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qpsabreauto_eimnor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6qp.cfg,MX6QP,SYS_BOOT_EIMNOR"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qpsabreauto_nand_defconfig ebf_6ull_uboot/configs/mx6qpsabreauto_nand_defconfig
--- u-boot-2016.03/configs/mx6qpsabreauto_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qpsabreauto_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6qp.cfg,MX6QP,SYS_BOOT_NAND"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qpsabreauto_sata_defconfig ebf_6ull_uboot/configs/mx6qpsabreauto_sata_defconfig
--- u-boot-2016.03/configs/mx6qpsabreauto_sata_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qpsabreauto_sata_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6qp.cfg,MX6QP,SYS_BOOT_SATA"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qpsabreauto_spinor_defconfig ebf_6ull_uboot/configs/mx6qpsabreauto_spinor_defconfig
--- u-boot-2016.03/configs/mx6qpsabreauto_spinor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qpsabreauto_spinor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6qp.cfg,MX6QP,SYS_BOOT_SPINOR"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qpsabresdandroid_defconfig ebf_6ull_uboot/configs/mx6qpsabresdandroid_defconfig
--- u-boot-2016.03/configs/mx6qpsabresdandroid_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qpsabresdandroid_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SABRESD=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sabresd/mx6qp.cfg,MX6QP,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qpsabresd_defconfig ebf_6ull_uboot/configs/mx6qpsabresd_defconfig
--- u-boot-2016.03/configs/mx6qpsabresd_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qpsabresd_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SABRESD=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sabresd/mx6qp.cfg,MX6QP"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qpsabresd_sata_defconfig ebf_6ull_uboot/configs/mx6qpsabresd_sata_defconfig
--- u-boot-2016.03/configs/mx6qpsabresd_sata_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qpsabresd_sata_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SABRESD=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sabresd/mx6qp.cfg,MX6QP,SYS_USE_SPINOR,SYS_BOOT_SATA"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qsabreautoandroid_defconfig ebf_6ull_uboot/configs/mx6qsabreautoandroid_defconfig
--- u-boot-2016.03/configs/mx6qsabreautoandroid_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qsabreautoandroid_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/imximage.cfg,MX6Q,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qsabreautoandroid_nand_defconfig ebf_6ull_uboot/configs/mx6qsabreautoandroid_nand_defconfig
--- u-boot-2016.03/configs/mx6qsabreautoandroid_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qsabreautoandroid_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/imximage.cfg,MX6Q,SYS_BOOT_NAND,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qsabreauto_defconfig ebf_6ull_uboot/configs/mx6qsabreauto_defconfig
--- u-boot-2016.03/configs/mx6qsabreauto_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qsabreauto_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -2,8 +2,4 @@
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6QSABREAUTO=y
 CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/imximage.cfg,MX6Q"
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_FLASH is not set
 CONFIG_CMD_GPIO=y
-CONFIG_SPI_FLASH=y
-CONFIG_SPI_FLASH_STMICRO=y
diff -urN u-boot-2016.03/configs/mx6qsabreauto_eimnor_defconfig ebf_6ull_uboot/configs/mx6qsabreauto_eimnor_defconfig
--- u-boot-2016.03/configs/mx6qsabreauto_eimnor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qsabreauto_eimnor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/imximage.cfg,MX6Q,SYS_BOOT_EIMNOR"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qsabreauto_nand_defconfig ebf_6ull_uboot/configs/mx6qsabreauto_nand_defconfig
--- u-boot-2016.03/configs/mx6qsabreauto_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qsabreauto_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/imximage.cfg,MX6Q,SYS_BOOT_NAND"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qsabreauto_sata_defconfig ebf_6ull_uboot/configs/mx6qsabreauto_sata_defconfig
--- u-boot-2016.03/configs/mx6qsabreauto_sata_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qsabreauto_sata_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/imximage.cfg,MX6Q,SYS_BOOT_SATA"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qsabreauto_spinor_defconfig ebf_6ull_uboot/configs/mx6qsabreauto_spinor_defconfig
--- u-boot-2016.03/configs/mx6qsabreauto_spinor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qsabreauto_spinor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/imximage.cfg,MX6Q,SYS_BOOT_SPINOR"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qsabresdandroid_defconfig ebf_6ull_uboot/configs/mx6qsabresdandroid_defconfig
--- u-boot-2016.03/configs/mx6qsabresdandroid_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qsabresdandroid_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SABRESD=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sabresd/mx6q_4x_mt41j128.cfg,MX6Q,SYS_USE_SPINOR,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6qsabresd_defconfig ebf_6ull_uboot/configs/mx6qsabresd_defconfig
--- u-boot-2016.03/configs/mx6qsabresd_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qsabresd_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -1,9 +1,5 @@
 CONFIG_ARM=y
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6SABRESD=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sabresd/mx6q_4x_mt41j128.cfg,MX6Q"
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_FLASH is not set
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sabresd/mx6q_4x_mt41j128.cfg,MX6Q,SYS_USE_SPINOR"
 CONFIG_CMD_GPIO=y
-CONFIG_SPI_FLASH=y
-CONFIG_SPI_FLASH_STMICRO=y
diff -urN u-boot-2016.03/configs/mx6qsabresd_sata_defconfig ebf_6ull_uboot/configs/mx6qsabresd_sata_defconfig
--- u-boot-2016.03/configs/mx6qsabresd_sata_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6qsabresd_sata_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SABRESD=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sabresd/mx6q_4x_mt41j128.cfg,MX6Q,SYS_USE_SPINOR,SYS_BOOT_SATA"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6slevkandroid_defconfig ebf_6ull_uboot/configs/mx6slevkandroid_defconfig
--- u-boot-2016.03/configs/mx6slevkandroid_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6slevkandroid_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,7 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SLEVK=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6slevk/imximage.cfg,MX6SL,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_STMICRO=y
diff -urN u-boot-2016.03/configs/mx6slevk_defconfig ebf_6ull_uboot/configs/mx6slevk_defconfig
--- u-boot-2016.03/configs/mx6slevk_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6slevk_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -2,11 +2,6 @@
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6SLEVK=y
 CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6slevk/imximage.cfg,MX6SL"
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_FLASH is not set
 CONFIG_CMD_GPIO=y
-# CONFIG_CMD_SETEXPR is not set
-CONFIG_DM=y
 CONFIG_SPI_FLASH=y
 CONFIG_SPI_FLASH_STMICRO=y
-CONFIG_DM_THERMAL=y
diff -urN u-boot-2016.03/configs/mx6slevk_epdc_defconfig ebf_6ull_uboot/configs/mx6slevk_epdc_defconfig
--- u-boot-2016.03/configs/mx6slevk_epdc_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6slevk_epdc_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,7 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6slevk/imximage.cfg,MX6SL,SPLASH_SCREEN"
+CONFIG_TARGET_MX6SLEVK=y
+CONFIG_CMD_GPIO=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_STMICRO=y
diff -urN u-boot-2016.03/configs/mx6slevk_spinor_defconfig ebf_6ull_uboot/configs/mx6slevk_spinor_defconfig
--- u-boot-2016.03/configs/mx6slevk_spinor_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6slevk_spinor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -2,11 +2,6 @@
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6SLEVK=y
 CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6slevk/imximage.cfg,MX6SL,SYS_BOOT_SPINOR"
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_FLASH is not set
 CONFIG_CMD_GPIO=y
-# CONFIG_CMD_SETEXPR is not set
-CONFIG_DM=y
 CONFIG_SPI_FLASH=y
 CONFIG_SPI_FLASH_STMICRO=y
-CONFIG_DM_THERMAL=y
diff -urN u-boot-2016.03/configs/mx6sllevk_defconfig ebf_6ull_uboot/configs/mx6sllevk_defconfig
--- u-boot-2016.03/configs/mx6sllevk_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sllevk_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sllevk/imximage.cfg"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SLLEVK=y
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sllevk_epdc_defconfig ebf_6ull_uboot/configs/mx6sllevk_epdc_defconfig
--- u-boot-2016.03/configs/mx6sllevk_epdc_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sllevk_epdc_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sllevk/imximage.cfg,MXC_EPDC"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SLLEVK=y
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sll_lpddr2_arm2_defconfig ebf_6ull_uboot/configs/mx6sll_lpddr2_arm2_defconfig
--- u-boot-2016.03/configs/mx6sll_lpddr2_arm2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sll_lpddr2_arm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sll_arm2/imximage_lpddr2.cfg,LPDDR2"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SLL_ARM2=y
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sll_lpddr3_arm2_defconfig ebf_6ull_uboot/configs/mx6sll_lpddr3_arm2_defconfig
--- u-boot-2016.03/configs/mx6sll_lpddr3_arm2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sll_lpddr3_arm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sll_arm2/imximage.cfg"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SLL_ARM2=y
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sll_lpddr3_arm2_epdc_defconfig ebf_6ull_uboot/configs/mx6sll_lpddr3_arm2_epdc_defconfig
--- u-boot-2016.03/configs/mx6sll_lpddr3_arm2_epdc_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sll_lpddr3_arm2_epdc_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sll_arm2/imximage.cfg,MXC_EPDC"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SLL_ARM2=y
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sll_lpddr3_arm2_spinor_defconfig ebf_6ull_uboot/configs/mx6sll_lpddr3_arm2_spinor_defconfig
--- u-boot-2016.03/configs/mx6sll_lpddr3_arm2_spinor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sll_lpddr3_arm2_spinor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sll_arm2/imximage.cfg,SYS_BOOT_SPINOR"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SLL_ARM2=y
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6solosabreautoandroid_defconfig ebf_6ull_uboot/configs/mx6solosabreautoandroid_defconfig
--- u-boot-2016.03/configs/mx6solosabreautoandroid_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6solosabreautoandroid_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6solo.cfg,MX6SOLO,SYS_NOSMP=\"nosmp\",ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6solosabreautoandroid_nand_defconfig ebf_6ull_uboot/configs/mx6solosabreautoandroid_nand_defconfig
--- u-boot-2016.03/configs/mx6solosabreautoandroid_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6solosabreautoandroid_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6solo.cfg,MX6SOLO,SYS_NOSMP=\"nosmp\",SYS_BOOT_NAND,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6solosabreauto_defconfig ebf_6ull_uboot/configs/mx6solosabreauto_defconfig
--- u-boot-2016.03/configs/mx6solosabreauto_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6solosabreauto_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6solo.cfg,MX6SOLO,SYS_NOSMP=\"nosmp\""
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6solosabreauto_eimnor_defconfig ebf_6ull_uboot/configs/mx6solosabreauto_eimnor_defconfig
--- u-boot-2016.03/configs/mx6solosabreauto_eimnor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6solosabreauto_eimnor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6solo.cfg,MX6SOLO,SYS_NOSMP=\"nosmp\",SYS_BOOT_EIMNOR"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6solosabreauto_nand_defconfig ebf_6ull_uboot/configs/mx6solosabreauto_nand_defconfig
--- u-boot-2016.03/configs/mx6solosabreauto_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6solosabreauto_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6solo.cfg,MX6SOLO,SYS_NOSMP=\"nosmp\",SYS_BOOT_NAND"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6solosabreauto_spinor_defconfig ebf_6ull_uboot/configs/mx6solosabreauto_spinor_defconfig
--- u-boot-2016.03/configs/mx6solosabreauto_spinor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6solosabreauto_spinor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qsabreauto/mx6solo.cfg,MX6SOLO,SYS_NOSMP=\"nosmp\",SYS_BOOT_SPINOR"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6solosabresdandroid_defconfig ebf_6ull_uboot/configs/mx6solosabresdandroid_defconfig
--- u-boot-2016.03/configs/mx6solosabresdandroid_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6solosabresdandroid_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SABRESD=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg,MX6SOLO,SYS_USE_SPINOR,SYS_NOSMP=\"nosmp\",ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6solosabresd_defconfig ebf_6ull_uboot/configs/mx6solosabresd_defconfig
--- u-boot-2016.03/configs/mx6solosabresd_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6solosabresd_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SABRESD=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg,MX6SOLO,SYS_USE_SPINOR,SYS_NOSMP=\"nosmp\""
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sx_14x14_lpddr2_arm2_defconfig ebf_6ull_uboot/configs/mx6sx_14x14_lpddr2_arm2_defconfig
--- u-boot-2016.03/configs/mx6sx_14x14_lpddr2_arm2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sx_14x14_lpddr2_arm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SX_17X17_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sx_17x17_arm2/mx6sx_14x14_lpddr2_arm2.cfg,MX6SX_14x14,LPDDR2"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sx_14x14_lpddr2_arm2_nand_defconfig ebf_6ull_uboot/configs/mx6sx_14x14_lpddr2_arm2_nand_defconfig
--- u-boot-2016.03/configs/mx6sx_14x14_lpddr2_arm2_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sx_14x14_lpddr2_arm2_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SX_17X17_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sx_17x17_arm2/mx6sx_14x14_lpddr2_arm2.cfg,MX6SX_14x14,LPDDR2,SYS_BOOT_NAND"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sx_17x17_arm2_defconfig ebf_6ull_uboot/configs/mx6sx_17x17_arm2_defconfig
--- u-boot-2016.03/configs/mx6sx_17x17_arm2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sx_17x17_arm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SX_17X17_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sx_17x17_arm2/imximage.cfg"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sx_17x17_arm2_eimnor_defconfig ebf_6ull_uboot/configs/mx6sx_17x17_arm2_eimnor_defconfig
--- u-boot-2016.03/configs/mx6sx_17x17_arm2_eimnor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sx_17x17_arm2_eimnor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SX_17X17_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sx_17x17_arm2/imximage.cfg,SYS_BOOT_EIMNOR"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sx_17x17_arm2_nand_defconfig ebf_6ull_uboot/configs/mx6sx_17x17_arm2_nand_defconfig
--- u-boot-2016.03/configs/mx6sx_17x17_arm2_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sx_17x17_arm2_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SX_17X17_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sx_17x17_arm2/imximage.cfg,SYS_BOOT_NAND"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sx_17x17_arm2_qspi2_defconfig ebf_6ull_uboot/configs/mx6sx_17x17_arm2_qspi2_defconfig
--- u-boot-2016.03/configs/mx6sx_17x17_arm2_qspi2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sx_17x17_arm2_qspi2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SX_17X17_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sx_17x17_arm2/imximage.cfg,SYS_BOOT_QSPI"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sx_17x17_arm2_spinor_defconfig ebf_6ull_uboot/configs/mx6sx_17x17_arm2_spinor_defconfig
--- u-boot-2016.03/configs/mx6sx_17x17_arm2_spinor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sx_17x17_arm2_spinor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SX_17X17_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sx_17x17_arm2/imximage.cfg,SYS_BOOT_SPINOR"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sx_17x17wp_arm2_defconfig ebf_6ull_uboot/configs/mx6sx_17x17wp_arm2_defconfig
--- u-boot-2016.03/configs/mx6sx_17x17wp_arm2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sx_17x17wp_arm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SX_17X17_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sx_17x17_arm2/imximage_wp.cfg"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sx_19x19_ddr3_arm2_defconfig ebf_6ull_uboot/configs/mx6sx_19x19_ddr3_arm2_defconfig
--- u-boot-2016.03/configs/mx6sx_19x19_ddr3_arm2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sx_19x19_ddr3_arm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SX_19X19_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sx_19x19_arm2/imximage.cfg"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sx_19x19_ddr3_arm2_eimnor_defconfig ebf_6ull_uboot/configs/mx6sx_19x19_ddr3_arm2_eimnor_defconfig
--- u-boot-2016.03/configs/mx6sx_19x19_ddr3_arm2_eimnor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sx_19x19_ddr3_arm2_eimnor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SX_19X19_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sx_19x19_arm2/imximage.cfg,SYS_BOOT_EIMNOR"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sx_19x19_ddr3_arm2_nand_defconfig ebf_6ull_uboot/configs/mx6sx_19x19_ddr3_arm2_nand_defconfig
--- u-boot-2016.03/configs/mx6sx_19x19_ddr3_arm2_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sx_19x19_ddr3_arm2_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SX_19X19_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sx_19x19_arm2/imximage.cfg,SYS_BOOT_NAND"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sx_19x19_ddr3_arm2_qspi2_defconfig ebf_6ull_uboot/configs/mx6sx_19x19_ddr3_arm2_qspi2_defconfig
--- u-boot-2016.03/configs/mx6sx_19x19_ddr3_arm2_qspi2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sx_19x19_ddr3_arm2_qspi2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SX_19X19_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sx_19x19_arm2/imximage.cfg,SYS_BOOT_QSPI"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sx_19x19_ddr3_arm2_spinor_defconfig ebf_6ull_uboot/configs/mx6sx_19x19_ddr3_arm2_spinor_defconfig
--- u-boot-2016.03/configs/mx6sx_19x19_ddr3_arm2_spinor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sx_19x19_ddr3_arm2_spinor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SX_19X19_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sx_19x19_arm2/imximage.cfg,SYS_BOOT_SPINOR"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sx_19x19_lpddr2_arm2_defconfig ebf_6ull_uboot/configs/mx6sx_19x19_lpddr2_arm2_defconfig
--- u-boot-2016.03/configs/mx6sx_19x19_lpddr2_arm2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sx_19x19_lpddr2_arm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SX_19X19_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sx_19x19_arm2/imximage_lpddr2.cfg,LPDDR2"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sx_19x19_lpddr2_arm2_qspi2_defconfig ebf_6ull_uboot/configs/mx6sx_19x19_lpddr2_arm2_qspi2_defconfig
--- u-boot-2016.03/configs/mx6sx_19x19_lpddr2_arm2_qspi2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sx_19x19_lpddr2_arm2_qspi2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SX_19X19_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sx_19x19_arm2/imximage_lpddr2.cfg,LPDDR2,SYS_BOOT_QSPI"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sxsabreautoandroid_defconfig ebf_6ull_uboot/configs/mx6sxsabreautoandroid_defconfig
--- u-boot-2016.03/configs/mx6sxsabreautoandroid_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sxsabreautoandroid_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SXSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxsabreauto/imximage.cfg,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sxsabreautoandroid_nand_defconfig ebf_6ull_uboot/configs/mx6sxsabreautoandroid_nand_defconfig
--- u-boot-2016.03/configs/mx6sxsabreautoandroid_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sxsabreautoandroid_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SXSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxsabreauto/imximage.cfg,MX6SX,SYS_BOOT_NAND,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sxsabreauto_defconfig ebf_6ull_uboot/configs/mx6sxsabreauto_defconfig
--- u-boot-2016.03/configs/mx6sxsabreauto_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sxsabreauto_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -1,11 +1,5 @@
 CONFIG_ARM=y
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6SXSABREAUTO=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxsabreauto/imximage.cfg,MX6SX"
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_FLASH is not set
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxsabreauto/imximage.cfg"
 CONFIG_CMD_GPIO=y
-# CONFIG_CMD_SETEXPR is not set
-CONFIG_SPI_FLASH=y
-CONFIG_SPI_FLASH_BAR=y
-CONFIG_SPI_FLASH_STMICRO=y
diff -urN u-boot-2016.03/configs/mx6sxsabreauto_nand_defconfig ebf_6ull_uboot/configs/mx6sxsabreauto_nand_defconfig
--- u-boot-2016.03/configs/mx6sxsabreauto_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sxsabreauto_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SXSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxsabreauto/imximage.cfg,MX6SX,SYS_BOOT_NAND"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sxsabreauto_qspi1_defconfig ebf_6ull_uboot/configs/mx6sxsabreauto_qspi1_defconfig
--- u-boot-2016.03/configs/mx6sxsabreauto_qspi1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sxsabreauto_qspi1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SXSABREAUTO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxsabreauto/imximage.cfg,MX6SX,SYS_BOOT_QSPI"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sxsabresdandroid_defconfig ebf_6ull_uboot/configs/mx6sxsabresdandroid_defconfig
--- u-boot-2016.03/configs/mx6sxsabresdandroid_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sxsabresdandroid_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SXSABRESD=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxsabresd/imximage.cfg,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sxsabresd_defconfig ebf_6ull_uboot/configs/mx6sxsabresd_defconfig
--- u-boot-2016.03/configs/mx6sxsabresd_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sxsabresd_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -1,10 +1,5 @@
 CONFIG_ARM=y
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6SXSABRESD=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxsabresd/imximage.cfg,MX6SX"
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_FLASH is not set
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxsabresd/imximage.cfg"
 CONFIG_CMD_GPIO=y
-# CONFIG_CMD_SETEXPR is not set
-CONFIG_SPI_FLASH=y
-CONFIG_SPI_FLASH_BAR=y
diff -urN u-boot-2016.03/configs/mx6sxsabresd_emmc_defconfig ebf_6ull_uboot/configs/mx6sxsabresd_emmc_defconfig
--- u-boot-2016.03/configs/mx6sxsabresd_emmc_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sxsabresd_emmc_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SXSABRESD=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxsabresd/imximage.cfg,MX6SX,MX6SXSABRESD_EMMC_REWORK"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sxsabresd_m4fastup_defconfig ebf_6ull_uboot/configs/mx6sxsabresd_m4fastup_defconfig
--- u-boot-2016.03/configs/mx6sxsabresd_m4fastup_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sxsabresd_m4fastup_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SXSABRESD=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxsabresd/imximage.cfg,SYS_BOOT_QSPI,SYS_AUXCORE_FASTUP"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sxsabresd_qspi2_defconfig ebf_6ull_uboot/configs/mx6sxsabresd_qspi2_defconfig
--- u-boot-2016.03/configs/mx6sxsabresd_qspi2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sxsabresd_qspi2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SXSABRESD=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxsabresd/imximage.cfg,MX6SX,SYS_BOOT_QSPI"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sxsabresd_spl_defconfig ebf_6ull_uboot/configs/mx6sxsabresd_spl_defconfig
--- u-boot-2016.03/configs/mx6sxsabresd_spl_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sxsabresd_spl_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -2,7 +2,7 @@
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6SXSABRESD=y
 CONFIG_SPL=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/imx-common/spl_sd.cfg,MX6SX"
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/imx-common/spl_sd.cfg"
 # CONFIG_CMD_IMLS is not set
 # CONFIG_CMD_FLASH is not set
 CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sxscm_1gb_evb_defconfig ebf_6ull_uboot/configs/mx6sxscm_1gb_evb_defconfig
--- u-boot-2016.03/configs/mx6sxscm_1gb_evb_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sxscm_1gb_evb_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SXSCM=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxscm/imximage_lpddr2.cfg,MX6SX"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sxscm_1gb_evb_m4fastup_defconfig ebf_6ull_uboot/configs/mx6sxscm_1gb_evb_m4fastup_defconfig
--- u-boot-2016.03/configs/mx6sxscm_1gb_evb_m4fastup_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sxscm_1gb_evb_m4fastup_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SXSCM=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxscm/imximage_lpddr2.cfg,MX6SX,SYS_BOOT_QSPI,SYS_AUXCORE_FASTUP"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sxscm_1gb_evb_qspi2_defconfig ebf_6ull_uboot/configs/mx6sxscm_1gb_evb_qspi2_defconfig
--- u-boot-2016.03/configs/mx6sxscm_1gb_evb_qspi2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sxscm_1gb_evb_qspi2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SXSCM=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxscm/imximage_lpddr2.cfg,MX6SX,SYS_BOOT_QSPI"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6sxscm_epop_evb_defconfig ebf_6ull_uboot/configs/mx6sxscm_epop_evb_defconfig
--- u-boot-2016.03/configs/mx6sxscm_epop_evb_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6sxscm_epop_evb_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SXSCM=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sxscm/imximage_lpddr2.cfg,MX6SX,512MB_LPDDR2,MX6SXSCM_EMMC"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ul_14x14_ddr3_arm2_defconfig ebf_6ull_uboot/configs/mx6ul_14x14_ddr3_arm2_defconfig
--- u-boot-2016.03/configs/mx6ul_14x14_ddr3_arm2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_14x14_ddr3_arm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6UL_14X14_DDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ul_14x14_ddr3_arm2_eimnor_defconfig ebf_6ull_uboot/configs/mx6ul_14x14_ddr3_arm2_eimnor_defconfig
--- u-boot-2016.03/configs/mx6ul_14x14_ddr3_arm2_eimnor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_14x14_ddr3_arm2_eimnor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6UL_14X14_DDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg,SYS_BOOT_EIMNOR"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ul_14x14_ddr3_arm2_emmc_defconfig ebf_6ull_uboot/configs/mx6ul_14x14_ddr3_arm2_emmc_defconfig
--- u-boot-2016.03/configs/mx6ul_14x14_ddr3_arm2_emmc_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_14x14_ddr3_arm2_emmc_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6UL_14X14_DDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg,MX6UL_DDR3_ARM2_EMMC_REWORK"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ul_14x14_ddr3_arm2_nand_defconfig ebf_6ull_uboot/configs/mx6ul_14x14_ddr3_arm2_nand_defconfig
--- u-boot-2016.03/configs/mx6ul_14x14_ddr3_arm2_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_14x14_ddr3_arm2_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6UL_14X14_DDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg,SYS_BOOT_NAND"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ul_14x14_ddr3_arm2_qspi1_defconfig ebf_6ull_uboot/configs/mx6ul_14x14_ddr3_arm2_qspi1_defconfig
--- u-boot-2016.03/configs/mx6ul_14x14_ddr3_arm2_qspi1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_14x14_ddr3_arm2_qspi1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6UL_14X14_DDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg,SYS_BOOT_QSPI"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ul_14x14_ddr3_arm2_spinor_defconfig ebf_6ull_uboot/configs/mx6ul_14x14_ddr3_arm2_spinor_defconfig
--- u-boot-2016.03/configs/mx6ul_14x14_ddr3_arm2_spinor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_14x14_ddr3_arm2_spinor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6UL_14X14_DDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg,SYS_BOOT_SPINOR"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ul_14x14_evk_ddr_eol_brillo_defconfig ebf_6ull_uboot/configs/mx6ul_14x14_evk_ddr_eol_brillo_defconfig
--- u-boot-2016.03/configs/mx6ul_14x14_evk_ddr_eol_brillo_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_14x14_evk_ddr_eol_brillo_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,7 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6UL_14X14_EVK=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage.cfg,ANDROID_SUPPORT,BRILLO_SUPPORT,DDR3L_MT41K256M16HA"
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx6ul_14x14_evk_ddr_eol_defconfig ebf_6ull_uboot/configs/mx6ul_14x14_evk_ddr_eol_defconfig
--- u-boot-2016.03/configs/mx6ul_14x14_evk_ddr_eol_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_14x14_evk_ddr_eol_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,7 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6UL_14X14_EVK=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage.cfg,DDR3L_MT41K256M16HA"
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx6ul_14x14_evk_ddr_eol_qspi1_defconfig ebf_6ull_uboot/configs/mx6ul_14x14_evk_ddr_eol_qspi1_defconfig
--- u-boot-2016.03/configs/mx6ul_14x14_evk_ddr_eol_qspi1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_14x14_evk_ddr_eol_qspi1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,7 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6UL_14X14_EVK=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage.cfg,SYS_BOOT_QSPI,DDR3L_MT41K256M16HA"
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx6ul_14x14_evk_defconfig ebf_6ull_uboot/configs/mx6ul_14x14_evk_defconfig
--- u-boot-2016.03/configs/mx6ul_14x14_evk_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_14x14_evk_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -1,8 +1,7 @@
 CONFIG_ARM=y
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6UL_14X14_EVK=y
-CONFIG_SPL=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/imx-common/spl_sd.cfg"
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage.cfg"
 CONFIG_CMD_GPIO=y
 CONFIG_CMD_DHCP=y
 CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx6ul_14x14_evk_emmc_defconfig ebf_6ull_uboot/configs/mx6ul_14x14_evk_emmc_defconfig
--- u-boot-2016.03/configs/mx6ul_14x14_evk_emmc_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_14x14_evk_emmc_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,7 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6UL_14X14_EVK=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage.cfg,MX6UL_EVK_EMMC_REWORK"
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx6ul_14x14_evk_nand_defconfig ebf_6ull_uboot/configs/mx6ul_14x14_evk_nand_defconfig
--- u-boot-2016.03/configs/mx6ul_14x14_evk_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_14x14_evk_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,7 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6UL_14X14_EVK=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage.cfg,SYS_BOOT_NAND"
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx6ul_14x14_evk_qspi1_defconfig ebf_6ull_uboot/configs/mx6ul_14x14_evk_qspi1_defconfig
--- u-boot-2016.03/configs/mx6ul_14x14_evk_qspi1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_14x14_evk_qspi1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,7 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6UL_14X14_EVK=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage.cfg,SYS_BOOT_QSPI"
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx6ul_14x14_lpddr2_arm2_defconfig ebf_6ull_uboot/configs/mx6ul_14x14_lpddr2_arm2_defconfig
--- u-boot-2016.03/configs/mx6ul_14x14_lpddr2_arm2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_14x14_lpddr2_arm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6UL_14X14_LPDDR2_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_lpddr2_arm2/imximage.cfg"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ul_14x14_lpddr2_arm2_eimnor_defconfig ebf_6ull_uboot/configs/mx6ul_14x14_lpddr2_arm2_eimnor_defconfig
--- u-boot-2016.03/configs/mx6ul_14x14_lpddr2_arm2_eimnor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_14x14_lpddr2_arm2_eimnor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6UL_14X14_LPDDR2_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_lpddr2_arm2/imximage.cfg,SYS_BOOT_EIMNOR"
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ul_9x9_evk_defconfig ebf_6ull_uboot/configs/mx6ul_9x9_evk_defconfig
--- u-boot-2016.03/configs/mx6ul_9x9_evk_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_9x9_evk_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -1,8 +1,7 @@
 CONFIG_ARM=y
 CONFIG_ARCH_MX6=y
 CONFIG_TARGET_MX6UL_9X9_EVK=y
-CONFIG_SPL=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/imx-common/spl_sd.cfg"
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage_lpddr2.cfg"
 CONFIG_CMD_GPIO=y
 CONFIG_CMD_DHCP=y
 CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx6ul_9x9_evk_qspi1_defconfig ebf_6ull_uboot/configs/mx6ul_9x9_evk_qspi1_defconfig
--- u-boot-2016.03/configs/mx6ul_9x9_evk_qspi1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ul_9x9_evk_qspi1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,7 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6UL_9X9_EVK=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage_lpddr2.cfg,SYS_BOOT_QSPI"
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx6ull_14x14_ddr3_arm2_defconfig ebf_6ull_uboot/configs/mx6ull_14x14_ddr3_arm2_defconfig
--- u-boot-2016.03/configs/mx6ull_14x14_ddr3_arm2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ull_14x14_ddr3_arm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ull_ddr3_arm2/imximage.cfg"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6ULL_DDR3_ARM2=y
+CONFIG_CMD_GPIO=y
\ 文件尾没有换行符
diff -urN u-boot-2016.03/configs/mx6ull_14x14_ddr3_arm2_emmc_defconfig ebf_6ull_uboot/configs/mx6ull_14x14_ddr3_arm2_emmc_defconfig
--- u-boot-2016.03/configs/mx6ull_14x14_ddr3_arm2_emmc_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ull_14x14_ddr3_arm2_emmc_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ull_ddr3_arm2/imximage.cfg,MX6ULL_DDR3_ARM2_EMMC_REWORK"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6ULL_DDR3_ARM2=y
+CONFIG_CMD_GPIO=y
\ 文件尾没有换行符
diff -urN u-boot-2016.03/configs/mx6ull_14x14_ddr3_arm2_epdc_defconfig ebf_6ull_uboot/configs/mx6ull_14x14_ddr3_arm2_epdc_defconfig
--- u-boot-2016.03/configs/mx6ull_14x14_ddr3_arm2_epdc_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ull_14x14_ddr3_arm2_epdc_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ull_ddr3_arm2/imximage.cfg,MXC_EPDC"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6ULL_DDR3_ARM2=y
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ull_14x14_ddr3_arm2_nand_defconfig ebf_6ull_uboot/configs/mx6ull_14x14_ddr3_arm2_nand_defconfig
--- u-boot-2016.03/configs/mx6ull_14x14_ddr3_arm2_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ull_14x14_ddr3_arm2_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ull_ddr3_arm2/imximage.cfg,SYS_BOOT_NAND"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6ULL_DDR3_ARM2=y
+CONFIG_CMD_GPIO=y
\ 文件尾没有换行符
diff -urN u-boot-2016.03/configs/mx6ull_14x14_ddr3_arm2_qspi1_defconfig ebf_6ull_uboot/configs/mx6ull_14x14_ddr3_arm2_qspi1_defconfig
--- u-boot-2016.03/configs/mx6ull_14x14_ddr3_arm2_qspi1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ull_14x14_ddr3_arm2_qspi1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ull_ddr3_arm2/imximage.cfg,SYS_BOOT_QSPI"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6ULL_DDR3_ARM2=y
+CONFIG_CMD_GPIO=y
\ 文件尾没有换行符
diff -urN u-boot-2016.03/configs/mx6ull_14x14_ddr3_arm2_spinor_defconfig ebf_6ull_uboot/configs/mx6ull_14x14_ddr3_arm2_spinor_defconfig
--- u-boot-2016.03/configs/mx6ull_14x14_ddr3_arm2_spinor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ull_14x14_ddr3_arm2_spinor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ull_ddr3_arm2/imximage.cfg,SYS_BOOT_SPINOR"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6ULL_DDR3_ARM2=y
+CONFIG_CMD_GPIO=y
\ 文件尾没有换行符
diff -urN u-boot-2016.03/configs/mx6ull_14x14_ddr3_arm2_tsc_defconfig ebf_6ull_uboot/configs/mx6ull_14x14_ddr3_arm2_tsc_defconfig
--- u-boot-2016.03/configs/mx6ull_14x14_ddr3_arm2_tsc_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ull_14x14_ddr3_arm2_tsc_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ull_ddr3_arm2/imximage.cfg,MX6ULL_DDR3_ARM2_TSC_REWORK"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6ULL_DDR3_ARM2=y
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ull_14x14_evk_defconfig ebf_6ull_uboot/configs/mx6ull_14x14_evk_defconfig
--- u-boot-2016.03/configs/mx6ull_14x14_evk_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ull_14x14_evk_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ullevk/imximage.cfg"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6ULL_14X14_EVK=y
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ull_14x14_evk_emmc_defconfig ebf_6ull_uboot/configs/mx6ull_14x14_evk_emmc_defconfig
--- u-boot-2016.03/configs/mx6ull_14x14_evk_emmc_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ull_14x14_evk_emmc_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ullevk/imximage.cfg,MX6ULL_EVK_EMMC_REWORK"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6ULL_14X14_EVK=y
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ull_14x14_evk_nand_defconfig ebf_6ull_uboot/configs/mx6ull_14x14_evk_nand_defconfig
--- u-boot-2016.03/configs/mx6ull_14x14_evk_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ull_14x14_evk_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ullevk/imximage.cfg,SYS_BOOT_NAND"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6ULL_14X14_EVK=y
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ull_14x14_evk_qspi1_defconfig ebf_6ull_uboot/configs/mx6ull_14x14_evk_qspi1_defconfig
--- u-boot-2016.03/configs/mx6ull_14x14_evk_qspi1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ull_14x14_evk_qspi1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ullevk/imximage.cfg,SYS_BOOT_QSPI"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6ULL_14X14_EVK=y
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ull_9x9_evk_defconfig ebf_6ull_uboot/configs/mx6ull_9x9_evk_defconfig
--- u-boot-2016.03/configs/mx6ull_9x9_evk_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ull_9x9_evk_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ullevk/imximage_lpddr2.cfg"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6ULL_9X9_EVK=y
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx6ull_9x9_evk_qspi1_defconfig ebf_6ull_uboot/configs/mx6ull_9x9_evk_qspi1_defconfig
--- u-boot-2016.03/configs/mx6ull_9x9_evk_qspi1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx6ull_9x9_evk_qspi1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ullevk/imximage_lpddr2.cfg,SYS_BOOT_QSPI"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6ULL_9X9_EVK=y
+CONFIG_CMD_GPIO=y
diff -urN u-boot-2016.03/configs/mx7d_12x12_ddr3_arm2_defconfig ebf_6ull_uboot/configs/mx7d_12x12_ddr3_arm2_defconfig
--- u-boot-2016.03/configs/mx7d_12x12_ddr3_arm2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7d_12x12_ddr3_arm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7D_12X12_DDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7d_12x12_ddr3_arm2/imximage.cfg,DEFAULT_FDT_FILE=\"imx7d-12x12-ddr3-arm2.dtb\""
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7d_12x12_ddr3_arm2_TO_1_1_defconfig ebf_6ull_uboot/configs/mx7d_12x12_ddr3_arm2_TO_1_1_defconfig
--- u-boot-2016.03/configs/mx7d_12x12_ddr3_arm2_TO_1_1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7d_12x12_ddr3_arm2_TO_1_1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7D_12X12_DDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7d_12x12_ddr3_arm2/imximage_TO_1_1.cfg,DEFAULT_FDT_FILE=\"imx7d-12x12-ddr3-arm2.dtb\""
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7d_12x12_lpddr3_arm2_defconfig ebf_6ull_uboot/configs/mx7d_12x12_lpddr3_arm2_defconfig
--- u-boot-2016.03/configs/mx7d_12x12_lpddr3_arm2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7d_12x12_lpddr3_arm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7D_12X12_LPDDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7d_12x12_lpddr3_arm2/imximage.cfg,DEFAULT_FDT_FILE=\"imx7d-12x12-lpddr3-arm2.dtb\""
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7d_12x12_lpddr3_arm2_epdc_defconfig ebf_6ull_uboot/configs/mx7d_12x12_lpddr3_arm2_epdc_defconfig
--- u-boot-2016.03/configs/mx7d_12x12_lpddr3_arm2_epdc_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7d_12x12_lpddr3_arm2_epdc_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7D_12X12_LPDDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7d_12x12_lpddr3_arm2/imximage.cfg,DEFAULT_FDT_FILE=\"imx7d-12x12-lpddr3-arm2.dtb\",MXC_EPDC"
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7d_12x12_lpddr3_arm2_qspi1_defconfig ebf_6ull_uboot/configs/mx7d_12x12_lpddr3_arm2_qspi1_defconfig
--- u-boot-2016.03/configs/mx7d_12x12_lpddr3_arm2_qspi1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7d_12x12_lpddr3_arm2_qspi1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7D_12X12_LPDDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7d_12x12_lpddr3_arm2/imximage.cfg,SYS_BOOT_QSPI,DEFAULT_FDT_FILE=\"imx7d-12x12-lpddr3-arm2.dtb\""
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7d_12x12_lpddr3_arm2_spinor_defconfig ebf_6ull_uboot/configs/mx7d_12x12_lpddr3_arm2_spinor_defconfig
--- u-boot-2016.03/configs/mx7d_12x12_lpddr3_arm2_spinor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7d_12x12_lpddr3_arm2_spinor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7D_12X12_LPDDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7d_12x12_lpddr3_arm2/imximage.cfg,SYS_BOOT_SPINOR,DEFAULT_FDT_FILE=\"imx7d-12x12-lpddr3-arm2.dtb\""
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7d_12x12_lpddr3_arm2_TO_1_1_defconfig ebf_6ull_uboot/configs/mx7d_12x12_lpddr3_arm2_TO_1_1_defconfig
--- u-boot-2016.03/configs/mx7d_12x12_lpddr3_arm2_TO_1_1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7d_12x12_lpddr3_arm2_TO_1_1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7D_12X12_LPDDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7d_12x12_lpddr3_arm2/imximage_TO_1_1.cfg,DEFAULT_FDT_FILE=\"imx7d-12x12-lpddr3-arm2.dtb\""
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7d_19x19_ddr3_arm2_defconfig ebf_6ull_uboot/configs/mx7d_19x19_ddr3_arm2_defconfig
--- u-boot-2016.03/configs/mx7d_19x19_ddr3_arm2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7d_19x19_ddr3_arm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7D_19X19_DDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7d_19x19_ddr3_arm2/imximage.cfg,DEFAULT_FDT_FILE=\"imx7d-19x19-ddr3-arm2.dtb\""
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7d_19x19_ddr3_arm2_TO_1_1_defconfig ebf_6ull_uboot/configs/mx7d_19x19_ddr3_arm2_TO_1_1_defconfig
--- u-boot-2016.03/configs/mx7d_19x19_ddr3_arm2_TO_1_1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7d_19x19_ddr3_arm2_TO_1_1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7D_19X19_DDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7d_19x19_ddr3_arm2/imximage_TO_1_1.cfg,DEFAULT_FDT_FILE=\"imx7d-19x19-ddr3-arm2.dtb\""
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7d_19x19_lpddr2_arm2_defconfig ebf_6ull_uboot/configs/mx7d_19x19_lpddr2_arm2_defconfig
--- u-boot-2016.03/configs/mx7d_19x19_lpddr2_arm2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7d_19x19_lpddr2_arm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7D_19X19_LPDDR2_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7d_19x19_lpddr3_arm2/imximage_lpddr2.cfg,DEFAULT_FDT_FILE=\"imx7d-19x19-lpddr2-arm2.dtb\""
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7d_19x19_lpddr2_arm2_TO_1_1_defconfig ebf_6ull_uboot/configs/mx7d_19x19_lpddr2_arm2_TO_1_1_defconfig
--- u-boot-2016.03/configs/mx7d_19x19_lpddr2_arm2_TO_1_1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7d_19x19_lpddr2_arm2_TO_1_1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7D_19X19_LPDDR2_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7d_19x19_lpddr3_arm2/imximage_lpddr2_TO_1_1.cfg,DEFAULT_FDT_FILE=\"imx7d-19x19-lpddr2-arm2.dtb\""
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7d_19x19_lpddr3_arm2_defconfig ebf_6ull_uboot/configs/mx7d_19x19_lpddr3_arm2_defconfig
--- u-boot-2016.03/configs/mx7d_19x19_lpddr3_arm2_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7d_19x19_lpddr3_arm2_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7D_19X19_LPDDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7d_19x19_lpddr3_arm2/imximage.cfg,DEFAULT_FDT_FILE=\"imx7d-19x19-lpddr3-arm2.dtb\""
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7d_19x19_lpddr3_arm2_eimnor_defconfig ebf_6ull_uboot/configs/mx7d_19x19_lpddr3_arm2_eimnor_defconfig
--- u-boot-2016.03/configs/mx7d_19x19_lpddr3_arm2_eimnor_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7d_19x19_lpddr3_arm2_eimnor_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7D_19X19_LPDDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7d_19x19_lpddr3_arm2/imximage.cfg,SYS_BOOT_EIMNOR,DEFAULT_FDT_FILE=\"imx7d-19x19-lpddr3-arm2.dtb\""
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7d_19x19_lpddr3_arm2_nand_defconfig ebf_6ull_uboot/configs/mx7d_19x19_lpddr3_arm2_nand_defconfig
--- u-boot-2016.03/configs/mx7d_19x19_lpddr3_arm2_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7d_19x19_lpddr3_arm2_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7D_19X19_LPDDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7d_19x19_lpddr3_arm2/imximage.cfg,SYS_BOOT_NAND,DEFAULT_FDT_FILE=\"imx7d-19x19-lpddr3-arm2.dtb\""
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7d_19x19_lpddr3_arm2_TO_1_1_defconfig ebf_6ull_uboot/configs/mx7d_19x19_lpddr3_arm2_TO_1_1_defconfig
--- u-boot-2016.03/configs/mx7d_19x19_lpddr3_arm2_TO_1_1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7d_19x19_lpddr3_arm2_TO_1_1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7D_19X19_LPDDR3_ARM2=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7d_19x19_lpddr3_arm2/imximage_TO_1_1.cfg,DEFAULT_FDT_FILE=\"imx7d-19x19-lpddr3-arm2.dtb\""
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7dsabresdandroid_defconfig ebf_6ull_uboot/configs/mx7dsabresdandroid_defconfig
--- u-boot-2016.03/configs/mx7dsabresdandroid_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7dsabresdandroid_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_TARGET_MX7DSABRESD=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7dsabresd/imximage.cfg,ANDROID_SUPPORT"
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7dsabresd_defconfig ebf_6ull_uboot/configs/mx7dsabresd_defconfig
--- u-boot-2016.03/configs/mx7dsabresd_defconfig	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7dsabresd_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -3,12 +3,7 @@
 CONFIG_TARGET_MX7DSABRESD=y
 CONFIG_IMX_RDC=y
 CONFIG_IMX_BOOTAUX=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7dsabresd/imximage.cfg,MX7D"
-# CONFIG_CMD_BOOTD is not set
-# CONFIG_CMD_IMI is not set
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_XIMG is not set
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7dsabresd/imximage.cfg"
 CONFIG_CMD_GPIO=y
-# CONFIG_CMD_SETEXPR is not set
 CONFIG_CMD_DHCP=y
 CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7dsabresd_epdc_defconfig ebf_6ull_uboot/configs/mx7dsabresd_epdc_defconfig
--- u-boot-2016.03/configs/mx7dsabresd_epdc_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7dsabresd_epdc_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_TARGET_MX7DSABRESD=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7dsabresd/imximage.cfg,MXC_EPDC"
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7dsabresd_nand_defconfig ebf_6ull_uboot/configs/mx7dsabresd_nand_defconfig
--- u-boot-2016.03/configs/mx7dsabresd_nand_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7dsabresd_nand_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_TARGET_MX7DSABRESD=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7dsabresd/imximage.cfg,SYS_BOOT_NAND"
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7dsabresd_qspi1_defconfig ebf_6ull_uboot/configs/mx7dsabresd_qspi1_defconfig
--- u-boot-2016.03/configs/mx7dsabresd_qspi1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7dsabresd_qspi1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_TARGET_MX7DSABRESD=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7dsabresd/imximage.cfg,SYS_BOOT_QSPI"
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/mx7dsabresd_TO_1_1_defconfig ebf_6ull_uboot/configs/mx7dsabresd_TO_1_1_defconfig
--- u-boot-2016.03/configs/mx7dsabresd_TO_1_1_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/mx7dsabresd_TO_1_1_defconfig	2021-04-16 14:42:15.592585442 +0800
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_TARGET_MX7DSABRESD=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx7dsabresd/imximage_TO_1_1.cfg"
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/picosom-imx6ul_defconfig ebf_6ull_uboot/configs/picosom-imx6ul_defconfig
--- u-boot-2016.03/configs/picosom-imx6ul_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/picosom-imx6ul_defconfig	2021-04-16 14:42:15.596585464 +0800
@@ -0,0 +1,7 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/technexion/picosom-imx6ul/imximage.cfg,ANDROID_SUPPORT,BRILLO_SUPPORT"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_PICOSOM_IMX6UL=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/configs/picosom-imx6ul-qspi_defconfig ebf_6ull_uboot/configs/picosom-imx6ul-qspi_defconfig
--- u-boot-2016.03/configs/picosom-imx6ul-qspi_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/configs/picosom-imx6ul-qspi_defconfig	2021-04-16 14:42:15.596585464 +0800
@@ -0,0 +1,7 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/technexion/picosom-imx6ul/imximage.cfg,SYS_BOOT_QSPI"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_PICOSOM_IMX6UL=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
diff -urN u-boot-2016.03/drivers/block/dwc_ahsata.c ebf_6ull_uboot/drivers/block/dwc_ahsata.c
--- u-boot-2016.03/drivers/block/dwc_ahsata.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/block/dwc_ahsata.c	2021-04-16 14:42:15.960587348 +0800
@@ -563,7 +563,8 @@
 	struct ahci_probe_ent *probe_ent = NULL;
 
 #if defined(CONFIG_MX6)
-	if (!is_cpu_type(MXC_CPU_MX6Q) && !is_cpu_type(MXC_CPU_MX6D))
+	if (!is_cpu_type(MXC_CPU_MX6Q) && !is_cpu_type(MXC_CPU_MX6D) &&
+		!is_cpu_type(MXC_CPU_MX6QP) && !is_cpu_type(MXC_CPU_MX6DP))
 		return 1;
 #endif
 	if (dev < 0 || dev > (CONFIG_SYS_SATA_MAX_DEVICE - 1)) {
diff -urN u-boot-2016.03/drivers/dfu/dfu.c ebf_6ull_uboot/drivers/dfu/dfu.c
--- u-boot-2016.03/drivers/dfu/dfu.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/dfu/dfu.c	2021-04-16 14:42:15.964587367 +0800
@@ -468,8 +468,10 @@
 		s = strsep(&env, ";");
 		ret = dfu_fill_entity(&dfu[i], s, alt_num_cnt, interface,
 				      devstr);
-		if (ret)
+		if (ret) {
+			free(dfu);
 			return -1;
+		}
 
 		list_add_tail(&dfu[i].list, &dfu_list);
 		alt_num_cnt++;
diff -urN u-boot-2016.03/drivers/dma/apbh_dma.c ebf_6ull_uboot/drivers/dma/apbh_dma.c
--- u-boot-2016.03/drivers/dma/apbh_dma.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/dma/apbh_dma.c	2021-04-16 14:42:15.964587367 +0800
@@ -5,7 +5,7 @@
  * on behalf of DENX Software Engineering GmbH
  *
  * Based on code from LTIB:
- * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -126,10 +126,10 @@
 		return 0;
 	}
 
-	pdesc = list_first_entry(&pchan->active, struct mxs_dma_desc, node);
-	if (pdesc == NULL)
+	if (list_empty(&pchan->active))
 		return -EFAULT;
 
+	pdesc = list_first_entry(&pchan->active, struct mxs_dma_desc, node);
 	if (pchan->flags & MXS_DMA_FLAGS_BUSY) {
 		if (!(pdesc->cmd.data & MXS_DMA_DESC_CHAIN))
 			return 0;
@@ -574,6 +574,14 @@
 	struct mxs_apbh_regs *apbh_regs =
 		(struct mxs_apbh_regs *)MXS_APBH_BASE;
 
+#ifdef CONFIG_MX6
+	if (check_module_fused(MX6_MODULE_APBHDMA)) {
+		printf("NAND APBH-DMA@0x%x is fused, disable it\n",
+			MXS_APBH_BASE);
+		return;
+	}
+#endif
+
 	mxs_reset_block(&apbh_regs->hw_apbh_ctrl0_reg);
 
 #ifdef CONFIG_APBH_DMA_BURST8
diff -urN u-boot-2016.03/drivers/gpio/mxc_gpio.c ebf_6ull_uboot/drivers/gpio/mxc_gpio.c
--- u-boot-2016.03/drivers/gpio/mxc_gpio.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/gpio/mxc_gpio.c	2021-04-16 14:42:15.968587389 +0800
@@ -5,6 +5,8 @@
  * Copyright (C) 2011
  * Stefano Babic, DENX Software Engineering, <sbabic@denx.de>
  *
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 #include <common.h>
@@ -14,6 +16,11 @@
 #include <asm/arch/imx-regs.h>
 #include <asm/gpio.h>
 #include <asm/io.h>
+#include <errno.h>
+#ifdef CONFIG_IMX_RDC
+#include <asm/imx-common/rdc-sema.h>
+#include <asm/arch/imx-rdc.h>
+#endif
 
 enum mxc_gpio_direction {
 	MXC_GPIO_DIRECTION_IN,
@@ -58,6 +65,27 @@
 #endif
 };
 
+#ifdef CONFIG_IMX_RDC
+static unsigned int gpio_rdc[] = {
+	RDC_PER_GPIO1,
+	RDC_PER_GPIO2,
+	RDC_PER_GPIO3,
+	RDC_PER_GPIO4,
+	RDC_PER_GPIO5,
+	RDC_PER_GPIO6,
+	RDC_PER_GPIO7,
+};
+
+#define RDC_CHECK(x) imx_rdc_check_permission(gpio_rdc[x], 0)
+#define RDC_SPINLOCK_UP(x) imx_rdc_sema_lock(gpio_rdc[x])
+#define RDC_SPINLOCK_DOWN(x) imx_rdc_sema_unlock(gpio_rdc[x])
+#else
+#define RDC_CHECK(x) 0
+#define RDC_SPINLOCK_UP(x)
+#define RDC_SPINLOCK_DOWN(x)
+#endif
+
+
 static int mxc_gpio_direction(unsigned int gpio,
 	enum mxc_gpio_direction direction)
 {
@@ -68,6 +96,11 @@
 	if (port >= ARRAY_SIZE(gpio_ports))
 		return -1;
 
+	if (RDC_CHECK(port))
+		return -1;
+
+	RDC_SPINLOCK_UP(port);
+
 	gpio &= 0x1f;
 
 	regs = (struct gpio_regs *)gpio_ports[port];
@@ -83,6 +116,8 @@
 	}
 	writel(l, &regs->gpio_dir);
 
+	RDC_SPINLOCK_DOWN(port);
+
 	return 0;
 }
 
@@ -95,6 +130,11 @@
 	if (port >= ARRAY_SIZE(gpio_ports))
 		return -1;
 
+	if (RDC_CHECK(port))
+		return -1;
+
+	RDC_SPINLOCK_UP(port);
+
 	gpio &= 0x1f;
 
 	regs = (struct gpio_regs *)gpio_ports[port];
@@ -106,6 +146,8 @@
 		l &= ~(1 << gpio);
 	writel(l, &regs->gpio_dr);
 
+	RDC_SPINLOCK_DOWN(port);
+
 	return 0;
 }
 
@@ -118,12 +160,19 @@
 	if (port >= ARRAY_SIZE(gpio_ports))
 		return -1;
 
+	if (RDC_CHECK(port))
+		return -1;
+
+	RDC_SPINLOCK_UP(port);
+
 	gpio &= 0x1f;
 
 	regs = (struct gpio_regs *)gpio_ports[port];
 
 	val = (readl(&regs->gpio_psr) >> gpio) & 0x01;
 
+	RDC_SPINLOCK_DOWN(port);
+
 	return val;
 }
 
@@ -132,6 +181,10 @@
 	unsigned int port = GPIO_TO_PORT(gpio);
 	if (port >= ARRAY_SIZE(gpio_ports))
 		return -1;
+
+	if (RDC_CHECK(port))
+		return -1;
+
 	return 0;
 }
 
diff -urN u-boot-2016.03/drivers/i2c/mxc_i2c.c ebf_6ull_uboot/drivers/i2c/mxc_i2c.c
--- u-boot-2016.03/drivers/i2c/mxc_i2c.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/i2c/mxc_i2c.c	2021-04-16 14:42:15.968587389 +0800
@@ -4,6 +4,8 @@
  * (c) 2007 Pengutronix, Sascha Hauer <s.hauer@pengutronix.de>
  * (c) 2011 Marek Vasut <marek.vasut@gmail.com>
  *
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
  * Based on i2c-imx.c from linux kernel:
  *  Copyright (C) 2005 Torsten Koschorrek <koschorrek at synertronixx.de>
  *  Copyright (C) 2005 Matthias Blaschke <blaschke at synertronixx.de>
@@ -24,6 +26,7 @@
 #include <watchdog.h>
 #include <dm.h>
 #include <fdtdec.h>
+#include <asm/arch/sys_proto.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -581,6 +584,14 @@
 		return;
 	}
 
+#ifdef CONFIG_MX6
+	if (mx6_i2c_fused((u32)mxc_i2c_buses[index].base)) {
+		printf("I2C@0x%x is fused, disable it\n",
+			(u32)mxc_i2c_buses[index].base);
+		return;
+	}
+#endif
+
 	/*
 	 * Warning: Be careful to allow the assignment to a static
 	 * variable here. This function could be called while U-Boot is
diff -urN u-boot-2016.03/drivers/input/Makefile ebf_6ull_uboot/drivers/input/Makefile
--- u-boot-2016.03/drivers/input/Makefile	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/input/Makefile	2021-04-16 14:42:15.968587389 +0800
@@ -17,3 +17,4 @@
 endif
 obj-y += input.o
 obj-$(CONFIG_$(SPL_)OF_CONTROL) += key_matrix.o
+obj-$(CONFIG_MXC_KPD) += mxc_keyb.o
diff -urN u-boot-2016.03/drivers/input/mxc_keyb.c ebf_6ull_uboot/drivers/input/mxc_keyb.c
--- u-boot-2016.03/drivers/input/mxc_keyb.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/drivers/input/mxc_keyb.c	2021-04-16 14:42:15.968587389 +0800
@@ -0,0 +1,592 @@
+/*
+ * Copyright (C) 2009-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*!
+ * @file mxc_keyb.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC keypad port.
+ *
+ * The keypad driver is designed as a standard Input driver which interacts
+ * with low level keypad port hardware. Upon opening, the Keypad driver
+ * initializes the keypad port. When the keypad interrupt happens the driver
+ * calles keypad polling timer and scans the keypad matrix for key
+ * press/release. If all key press/release happened it comes out of timer and
+ * waits for key press interrupt. The scancode for key press and release events
+ * are passed to Input subsytem.
+ *
+ * @ingroup keypad
+ */
+
+#include <asm/io.h>
+#include <common.h>
+#include <asm/errno.h>
+#include <linux/types.h>
+#include <asm/imx-common/mxc_key_defs.h>
+#include <malloc.h>
+
+/*
+ *  * Module header file
+ *   */
+#include <mxc_keyb.h>
+
+/*!
+ * Comment KPP_DEBUG to disable debug messages
+ */
+
+#undef	KPP_DEBUG
+
+#ifdef	KPP_DEBUG
+#define	KPP_PRINTF(fmt, args...)	printf(fmt , ##args)
+
+static void mxc_kpp_dump_regs()
+{
+	unsigned short t1, t2, t3;
+
+	t1 = __raw_readw(KPCR);
+	t2 = __raw_readw(KPSR);
+	t3 = __raw_readw(KDDR);
+	/*
+	KPP_PRINTF("KPCR=0x%04x, KPSR=0x%04x, KDDR=0x%04x\n",
+		t1, t2, t3);
+		*/
+}
+#else
+#define KPP_PRINTF(fmt, args...)
+#endif
+
+static u16 mxc_key_mapping[] = CONFIG_MXC_KEYMAPPING;
+
+/*!
+ * This structure holds the keypad private data structure.
+ */
+static struct keypad_priv kpp_dev;
+
+/*! Indicates if the key pad device is enabled. */
+
+/*! This static variable indicates whether a key event is pressed/released. */
+static unsigned short KPress;
+
+/*! cur_rcmap and prev_rcmap array is used to detect key press and release. */
+static unsigned short *cur_rcmap;	/* max 64 bits (8x8 matrix) */
+static unsigned short *prev_rcmap;
+
+/*!
+ * Debounce polling period(10ms) in system ticks.
+ */
+/*static unsigned short KScanRate = (10 * CONFIG_SYS_HZ) / 1000;*/
+
+/*!
+ * These arrays are used to store press and release scancodes.
+ */
+static short **press_scancode;
+static short **release_scancode;
+
+static const unsigned short *mxckpd_keycodes;
+static unsigned short mxckpd_keycodes_size;
+
+/*!
+ * This function is called to scan the keypad matrix to find out the key press
+ * and key release events. Make scancode and break scancode are generated for
+ * key press and key release events.
+ *
+ * The following scanning sequence are done for
+ * keypad row and column scanning,
+ * -# Write 1's to KPDR[15:8], setting column data to 1's
+ * -# Configure columns as totem pole outputs(for quick discharging of keypad
+ * capacitance)
+ * -# Configure columns as open-drain
+ * -# Write a single column to 0, others to 1.
+ * -# Sample row inputs and save data. Multiple key presses can be detected on
+ * a single column.
+ * -# Repeat steps the above steps for remaining columns.
+ * -# Return all columns to 0 in preparation for standby mode.
+ * -# Clear KPKD and KPKR status bit(s) by writing to a 1,
+ *    Set the KPKR synchronizer chain by writing "1" to KRSS register,
+ *    Clear the KPKD synchronizer chain by writing "1" to KDSC register
+ *
+ * @result    Number of key pressed/released.
+ */
+static int mxc_kpp_scan_matrix(void)
+{
+	unsigned short reg_val;
+	int col, row;
+	short scancode = 0;
+	int keycnt = 0;		/* How many keys are still pressed */
+
+	/*
+	 * wmb() linux kernel function which guarantees orderings in write
+	 * operations
+	 */
+	/* wmb(); */
+
+	/* save cur keypad matrix to prev */
+	memcpy(prev_rcmap, cur_rcmap, kpp_dev.kpp_rows * sizeof(prev_rcmap[0]));
+	memset(cur_rcmap, 0, kpp_dev.kpp_rows * sizeof(cur_rcmap[0]));
+
+	/*1. Disable both (depress and release) keypad interrupts.*/
+
+	/* KDIE has been disabled in mxc_kpp_getc before calling scan matrix.
+	  * KRIE is always disabled in this driver.
+	  */
+
+	for (col = 0; col < kpp_dev.kpp_cols; col++) {	/* Col */
+		/* 2. Write 1.s to KPDR[15:8] setting column data to 1.s */
+		reg_val = __raw_readw(KPDR);
+		reg_val |= 0xff00;
+		__raw_writew(reg_val, KPDR);
+
+		/*
+		 * 3. Configure columns as totem pole outputs(for quick
+		 * discharging of keypad capacitance)
+		 */
+		reg_val = __raw_readw(KPCR);
+		reg_val &= 0x00ff;
+		__raw_writew(reg_val, KPCR);
+
+		udelay(2);
+
+#ifdef KPP_DEBUG
+		mxc_kpp_dump_regs();
+#endif
+
+		/*
+		 * 4. Configure columns as open-drain
+		 */
+		reg_val = __raw_readw(KPCR);
+		reg_val |= ((1 << kpp_dev.kpp_cols) - 1) << 8;
+		__raw_writew(reg_val, KPCR);
+
+		/*
+		 * 5. Write a single column to 0, others to 1.
+		 * 6. Sample row inputs and save data. Multiple key presses
+		 * can be detected on a single column.
+		 * 7. Repeat steps 2 - 6 for remaining columns.
+		 */
+
+		/* Col bit starts at 8th bit in KPDR */
+		reg_val = __raw_readw(KPDR);
+		reg_val &= ~(1 << (8 + col));
+		__raw_writew(reg_val, KPDR);
+
+		/* Delay added to avoid propagating the 0 from column to row
+		 * when scanning. */
+
+		udelay(5);
+
+#ifdef KPP_DEBUG
+		mxc_kpp_dump_regs();
+#endif
+
+		/* Read row input */
+		reg_val = __raw_readw(KPDR);
+		for (row = 0; row < kpp_dev.kpp_rows; row++) {	/* sample row */
+			if (TEST_BIT(reg_val, row) == 0) {
+				cur_rcmap[row] = BITSET(cur_rcmap[row], col);
+				keycnt++;
+			}
+		}
+	}
+
+	/*
+	 * 8. Return all columns to 0 in preparation for standby mode.
+	 * 9. Clear KPKD and KPKR status bit(s) by writing to a .1.,
+	 * set the KPKR synchronizer chain by writing "1" to KRSS register,
+	 * clear the KPKD synchronizer chain by writing "1" to KDSC register
+	 */
+	reg_val = 0x00;
+	__raw_writew(reg_val, KPDR);
+	reg_val = __raw_readw(KPDR);
+	reg_val = __raw_readw(KPSR);
+	reg_val |= KBD_STAT_KPKD | KBD_STAT_KPKR | KBD_STAT_KRSS |
+	    KBD_STAT_KDSC;
+	__raw_writew(reg_val, KPSR);
+
+#ifdef KPP_DEBUG
+	mxc_kpp_dump_regs();
+#endif
+
+	/* Check key press status change */
+
+	/*
+	 * prev_rcmap array will contain the previous status of the keypad
+	 * matrix.  cur_rcmap array will contains the present status of the
+	 * keypad matrix. If a bit is set in the array, that (row, col) bit is
+	 * pressed, else it is not pressed.
+	 *
+	 * XORing these two variables will give us the change in bit for
+	 * particular row and column.  If a bit is set in XOR output, then that
+	 * (row, col) has a change of status from the previous state.  From
+	 * the diff variable the key press and key release of row and column
+	 * are found out.
+	 *
+	 * If the key press is determined then scancode for key pressed
+	 * can be generated using the following statement:
+	 *    scancode = ((row * 8) + col);
+	 *
+	 * If the key release is determined then scancode for key release
+	 * can be generated using the following statement:
+	 *    scancode = ((row * 8) + col) + MXC_KEYRELEASE;
+	 */
+	for (row = 0; row < kpp_dev.kpp_rows; row++) {
+		unsigned char diff;
+
+		/*
+		 * Calculate the change in the keypad row status
+		 */
+		diff = prev_rcmap[row] ^ cur_rcmap[row];
+
+		for (col = 0; col < kpp_dev.kpp_cols; col++) {
+			if ((diff >> col) & 0x1) {
+				/* There is a status change on col */
+				if ((prev_rcmap[row] & BITSET(0, col)) == 0) {
+					/*
+					 * Previous state is 0, so now
+					 * a key is pressed
+					 */
+					scancode =
+					    ((row * kpp_dev.kpp_cols) +
+					     col);
+					KPress = 1;
+					kpp_dev.iKeyState = KStateUp;
+
+					KPP_PRINTF("Press   (%d, %d) scan=%d "
+						 "Kpress=%d\n",
+						 row, col, scancode, KPress);
+					press_scancode[row][col] =
+					    (short)scancode;
+				} else {
+					/*
+					 * Previous state is not 0, so
+					 * now a key is released
+					 */
+					scancode =
+					    (row * kpp_dev.kpp_cols) +
+					    col + MXC_KEYRELEASE;
+					KPress = 0;
+					kpp_dev.iKeyState = KStateDown;
+
+					KPP_PRINTF
+					    ("Release (%d, %d) scan=%d Kpress=%d\n",
+					     row, col, scancode, KPress);
+					release_scancode[row][col] =
+					    (short)scancode;
+					keycnt++;
+				}
+			}
+		}
+	}
+
+	return keycnt;
+}
+
+static int mxc_kpp_reset(void)
+{
+	unsigned short reg_val;
+	int i;
+
+	/*
+	* Stop scanning and wait for interrupt.
+	* Enable press interrupt and disable release interrupt.
+	*/
+	__raw_writew(0x00FF, KPDR);
+	reg_val = __raw_readw(KPSR);
+	reg_val |= (KBD_STAT_KPKR | KBD_STAT_KPKD);
+	reg_val |= KBD_STAT_KRSS | KBD_STAT_KDSC;
+	__raw_writew(reg_val, KPSR);
+	reg_val |= KBD_STAT_KDIE;
+	reg_val &= ~KBD_STAT_KRIE;
+	__raw_writew(reg_val, KPSR);
+
+#ifdef KPP_DEBUG
+	mxc_kpp_dump_regs();
+#endif
+
+	/*
+	* No more keys pressed... make sure unwanted key codes are
+	* not given upstairs
+	*/
+	for (i = 0; i < kpp_dev.kpp_rows; i++) {
+		memset(press_scancode[i], -1,
+			sizeof(press_scancode[0][0]) * kpp_dev.kpp_cols);
+		memset(release_scancode[i], -1,
+			sizeof(release_scancode[0][0]) *
+			kpp_dev.kpp_cols);
+	}
+
+	return 0;
+}
+
+int mxc_kpp_getc(struct kpp_key_info **key_info)
+{
+	int col, row;
+	int key_cnt;
+	unsigned short reg_val;
+	short scancode = 0;
+	int index = 0;
+	struct kpp_key_info *keyi;
+
+	reg_val = __raw_readw(KPSR);
+
+	if (reg_val & KBD_STAT_KPKD) {
+		/*
+		* Disable key press(KDIE status bit) interrupt
+		*/
+		reg_val &= ~KBD_STAT_KDIE;
+		__raw_writew(reg_val, KPSR);
+
+#ifdef KPP_DEBUG
+		mxc_kpp_dump_regs();
+#endif
+
+		key_cnt = mxc_kpp_scan_matrix();
+	} else {
+		return 0;
+	}
+
+	if (key_cnt <= 0)
+		return 0;
+
+	*key_info = keyi =
+		(struct kpp_key_info *)malloc
+		(sizeof(struct kpp_key_info) * key_cnt);
+
+	/*
+	* This switch case statement is the
+	* implementation of state machine of debounc
+	* logic for key press/release.
+	* The explaination of state machine is as
+	* follows:
+	*
+	* KStateUp State:
+	* This is in intial state of the state machine
+	* this state it checks for any key presses.
+	* The key press can be checked using the
+	* variable KPress. If KPress is set, then key
+	* press is identified and switches the to
+	* KStateFirstDown state for key press to
+	* debounce.
+	*
+	* KStateFirstDown:
+	* After debounce delay(10ms), if the KPress is
+	* still set then pass scancode generated to
+	* input device and change the state to
+	* KStateDown, else key press debounce is not
+	* satisfied so change the state to KStateUp.
+	*
+	* KStateDown:
+	* In this state it checks for any key release.
+	* If KPress variable is cleared, then key
+	* release is indicated and so, switch the
+	* state to KStateFirstUp else to state
+	* KStateDown.
+	*
+	* KStateFirstUp:
+	* After debounce delay(10ms), if the KPress is
+	* still reset then pass the key release
+	* scancode to input device and change
+	* the state to KStateUp else key release is
+	* not satisfied so change the state to
+	* KStateDown.
+	*/
+
+	for (row = 0; row < kpp_dev.kpp_rows; row++) {
+		for (col = 0; col < kpp_dev.kpp_cols; col++) {
+			if ((press_scancode[row][col] != -1)) {
+				/* Still Down, so add scancode */
+				scancode =
+				    press_scancode[row][col];
+
+				keyi[index].val = mxckpd_keycodes[scancode];
+				keyi[index++].evt = KDepress;
+
+				KPP_PRINTF("KStateFirstDown: scan=%d val=%d\n",
+					scancode, mxckpd_keycodes[scancode]);
+				if (index >= key_cnt)
+					goto key_detect;
+
+				kpp_dev.iKeyState = KStateDown;
+				press_scancode[row][col] = -1;
+			}
+		}
+	}
+
+	for (row = 0; row < kpp_dev.kpp_rows; row++) {
+		for (col = 0; col < kpp_dev.kpp_cols; col++) {
+			if ((release_scancode[row][col] != -1)) {
+				scancode =
+				    release_scancode[row][col];
+				scancode =
+					scancode - MXC_KEYRELEASE;
+
+				keyi[index].val = mxckpd_keycodes[scancode];
+				keyi[index++].evt = KRelease;
+
+				KPP_PRINTF("KStateFirstUp: scan=%d val=%d\n",
+					scancode, mxckpd_keycodes[scancode]);
+				if (index >= key_cnt)
+					goto key_detect;
+
+				kpp_dev.iKeyState = KStateUp;
+				release_scancode[row][col] = -1;
+			}
+		}
+	}
+
+key_detect:
+	mxc_kpp_reset();
+	return key_cnt;
+}
+
+/*!
+ * This function is called to free the allocated memory for local arrays
+ */
+static void mxc_kpp_free_allocated(void)
+{
+	int i;
+
+	if (press_scancode) {
+		for (i = 0; i < kpp_dev.kpp_rows; i++) {
+			if (press_scancode[i])
+				free(press_scancode[i]);
+		}
+		free(press_scancode);
+	}
+
+	if (release_scancode) {
+		for (i = 0; i < kpp_dev.kpp_rows; i++) {
+			if (release_scancode[i])
+				free(release_scancode[i]);
+		}
+		free(release_scancode);
+	}
+
+	if (cur_rcmap)
+		free(cur_rcmap);
+
+	if (prev_rcmap)
+		free(prev_rcmap);
+}
+
+/*!
+ * This function is called during the driver binding process.
+ *
+ * @param   pdev  the device structure used to store device specific
+ *                information that is used by the suspend, resume and remove
+ *                functions.
+ *
+ * @return  The function returns 0 on successful registration. Otherwise returns
+ *          specific error code.
+ */
+int mxc_kpp_init(void)
+{
+	int i;
+	int retval;
+	unsigned int reg_val;
+
+	kpp_dev.kpp_cols = CONFIG_MXC_KPD_COLMAX;
+	kpp_dev.kpp_rows = CONFIG_MXC_KPD_ROWMAX;
+
+	/* clock and IOMUX configuration for keypad */
+	setup_mxc_kpd();
+
+	/* Configure keypad */
+
+	/* Enable number of rows in keypad (KPCR[7:0])
+	 * Configure keypad columns as open-drain (KPCR[15:8])
+	 *
+	 * Configure the rows/cols in KPP
+	 * LSB nibble in KPP is for 8 rows
+	 * MSB nibble in KPP is for 8 cols
+	 */
+	reg_val = __raw_readw(KPCR);
+	reg_val |= (1  << kpp_dev.kpp_rows) - 1;	/* LSB */
+	reg_val |= ((1 << kpp_dev.kpp_cols) - 1) << 8;	/* MSB */
+	__raw_writew(reg_val, KPCR);
+
+	/* Write 0's to KPDR[15:8] */
+	reg_val = __raw_readw(KPDR);
+	reg_val &= 0x00ff;
+	__raw_writew(reg_val, KPDR);
+
+	/* Configure columns as output,
+	 * rows as input (KDDR[15:0]) */
+	reg_val = __raw_readw(KDDR);
+	reg_val |= 0xff00;
+	reg_val &= 0xff00;
+	__raw_writew(reg_val, KDDR);
+
+	/* Clear the KPKD Status Flag
+	 * and Synchronizer chain. */
+	reg_val = __raw_readw(KPSR);
+	reg_val &= ~(KBD_STAT_KPKR | KBD_STAT_KPKD);
+	reg_val |= KBD_STAT_KPKD;
+	reg_val |= KBD_STAT_KRSS | KBD_STAT_KDSC;
+	__raw_writew(reg_val, KPSR);
+	/* Set the KDIE control bit, and clear the KRIE
+	 * control bit (avoid false release events). */
+	reg_val |= KBD_STAT_KDIE;
+	reg_val &= ~KBD_STAT_KRIE;
+	__raw_writew(reg_val, KPSR);
+
+#ifdef KPP_DEBUG
+	mxc_kpp_dump_regs();
+#endif
+
+	mxckpd_keycodes = mxc_key_mapping;
+	mxckpd_keycodes_size = kpp_dev.kpp_cols * kpp_dev.kpp_rows;
+
+	if ((mxckpd_keycodes == (void *)0)
+	    || (mxckpd_keycodes_size == 0)) {
+		retval = -ENODEV;
+		goto err;
+	}
+
+	/* allocate required memory */
+	press_scancode   = (short **)malloc(kpp_dev.kpp_rows * sizeof(press_scancode[0]));
+	release_scancode = (short **)malloc(kpp_dev.kpp_rows * sizeof(release_scancode[0]));
+
+	if (!press_scancode || !release_scancode) {
+		retval = -ENOMEM;
+		goto err;
+	}
+
+	for (i = 0; i < kpp_dev.kpp_rows; i++) {
+		press_scancode[i] = (short *)malloc(kpp_dev.kpp_cols
+					    * sizeof(press_scancode[0][0]));
+		release_scancode[i] =
+		    (short *)malloc(kpp_dev.kpp_cols * sizeof(release_scancode[0][0]));
+
+		if (!press_scancode[i] || !release_scancode[i]) {
+			retval = -ENOMEM;
+			goto err;
+		}
+	}
+
+	cur_rcmap =
+	    (unsigned short *)malloc(kpp_dev.kpp_rows * sizeof(cur_rcmap[0]));
+	prev_rcmap =
+	    (unsigned short *)malloc(kpp_dev.kpp_rows * sizeof(prev_rcmap[0]));
+
+	if (!cur_rcmap || !prev_rcmap) {
+		retval = -ENOMEM;
+		goto err;
+	}
+
+	for (i = 0; i < kpp_dev.kpp_rows; i++) {
+		memset(press_scancode[i], -1,
+		       sizeof(press_scancode[0][0]) * kpp_dev.kpp_cols);
+		memset(release_scancode[i], -1,
+		       sizeof(release_scancode[0][0]) * kpp_dev.kpp_cols);
+	}
+	memset(cur_rcmap, 0, kpp_dev.kpp_rows * sizeof(cur_rcmap[0]));
+	memset(prev_rcmap, 0, kpp_dev.kpp_rows * sizeof(prev_rcmap[0]));
+
+	return 0;
+
+err:
+	mxc_kpp_free_allocated();
+	return retval;
+}
diff -urN u-boot-2016.03/drivers/misc/mxc_ocotp.c ebf_6ull_uboot/drivers/misc/mxc_ocotp.c
--- u-boot-2016.03/drivers/misc/mxc_ocotp.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/misc/mxc_ocotp.c	2021-04-16 14:42:15.972587409 +0800
@@ -7,7 +7,7 @@
  * which is based on Freescale's
  * http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/tree/drivers/misc/imx_otp.c?h=imx_v2009.08_1.1.0&id=9aa74e6,
  * which is:
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -18,6 +18,7 @@
 #include <asm/io.h>
 #include <asm/arch/clock.h>
 #include <asm/arch/imx-regs.h>
+#include <asm/imx-common/sys_proto.h>
 
 #define BO_CTRL_WR_UNLOCK		16
 #define BM_CTRL_WR_UNLOCK		0xffff0000
@@ -61,6 +62,8 @@
 #define FUSE_BANK_SIZE	0x80
 #ifdef CONFIG_MX6SL
 #define FUSE_BANKS	8
+#elif defined(CONFIG_MX6ULL) || defined(CONFIG_MX6SLL)
+#define FUSE_BANKS	9
 #else
 #define FUSE_BANKS	16
 #endif
@@ -72,11 +75,11 @@
 #endif
 
 #if defined(CONFIG_MX6)
-#include <asm/arch/sys_proto.h>
 
 /*
  * There is a hole in shadow registers address map of size 0x100
- * between bank 5 and bank 6 on iMX6QP, iMX6DQ, iMX6SDL, iMX6SX and iMX6UL.
+ * between bank 5 and bank 6 on iMX6QP, iMX6DQ, iMX6SDL, iMX6SX, iMX6UL,
+ * iMX6ULL and iMX6SLL.
  * Bank 5 ends at 0x6F0 and Bank 6 starts at 0x800. When reading the fuses,
  * we should account for this hole in address space.
  *
@@ -97,7 +100,11 @@
 
 	if (is_cpu_type(MXC_CPU_MX6SL)) {
 		phy_index = index;
-	} else if (is_cpu_type(MXC_CPU_MX6UL)) {
+	} else if (is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL) ||
+			is_cpu_type(MXC_CPU_MX6SLL)) {
+		if ((is_cpu_type(MXC_CPU_MX6ULL) || is_cpu_type(MXC_CPU_MX6SLL)) && index == 8)
+			index = 7;
+
 		if (index >= 6)
 			phy_index = fuse_bank_physical(5) + (index - 6) + 3;
 		else
@@ -112,11 +119,27 @@
 	}
 	return phy_index;
 }
+
+u32 fuse_word_physical(u32 bank, u32 word_index)
+{
+	if (is_cpu_type(MXC_CPU_MX6ULL) || is_cpu_type(MXC_CPU_MX6SLL)) {
+		if (bank == 8)
+			word_index = word_index + 4;
+	}
+
+	return word_index;
+}
 #else
 u32 fuse_bank_physical(int index)
 {
 	return index;
 }
+
+u32 fuse_word_physical(u32 bank, u32 word_index)
+{
+	return word_index;
+}
+
 #endif
 
 static void wait_busy(struct ocotp_regs *regs, unsigned int delay_us)
@@ -142,6 +165,14 @@
 		return -EINVAL;
 	}
 
+	if (is_cpu_type(MXC_CPU_MX6ULL) || is_cpu_type(MXC_CPU_MX6SLL)) {
+		if ((bank == 7 || bank == 8) &&
+		    word >= ARRAY_SIZE((*regs)->bank[0].fuse_regs) >> 3) {
+			printf("mxc_ocotp %s(): Invalid argument\n", caller);
+			return -EINVAL;
+		}
+	}
+
 	enable_ocotp_clk(1);
 
 	wait_busy(*regs, 1);
@@ -176,14 +207,16 @@
 	struct ocotp_regs *regs;
 	int ret;
 	u32 phy_bank;
+	u32 phy_word;
 
 	ret = prepare_read(&regs, bank, word, val, __func__);
 	if (ret)
 		return ret;
 
 	phy_bank = fuse_bank_physical(bank);
+	phy_word = fuse_word_physical(bank, word);
 
-	*val = readl(&regs->bank[phy_bank].fuse_regs[word << 2]);
+	*val = readl(&regs->bank[phy_bank].fuse_regs[phy_word << 2]);
 
 	return finish_access(regs, __func__);
 }
@@ -237,7 +270,13 @@
 #ifdef CONFIG_MX7
 	u32 addr = bank;
 #else
-	u32 addr = bank << 3 | word;
+	u32 addr;
+	/* Bank 7 and Bank 8 only supports 4 words each */
+	if ((is_cpu_type(MXC_CPU_MX6ULL) || is_cpu_type(MXC_CPU_MX6SLL)) && (bank > 7)) {
+		bank = bank - 1;
+		word += 4;
+	}
+	addr = bank << 3 | word;
 #endif
 
 	set_timing(regs);
@@ -325,14 +364,16 @@
 	struct ocotp_regs *regs;
 	int ret;
 	u32 phy_bank;
+	u32 phy_word;
 
 	ret = prepare_write(&regs, bank, word, __func__);
 	if (ret)
 		return ret;
 
 	phy_bank = fuse_bank_physical(bank);
+	phy_word = fuse_word_physical(bank, word);
 
-	writel(val, &regs->bank[phy_bank].fuse_regs[word << 2]);
+	writel(val, &regs->bank[phy_bank].fuse_regs[phy_word << 2]);
 
 	return finish_access(regs, __func__);
 }
diff -urN u-boot-2016.03/drivers/mmc/fsl_esdhc.c ebf_6ull_uboot/drivers/mmc/fsl_esdhc.c
--- u-boot-2016.03/drivers/mmc/fsl_esdhc.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/mmc/fsl_esdhc.c	2021-04-16 14:42:15.972587409 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007, 2010-2011 Freescale Semiconductor, Inc
+ * Copyright 2007, 2010-2016 Freescale Semiconductor, Inc
  * Andy Fleming
  *
  * Based vaguely on the pxa mmc code:
@@ -20,6 +20,7 @@
 #include <fsl_esdhc.h>
 #include <fdt_support.h>
 #include <asm/io.h>
+#include <asm/arch/sys_proto.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -54,22 +55,30 @@
 	uint    fevt;		/* Force event register */
 	uint    admaes;		/* ADMA error status register */
 	uint    adsaddr;	/* ADMA system address register */
-	char    reserved2[100];	/* reserved */
-	uint    vendorspec;	/* Vendor Specific register */
-	char    reserved3[56];	/* reserved */
+	char    reserved2[4];
+	uint    dllctrl;
+	uint    dllstat;
+	uint    clktunectrlstatus;
+	char    reserved3[84];
+	uint    vendorspec;
+	uint    mmcboot;
+	uint    vendorspec2;
+	char	reserved4[48];
 	uint    hostver;	/* Host controller version register */
-	char    reserved4[4];	/* reserved */
-	uint    dmaerraddr;	/* DMA error address register */
+#ifndef ARCH_MXC
 	char    reserved5[4];	/* reserved */
-	uint    dmaerrattr;	/* DMA error attribute register */
+	uint    dmaerraddr;	/* DMA error address register */
 	char    reserved6[4];	/* reserved */
+	uint    dmaerrattr;	/* DMA error attribute register */
+	char    reserved7[4];	/* reserved */
 	uint    hostcapblt2;	/* Host controller capabilities register 2 */
-	char    reserved7[8];	/* reserved */
+	char    reserved8[8];	/* reserved */
 	uint    tcr;		/* Tuning control register */
-	char    reserved8[28];	/* reserved */
+	char    reserved9[28];	/* reserved */
 	uint    sddirctl;	/* SD direction control register */
-	char    reserved9[712];	/* reserved */
+	char    reserved10[712];/* reserved */
 	uint    scr;		/* eSDHC control register */
+#endif
 };
 
 /* Return the XFERTYP flags for a given command and data packet */
@@ -213,9 +222,12 @@
 #endif
 		if (wml_value > WML_WR_WML_MAX)
 			wml_value = WML_WR_WML_MAX_VAL;
-		if ((esdhc_read32(&regs->prsstat) & PRSSTAT_WPSPL) == 0) {
-			printf("\nThe SD card is locked. Can not write to a locked card.\n\n");
-			return TIMEOUT;
+
+		if (cfg->wp_enable) {
+			if ((esdhc_read32(&regs->prsstat) & PRSSTAT_WPSPL) == 0) {
+				printf("\nThe SD card is locked. Can not write to a locked card.\n\n");
+				return TIMEOUT;
+			}
 		}
 
 		esdhc_clrsetbits32(&regs->wml, WML_WR_WML_MASK,
@@ -507,7 +519,7 @@
 	clk = (pre_div << 8) | (div << 4);
 
 #ifdef CONFIG_FSL_USDHC
-	esdhc_setbits32(&regs->sysctl, SYSCTL_RSTA);
+	esdhc_clrbits32(&regs->vendorspec, VENDORSPEC_CKEN);
 #else
 	esdhc_clrbits32(&regs->sysctl, SYSCTL_CKEN);
 #endif
@@ -517,7 +529,7 @@
 	udelay(10000);
 
 #ifdef CONFIG_FSL_USDHC
-	esdhc_clrbits32(&regs->sysctl, SYSCTL_RSTA);
+	esdhc_setbits32(&regs->vendorspec, VENDORSPEC_PEREN | VENDORSPEC_CKEN);
 #else
 	esdhc_setbits32(&regs->sysctl, SYSCTL_PEREN | SYSCTL_CKEN);
 #endif
@@ -591,6 +603,23 @@
 	while ((esdhc_read32(&regs->sysctl) & SYSCTL_RSTA) && --timeout)
 		udelay(1000);
 
+#if defined(CONFIG_FSL_USDHC)
+	/* RSTA doesn't reset MMC_BOOT register, so manually reset it */
+	esdhc_write32(&regs->mmcboot, 0x0);
+	/* Reset MIX_CTRL and CLK_TUNE_CTRL_STATUS regs to 0 */
+	esdhc_write32(&regs->mixctrl, 0x0);
+	esdhc_write32(&regs->clktunectrlstatus, 0x0);
+
+	/* Put VEND_SPEC to default value */
+	if (cfg->vs18_enable)
+		esdhc_write32(&regs->vendorspec, (VENDORSPEC_INIT | ESDHC_VENDORSPEC_VSELECT));
+	else
+		esdhc_write32(&regs->vendorspec, VENDORSPEC_INIT);
+
+	/* Disable DLL_CTRL delay line */
+	esdhc_write32(&regs->dllctrl, 0x0);
+#endif
+
 #ifndef ARCH_MXC
 	/* Enable cache snooping */
 	esdhc_write32(&regs->scr, 0x00000040);
@@ -598,6 +627,8 @@
 
 #ifndef CONFIG_FSL_USDHC
 	esdhc_setbits32(&regs->sysctl, SYSCTL_HCKEN | SYSCTL_IPGEN);
+#else
+	esdhc_setbits32(&regs->vendorspec, VENDORSPEC_HCKEN | VENDORSPEC_IPGEN);
 #endif
 
 	/* Set the initial clock speed */
@@ -612,10 +643,6 @@
 	/* Set timout to the maximum value */
 	esdhc_clrsetbits32(&regs->sysctl, SYSCTL_TIMEOUT_MASK, 14 << 16);
 
-#ifdef CONFIG_SYS_FSL_ESDHC_FORCE_VSELECT
-	esdhc_setbits32(&regs->vendorspec, ESDHC_VENDORSPEC_VSELECT);
-#endif
-
 	return 0;
 }
 
@@ -667,13 +694,25 @@
 
 	regs = (struct fsl_esdhc *)cfg->esdhc_base;
 
+#ifdef CONFIG_MX6
+	if (mx6_esdhc_fused(cfg->esdhc_base)) {
+		printf("ESDHC@0x%x is fused, disable it\n", cfg->esdhc_base);
+		return -2;
+	}
+#endif
+
 	/* First reset the eSDHC controller */
 	esdhc_reset(regs);
 
 #ifndef CONFIG_FSL_USDHC
 	esdhc_setbits32(&regs->sysctl, SYSCTL_PEREN | SYSCTL_HCKEN
 				| SYSCTL_IPGEN | SYSCTL_CKEN);
+#else
+	esdhc_setbits32(&regs->vendorspec, VENDORSPEC_PEREN | VENDORSPEC_HCKEN
+				| VENDORSPEC_IPGEN | VENDORSPEC_CKEN);
 #endif
+	if (cfg->vs18_enable)
+                esdhc_setbits32(&regs->vendorspec, ESDHC_VENDORSPEC_VSELECT);
 
 	writel(SDHCI_IRQ_EN_BITS, &regs->irqstaten);
 	memset(&cfg->cfg, 0, sizeof(cfg->cfg));
diff -urN u-boot-2016.03/drivers/mmc/mmc.c ebf_6ull_uboot/drivers/mmc/mmc.c
--- u-boot-2016.03/drivers/mmc/mmc.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/mmc/mmc.c	2021-04-16 14:42:15.972587409 +0800
@@ -24,6 +24,14 @@
 static struct list_head mmc_devices;
 static int cur_dev_num = -1;
 
+static const unsigned int sd_au_size[] = {
+	0,		SZ_16K / 512,		SZ_32K / 512,
+	SZ_64K / 512,	SZ_128K / 512,		SZ_256K / 512,
+	SZ_512K / 512,	SZ_1M / 512,		SZ_2M / 512,
+	SZ_4M / 512,	SZ_8M / 512,		(SZ_8M + SZ_4M) / 512,
+	SZ_16M / 512,	(SZ_16M + SZ_8M) / 512,	SZ_32M / 512,	SZ_64M / 512,
+};
+
 __weak int board_mmc_getwp(struct mmc *mmc)
 {
 	return -1;
@@ -967,6 +975,62 @@
 	return 0;
 }
 
+static int sd_read_ssr(struct mmc *mmc)
+{
+	int err, i;
+	struct mmc_cmd cmd;
+	ALLOC_CACHE_ALIGN_BUFFER(uint, ssr, 16);
+	struct mmc_data data;
+	int timeout = 3;
+	unsigned int au, eo, et, es;
+
+	cmd.cmdidx = MMC_CMD_APP_CMD;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = mmc->rca << 16;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		return err;
+
+	cmd.cmdidx = SD_CMD_APP_SD_STATUS;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = 0;
+
+retry_ssr:
+	data.dest = (char *)ssr;
+	data.blocksize = 64;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+	if (err) {
+		if (timeout--)
+			goto retry_ssr;
+
+		return err;
+	}
+
+	for (i = 0; i < 16; i++)
+		ssr[i] = be32_to_cpu(ssr[i]);
+
+	au = (ssr[2] >> 12) & 0xF;
+	if ((au <= 9) || (mmc->version == SD_VERSION_3)) {
+		mmc->ssr.au = sd_au_size[au];
+		es = (ssr[3] >> 24) & 0xFF;
+		es |= (ssr[2] & 0xFF) << 8;
+		et = (ssr[3] >> 18) & 0x3F;
+		if (es && et) {
+			eo = (ssr[3] >> 16) & 0x3;
+			mmc->ssr.erase_timeout = (et * 1000) / es;
+			mmc->ssr.erase_offset = eo * 1000;
+		}
+	} else {
+		debug("Invalid Allocation Unit Size.\n");
+	}
+
+	return 0;
+}
+
 /* frequency bases */
 /* divided by 10 to be nice to platforms without floating point */
 static const int fbase[] = {
@@ -1366,6 +1430,10 @@
 			mmc_set_bus_width(mmc, 4);
 		}
 
+		err = sd_read_ssr(mmc);
+		if (err)
+			return err;
+
 		if (mmc->card_caps & MMC_MODE_HS)
 			mmc->tran_speed = 50000000;
 		else
diff -urN u-boot-2016.03/drivers/mmc/mmc_write.c ebf_6ull_uboot/drivers/mmc/mmc_write.c
--- u-boot-2016.03/drivers/mmc/mmc_write.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/mmc/mmc_write.c	2021-04-16 14:42:15.972587409 +0800
@@ -98,8 +98,13 @@
 		       & ~(mmc->erase_grp_size - 1)) - 1);
 
 	while (blk < blkcnt) {
-		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
-			mmc->erase_grp_size : (blkcnt - blk);
+		if (IS_SD(mmc) && mmc->ssr.au) {
+			blk_r = ((blkcnt - blk) > mmc->ssr.au) ?
+				mmc->ssr.au : (blkcnt - blk);
+		} else {
+			blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
+				mmc->erase_grp_size : (blkcnt - blk);
+		}
 		err = mmc_erase_t(mmc, start + blk, blk_r);
 		if (err)
 			break;
diff -urN u-boot-2016.03/drivers/mtd/nand/mxs_nand.c ebf_6ull_uboot/drivers/mtd/nand/mxs_nand.c
--- u-boot-2016.03/drivers/mtd/nand/mxs_nand.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/mtd/nand/mxs_nand.c	2021-04-16 14:42:15.976587431 +0800
@@ -7,7 +7,7 @@
  * Based on code from LTIB:
  * Freescale GPMI NFC NAND Flash Driver
  *
- * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc.
  * Copyright (C) 2008 Embedded Alley Solutions, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
@@ -41,6 +41,11 @@
 
 #define	MXS_NAND_BCH_TIMEOUT			10000
 
+int bbm_chunk;
+int ecc_strength;
+bool large_oob_flag;
+bool ecc_for_meta;
+
 struct mxs_nand_info {
 	int		cur_chip;
 
@@ -132,7 +137,8 @@
 
 static uint32_t mxs_nand_ecc_chunk_cnt(uint32_t page_data_size)
 {
-	return page_data_size / chunk_data_size;
+	int tmp = page_data_size / chunk_data_size;
+	return ecc_for_meta ? tmp + 1 : tmp;
 }
 
 static uint32_t mxs_nand_ecc_size_in_bits(uint32_t ecc_strength)
@@ -145,10 +151,50 @@
 	return (MXS_NAND_METADATA_SIZE + 0x3) & ~0x3;
 }
 
-static inline uint32_t mxs_nand_get_ecc_strength(uint32_t page_data_size,
-						uint32_t page_oob_size)
+/*
+ * For some large oob NAND chip( the oob larger than data chunk), combined meta
+ * with chunk0 style bch layout might override the bbm with ecc data. The
+ * function checked if bbm can be in the data chunk. If it is true, chunk_num
+ * indicate the chunk number that bbm located.
+ *
+ */
+static bool mxs_nand_bbm_in_data_chunk(struct mtd_info *mtd, int gf_len,
+		int *chunk_num)
 {
-	int ecc_strength;
+	int i, j;
+	int meta = MXS_NAND_METADATA_SIZE;
+
+	i = (mtd->writesize * 8 - meta * 8) /
+		(gf_len * ecc_strength +
+		chunk_data_size * 8);
+
+	j = (mtd->writesize * 8 - meta * 8) %
+		(gf_len * ecc_strength +
+		chunk_data_size * 8);
+
+	if (j < chunk_data_size * 8) {
+		*chunk_num = i+1;
+		return true;
+       }
+
+	return false;
+}
+
+/*
+ * the work flow about how to set the ecc layout
+ *
+ * 1. if ecc_strength_ds>max_soc_ecc, quit
+ * 2. if ecc_strength_ds>0 and ecc_stride_ds>0,
+ *         if ecc_stride_ds > oob, go to large_oob branch
+ *         else go to normal branch
+ * 3. if either ecc_stride_ds<=0 or ecc_stride_ds<=0, quit
+ *
+ */
+static int mxs_nand_get_ecc_strength(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	uint32_t page_oob_size = mtd->oobsize;
+	int meta = MXS_NAND_METADATA_SIZE;
 	int max_ecc_strength_supported;
 
 	/* Refer to Chapter 17 for i.MX6DQ, Chapter 18 for i.MX6SX */
@@ -157,20 +203,61 @@
 	else
 		max_ecc_strength_supported = 40;
 
-	/*
-	 * Determine the ECC layout with the formula:
-	 *	ECC bits per chunk = (total page spare data bits) /
-	 *		(bits per ECC level) / (chunks per page)
-	 * where:
-	 *	total page spare data bits =
-	 *		(page oob size - meta data size) * (bits per byte)
-	 */
-	ecc_strength = ((page_oob_size - MXS_NAND_METADATA_SIZE) * 8)
-			/ (galois_field *
-			   mxs_nand_ecc_chunk_cnt(page_data_size));
+	if (chip->ecc_strength_ds > max_ecc_strength_supported) {
+		printf("cannot support the NAND, ecc too weak\n");
+		return -EINVAL;
+	}
 
-	return min(round_down(ecc_strength, 2), max_ecc_strength_supported);
-}
+	if (!(chip->ecc_strength_ds > 0 && chip->ecc_step_ds > 0) &&
+			!(page_oob_size > 1024)) {
+		printf("cannot support the NAND, missing necessary info\n");
+		return -EINVAL;
+	}
+
+	/* set some parameters according to NAND chip parameters */
+	chunk_data_size = chip->ecc_step_ds;
+	if (1024 == chunk_data_size)
+		galois_field = 14;
+	if (chunk_data_size < page_oob_size)
+		large_oob_flag = true;
+
+	if (large_oob_flag) {
+		/* start from the minimum ecc NAND chips required */
+		ecc_strength = chip->ecc_strength_ds;
+		while (!(ecc_strength > max_ecc_strength_supported)) {
+			if (mxs_nand_bbm_in_data_chunk(mtd,
+						galois_field,
+						&bbm_chunk))
+				break;
+			ecc_strength += 2;
+		}
+		/*
+		 * if all supported ecc cannot satisfy the bbm
+		 * requirement, change * the ecc layout to meta
+		 * with ecc type.
+		 *
+		 */
+		if (ecc_strength > max_ecc_strength_supported) {
+			ecc_strength = chip->ecc_strength_ds;
+			ecc_for_meta = true;
+			/* calculate in which chunk bbm located */
+			bbm_chunk = (mtd->writesize * 8 - meta * 8 -
+				galois_field * ecc_strength) /
+				(galois_field * ecc_strength +
+				chunk_data_size * 8) + 1;
+		}
+	} else {
+		ecc_strength = chip->ecc_strength_ds;
+		ecc_strength += ecc_strength & 1;
+#if defined(CONFIG_NAND_MXS_BCH_LEGACY_GEO)
+		ecc_strength = ((page_oob_size - MXS_NAND_METADATA_SIZE) * 8)
+			/(galois_field * mxs_nand_ecc_chunk_cnt(mtd->writesize));
+		ecc_strength += ecc_strength & 1;
+		ecc_strength = min(ecc_strength, MXS_NAND_MAX_ECC_STRENGTH);
+#endif
+	}
+	return 0;
+};
 
 static inline uint32_t mxs_nand_get_mark_offset(uint32_t page_data_size,
 						uint32_t ecc_strength)
@@ -191,8 +278,13 @@
 	/* Compute the bit offset of the block mark within the physical page. */
 	block_mark_bit_offset = page_data_size * 8;
 
-	/* Subtract the metadata bits. */
-	block_mark_bit_offset -= MXS_NAND_METADATA_SIZE * 8;
+	if (ecc_for_meta)
+		/* Subtract the metadata bits and ecc bits. */
+		block_mark_bit_offset -= MXS_NAND_METADATA_SIZE * 8
+					+ chunk_ecc_size_in_bits;
+	else
+		/* Subtract the metadata bits. */
+		block_mark_bit_offset -= MXS_NAND_METADATA_SIZE * 8;
 
 	/*
 	 * Compute the chunk number (starting at zero) in which the block mark
@@ -223,15 +315,11 @@
 
 static uint32_t mxs_nand_mark_byte_offset(struct mtd_info *mtd)
 {
-	uint32_t ecc_strength;
-	ecc_strength = mxs_nand_get_ecc_strength(mtd->writesize, mtd->oobsize);
 	return mxs_nand_get_mark_offset(mtd->writesize, ecc_strength) >> 3;
 }
 
 static uint32_t mxs_nand_mark_bit_offset(struct mtd_info *mtd)
 {
-	uint32_t ecc_strength;
-	ecc_strength = mxs_nand_get_ecc_strength(mtd->writesize, mtd->oobsize);
 	return mxs_nand_get_mark_offset(mtd->writesize, ecc_strength) & 0x7;
 }
 
@@ -552,6 +640,45 @@
 	return buf;
 }
 
+static bool mxs_nand_erased_page(struct mtd_info *mtd, struct nand_chip *nand,
+				 uint8_t *buf, int chunk, int page)
+{
+	int gf_len = galois_field;
+	unsigned int flip_bits = 0, flip_bits_noecc = 0;
+	unsigned int threshold;
+	unsigned int ecc_chunkn_size = MXS_NAND_CHUNK_DATA_CHUNK_SIZE;
+	unsigned int base = ecc_chunkn_size * chunk;
+	uint32_t *dma_buf = (uint32_t *)buf;
+	int i;
+
+	threshold = gf_len / 2;
+	if (threshold > ecc_strength)
+		threshold = ecc_strength;
+
+	for (i = 0; i < ecc_chunkn_size; i++) {
+		flip_bits += hweight8(~buf[base + i]);
+		if (flip_bits > threshold)
+			return false;
+	}
+
+	nand->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+	nand->read_buf(mtd, buf, mtd->writesize);
+
+	for (i = 0; i < mtd->writesize / 4; i++) {
+		flip_bits_noecc += hweight32(~dma_buf[i]);
+		if (flip_bits_noecc > threshold)
+			return false;
+	}
+
+	mtd->ecc_stats.corrected += flip_bits;
+
+	memset(buf, 0xff, mtd->writesize);
+
+	printf("The page(%d) is an erased page(%d,%d,%d,%d).\n", page, chunk, threshold, flip_bits, flip_bits_noecc);
+
+	return true;
+}
+
 /*
  * Read a page from NAND.
  */
@@ -561,10 +688,12 @@
 {
 	struct mxs_nand_info *nand_info = nand->priv;
 	struct mxs_dma_desc *d;
+	struct mxs_bch_regs *bch_regs = (struct mxs_bch_regs *)MXS_BCH_BASE;
 	uint32_t channel = MXS_DMA_CHANNEL_AHB_APBH_GPMI0 + nand_info->cur_chip;
 	uint32_t corrected = 0, failed = 0;
 	uint8_t	*status;
 	int i, ret;
+	int flag = 0;
 
 	/* Compile the DMA descriptor - wait for ready. */
 	d = mxs_nand_get_dma_desc(nand_info);
@@ -654,6 +783,8 @@
 		goto rtn;
 	}
 
+	mxs_nand_return_dma_descs(nand_info);
+
 	/* Invalidate caches */
 	mxs_nand_inval_data_buf(nand_info);
 
@@ -666,10 +797,18 @@
 		if (status[i] == 0x00)
 			continue;
 
-		if (status[i] == 0xff)
+		if (status[i] == 0xff) {
+			if (is_mx6dqp() || is_soc_type(MXC_SOC_MX7) ||
+			    is_cpu_type(MXC_CPU_MX6UL))
+				if (readl(&bch_regs->hw_bch_debug1))
+					flag = 1;
 			continue;
+		}
 
 		if (status[i] == 0xfe) {
+			if (mxs_nand_erased_page(mtd, nand,
+						 nand_info->data_buf, i, page))
+				break;
 			failed++;
 			continue;
 		}
@@ -696,6 +835,9 @@
 
 	memcpy(buf, nand_info->data_buf, mtd->writesize);
 
+	if (flag)
+		memset(buf, 0xff, mtd->writesize);
+
 rtn:
 	mxs_nand_return_dma_descs(nand_info);
 
@@ -987,15 +1129,8 @@
 	struct mxs_bch_regs *bch_regs = (struct mxs_bch_regs *)MXS_BCH_BASE;
 	uint32_t tmp;
 
-	if (mtd->oobsize > MXS_NAND_CHUNK_DATA_CHUNK_SIZE) {
-		galois_field = 14;
-		chunk_data_size = MXS_NAND_CHUNK_DATA_CHUNK_SIZE * 2;
-	}
-
-	if (mtd->oobsize > chunk_data_size) {
-		printf("Not support the NAND chips whose oob size is larger then %d bytes!\n", chunk_data_size);
-		return -EINVAL;
-	}
+	/* calculate ecc_strength, bbm_chunk, eec_for meta, if necessary */
+	mxs_nand_get_ecc_strength(mtd);
 
 	/* Configure BCH and set NFC geometry */
 	mxs_reset_block(&bch_regs->hw_bch_ctrl_reg);
@@ -1004,22 +1139,33 @@
 	tmp = (mxs_nand_ecc_chunk_cnt(mtd->writesize) - 1)
 		<< BCH_FLASHLAYOUT0_NBLOCKS_OFFSET;
 	tmp |= MXS_NAND_METADATA_SIZE << BCH_FLASHLAYOUT0_META_SIZE_OFFSET;
-	tmp |= (mxs_nand_get_ecc_strength(mtd->writesize, mtd->oobsize) >> 1)
+	tmp |= (ecc_strength >> 1)
 		<< BCH_FLASHLAYOUT0_ECC0_OFFSET;
-	tmp |= chunk_data_size >> MXS_NAND_CHUNK_DATA_CHUNK_SIZE_SHIFT;
-	tmp |= (14 == galois_field ? 1 : 0) <<
-		BCH_FLASHLAYOUT0_GF13_0_GF14_1_OFFSET;
+	if (!ecc_for_meta)
+		tmp |= chunk_data_size
+			>> MXS_NAND_CHUNK_DATA_CHUNK_SIZE_SHIFT;
+	else
+		/* set data0 size as 0 */
+		tmp &= ~BCH_FLASHLAYOUT0_DATA0_SIZE_MASK;
+	tmp |= (14 == galois_field ? 1 : 0)
+		<< BCH_FLASHLAYOUT0_GF13_0_GF14_1_OFFSET;
 	writel(tmp, &bch_regs->hw_bch_flash0layout0);
 
 	tmp = (mtd->writesize + mtd->oobsize)
 		<< BCH_FLASHLAYOUT1_PAGE_SIZE_OFFSET;
-	tmp |= (mxs_nand_get_ecc_strength(mtd->writesize, mtd->oobsize) >> 1)
+	tmp |= (ecc_strength >> 1)
 		<< BCH_FLASHLAYOUT1_ECCN_OFFSET;
 	tmp |= chunk_data_size >> MXS_NAND_CHUNK_DATA_CHUNK_SIZE_SHIFT;
 	tmp |= (14 == galois_field ? 1 : 0) <<
 		BCH_FLASHLAYOUT1_GF13_0_GF14_1_OFFSET;
 	writel(tmp, &bch_regs->hw_bch_flash0layout1);
 
+	/* Set erase threshold to ecc strength for mx6ul, mx6qp and mx7 */
+	if (is_mx6dqp() || is_soc_type(MXC_SOC_MX7) ||
+	    is_cpu_type(MXC_CPU_MX6UL))
+		writel(BCH_MODE_ERASE_THRESHOLD(ecc_strength),
+		       &bch_regs->hw_bch_mode);
+
 	/* Set *all* chip selects to use layout 0 */
 	writel(0, &bch_regs->hw_bch_layoutselect);
 
@@ -1092,6 +1238,13 @@
 		(struct mxs_bch_regs *)MXS_BCH_BASE;
 	int i = 0, j, ret = 0;
 
+#ifdef CONFIG_MX6
+	if (check_module_fused(MX6_MODULE_GPMI)) {
+		printf("NAND GPMI@0x%x is fused, disable it\n", MXS_GPMI_BASE);
+		return -EPERM;
+	}
+#endif
+
 	info->desc = malloc(sizeof(struct mxs_dma_desc *) *
 				MXS_NAND_DMA_DESCRIPTOR_COUNT);
 	if (!info->desc) {
diff -urN u-boot-2016.03/drivers/net/fec_mxc.c ebf_6ull_uboot/drivers/net/fec_mxc.c
--- u-boot-2016.03/drivers/net/fec_mxc.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/net/fec_mxc.c	2021-04-16 14:42:15.980587451 +0800
@@ -4,6 +4,7 @@
  * (C) Copyright 2008 Armadeus Systems nc
  * (C) Copyright 2007 Pengutronix, Sascha Hauer <s.hauer@pengutronix.de>
  * (C) Copyright 2007 Pengutronix, Juergen Beisert <j.beisert@pengutronix.de>
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -22,6 +23,7 @@
 #include <asm/io.h>
 #include <asm/errno.h>
 #include <linux/compiler.h>
+#include <asm/arch/sys_proto.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -566,7 +568,7 @@
 
 
 	/* Do not access reserved register for i.MX6UL */
-	if (!is_cpu_type(MXC_CPU_MX6UL)) {
+	if (!is_cpu_type(MXC_CPU_MX6UL) && !is_cpu_type(MXC_CPU_MX6ULL)) {
 		/* clear MIB RAM */
 		for (i = mib_ptr; i <= mib_ptr + 0xfc; i += 4)
 			writel(0, i);
@@ -1093,6 +1095,13 @@
 #endif
 	int ret;
 
+#ifdef CONFIG_MX6
+	if (mx6_enet_fused(addr)) {
+		printf("Ethernet@0x%x is fused, disable it\n", addr);
+		return -2;
+	}
+#endif
+
 #ifdef CONFIG_MX28
 	/*
 	 * The i.MX28 has two ethernet interfaces, but they are not equal.
@@ -1100,8 +1109,12 @@
 	 */
 	base_mii = MXS_ENET0_BASE;
 #else
+#ifdef CONFIG_FEC_MXC_MDIO_BASE
+	base_mii = CONFIG_FEC_MXC_MDIO_BASE;
+#else
 	base_mii = addr;
 #endif
+#endif
 	debug("eth_init: fec_probe(bd, %i, %i) @ %08x\n", dev_id, phy_id, addr);
 	bus = fec_get_miibus(base_mii, dev_id);
 	if (!bus)
diff -urN u-boot-2016.03/drivers/pci/pcie_imx.c ebf_6ull_uboot/drivers/pci/pcie_imx.c
--- u-boot-2016.03/drivers/pci/pcie_imx.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/pci/pcie_imx.c	2021-04-16 14:42:15.984587471 +0800
@@ -3,6 +3,8 @@
  *
  * Copyright (C) 2013 Marek Vasut <marex@denx.de>
  *
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
  * Based on upstream Linux kernel driver:
  * pci-imx6.c:		Sean Cross <xobs@kosagi.com>
  * pcie-designware.c:	Jingoo Han <jg1.han@samsung.com>
@@ -90,6 +92,43 @@
 #define PCIE_ATU_FUNC(x)		(((x) & 0x7) << 16)
 #define PCIE_ATU_UPPER_TARGET		0x91C
 
+#ifdef DEBUG
+
+#ifdef DEBUG_STRESS_WR /* warm-reset stress tests */
+#define SNVS_LPGRP 0x020cc068
+#endif
+
+#define DBGF(x...) printf(x)
+
+static void print_regs(int contain_pcie_reg)
+{
+	u32 val;
+	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	val = readl(&iomuxc_regs->gpr[1]);
+	DBGF("GPR01 a:0x%08x v:0x%08x\n", (u32)&iomuxc_regs->gpr[1], val);
+	val = readl(&iomuxc_regs->gpr[5]);
+	DBGF("GPR05 a:0x%08x v:0x%08x\n", (u32)&iomuxc_regs->gpr[5], val);
+	val = readl(&iomuxc_regs->gpr[8]);
+	DBGF("GPR08 a:0x%08x v:0x%08x\n", (u32)&iomuxc_regs->gpr[8], val);
+	val = readl(&iomuxc_regs->gpr[12]);
+	DBGF("GPR12 a:0x%08x v:0x%08x\n", (u32)&iomuxc_regs->gpr[12], val);
+	val = readl(&ccm_regs->analog_pll_enet);
+	DBGF("PLL06 a:0x%08x v:0x%08x\n", (u32)&ccm_regs->analog_pll_enet, val);
+	val = readl(&ccm_regs->ana_misc1);
+	DBGF("MISC1 a:0x%08x v:0x%08x\n", (u32)&ccm_regs->ana_misc1, val);
+	if (contain_pcie_reg) {
+		val = readl(MX6_DBI_ADDR + 0x728);
+		DBGF("dbr0 offset 0x728 %08x\n", val);
+		val = readl(MX6_DBI_ADDR + 0x72c);
+		DBGF("dbr1 offset 0x72c %08x\n", val);
+	}
+}
+#else
+#define DBGF(x...)
+static void print_regs(int contain_pcie_reg) {}
+#endif
+
 /*
  * PHY access functions
  */
@@ -381,7 +420,7 @@
 	ret = imx_pcie_addr_valid(d);
 	if (ret) {
 		*val = 0xffffffff;
-		return 0;
+		return ret;
 	}
 
 	va_address = get_bus_address(d, where);
@@ -444,6 +483,7 @@
 	setbits_le32(&iomuxc_regs->gpr[5], IOMUXC_GPR5_PCIE_BTNRST);
 	/* Power up PCIe PHY */
 	setbits_le32(&gpc_regs->cntr, PCIE_PHY_PUP_REQ);
+	pcie_power_up();
 #else
 	setbits_le32(&iomuxc_regs->gpr[1], IOMUXC_GPR1_TEST_POWERDOWN);
 	clrbits_le32(&iomuxc_regs->gpr[1], IOMUXC_GPR1_REF_SSP_EN);
@@ -456,7 +496,9 @@
 {
 	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
 
+#ifndef DEBUG
 	clrbits_le32(&iomuxc_regs->gpr[12], IOMUXC_GPR12_APPS_LTSSM_ENABLE);
+#endif
 
 	clrsetbits_le32(&iomuxc_regs->gpr[12],
 			IOMUXC_GPR12_DEVICE_TYPE_MASK,
@@ -595,6 +637,22 @@
 	while (!imx6_pcie_link_up()) {
 		udelay(10);
 		count++;
+		if (count == 1000) {
+			print_regs(1);
+			/* link down, try reset ep, and re-try link here */
+			DBGF("pcie link is down, reset ep, then retry!\n");
+			imx6_pcie_toggle_reset();
+			continue;
+		}
+#ifdef DEBUG
+		else if (count >= 2000) {
+			print_regs(1);
+			/* link is down, stop here */
+			setenv("bootcmd", "sleep 2;");
+			DBGF("pcie link is down, stop here!\n");
+			return -EINVAL;
+		}
+#endif
 		if (count >= 2000) {
 #ifdef CONFIG_PCI_SCAN_SHOW
 			puts("PCI:   pcie phy link never came up\n");
@@ -615,6 +673,10 @@
 	static struct pci_controller	pcc;
 	struct pci_controller		*hose = &pcc;
 	int ret;
+#ifdef DEBUG_STRESS_WR
+	u32 dbg_reg_addr = SNVS_LPGRP;
+	u32 dbg_reg = readl(dbg_reg_addr) + 1;
+#endif
 
 	memset(&pcc, 0, sizeof(pcc));
 
@@ -649,7 +711,15 @@
 	if (!ret) {
 		pci_register_hose(hose);
 		hose->last_busno = pci_hose_scan(hose);
+#ifdef DEBUG_STRESS_WR
+		dbg_reg += 1<<16;
+#endif
 	}
+#ifdef DEBUG_STRESS_WR
+	writel(dbg_reg, dbg_reg_addr);
+	DBGF("PCIe Successes/Attempts: %d/%d\n",
+			dbg_reg >> 16, dbg_reg & 0xffff);
+#endif
 }
 
 /* Probe function. */
diff -urN u-boot-2016.03/drivers/spi/fsl_qspi.c ebf_6ull_uboot/drivers/spi/fsl_qspi.c
--- u-boot-2016.03/drivers/spi/fsl_qspi.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/spi/fsl_qspi.c	2021-04-16 14:42:16.312589169 +0800
@@ -1,35 +1,175 @@
 /*
- * Copyright 2013-2015 Freescale Semiconductor, Inc.
+ * Freescale QuadSPI driver.
  *
- * Freescale Quad Serial Peripheral Interface (QSPI) driver
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
  */
-
 #include <common.h>
 #include <malloc.h>
 #include <spi.h>
+
 #include <asm/io.h>
-#include <linux/sizes.h>
-#include <dm.h>
-#include <errno.h>
-#include <watchdog.h>
-#include "fsl_qspi.h"
-
-DECLARE_GLOBAL_DATA_PTR;
-
-#define RX_BUFFER_SIZE		0x80
-#ifdef CONFIG_MX6SX
-#define TX_BUFFER_SIZE		0x200
-#else
-#define TX_BUFFER_SIZE		0x40
-#endif
+#include <asm/arch/sys_proto.h>
+
+#define QUADSPI_AHBMAP_BANK_MAXSIZE SZ_64M
+
+/* The registers */
+#define QUADSPI_MCR			0x00
+#define QUADSPI_MCR_RESERVED_SHIFT	16
+#define QUADSPI_MCR_RESERVED_MASK	(0xF << QUADSPI_MCR_RESERVED_SHIFT)
+#define QUADSPI_MCR_MDIS_SHIFT		14
+#define QUADSPI_MCR_MDIS_MASK		(1 << QUADSPI_MCR_MDIS_SHIFT)
+#define QUADSPI_MCR_CLR_TXF_SHIFT	11
+#define QUADSPI_MCR_CLR_TXF_MASK	(1 << QUADSPI_MCR_CLR_TXF_SHIFT)
+#define QUADSPI_MCR_CLR_RXF_SHIFT	10
+#define QUADSPI_MCR_CLR_RXF_MASK	(1 << QUADSPI_MCR_CLR_RXF_SHIFT)
+#define QUADSPI_MCR_DDR_EN_SHIFT	7
+#define QUADSPI_MCR_DDR_EN_MASK		(1 << QUADSPI_MCR_DDR_EN_SHIFT)
+#define QUADSPI_MCR_END_CFG_SHIFT   2
+#define QUADSPI_MCR_END_CFG_MASK    (3 << QUADSPI_MCR_END_CFG_SHIFT)
+#define QUADSPI_MCR_SWRSTHD_SHIFT	1
+#define QUADSPI_MCR_SWRSTHD_MASK	(1 << QUADSPI_MCR_SWRSTHD_SHIFT)
+#define QUADSPI_MCR_SWRSTSD_SHIFT	0
+#define QUADSPI_MCR_SWRSTSD_MASK	(1 << QUADSPI_MCR_SWRSTSD_SHIFT)
+
+#define QUADSPI_IPCR			0x08
+#define QUADSPI_IPCR_SEQID_SHIFT	24
+#define QUADSPI_IPCR_SEQID_MASK		(0xF << QUADSPI_IPCR_SEQID_SHIFT)
+
+#define QUADSPI_BUF0CR			0x10
+#define QUADSPI_BUF1CR			0x14
+#define QUADSPI_BUF2CR			0x18
+#define QUADSPI_BUFXCR_INVALID_MSTRID	0xe
+
+#define QUADSPI_BUF3CR			0x1c
+#define QUADSPI_BUF3CR_ALLMST_SHIFT	31
+#define QUADSPI_BUF3CR_ALLMST_MASK  (1 << QUADSPI_BUF3CR_ALLMST_SHIFT)
+#define QUADSPI_BUF3CR_ADATSZ_SHIFT	8
+#define QUADSPI_BUF3CR_ADATSZ_MASK	(0xFF << QUADSPI_BUF3CR_ADATSZ_SHIFT)
+
+#define QUADSPI_BFGENCR			0x20
+#define QUADSPI_BFGENCR_PAR_EN_SHIFT	16
+#define QUADSPI_BFGENCR_PAR_EN_MASK	(1 << (QUADSPI_BFGENCR_PAR_EN_SHIFT))
+#define QUADSPI_BFGENCR_SEQID_SHIFT	12
+#define QUADSPI_BFGENCR_SEQID_MASK	(0xF << QUADSPI_BFGENCR_SEQID_SHIFT)
+
+#define QUADSPI_BUF0IND			0x30
+#define QUADSPI_BUF1IND			0x34
+#define QUADSPI_BUF2IND			0x38
+#define QUADSPI_SFAR			0x100
+
+#define QUADSPI_SMPR			0x108
+#define QUADSPI_SMPR_DDRSMP_SHIFT	16
+#define QUADSPI_SMPR_DDRSMP_MASK	(7 << QUADSPI_SMPR_DDRSMP_SHIFT)
+#define QUADSPI_SMPR_FSDLY_SHIFT	6
+#define QUADSPI_SMPR_FSDLY_MASK		(1 << QUADSPI_SMPR_FSDLY_SHIFT)
+#define QUADSPI_SMPR_FSPHS_SHIFT	5
+#define QUADSPI_SMPR_FSPHS_MASK		(1 << QUADSPI_SMPR_FSPHS_SHIFT)
+#define QUADSPI_SMPR_HSENA_SHIFT	0
+#define QUADSPI_SMPR_HSENA_MASK		(1 << QUADSPI_SMPR_HSENA_SHIFT)
+
+#define QUADSPI_RBSR			0x10c
+#define QUADSPI_RBSR_RDBFL_SHIFT	8
+#define QUADSPI_RBSR_RDBFL_MASK		(0x3F << QUADSPI_RBSR_RDBFL_SHIFT)
+
+#define QUADSPI_RBCT			0x110
+#define QUADSPI_RBCT_WMRK_MASK		0x1F
+#define QUADSPI_RBCT_RXBRD_SHIFT	8
+#define QUADSPI_RBCT_RXBRD_USEIPS	(0x1 << QUADSPI_RBCT_RXBRD_SHIFT)
+
+#define QUADSPI_TBSR			0x150
+#define QUADSPI_TBDR			0x154
+#define QUADSPI_SR			0x15c
+#define QUADSPI_SR_IP_ACC_SHIFT     1
+#define QUADSPI_SR_IP_ACC_MASK      (0x1 << QUADSPI_SR_IP_ACC_SHIFT)
+#define QUADSPI_SR_AHB_ACC_SHIFT    2
+#define QUADSPI_SR_AHB_ACC_MASK     (0x1 << QUADSPI_SR_AHB_ACC_SHIFT)
+
+
+#define QUADSPI_FR			0x160
+#define QUADSPI_FR_TFF_MASK		0x1
+
+#define QUADSPI_SFA1AD			0x180
+#define QUADSPI_SFA2AD			0x184
+#define QUADSPI_SFB1AD			0x188
+#define QUADSPI_SFB2AD			0x18c
+#define QUADSPI_RBDR			0x200
+
+#define QUADSPI_LUTKEY			0x300
+#define QUADSPI_LUTKEY_VALUE		0x5AF05AF0
+
+#define QUADSPI_LCKCR			0x304
+#define QUADSPI_LCKER_LOCK		0x1
+#define QUADSPI_LCKER_UNLOCK		0x2
 
-#define OFFSET_BITS_MASK	GENMASK(23, 0)
+#define QUADSPI_RSER			0x164
+#define QUADSPI_RSER_TFIE		(0x1 << 0)
 
-#define FLASH_STATUS_WEL	0x02
+#define QUADSPI_LUT_BASE		0x310
+
+/*
+ * The definition of the LUT register shows below:
+ *
+ *  ---------------------------------------------------
+ *  | INSTR1 | PAD1 | OPRND1 | INSTR0 | PAD0 | OPRND0 |
+ *  ---------------------------------------------------
+ */
+#define OPRND0_SHIFT		0
+#define PAD0_SHIFT		8
+#define INSTR0_SHIFT		10
+#define OPRND1_SHIFT		16
+
+/* Instruction set for the LUT register. */
+#define LUT_STOP		0
+#define LUT_CMD			1
+#define LUT_ADDR		2
+#define LUT_DUMMY		3
+#define LUT_MODE		4
+#define LUT_MODE2		5
+#define LUT_MODE4		6
+#define LUT_READ		7
+#define LUT_WRITE		8
+#define LUT_JMP_ON_CS		9
+#define LUT_ADDR_DDR		10
+#define LUT_MODE_DDR		11
+#define LUT_MODE2_DDR		12
+#define LUT_MODE4_DDR		13
+#define LUT_READ_DDR		14
+#define LUT_WRITE_DDR		15
+#define LUT_DATA_LEARN		16
 
-/* SEQID */
+/*
+ * The PAD definitions for LUT register.
+ *
+ * The pad stands for the lines number of IO[0:3].
+ * For example, the Quad read need four IO lines, so you should
+ * set LUT_PAD4 which means we use four IO lines.
+ */
+#define LUT_PAD1		0
+#define LUT_PAD2		1
+#define LUT_PAD4		2
+
+/* Oprands for the LUT register. */
+#define ADDR24BIT		0x18
+#define ADDR32BIT		0x20
+
+/* Macros for constructing the LUT register. */
+#define LUT0(ins, pad, opr)						\
+		(((opr) << OPRND0_SHIFT) | ((LUT_##pad) << PAD0_SHIFT) | \
+		((LUT_##ins) << INSTR0_SHIFT))
+
+#define LUT1(ins, pad, opr)	(LUT0(ins, pad, opr) << OPRND1_SHIFT)
+
+/* other macros for LUT register. */
+#define QUADSPI_LUT(x)          (QUADSPI_LUT_BASE + (x) * 4)
+#define QUADSPI_LUT_NUM		64
+
+/* SEQID -- we can have 16 seqids at most. */
+#define SEQID_QUAD_READ		0
 #define SEQID_WREN		1
 #define SEQID_FAST_READ		2
 #define SEQID_RDSR		3
@@ -37,356 +177,269 @@
 #define SEQID_CHIP_ERASE	5
 #define SEQID_PP		6
 #define SEQID_RDID		7
-#define SEQID_BE_4K		8
+#define SEQID_WRSR		8
+#define SEQID_RDCR		9
+#define SEQID_DDR_QUAD_READ	10
+#define SEQID_BE_4K		11
 #ifdef CONFIG_SPI_FLASH_BAR
-#define SEQID_BRRD		9
-#define SEQID_BRWR		10
-#define SEQID_RDEAR		11
-#define SEQID_WREAR		12
-#endif
-
-/* QSPI CMD */
-#define QSPI_CMD_PP		0x02	/* Page program (up to 256 bytes) */
-#define QSPI_CMD_RDSR		0x05	/* Read status register */
-#define QSPI_CMD_WREN		0x06	/* Write enable */
-#define QSPI_CMD_FAST_READ	0x0b	/* Read data bytes (high frequency) */
-#define QSPI_CMD_BE_4K		0x20    /* 4K erase */
-#define QSPI_CMD_CHIP_ERASE	0xc7	/* Erase whole flash chip */
-#define QSPI_CMD_SE		0xd8	/* Sector erase (usually 64KiB) */
-#define QSPI_CMD_RDID		0x9f	/* Read JEDEC ID */
+#define SEQID_BRRD		12
+#define SEQID_BRWR		13
+#define SEQID_RDEAR		14
+#define SEQID_WREAR		15
+#endif
+
+/* Flash opcodes. */
+#define	OPCODE_WREN		0x06	/* Write enable */
+#define	OPCODE_RDSR		0x05	/* Read status register */
+#define	OPCODE_WRSR		0x01	/* Write status register 1 byte */
+#define	OPCODE_NORM_READ	0x03	/* Read data bytes (low frequency) */
+#define	OPCODE_FAST_READ	0x0b	/* Read data bytes (high frequency) */
+#define	OPCODE_QUAD_READ        0x6b    /* Read data bytes */
+#define	OPCODE_DDR_QUAD_READ	0x6d    /* Read data bytes in DDR mode*/
+#define	OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
+#define	OPCODE_BE_4K		0x20	/* Erase 4KiB block */
+#define	OPCODE_BE_4K_PMC	0xd7	/* Erase 4KiB block on PMC chips */
+#define	OPCODE_BE_32K		0x52	/* Erase 32KiB block */
+#define	OPCODE_CHIP_ERASE	0xc7	/* Erase whole flash chip */
+#define	OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
+#define	OPCODE_RDID		0x9f	/* Read JEDEC ID */
+#define	OPCODE_RDCR             0x35    /* Read configuration register */
+
+/* 4-byte address opcodes - used on Spansion and some Macronix flashes. */
+#define	OPCODE_NORM_READ_4B	0x13	/* Read data bytes (low frequency) */
+#define	OPCODE_FAST_READ_4B	0x0c	/* Read data bytes (high frequency) */
+#define	OPCODE_QUAD_READ_4B	0x6c    /* Read data bytes */
+#define	OPCODE_PP_4B		0x12	/* Page program (up to 256 bytes) */
+#define	OPCODE_SE_4B		0xdc	/* Sector erase (usually 64KiB) */
+
+/* Used for SST flashes only. */
+#define	OPCODE_BP		0x02	/* Byte program */
+#define	OPCODE_WRDI		0x04	/* Write disable */
+#define	OPCODE_AAI_WP		0xad	/* Auto address increment word program */
+
+/* Used for Macronix and Winbond flashes. */
+#define	OPCODE_EN4B		0xb7	/* Enter 4-byte mode */
+#define	OPCODE_EX4B		0xe9	/* Exit 4-byte mode */
 
 /* Used for Micron, winbond and Macronix flashes */
-#define	QSPI_CMD_WREAR		0xc5	/* EAR register write */
-#define	QSPI_CMD_RDEAR		0xc8	/* EAR reigster read */
+#define	OPCODE_WREAR		0xc5	/* EAR register write */
+#define	OPCODE_RDEAR		0xc8	/* EAR reigster read */
 
 /* Used for Spansion flashes only. */
-#define	QSPI_CMD_BRRD		0x16	/* Bank register read */
-#define	QSPI_CMD_BRWR		0x17	/* Bank register write */
+#define	OPCODE_BRRD		0x16	/* Bank register read */
+#define	OPCODE_BRWR		0x17	/* Bank register write */
 
-/* 4-byte address QSPI CMD - used on Spansion and some Macronix flashes */
-#define QSPI_CMD_FAST_READ_4B	0x0c    /* Read data bytes (high frequency) */
-#define QSPI_CMD_PP_4B		0x12    /* Page program (up to 256 bytes) */
-#define QSPI_CMD_SE_4B		0xdc    /* Sector erase (usually 64KiB) */
-
-/* fsl_qspi_platdata flags */
-#define QSPI_FLAG_REGMAP_ENDIAN_BIG	BIT(0)
-
-/* default SCK frequency, unit: HZ */
-#define FSL_QSPI_DEFAULT_SCK_FREQ	50000000
-
-/* QSPI max chipselect signals number */
-#define FSL_QSPI_MAX_CHIPSELECT_NUM     4
-
-#ifdef CONFIG_DM_SPI
-/**
- * struct fsl_qspi_platdata - platform data for Freescale QSPI
- *
- * @flags: Flags for QSPI QSPI_FLAG_...
- * @speed_hz: Default SCK frequency
- * @reg_base: Base address of QSPI registers
- * @amba_base: Base address of QSPI memory mapping
- * @amba_total_size: size of QSPI memory mapping
- * @flash_num: Number of active slave devices
- * @num_chipselect: Number of QSPI chipselect signals
- */
-struct fsl_qspi_platdata {
-	u32 flags;
-	u32 speed_hz;
-	u32 reg_base;
-	u32 amba_base;
-	u32 amba_total_size;
-	u32 flash_num;
-	u32 num_chipselect;
+/* Status Register bits. */
+#define	SR_WIP			1	/* Write in progress */
+#define	SR_WEL			2	/* Write enable latch */
+/* meaning of other SR_* bits may differ between vendors */
+#define	SR_BP0			4	/* Block protect 0 */
+#define	SR_BP1			8	/* Block protect 1 */
+#define	SR_BP2			0x10	/* Block protect 2 */
+#define	SR_SRWD			0x80	/* SR write protect */
+
+#define SR_QUAD_EN_MX           0x40    /* Macronix Quad I/O */
+
+/* Configuration Register bits. */
+#define CR_QUAD_EN_SPAN		0x2     /* Spansion Quad I/O */
+
+/* Endianess Configuration */
+#define BE_64	0x00
+#define LE_32	0x01
+#define BE_32	0x02
+#define LE_64	0x03
+
+
+
+enum fsl_qspi_devtype {
+	FSL_QUADSPI_VYBRID,
+	FSL_QUADSPI_IMX6SX,
 };
-#endif
 
-/**
- * struct fsl_qspi_priv - private data for Freescale QSPI
- *
- * @flags: Flags for QSPI QSPI_FLAG_...
- * @bus_clk: QSPI input clk frequency
- * @speed_hz: Default SCK frequency
- * @cur_seqid: current LUT table sequence id
- * @sf_addr: flash access offset
- * @amba_base: Base address of QSPI memory mapping of every CS
- * @amba_total_size: size of QSPI memory mapping
- * @cur_amba_base: Base address of QSPI memory mapping of current CS
- * @flash_num: Number of active slave devices
- * @num_chipselect: Number of QSPI chipselect signals
- * @regs: Point to QSPI register structure for I/O access
- */
-struct fsl_qspi_priv {
-	u32 flags;
-	u32 bus_clk;
-	u32 speed_hz;
-	u32 cur_seqid;
-	u32 sf_addr;
-	u32 amba_base[FSL_QSPI_MAX_CHIPSELECT_NUM];
-	u32 amba_total_size;
-	u32 cur_amba_base;
-	u32 flash_num;
-	u32 num_chipselect;
-	struct fsl_qspi_regs *regs;
+struct fsl_qspi_devtype_data {
+	enum fsl_qspi_devtype devtype;
+	int rxfifo;
+	int txfifo;
 };
 
-#ifndef CONFIG_DM_SPI
 struct fsl_qspi {
 	struct spi_slave slave;
-	struct fsl_qspi_priv priv;
+	uint32_t max_khz;
+	uint32_t mode;
+	u32 iobase;
+	u32 ahb_base; /* Used when read from AHB bus */
+	u32 bank_memmap_phy[4];
+	struct fsl_qspi_devtype_data *devtype_data;
 };
-#endif
-
-static u32 qspi_read32(u32 flags, u32 *addr)
-{
-	return flags & QSPI_FLAG_REGMAP_ENDIAN_BIG ?
-		in_be32(addr) : in_le32(addr);
-}
 
-static void qspi_write32(u32 flags, u32 *addr, u32 val)
+static inline void fsl_qspi_unlock_lut(struct fsl_qspi *q)
 {
-	flags & QSPI_FLAG_REGMAP_ENDIAN_BIG ?
-		out_be32(addr, val) : out_le32(addr, val);
+	writel(QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);
+	writel(QUADSPI_LCKER_UNLOCK, q->iobase + QUADSPI_LCKCR);
 }
 
-/* QSPI support swapping the flash read/write data
- * in hardware for LS102xA, but not for VF610 */
-static inline u32 qspi_endian_xchg(u32 data)
+static inline void fsl_qspi_lock_lut(struct fsl_qspi *q)
 {
-#ifdef CONFIG_VF610
-	return swab32(data);
-#else
-	return data;
-#endif
+	writel(QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);
+	writel(QUADSPI_LCKER_LOCK, q->iobase + QUADSPI_LCKCR);
 }
 
-static void qspi_set_lut(struct fsl_qspi_priv *priv)
+static void fsl_qspi_init_lut(struct fsl_qspi *q)
 {
-	struct fsl_qspi_regs *regs = priv->regs;
+	u32 base = q->iobase;
+	int rxfifo = q->devtype_data->rxfifo;
 	u32 lut_base;
+	u8 cmd, addrlen, dummy;
+	int i;
 
-	/* Unlock the LUT */
-	qspi_write32(priv->flags, &regs->lutkey, LUT_KEY_VALUE);
-	qspi_write32(priv->flags, &regs->lckcr, QSPI_LCKCR_UNLOCK);
+	fsl_qspi_unlock_lut(q);
 
-	/* Write Enable */
+	/* Clear all the LUT table */
+	for (i = 0; i < QUADSPI_LUT_NUM; i++)
+		writel(0, base + QUADSPI_LUT_BASE + i * 4);
+
+	/* Quad Read */
+	lut_base = SEQID_QUAD_READ * 4;
+
+	/* U-boot SPI flash only support 24bits address*/
+	cmd = OPCODE_QUAD_READ;
+	addrlen = ADDR24BIT;
+	dummy = 8;
+
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(ADDR, PAD1, addrlen),
+			base + QUADSPI_LUT(lut_base));
+	writel(LUT0(DUMMY, PAD1, dummy) | LUT1(READ, PAD4, rxfifo),
+			base + QUADSPI_LUT(lut_base + 1));
+
+	/* Write enable */
 	lut_base = SEQID_WREN * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_WREN) |
-		PAD0(LUT_PAD1) | INSTR0(LUT_CMD));
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 2], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 3], 0);
+	writel(LUT0(CMD, PAD1, OPCODE_WREN), base + QUADSPI_LUT(lut_base));
 
 	/* Fast Read */
 	lut_base = SEQID_FAST_READ * 4;
-#ifdef CONFIG_SPI_FLASH_BAR
-	qspi_write32(priv->flags, &regs->lut[lut_base],
-		     OPRND0(QSPI_CMD_FAST_READ) | PAD0(LUT_PAD1) |
-		     INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-#else
-	if (FSL_QSPI_FLASH_SIZE  <= SZ_16M)
-		qspi_write32(priv->flags, &regs->lut[lut_base],
-			     OPRND0(QSPI_CMD_FAST_READ) | PAD0(LUT_PAD1) |
-			     INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-			     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-	else
-		qspi_write32(priv->flags, &regs->lut[lut_base],
-			     OPRND0(QSPI_CMD_FAST_READ_4B) |
-			     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) |
-			     OPRND1(ADDR32BIT) | PAD1(LUT_PAD1) |
-			     INSTR1(LUT_ADDR));
-#endif
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1],
-		     OPRND0(8) | PAD0(LUT_PAD1) | INSTR0(LUT_DUMMY) |
-		     OPRND1(RX_BUFFER_SIZE) | PAD1(LUT_PAD1) |
-		     INSTR1(LUT_READ));
-	qspi_write32(priv->flags, &regs->lut[lut_base + 2], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 3], 0);
+	cmd = OPCODE_FAST_READ;
+	addrlen = ADDR24BIT;
+	dummy = 8;
+
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(ADDR, PAD1, addrlen),
+			base + QUADSPI_LUT(lut_base));
+	writel(LUT0(DUMMY, PAD1, dummy) | LUT1(READ, PAD1, rxfifo),
+			base + QUADSPI_LUT(lut_base + 1));
+
+	/* Page Program */
+	lut_base = SEQID_PP * 4;
+	cmd = OPCODE_PP;
+	addrlen = ADDR24BIT;
+
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(ADDR, PAD1, addrlen),
+			base + QUADSPI_LUT(lut_base));
+	writel(LUT0(WRITE, PAD1, 0), base + QUADSPI_LUT(lut_base + 1));
 
 	/* Read Status */
 	lut_base = SEQID_RDSR * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_RDSR) |
-		PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(1) |
-		PAD1(LUT_PAD1) | INSTR1(LUT_READ));
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 2], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 3], 0);
+	writel(LUT0(CMD, PAD1, OPCODE_RDSR) | LUT1(READ, PAD1, 0x1),
+			base + QUADSPI_LUT(lut_base));
 
 	/* Erase a sector */
 	lut_base = SEQID_SE * 4;
-#ifdef CONFIG_SPI_FLASH_BAR
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_SE) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-#else
-	if (FSL_QSPI_FLASH_SIZE  <= SZ_16M)
-		qspi_write32(priv->flags, &regs->lut[lut_base],
-			     OPRND0(QSPI_CMD_SE) | PAD0(LUT_PAD1) |
-			     INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-			     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-	else
-		qspi_write32(priv->flags, &regs->lut[lut_base],
-			     OPRND0(QSPI_CMD_SE_4B) | PAD0(LUT_PAD1) |
-			     INSTR0(LUT_CMD) | OPRND1(ADDR32BIT) |
-			     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-#endif
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 2], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 3], 0);
+	cmd = OPCODE_SE;
+	addrlen = ADDR24BIT;
+
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(ADDR, PAD1, addrlen),
+			base + QUADSPI_LUT(lut_base));
 
 	/* Erase the whole chip */
 	lut_base = SEQID_CHIP_ERASE * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base],
-		     OPRND0(QSPI_CMD_CHIP_ERASE) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD));
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 2], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 3], 0);
-
-	/* Page Program */
-	lut_base = SEQID_PP * 4;
-#ifdef CONFIG_SPI_FLASH_BAR
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_PP) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-#else
-	if (FSL_QSPI_FLASH_SIZE  <= SZ_16M)
-		qspi_write32(priv->flags, &regs->lut[lut_base],
-			     OPRND0(QSPI_CMD_PP) | PAD0(LUT_PAD1) |
-			     INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-			     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-	else
-		qspi_write32(priv->flags, &regs->lut[lut_base],
-			     OPRND0(QSPI_CMD_PP_4B) | PAD0(LUT_PAD1) |
-			     INSTR0(LUT_CMD) | OPRND1(ADDR32BIT) |
-			     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-#endif
-#ifdef CONFIG_MX6SX
-	/*
-	 * To MX6SX, OPRND0(TX_BUFFER_SIZE) can not work correctly.
-	 * So, Use IDATSZ in IPCR to determine the size and here set 0.
-	 */
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1], OPRND0(0) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_WRITE));
-#else
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1],
-		     OPRND0(TX_BUFFER_SIZE) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_WRITE));
-#endif
-	qspi_write32(priv->flags, &regs->lut[lut_base + 2], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 3], 0);
+	writel(LUT0(CMD, PAD1, OPCODE_CHIP_ERASE),
+			base + QUADSPI_LUT(lut_base));
 
 	/* READ ID */
 	lut_base = SEQID_RDID * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_RDID) |
-		PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(8) |
-		PAD1(LUT_PAD1) | INSTR1(LUT_READ));
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 2], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 3], 0);
+	writel(LUT0(CMD, PAD1, OPCODE_RDID) | LUT1(READ, PAD1, 0x8),
+			base + QUADSPI_LUT(lut_base));
+
+	/* Write Register */
+	lut_base = SEQID_WRSR * 4;
+	writel(LUT0(CMD, PAD1, OPCODE_WRSR) | LUT1(WRITE, PAD1, 0x2),
+			base + QUADSPI_LUT(lut_base));
+
+	/* Read Configuration Register */
+	lut_base = SEQID_RDCR * 4;
+	writel(LUT0(CMD, PAD1, OPCODE_RDCR) | LUT1(READ, PAD1, 0x1),
+			base + QUADSPI_LUT(lut_base));
+
+	/* DDR QUAD Read */
+	lut_base = SEQID_DDR_QUAD_READ * 4;
+	cmd = OPCODE_DDR_QUAD_READ;
+	addrlen = ADDR24BIT;
+	dummy = 6;
+
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(ADDR_DDR, PAD1, addrlen),
+			base + QUADSPI_LUT(lut_base));
+	writel(LUT0(DUMMY, PAD1, dummy) | LUT1(READ_DDR, PAD4, rxfifo),
+			base + QUADSPI_LUT(lut_base + 1));
+	writel(LUT0(JMP_ON_CS, PAD1, 0),
+			base + QUADSPI_LUT(lut_base + 2));
 
 	/* SUB SECTOR 4K ERASE */
 	lut_base = SEQID_BE_4K * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_BE_4K) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
+	cmd = OPCODE_BE_4K;
+	addrlen = ADDR24BIT;
+
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(ADDR, PAD1, addrlen),
+			base + QUADSPI_LUT(lut_base));
 
 #ifdef CONFIG_SPI_FLASH_BAR
 	/*
 	 * BRRD BRWR RDEAR WREAR are all supported, because it is hard to
-	 * dynamically check whether to set BRRD BRWR or RDEAR WREAR during
-	 * initialization.
+	 * dynamically check whether to set BRRD BRWR or RDEAR WREAR.
 	 */
 	lut_base = SEQID_BRRD * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_BRRD) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(1) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_READ));
+	cmd = OPCODE_BRRD;
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(READ, PAD1, 0x1),
+	       base + QUADSPI_LUT(lut_base));
 
 	lut_base = SEQID_BRWR * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_BRWR) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(1) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_WRITE));
+	cmd = OPCODE_BRWR;
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(WRITE, PAD1, 0x1),
+	       base + QUADSPI_LUT(lut_base));
 
 	lut_base = SEQID_RDEAR * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_RDEAR) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(1) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_READ));
+	cmd = OPCODE_RDEAR;
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(READ, PAD1, 0x1),
+	       base + QUADSPI_LUT(lut_base));
 
 	lut_base = SEQID_WREAR * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_WREAR) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(1) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_WRITE));
+	cmd = OPCODE_WREAR;
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(WRITE, PAD1, 0x1),
+	       base + QUADSPI_LUT(lut_base));
 #endif
-	/* Lock the LUT */
-	qspi_write32(priv->flags, &regs->lutkey, LUT_KEY_VALUE);
-	qspi_write32(priv->flags, &regs->lckcr, QSPI_LCKCR_LOCK);
-}
-
-#if defined(CONFIG_SYS_FSL_QSPI_AHB)
-/*
- * If we have changed the content of the flash by writing or erasing,
- * we need to invalidate the AHB buffer. If we do not do so, we may read out
- * the wrong data. The spec tells us reset the AHB domain and Serial Flash
- * domain at the same time.
- */
-static inline void qspi_ahb_invalid(struct fsl_qspi_priv *priv)
-{
-	struct fsl_qspi_regs *regs = priv->regs;
-	u32 reg;
-
-	reg = qspi_read32(priv->flags, &regs->mcr);
-	reg |= QSPI_MCR_SWRSTHD_MASK | QSPI_MCR_SWRSTSD_MASK;
-	qspi_write32(priv->flags, &regs->mcr, reg);
-
-	/*
-	 * The minimum delay : 1 AHB + 2 SFCK clocks.
-	 * Delay 1 us is enough.
-	 */
-	udelay(1);
 
-	reg &= ~(QSPI_MCR_SWRSTHD_MASK | QSPI_MCR_SWRSTSD_MASK);
-	qspi_write32(priv->flags, &regs->mcr, reg);
+	fsl_qspi_lock_lut(q);
 }
 
-/* Read out the data from the AHB buffer. */
-static inline void qspi_ahb_read(struct fsl_qspi_priv *priv, u8 *rxbuf, int len)
-{
-	struct fsl_qspi_regs *regs = priv->regs;
-	u32 mcr_reg;
-
-	mcr_reg = qspi_read32(priv->flags, &regs->mcr);
-
-	qspi_write32(priv->flags, &regs->mcr,
-		     QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
-		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
-
-	/* Read out the data directly from the AHB buffer. */
-	memcpy(rxbuf, (u8 *)(priv->cur_amba_base + priv->sf_addr), len);
-
-	qspi_write32(priv->flags, &regs->mcr, mcr_reg);
-}
-
-static void qspi_enable_ddr_mode(struct fsl_qspi_priv *priv)
+/*Enable DDR Read Mode*/
+static void fsl_enable_ddr_mode(struct fsl_qspi *q)
 {
+	u32 base = q->iobase;
 	u32 reg, reg2;
-	struct fsl_qspi_regs *regs = priv->regs;
 
-	reg = qspi_read32(priv->flags, &regs->mcr);
-	/* Disable the module */
-	qspi_write32(priv->flags, &regs->mcr, reg | QSPI_MCR_MDIS_MASK);
+	reg = readl(base + QUADSPI_MCR);
+	/* Firstly, disable the module */
+	writel(reg | QUADSPI_MCR_MDIS_MASK, base + QUADSPI_MCR);
 
 	/* Set the Sampling Register for DDR */
-	reg2 = qspi_read32(priv->flags, &regs->smpr);
-	reg2 &= ~QSPI_SMPR_DDRSMP_MASK;
-	reg2 |= (2 << QSPI_SMPR_DDRSMP_SHIFT);
-	qspi_write32(priv->flags, &regs->smpr, reg2);
+	reg2 = readl(base + QUADSPI_SMPR);
+	reg2 &= ~QUADSPI_SMPR_DDRSMP_MASK;
+	reg2 |= (2 << QUADSPI_SMPR_DDRSMP_SHIFT);
+	writel(reg2, base + QUADSPI_SMPR);
 
 	/* Enable the module again (enable the DDR too) */
-	reg |= QSPI_MCR_DDR_EN_MASK;
-	/* Enable bit 29 for imx6sx */
-	reg |= BIT(29);
+	reg |= QUADSPI_MCR_DDR_EN_MASK;
+	reg |= (1 << 29); /* enable bit 29 for imx6sx */
+
+	writel(reg, base + QUADSPI_MCR);
 
-	qspi_write32(priv->flags, &regs->mcr, reg);
 }
 
 /*
@@ -402,715 +455,426 @@
  * causes the controller to clear the buffer, and use the sequence pointed
  * by the QUADSPI_BFGENCR[SEQID] to initiate a read from the flash.
  */
-static void qspi_init_ahb_read(struct fsl_qspi_priv *priv)
+static void fsl_qspi_init_abh_read(struct fsl_qspi *q)
 {
-	struct fsl_qspi_regs *regs = priv->regs;
+	u32 base = q->iobase;
+
+	/* Map the SPI NOR to accessiable address, arrage max space for each bank*/
+	writel(q->bank_memmap_phy[0] + QUADSPI_AHBMAP_BANK_MAXSIZE,
+		base + QUADSPI_SFA1AD);
+	writel(q->bank_memmap_phy[1] + QUADSPI_AHBMAP_BANK_MAXSIZE,
+		base + QUADSPI_SFA2AD);
+	writel(q->bank_memmap_phy[2] + QUADSPI_AHBMAP_BANK_MAXSIZE,
+		base + QUADSPI_SFB1AD);
+	writel(q->bank_memmap_phy[3] + QUADSPI_AHBMAP_BANK_MAXSIZE,
+		base + QUADSPI_SFB2AD);
 
 	/* AHB configuration for access buffer 0/1/2 .*/
-	qspi_write32(priv->flags, &regs->buf0cr, QSPI_BUFXCR_INVALID_MSTRID);
-	qspi_write32(priv->flags, &regs->buf1cr, QSPI_BUFXCR_INVALID_MSTRID);
-	qspi_write32(priv->flags, &regs->buf2cr, QSPI_BUFXCR_INVALID_MSTRID);
-	qspi_write32(priv->flags, &regs->buf3cr, QSPI_BUF3CR_ALLMST_MASK |
-		     (0x80 << QSPI_BUF3CR_ADATSZ_SHIFT));
+	writel(QUADSPI_BUFXCR_INVALID_MSTRID, base + QUADSPI_BUF0CR);
+	writel(QUADSPI_BUFXCR_INVALID_MSTRID, base + QUADSPI_BUF1CR);
+	writel(QUADSPI_BUFXCR_INVALID_MSTRID, base + QUADSPI_BUF2CR);
+	writel(QUADSPI_BUF3CR_ALLMST_MASK | (0x80 << QUADSPI_BUF3CR_ADATSZ_SHIFT),
+			base + QUADSPI_BUF3CR);
 
 	/* We only use the buffer3 */
-	qspi_write32(priv->flags, &regs->buf0ind, 0);
-	qspi_write32(priv->flags, &regs->buf1ind, 0);
-	qspi_write32(priv->flags, &regs->buf2ind, 0);
-
-	/*
-	 * Set the default lut sequence for AHB Read.
-	 * Parallel mode is disabled.
-	 */
-	qspi_write32(priv->flags, &regs->bfgencr,
-		     SEQID_FAST_READ << QSPI_BFGENCR_SEQID_SHIFT);
+	writel(0, base + QUADSPI_BUF0IND);
+	writel(0, base + QUADSPI_BUF1IND);
+	writel(0, base + QUADSPI_BUF2IND);
+
+	/* Set the default lut sequence for AHB Read. */
+	writel(SEQID_FAST_READ << QUADSPI_BFGENCR_SEQID_SHIFT,
+		base + QUADSPI_BFGENCR);
 
 	/*Enable DDR Mode*/
-	qspi_enable_ddr_mode(priv);
+	fsl_enable_ddr_mode(q);
 }
-#endif
 
-#ifdef CONFIG_SPI_FLASH_BAR
-/* Bank register read/write, EAR register read/write */
-static void qspi_op_rdbank(struct fsl_qspi_priv *priv, u8 *rxbuf, u32 len)
+static int fsl_qspi_init(struct fsl_qspi *q)
 {
-	struct fsl_qspi_regs *regs = priv->regs;
-	u32 reg, mcr_reg, data, seqid;
+	u32 base = q->iobase;
+	u32 reg;
+	void *ptr;
 
-	mcr_reg = qspi_read32(priv->flags, &regs->mcr);
-	qspi_write32(priv->flags, &regs->mcr,
-		     QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
-		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
-	qspi_write32(priv->flags, &regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
+	ptr = malloc(sizeof(struct fsl_qspi_devtype_data));
+	if (!ptr) {
+		puts("FSL_QSPI: per-type data not allocated !\n");
+		return 1;
+	}
+	q->devtype_data = ptr;
+	q->devtype_data->rxfifo = 128;
+	q->devtype_data->txfifo = 512;
 
-	qspi_write32(priv->flags, &regs->sfar, priv->cur_amba_base);
+	/* init the LUT table */
+	fsl_qspi_init_lut(q);
 
-	if (priv->cur_seqid == QSPI_CMD_BRRD)
-		seqid = SEQID_BRRD;
-	else
-		seqid = SEQID_RDEAR;
+	/* Disable the module */
+	writel(QUADSPI_MCR_MDIS_MASK | QUADSPI_MCR_RESERVED_MASK,
+			base + QUADSPI_MCR);
 
-	qspi_write32(priv->flags, &regs->ipcr,
-		     (seqid << QSPI_IPCR_SEQID_SHIFT) | len);
+	reg = readl(base + QUADSPI_SMPR);
+	writel(reg & ~(QUADSPI_SMPR_FSDLY_MASK
+			| QUADSPI_SMPR_FSPHS_MASK
+			| QUADSPI_SMPR_HSENA_MASK
+			| QUADSPI_SMPR_DDRSMP_MASK), base + QUADSPI_SMPR);
+
+	/* Enable the module */
+	writel(QUADSPI_MCR_RESERVED_MASK | LE_64 << QUADSPI_MCR_END_CFG_SHIFT,
+		base + QUADSPI_MCR);
 
-	/* Wait previous command complete */
-	while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-		;
+	/* We do not enable the interrupt */
 
-	while (1) {
-		reg = qspi_read32(priv->flags, &regs->rbsr);
-		if (reg & QSPI_RBSR_RDBFL_MASK) {
-			data = qspi_read32(priv->flags, &regs->rbdr[0]);
-			data = qspi_endian_xchg(data);
-			memcpy(rxbuf, &data, len);
-			qspi_write32(priv->flags, &regs->mcr,
-				     qspi_read32(priv->flags, &regs->mcr) |
-				     QSPI_MCR_CLR_RXF_MASK);
-			break;
-		}
-	}
+	/* init for AHB read */
+	fsl_qspi_init_abh_read(q);
+
+	/*
+	 * High level code use page_size and max_write_size to calculate
+	 * the number of bytes that should be programmed once.
+	 */
+	q->slave.max_write_size = q->devtype_data->txfifo;
 
-	qspi_write32(priv->flags, &regs->mcr, mcr_reg);
+	return 0;
 }
-#endif
 
-static void qspi_op_rdid(struct fsl_qspi_priv *priv, u32 *rxbuf, u32 len)
+void spi_init(void)
 {
-	struct fsl_qspi_regs *regs = priv->regs;
-	u32 mcr_reg, rbsr_reg, data, size;
-	int i;
-
-	mcr_reg = qspi_read32(priv->flags, &regs->mcr);
-	qspi_write32(priv->flags, &regs->mcr,
-		     QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
-		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
-	qspi_write32(priv->flags, &regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
-
-	qspi_write32(priv->flags, &regs->sfar, priv->cur_amba_base);
-
-	qspi_write32(priv->flags, &regs->ipcr,
-		     (SEQID_RDID << QSPI_IPCR_SEQID_SHIFT) | 0);
-	while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-		;
-
-	i = 0;
-	while ((RX_BUFFER_SIZE >= len) && (len > 0)) {
-		rbsr_reg = qspi_read32(priv->flags, &regs->rbsr);
-		if (rbsr_reg & QSPI_RBSR_RDBFL_MASK) {
-			data = qspi_read32(priv->flags, &regs->rbdr[i]);
-			data = qspi_endian_xchg(data);
-			size = (len < 4) ? len : 4;
-			memcpy(rxbuf, &data, size);
-			len -= size;
-			rxbuf++;
-			i++;
-		}
-	}
-
-	qspi_write32(priv->flags, &regs->mcr, mcr_reg);
 }
 
-#ifndef CONFIG_SYS_FSL_QSPI_AHB
-/* If not use AHB read, read data from ip interface */
-static void qspi_op_read(struct fsl_qspi_priv *priv, u32 *rxbuf, u32 len)
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
 {
-	struct fsl_qspi_regs *regs = priv->regs;
-	u32 mcr_reg, data;
-	int i, size;
-	u32 to_or_from;
-
-	mcr_reg = qspi_read32(priv->flags, &regs->mcr);
-	qspi_write32(priv->flags, &regs->mcr,
-		     QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
-		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
-	qspi_write32(priv->flags, &regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
-
-	to_or_from = priv->sf_addr + priv->cur_amba_base;
-
-	while (len > 0) {
-		WATCHDOG_RESET();
-
-		qspi_write32(priv->flags, &regs->sfar, to_or_from);
-
-		size = (len > RX_BUFFER_SIZE) ?
-			RX_BUFFER_SIZE : len;
+	struct fsl_qspi *q;
+	int ret;
 
-		qspi_write32(priv->flags, &regs->ipcr,
-			     (SEQID_FAST_READ << QSPI_IPCR_SEQID_SHIFT) |
-			     size);
-		while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-			;
-
-		to_or_from += size;
-		len -= size;
-
-		i = 0;
-		while ((RX_BUFFER_SIZE >= size) && (size > 0)) {
-			data = qspi_read32(priv->flags, &regs->rbdr[i]);
-			data = qspi_endian_xchg(data);
-			memcpy(rxbuf, &data, 4);
-			rxbuf++;
-			size -= 4;
-			i++;
-		}
-		qspi_write32(priv->flags, &regs->mcr,
-			     qspi_read32(priv->flags, &regs->mcr) |
-			     QSPI_MCR_CLR_RXF_MASK);
+#ifdef CONFIG_MX6
+	if (mx6_qspi_fused(CONFIG_QSPI_BASE)) {
+		printf("QSPI@0x%x is fused, disable it\n", CONFIG_QSPI_BASE);
+		return NULL;
 	}
-
-	qspi_write32(priv->flags, &regs->mcr, mcr_reg);
-}
 #endif
 
-static void qspi_op_write(struct fsl_qspi_priv *priv, u8 *txbuf, u32 len)
-{
-	struct fsl_qspi_regs *regs = priv->regs;
-	u32 mcr_reg, data, reg, status_reg, seqid;
-	int i, size, tx_size;
-	u32 to_or_from = 0;
-
-	mcr_reg = qspi_read32(priv->flags, &regs->mcr);
-	qspi_write32(priv->flags, &regs->mcr,
-		     QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
-		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
-	qspi_write32(priv->flags, &regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
-
-	status_reg = 0;
-	while ((status_reg & FLASH_STATUS_WEL) != FLASH_STATUS_WEL) {
-		WATCHDOG_RESET();
-
-		qspi_write32(priv->flags, &regs->ipcr,
-			     (SEQID_WREN << QSPI_IPCR_SEQID_SHIFT) | 0);
-		while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-			;
-
-		qspi_write32(priv->flags, &regs->ipcr,
-			     (SEQID_RDSR << QSPI_IPCR_SEQID_SHIFT) | 1);
-		while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-			;
-
-		reg = qspi_read32(priv->flags, &regs->rbsr);
-		if (reg & QSPI_RBSR_RDBFL_MASK) {
-			status_reg = qspi_read32(priv->flags, &regs->rbdr[0]);
-			status_reg = qspi_endian_xchg(status_reg);
-		}
-		qspi_write32(priv->flags, &regs->mcr,
-			     qspi_read32(priv->flags, &regs->mcr) |
-			     QSPI_MCR_CLR_RXF_MASK);
+	if (bus > 1) {
+		puts("FSL_QSPI: Not a valid bus !\n");
+		return NULL;
 	}
 
-	/* Default is page programming */
-	seqid = SEQID_PP;
-#ifdef CONFIG_SPI_FLASH_BAR
-	if (priv->cur_seqid == QSPI_CMD_BRWR)
-		seqid = SEQID_BRWR;
-	else if (priv->cur_seqid == QSPI_CMD_WREAR)
-		seqid = SEQID_WREAR;
-#endif
-
-	to_or_from = priv->sf_addr + priv->cur_amba_base;
-
-	qspi_write32(priv->flags, &regs->sfar, to_or_from);
-
-	tx_size = (len > TX_BUFFER_SIZE) ?
-		TX_BUFFER_SIZE : len;
-
-	size = tx_size / 4;
-	for (i = 0; i < size; i++) {
-		memcpy(&data, txbuf, 4);
-		data = qspi_endian_xchg(data);
-		qspi_write32(priv->flags, &regs->tbdr, data);
-		txbuf += 4;
+	if (cs > 1) {
+		puts("FSL_QSPI: Not a valid cs !\n");
+		return NULL;
 	}
 
-	size = tx_size % 4;
-	if (size) {
-		data = 0;
-		memcpy(&data, txbuf, size);
-		data = qspi_endian_xchg(data);
-		qspi_write32(priv->flags, &regs->tbdr, data);
+	q = spi_alloc_slave(struct fsl_qspi, bus, cs);
+	if (!q) {
+		puts("FSL_QSPI: SPI Slave not allocated !\n");
+		return NULL;
 	}
 
-	qspi_write32(priv->flags, &regs->ipcr,
-		     (seqid << QSPI_IPCR_SEQID_SHIFT) | tx_size);
-	while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-		;
+	q->iobase = CONFIG_QSPI_BASE;
+	q->bank_memmap_phy[0] = CONFIG_QSPI_MEMMAP_BASE;
+	q->bank_memmap_phy[1] = q->bank_memmap_phy[0] + QUADSPI_AHBMAP_BANK_MAXSIZE;
+	q->bank_memmap_phy[2] = q->bank_memmap_phy[1] + QUADSPI_AHBMAP_BANK_MAXSIZE;
+	q->bank_memmap_phy[3] = q->bank_memmap_phy[2] + QUADSPI_AHBMAP_BANK_MAXSIZE;
 
-	qspi_write32(priv->flags, &regs->mcr, mcr_reg);
-}
-
-static void qspi_op_rdsr(struct fsl_qspi_priv *priv, void *rxbuf, u32 len)
-{
-	struct fsl_qspi_regs *regs = priv->regs;
-	u32 mcr_reg, reg, data;
-
-	mcr_reg = qspi_read32(priv->flags, &regs->mcr);
-	qspi_write32(priv->flags, &regs->mcr,
-		     QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
-		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
-	qspi_write32(priv->flags, &regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
-
-	qspi_write32(priv->flags, &regs->sfar, priv->cur_amba_base);
-
-	qspi_write32(priv->flags, &regs->ipcr,
-		     (SEQID_RDSR << QSPI_IPCR_SEQID_SHIFT) | 0);
-	while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-		;
-
-	while (1) {
-		reg = qspi_read32(priv->flags, &regs->rbsr);
-		if (reg & QSPI_RBSR_RDBFL_MASK) {
-			data = qspi_read32(priv->flags, &regs->rbdr[0]);
-			data = qspi_endian_xchg(data);
-			memcpy(rxbuf, &data, len);
-			qspi_write32(priv->flags, &regs->mcr,
-				     qspi_read32(priv->flags, &regs->mcr) |
-				     QSPI_MCR_CLR_RXF_MASK);
-			break;
-		}
+	/* Init the QuadSPI controller */
+	ret = fsl_qspi_init(q);
+	if (ret) {
+		puts("FSL_QSPI: init failed!\n");
+		return NULL;
 	}
 
-	qspi_write32(priv->flags, &regs->mcr, mcr_reg);
+	return &q->slave;
 }
 
-static void qspi_op_erase(struct fsl_qspi_priv *priv)
+void spi_free_slave(struct spi_slave *slave)
 {
-	struct fsl_qspi_regs *regs = priv->regs;
-	u32 mcr_reg;
-	u32 to_or_from = 0;
-
-	mcr_reg = qspi_read32(priv->flags, &regs->mcr);
-	qspi_write32(priv->flags, &regs->mcr,
-		     QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
-		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
-	qspi_write32(priv->flags, &regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
-
-	to_or_from = priv->sf_addr + priv->cur_amba_base;
-	qspi_write32(priv->flags, &regs->sfar, to_or_from);
-
-	qspi_write32(priv->flags, &regs->ipcr,
-		     (SEQID_WREN << QSPI_IPCR_SEQID_SHIFT) | 0);
-	while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-		;
-
-	if (priv->cur_seqid == QSPI_CMD_SE) {
-		qspi_write32(priv->flags, &regs->ipcr,
-			     (SEQID_SE << QSPI_IPCR_SEQID_SHIFT) | 0);
-	} else if (priv->cur_seqid == QSPI_CMD_BE_4K) {
-		qspi_write32(priv->flags, &regs->ipcr,
-			     (SEQID_BE_4K << QSPI_IPCR_SEQID_SHIFT) | 0);
-	}
-	while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-		;
+	struct fsl_qspi *q;
 
-	qspi_write32(priv->flags, &regs->mcr, mcr_reg);
+	q = container_of(slave, struct fsl_qspi, slave);
+	free(q->devtype_data);
+	free(q);
 }
 
-int qspi_xfer(struct fsl_qspi_priv *priv, unsigned int bitlen,
-		const void *dout, void *din, unsigned long flags)
+int spi_claim_bus(struct spi_slave *q)
 {
-	u32 bytes = DIV_ROUND_UP(bitlen, 8);
-	static u32 wr_sfaddr;
-	u32 txbuf;
-
-	if (dout) {
-		if (flags & SPI_XFER_BEGIN) {
-			priv->cur_seqid = *(u8 *)dout;
-			memcpy(&txbuf, dout, 4);
-		}
-
-		if (flags == SPI_XFER_END) {
-			priv->sf_addr = wr_sfaddr;
-			qspi_op_write(priv, (u8 *)dout, bytes);
-			return 0;
-		}
-
-		if (priv->cur_seqid == QSPI_CMD_FAST_READ) {
-			priv->sf_addr = swab32(txbuf) & OFFSET_BITS_MASK;
-		} else if ((priv->cur_seqid == QSPI_CMD_SE) ||
-			   (priv->cur_seqid == QSPI_CMD_BE_4K)) {
-			priv->sf_addr = swab32(txbuf) & OFFSET_BITS_MASK;
-			qspi_op_erase(priv);
-		} else if (priv->cur_seqid == QSPI_CMD_PP) {
-			wr_sfaddr = swab32(txbuf) & OFFSET_BITS_MASK;
-		} else if ((priv->cur_seqid == QSPI_CMD_BRWR) ||
-			 (priv->cur_seqid == QSPI_CMD_WREAR)) {
-#ifdef CONFIG_SPI_FLASH_BAR
-			wr_sfaddr = 0;
-#endif
-		}
-	}
-
-	if (din) {
-		if (priv->cur_seqid == QSPI_CMD_FAST_READ) {
-#ifdef CONFIG_SYS_FSL_QSPI_AHB
-			qspi_ahb_read(priv, din, bytes);
-#else
-			qspi_op_read(priv, din, bytes);
-#endif
-		} else if (priv->cur_seqid == QSPI_CMD_RDID)
-			qspi_op_rdid(priv, din, bytes);
-		else if (priv->cur_seqid == QSPI_CMD_RDSR)
-			qspi_op_rdsr(priv, din, bytes);
-#ifdef CONFIG_SPI_FLASH_BAR
-		else if ((priv->cur_seqid == QSPI_CMD_BRRD) ||
-			 (priv->cur_seqid == QSPI_CMD_RDEAR)) {
-			priv->sf_addr = 0;
-			qspi_op_rdbank(priv, din, bytes);
-		}
-#endif
-	}
-
-#ifdef CONFIG_SYS_FSL_QSPI_AHB
-	if ((priv->cur_seqid == QSPI_CMD_SE) ||
-	    (priv->cur_seqid == QSPI_CMD_PP) ||
-	    (priv->cur_seqid == QSPI_CMD_BE_4K) ||
-	    (priv->cur_seqid == QSPI_CMD_WREAR) ||
-	    (priv->cur_seqid == QSPI_CMD_BRWR))
-		qspi_ahb_invalid(priv);
-#endif
-
 	return 0;
 }
 
-void qspi_module_disable(struct fsl_qspi_priv *priv, u8 disable)
-{
-	u32 mcr_val;
-
-	mcr_val = qspi_read32(priv->flags, &priv->regs->mcr);
-	if (disable)
-		mcr_val |= QSPI_MCR_MDIS_MASK;
-	else
-		mcr_val &= ~QSPI_MCR_MDIS_MASK;
-	qspi_write32(priv->flags, &priv->regs->mcr, mcr_val);
-}
-
-void qspi_cfg_smpr(struct fsl_qspi_priv *priv, u32 clear_bits, u32 set_bits)
+void spi_release_bus(struct spi_slave *q)
 {
-	u32 smpr_val;
-
-	smpr_val = qspi_read32(priv->flags, &priv->regs->smpr);
-	smpr_val &= ~clear_bits;
-	smpr_val |= set_bits;
-	qspi_write32(priv->flags, &priv->regs->smpr, smpr_val);
 }
-#ifndef CONFIG_DM_SPI
-static unsigned long spi_bases[] = {
-	QSPI0_BASE_ADDR,
-#ifdef CONFIG_MX6SX
-	QSPI1_BASE_ADDR,
-#endif
-};
 
-static unsigned long amba_bases[] = {
-	QSPI0_AMBA_BASE,
-#ifdef CONFIG_MX6SX
-	QSPI1_AMBA_BASE,
-#endif
-};
-
-static inline struct fsl_qspi *to_qspi_spi(struct spi_slave *slave)
+/* Get the SEQID for the command */
+static int fsl_qspi_get_seqid(struct fsl_qspi *q, u8 cmd)
 {
-	return container_of(slave, struct fsl_qspi, slave);
-}
-
-struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
-		unsigned int max_hz, unsigned int mode)
-{
-	struct fsl_qspi *qspi;
-	struct fsl_qspi_regs *regs;
-	u32 total_size;
-
-	if (bus >= ARRAY_SIZE(spi_bases))
-		return NULL;
-
-	if (cs >= FSL_QSPI_FLASH_NUM)
-		return NULL;
-
-	qspi = spi_alloc_slave(struct fsl_qspi, bus, cs);
-	if (!qspi)
-		return NULL;
-
-#ifdef CONFIG_SYS_FSL_QSPI_BE
-	qspi->priv.flags |= QSPI_FLAG_REGMAP_ENDIAN_BIG;
-#endif
-
-	regs = (struct fsl_qspi_regs *)spi_bases[bus];
-	qspi->priv.regs = regs;
-	/*
-	 * According cs, use different amba_base to choose the
-	 * corresponding flash devices.
-	 *
-	 * If not, only one flash device is used even if passing
-	 * different cs using `sf probe`
-	 */
-	qspi->priv.cur_amba_base = amba_bases[bus] + cs * FSL_QSPI_FLASH_SIZE;
-
-	qspi->slave.max_write_size = TX_BUFFER_SIZE;
-
-	qspi_write32(qspi->priv.flags, &regs->mcr,
-		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_MDIS_MASK);
-
-	qspi_cfg_smpr(&qspi->priv,
-		      ~(QSPI_SMPR_FSDLY_MASK | QSPI_SMPR_DDRSMP_MASK |
-		      QSPI_SMPR_FSPHS_MASK | QSPI_SMPR_HSENA_MASK), 0);
-
-	total_size = FSL_QSPI_FLASH_SIZE * FSL_QSPI_FLASH_NUM;
-	/*
-	 * Any read access to non-implemented addresses will provide
-	 * undefined results.
-	 *
-	 * In case single die flash devices, TOP_ADDR_MEMA2 and
-	 * TOP_ADDR_MEMB2 should be initialized/programmed to
-	 * TOP_ADDR_MEMA1 and TOP_ADDR_MEMB1 respectively - in effect,
-	 * setting the size of these devices to 0.  This would ensure
-	 * that the complete memory map is assigned to only one flash device.
-	 */
-	qspi_write32(qspi->priv.flags, &regs->sfa1ad,
-		     FSL_QSPI_FLASH_SIZE | amba_bases[bus]);
-	qspi_write32(qspi->priv.flags, &regs->sfa2ad,
-		     FSL_QSPI_FLASH_SIZE | amba_bases[bus]);
-	qspi_write32(qspi->priv.flags, &regs->sfb1ad,
-		     total_size | amba_bases[bus]);
-	qspi_write32(qspi->priv.flags, &regs->sfb2ad,
-		     total_size | amba_bases[bus]);
-
-	qspi_set_lut(&qspi->priv);
-
-#ifdef CONFIG_SYS_FSL_QSPI_AHB
-	qspi_init_ahb_read(&qspi->priv);
+	switch (cmd) {
+	case OPCODE_QUAD_READ:
+	case OPCODE_QUAD_READ_4B:
+		return SEQID_QUAD_READ;
+	case OPCODE_FAST_READ:
+	case OPCODE_FAST_READ_4B:
+		return SEQID_FAST_READ;
+	case OPCODE_WREN:
+		return SEQID_WREN;
+	case OPCODE_RDSR:
+		return SEQID_RDSR;
+	case OPCODE_SE:
+		return SEQID_SE;
+	case OPCODE_CHIP_ERASE:
+		return SEQID_CHIP_ERASE;
+	case OPCODE_PP:
+	case OPCODE_PP_4B:
+		return SEQID_PP;
+	case OPCODE_RDID:
+		return SEQID_RDID;
+	case OPCODE_WRSR:
+		return SEQID_WRSR;
+	case OPCODE_RDCR:
+		return SEQID_RDCR;
+	case OPCODE_DDR_QUAD_READ:
+		return SEQID_DDR_QUAD_READ;
+	case OPCODE_BE_4K:
+		return SEQID_BE_4K;
+#ifdef CONFIG_SPI_FLASH_BAR
+	case OPCODE_BRRD:
+		return SEQID_BRRD;
+	case OPCODE_BRWR:
+		return SEQID_BRWR;
+	case OPCODE_RDEAR:
+		return SEQID_RDEAR;
+	case OPCODE_WREAR:
+		return SEQID_WREAR;
 #endif
-
-	qspi_module_disable(&qspi->priv, 0);
-
-	return &qspi->slave;
+	default:
+		break;
+	}
+	return -1;
 }
 
-void spi_free_slave(struct spi_slave *slave)
+/* return 1 on success */
+static int fsl_qspi_wait_to_complete(struct fsl_qspi *q)
 {
-	struct fsl_qspi *qspi = to_qspi_spi(slave);
+	u32 base = q->iobase;
+	u32 reg;
 
-	free(qspi);
-}
+	/*printf("QuadSPI: poll the busy bit\n");*/
+	while (1) {
+		reg = readl(base + QUADSPI_SR);
+		if (reg & 1)
+			continue;
+		else
+			return 1;
+	}
 
-int spi_claim_bus(struct spi_slave *slave)
-{
 	return 0;
 }
 
-void spi_release_bus(struct spi_slave *slave)
-{
-	/* Nothing to do */
-}
-
-int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
-		const void *dout, void *din, unsigned long flags)
+/*
+ * If we have changed the content of the flash by writing or erasing,
+ * we need to invalidate the AHB buffer. If we do not do so, we may read out
+ * the wrong data. The spec tells us reset the AHB domain and Serial Flash
+ * domain at the same time.
+ */
+static inline void fsl_qspi_invalid(struct fsl_qspi *q)
 {
-	struct fsl_qspi *qspi = to_qspi_spi(slave);
-
-	return qspi_xfer(&qspi->priv, bitlen, dout, din, flags);
-}
+    u32 reg;
 
-void spi_init(void)
-{
-	/* Nothing to do */
-}
-#else
-static int fsl_qspi_child_pre_probe(struct udevice *dev)
-{
-	struct spi_slave *slave = dev_get_parent_priv(dev);
+    reg = readl(q->iobase + QUADSPI_MCR);
+    reg |= QUADSPI_MCR_SWRSTHD_MASK | QUADSPI_MCR_SWRSTSD_MASK;
+    writel(reg, q->iobase + QUADSPI_MCR);
 
-	slave->max_write_size = TX_BUFFER_SIZE;
+    /*
+     * The minimum delay : 1 AHB + 2 SFCK clocks.
+     * Delay 1 us is enough.
+     */
+    udelay(1);
 
-	return 0;
+    reg &= ~(QUADSPI_MCR_SWRSTHD_MASK | QUADSPI_MCR_SWRSTSD_MASK);
+    writel(reg, q->iobase + QUADSPI_MCR);
 }
 
-static int fsl_qspi_probe(struct udevice *bus)
+static int
+fsl_qspi_runcmd(struct fsl_qspi *q, u8 cmd, unsigned int addr, int len)
 {
-	u32 total_size;
-	struct fsl_qspi_platdata *plat = dev_get_platdata(bus);
-	struct fsl_qspi_priv *priv = dev_get_priv(bus);
-	struct dm_spi_bus *dm_spi_bus;
-
-	dm_spi_bus = bus->uclass_priv;
-
-	dm_spi_bus->max_hz = plat->speed_hz;
-
-	priv->regs = (struct fsl_qspi_regs *)(uintptr_t)plat->reg_base;
-	priv->flags = plat->flags;
-
-	priv->speed_hz = plat->speed_hz;
-	priv->amba_base[0] = plat->amba_base;
-	priv->amba_total_size = plat->amba_total_size;
-	priv->flash_num = plat->flash_num;
-	priv->num_chipselect = plat->num_chipselect;
-
-	qspi_write32(priv->flags, &priv->regs->mcr,
-		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_MDIS_MASK);
+	u32 base = q->iobase;
+	int seqid;
+	u32 reg, reg2;
+	int err;
+	int bank_id;
 
-	qspi_cfg_smpr(priv, ~(QSPI_SMPR_FSDLY_MASK | QSPI_SMPR_DDRSMP_MASK |
-		QSPI_SMPR_FSPHS_MASK | QSPI_SMPR_HSENA_MASK), 0);
+	/* check the SR first, wait previous cmd completed*/
+	do {
+		reg2 = readl(base + QUADSPI_SR);
+		if (reg2 & (QUADSPI_SR_IP_ACC_MASK | QUADSPI_SR_AHB_ACC_MASK)) {
+			udelay(1);
+			printf("The controller is busy, 0x%x\n", reg2);
+			continue;
+		}
+		break;
+	} while (1);
 
-	total_size = FSL_QSPI_FLASH_SIZE * FSL_QSPI_FLASH_NUM;
-	/*
-	 * Any read access to non-implemented addresses will provide
-	 * undefined results.
-	 *
-	 * In case single die flash devices, TOP_ADDR_MEMA2 and
-	 * TOP_ADDR_MEMB2 should be initialized/programmed to
-	 * TOP_ADDR_MEMA1 and TOP_ADDR_MEMB1 respectively - in effect,
-	 * setting the size of these devices to 0.  This would ensure
-	 * that the complete memory map is assigned to only one flash device.
-	 */
-	qspi_write32(priv->flags, &priv->regs->sfa1ad,
-		     FSL_QSPI_FLASH_SIZE | priv->amba_base[0]);
-	qspi_write32(priv->flags, &priv->regs->sfa2ad,
-		     FSL_QSPI_FLASH_SIZE | priv->amba_base[0]);
-	qspi_write32(priv->flags, &priv->regs->sfb1ad,
-		     total_size | priv->amba_base[0]);
-	qspi_write32(priv->flags, &priv->regs->sfb2ad,
-		     total_size | priv->amba_base[0]);
+	/* save the reg */
+	reg = readl(base + QUADSPI_MCR);
 
-	qspi_set_lut(priv);
+	/* get the bank index */
+	bank_id = ((q->slave.bus) << 1) + (q->slave.cs);
 
-#ifdef CONFIG_SYS_FSL_QSPI_AHB
-	qspi_init_ahb_read(priv);
-#endif
+	writel(q->bank_memmap_phy[bank_id] + addr, base + QUADSPI_SFAR);
+	writel(QUADSPI_RBCT_WMRK_MASK | QUADSPI_RBCT_RXBRD_USEIPS,
+			base + QUADSPI_RBCT);
+	writel(reg | QUADSPI_MCR_CLR_RXF_MASK, base + QUADSPI_MCR);
+
+	/* trigger the LUT now */
+	seqid = fsl_qspi_get_seqid(q, cmd);
+	writel((seqid << QUADSPI_IPCR_SEQID_SHIFT) | len, base + QUADSPI_IPCR);
+
+	/* Wait until completed */
+	err = fsl_qspi_wait_to_complete(q);
+	if (!err)
+		err = -1;
+	else
+		err = 0;
 
-	qspi_module_disable(priv, 0);
+	/* restore the MCR */
+	writel(reg, base + QUADSPI_MCR);
 
-	return 0;
+	/* After switch BANK, AHB buffer should also be invalid. */
+	if ((OPCODE_SE == cmd) || (OPCODE_PP == cmd) ||
+	    (OPCODE_BE_4K == cmd) || (OPCODE_WREAR == cmd) ||
+	    (OPCODE_BRWR == cmd))
+		fsl_qspi_invalid(q);
+	return err;
 }
 
-static int fsl_qspi_ofdata_to_platdata(struct udevice *bus)
+/*
+ * An IC bug makes us to re-arrange the 32-bit data.
+ * The following chips, such as IMX6SLX, have fixed this bug.
+ */
+static inline u32 fsl_qspi_endian_xchg(struct fsl_qspi *q, u32 a)
 {
-	struct reg_data {
-		u32 addr;
-		u32 size;
-	} regs_data[2];
-	struct fsl_qspi_platdata *plat = bus->platdata;
-	const void *blob = gd->fdt_blob;
-	int node = bus->of_offset;
-	int ret, flash_num = 0, subnode;
-
-	if (fdtdec_get_bool(blob, node, "big-endian"))
-		plat->flags |= QSPI_FLAG_REGMAP_ENDIAN_BIG;
-
-	ret = fdtdec_get_int_array(blob, node, "reg", (u32 *)regs_data,
-				   sizeof(regs_data)/sizeof(u32));
-	if (ret) {
-		debug("Error: can't get base addresses (ret = %d)!\n", ret);
-		return -ENOMEM;
-	}
-
-	/* Count flash numbers */
-	fdt_for_each_subnode(blob, subnode, node)
-		++flash_num;
-
-	if (flash_num == 0) {
-		debug("Error: Missing flashes!\n");
-		return -ENODEV;
-	}
-
-	plat->speed_hz = fdtdec_get_int(blob, node, "spi-max-frequency",
-					FSL_QSPI_DEFAULT_SCK_FREQ);
-	plat->num_chipselect = fdtdec_get_int(blob, node, "num-cs",
-					      FSL_QSPI_MAX_CHIPSELECT_NUM);
-
-	plat->reg_base = regs_data[0].addr;
-	plat->amba_base = regs_data[1].addr;
-	plat->amba_total_size = regs_data[1].size;
-	plat->flash_num = flash_num;
-
-	debug("%s: regs=<0x%x> <0x%x, 0x%x>, max-frequency=%d, endianess=%s\n",
-	      __func__,
-	      plat->reg_base,
-	      plat->amba_base,
-	      plat->amba_total_size,
-	      plat->speed_hz,
-	      plat->flags & QSPI_FLAG_REGMAP_ENDIAN_BIG ? "be" : "le"
-	      );
-
-	return 0;
+	return a;
 }
 
-static int fsl_qspi_xfer(struct udevice *dev, unsigned int bitlen,
-		const void *dout, void *din, unsigned long flags)
+/* Read out the data from the AHB buffer. */
+static void fsl_qspi_ahb_read(struct fsl_qspi *q,
+	unsigned int addr, int len, u8 *rxbuf)
 {
-	struct fsl_qspi_priv *priv;
-	struct udevice *bus;
+	int bank_id;
 
-	bus = dev->parent;
-	priv = dev_get_priv(bus);
+	/* get the bank index */
+	bank_id = ((q->slave.bus) << 1) + (q->slave.cs);
 
-	return qspi_xfer(priv, bitlen, dout, din, flags);
+	/* Read out the data directly from the AHB buffer.*/
+	memcpy(rxbuf, (u8 *)(q->bank_memmap_phy[bank_id] + addr), len);
 }
 
-static int fsl_qspi_claim_bus(struct udevice *dev)
+/* Read out the data from the QUADSPI_RBDR buffer registers. */
+static void fsl_qspi_ip_read(struct fsl_qspi *q, int len, u8 *rxbuf)
 {
-	struct fsl_qspi_priv *priv;
-	struct udevice *bus;
-	struct dm_spi_slave_platdata *slave_plat = dev_get_parent_platdata(dev);
+	u32 tmp;
+	int i = 0;
 
-	bus = dev->parent;
-	priv = dev_get_priv(bus);
-
-	priv->cur_amba_base =
-		priv->amba_base[0] + FSL_QSPI_FLASH_SIZE * slave_plat->cs;
+	while (len > 0) {
+		tmp = readl(q->iobase + QUADSPI_RBDR + i * 4);
+		tmp = fsl_qspi_endian_xchg(q, tmp);
 
-	qspi_module_disable(priv, 0);
+		if (len >= 4) {
+			memcpy(rxbuf, &tmp, 4);
+			rxbuf += 4;
+		} else {
+			memcpy(rxbuf, &tmp, len);
+			break;
+		}
 
-	return 0;
+		len -= 4;
+		i++;
+	}
 }
 
-static int fsl_qspi_release_bus(struct udevice *dev)
+/* Write data to the QUADSPI_TBDR buffer registers. */
+static void fsl_qspi_write_data(struct fsl_qspi *q, int len, u8* txbuf)
 {
-	struct fsl_qspi_priv *priv;
-	struct udevice *bus;
+	u32 tmp;
+	u32 t1, t2;
+	int j;
 
-	bus = dev->parent;
-	priv = dev_get_priv(bus);
+	/* clear the TX FIFO. */
+	tmp = readl(q->iobase + QUADSPI_MCR);
+	writel(tmp | QUADSPI_MCR_CLR_TXF_MASK, q->iobase + QUADSPI_MCR);
 
-	qspi_module_disable(priv, 1);
+	/* fill the TX data to the FIFO */
+	t2 = len % 4;
+	t1 = len >> 2; /* 4 Bytes aligned */
 
-	return 0;
-}
+	for (j = 0; j < t1; j++) {
+		memcpy(&tmp, txbuf, 4);
+		tmp = fsl_qspi_endian_xchg(q, tmp);
+		writel(tmp, q->iobase + QUADSPI_TBDR);
+		txbuf += 4;
+	}
 
-static int fsl_qspi_set_speed(struct udevice *bus, uint speed)
-{
-	/* Nothing to do */
-	return 0;
-}
+	if (t2) {
+		tmp = 0;
+		memcpy(&tmp, txbuf, t2);
+		tmp = fsl_qspi_endian_xchg(q, tmp);
+		writel(tmp, q->iobase + QUADSPI_TBDR);
+	}
+
+#if defined(CONFIG_MX7D) || defined(CONFIG_MX6UL)
+	u32 t3;
+	/* iMX7D and MX6UL TXFIFO must be at least 16 bytes*/
+	t3 = t1 + ((t2 + 3) >> 2);
+	for (; t3 < 4; t3++)
+		writel(0, q->iobase + QUADSPI_TBDR);
+#endif
 
-static int fsl_qspi_set_mode(struct udevice *bus, uint mode)
-{
-	/* Nothing to do */
-	return 0;
 }
 
-static const struct dm_spi_ops fsl_qspi_ops = {
-	.claim_bus	= fsl_qspi_claim_bus,
-	.release_bus	= fsl_qspi_release_bus,
-	.xfer		= fsl_qspi_xfer,
-	.set_speed	= fsl_qspi_set_speed,
-	.set_mode	= fsl_qspi_set_mode,
-};
+/* see the spi_flash_read_write() */
+int  spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
+		void *din, unsigned long flags)
+{
+	struct fsl_qspi *q = container_of(slave, struct fsl_qspi, slave);
+	int len = bitlen / 8;
+	int ret = 0;
+	u8 *buf;
+	static u8 opcode;
+	static unsigned int addr;
+
+	if (!opcode && (flags & SPI_XFER_BEGIN)) {
+		/* spi_xfer for cmd phase */
+		buf = (u8 *)dout;
+		opcode = buf[0];
+		if (len > 1)
+			addr = buf[1] << 16 | buf[2] << 8 | buf[3];
+
+		/* if transfer cmd only */
+		if (flags & SPI_XFER_END)
+			ret = fsl_qspi_runcmd(q, opcode, addr, 0);
+
+	} else if (opcode) {
+		/* spi_xfer for data phase */
+		if (din) {
+			/* read*/
+			buf = (u8 *)din;
+			if (OPCODE_FAST_READ == opcode) {
+				fsl_qspi_ahb_read(q, addr, len, buf);
+			} else {
+				ret = fsl_qspi_runcmd(q, opcode, addr, len);
+				if (!ret)
+					fsl_qspi_ip_read(q, len, buf);
+			}
+		} else if (dout) {
+			/* write data, prepare data first */
+			buf = (u8 *)dout;
+			fsl_qspi_write_data(q, len, buf);
+			/* then run page program cmd */
+			ret = fsl_qspi_runcmd(q, opcode, addr, len);
+		}
+	}
 
-static const struct udevice_id fsl_qspi_ids[] = {
-	{ .compatible = "fsl,vf610-qspi" },
-	{ .compatible = "fsl,imx6sx-qspi" },
-	{ }
-};
+	if (ret || (flags & SPI_XFER_END)) {
+		opcode = 0;
+		addr = 0;
+	}
 
-U_BOOT_DRIVER(fsl_qspi) = {
-	.name	= "fsl_qspi",
-	.id	= UCLASS_SPI,
-	.of_match = fsl_qspi_ids,
-	.ops	= &fsl_qspi_ops,
-	.ofdata_to_platdata = fsl_qspi_ofdata_to_platdata,
-	.platdata_auto_alloc_size = sizeof(struct fsl_qspi_platdata),
-	.priv_auto_alloc_size = sizeof(struct fsl_qspi_priv),
-	.probe	= fsl_qspi_probe,
-	.child_pre_probe = fsl_qspi_child_pre_probe,
-};
-#endif
+	return ret;
+}
diff -urN u-boot-2016.03/drivers/spi/mxc_spi.c ebf_6ull_uboot/drivers/spi/mxc_spi.c
--- u-boot-2016.03/drivers/spi/mxc_spi.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/spi/mxc_spi.c	2021-04-16 14:42:16.312589169 +0800
@@ -1,6 +1,8 @@
 /*
  * Copyright (C) 2008, Guennadi Liakhovetski <lg@denx.de>
  *
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -13,6 +15,7 @@
 #include <asm/arch/imx-regs.h>
 #include <asm/arch/clock.h>
 #include <asm/imx-common/spi.h>
+#include <asm/arch/sys_proto.h>
 
 #ifdef CONFIG_MX27
 /* i.MX27 has a completely wrong register layout and register definitions in the
@@ -413,6 +416,13 @@
 		return NULL;
 	}
 
+#ifdef CONFIG_MX6
+	if (mx6_ecspi_fused(spi_bases[bus])) {
+		printf("ECSPI@0x%lx is fused, disable it\n", spi_bases[bus]);
+		return NULL;
+	}
+#endif
+
 	mxcs = spi_alloc_slave(struct mxc_spi_slave, bus, cs);
 	if (!mxcs) {
 		puts("mxc_spi: SPI Slave not allocated !\n");
diff -urN u-boot-2016.03/drivers/thermal/imx_thermal.c ebf_6ull_uboot/drivers/thermal/imx_thermal.c
--- u-boot-2016.03/drivers/thermal/imx_thermal.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/thermal/imx_thermal.c	2021-04-16 14:42:16.312589169 +0800
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2014 Freescale Semiconductor, Inc.
+ * (C) Copyright 2014-2016 Freescale Semiconductor, Inc.
  * Author: Nitin Garg <nitin.garg@freescale.com>
  *             Ye Li <Ye.Li@freescale.com>
  *
@@ -22,8 +22,9 @@
 /* board will busyloop until this many degrees C below CPU max temperature */
 #define TEMPERATURE_HOT_DELTA   5 /* CPU maxT - 5C */
 #define FACTOR0			10000000
-#define FACTOR1			15976
-#define FACTOR2			4297157
+#define FACTOR1			15423
+#define FACTOR2			4148468
+#define OFFSET			3580661
 #define MEASURE_FREQ		327
 #define TEMPERATURE_MIN         -40
 #define TEMPERATURE_HOT         85
@@ -54,39 +55,42 @@
 	struct thermal_data *priv = dev_get_priv(dev);
 	u32 fuse = priv->fuse;
 	int t1, n1;
-	u32 c1, c2;
+	u64 c1, c2;
 	u64 temp64;
 
 	/*
 	 * Sensor data layout:
 	 *   [31:20] - sensor value @ 25C
 	 * We use universal formula now and only need sensor value @ 25C
-	 * slope = 0.4297157 - (0.0015976 * 25C fuse)
+	 * slope = 0.4445388 - (0.0016549 * 25C fuse)
 	 */
 	n1 = fuse >> 20;
 	t1 = 25; /* t1 always 25C */
 
 	/*
 	 * Derived from linear interpolation:
-	 * slope = 0.4297157 - (0.0015976 * 25C fuse)
+	 * slope = 0.4445388 - (0.0016549 * 25C fuse)
 	 * slope = (FACTOR2 - FACTOR1 * n1) / FACTOR0
+	 * offset = 3.580661
+	 * offset = OFFSET / 1000000
 	 * (Nmeas - n1) / (Tmeas - t1) = slope
 	 * We want to reduce this down to the minimum computation necessary
 	 * for each temperature read.  Also, we want Tmeas in millicelsius
 	 * and we don't want to lose precision from integer division. So...
-	 * Tmeas = (Nmeas - n1) / slope + t1
-	 * milli_Tmeas = 1000 * (Nmeas - n1) / slope + 1000 * t1
-	 * milli_Tmeas = -1000 * (n1 - Nmeas) / slope + 1000 * t1
-	 * Let constant c1 = (-1000 / slope)
-	 * milli_Tmeas = (n1 - Nmeas) * c1 + 1000 * t1
-	 * Let constant c2 = n1 *c1 + 1000 * t1
-	 * milli_Tmeas = c2 - Nmeas * c1
+	 * Tmeas = (Nmeas - n1) / slope + t1 + offset
+	 * milli_Tmeas = 1000000 * (Nmeas - n1) / slope + 1000000 * t1 + OFFSET
+	 * milli_Tmeas = -1000000 * (n1 - Nmeas) / slope + 1000000 * t1 + OFFSET
+	 * Let constant c1 = (-1000000 / slope)
+	 * milli_Tmeas = (n1 - Nmeas) * c1 + 1000000 * t1 + OFFSET
+	 * Let constant c2 = n1 *c1 + 1000000 * t1
+	 * milli_Tmeas = (c2 - Nmeas * c1) / 1000000 + OFFSET
+	 * Tmeas = ((c2 - Nmeas * c1) + OFFSET) / 1000000
 	 */
 	temp64 = FACTOR0;
-	temp64 *= 1000;
+	temp64 *= 1000000;
 	do_div(temp64, FACTOR1 * n1 - FACTOR2);
 	c1 = temp64;
-	c2 = n1 * c1 + 1000 * t1;
+	c2 = n1 * c1 + 1000000 * t1;
 
 	/*
 	 * now we only use single measure, every time we read
@@ -118,8 +122,8 @@
 		>> TEMPSENSE0_TEMP_CNT_SHIFT;
 	writel(TEMPSENSE0_FINISHED, &anatop->tempsense0_clr);
 
-	/* milli_Tmeas = c2 - Nmeas * c1 */
-	temperature = (long)(c2 - n_meas * c1)/1000;
+	/* Tmeas = (c2 - Nmeas * c1 + OFFSET) / 1000000 */
+	temperature = lldiv(c2 - n_meas * c1 + OFFSET, 1000000);
 
 	/* power down anatop thermal sensor */
 	writel(TEMPSENSE0_POWER_DOWN, &anatop->tempsense0_set);
diff -urN u-boot-2016.03/drivers/usb/gadget/f_fastboot.c ebf_6ull_uboot/drivers/usb/gadget/f_fastboot.c
--- u-boot-2016.03/drivers/usb/gadget/f_fastboot.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/usb/gadget/f_fastboot.c	2021-04-16 14:42:16.320589210 +0800
@@ -8,6 +8,8 @@
  * Copyright 2014 Linaro, Ltd.
  * Rob Herring <robh@kernel.org>
  *
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 #include <config.h>
@@ -28,6 +30,20 @@
 #include <fb_nand.h>
 #endif
 
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#include <mmc.h>
+#include <android_image.h>
+#include <asm/bootm.h>
+#include <nand.h>
+#include <part.h>
+#include <sparse_format.h>
+#include <image-sparse.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif
+
 #define FASTBOOT_VERSION		"0.4"
 
 #define FASTBOOT_INTERFACE_CLASS	0xff
@@ -124,6 +140,1855 @@
 	NULL,
 };
 
+#ifdef CONFIG_FSL_FASTBOOT
+
+#define ANDROID_MBR_OFFSET	    0
+#define ANDROID_MBR_SIZE	    0x200
+#define ANDROID_BOOTLOADER_OFFSET   0x400
+#define ANDROID_BOOTLOADER_SIZE	    0xFFC00
+#define ANDROID_KERNEL_OFFSET	    0x100000
+#define ANDROID_KERNEL_SIZE	    0x500000
+#define ANDROID_URAMDISK_OFFSET	    0x600000
+#define ANDROID_URAMDISK_SIZE	    0x100000
+
+
+
+#define MMC_SATA_BLOCK_SIZE 512
+#define FASTBOOT_FBPARTS_ENV_MAX_LEN 1024
+/* To support the Android-style naming of flash */
+#define MAX_PTN		    16
+
+
+/*pentry index internally*/
+enum {
+    PTN_MBR_INDEX = 0,
+    PTN_BOOTLOADER_INDEX,
+    PTN_KERNEL_INDEX,
+    PTN_URAMDISK_INDEX,
+    PTN_SYSTEM_INDEX,
+    PTN_RECOVERY_INDEX,
+    PTN_DATA_INDEX
+};
+
+static unsigned int download_bytes_unpadded;
+
+static struct cmd_fastboot_interface interface = {
+	.rx_handler            = NULL,
+	.reset_handler         = NULL,
+	.product_name          = NULL,
+	.serial_no             = NULL,
+	.nand_block_size       = 0,
+	.transfer_buffer       = (unsigned char *)0xffffffff,
+	.transfer_buffer_size  = 0,
+};
+
+
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+static void save_env(struct fastboot_ptentry *ptn,
+		     char *var, char *val)
+{
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	char lock[128], unlock[128];
+#endif
+
+	setenv(var, val);
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	sprintf(lock, "nand lock 0x%x 0x%x", ptn->start, ptn->length);
+	sprintf(unlock, "nand unlock 0x%x 0x%x", ptn->start, ptn->length);
+
+	/* This could be a problem is there is an outstanding lock */
+	run_command(unlock, 0);
+#endif
+	saveenv();
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	run_command(lock, 0);
+#endif
+}
+
+void save_parts_values(struct fastboot_ptentry *ptn,
+			      unsigned int offset,
+			      unsigned int size)
+{
+	char var[64], val[32];
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	char lock[128], unlock[128];
+	struct fastboot_ptentry *env_ptn;
+#endif
+
+	printf("saving it..\n");
+
+
+	sprintf(var, "%s_nand_offset", ptn->name);
+	sprintf(val, "0x%x", offset);
+
+	printf("setenv %s %s\n", var, val);
+
+	setenv(var, val);
+
+	sprintf(var, "%s_nand_size", ptn->name);
+	sprintf(val, "0x%x", size);
+
+	printf("setenv %s %s\n", var, val);
+
+	setenv(var, val);
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	/* Warning :
+	   The environment is assumed to be in a partition named 'enviroment'.
+	   It is very possible that your board stores the enviroment
+	   someplace else. */
+	env_ptn = fastboot_flash_find_ptn("environment");
+
+	if (env_ptn) {
+		sprintf(lock, "nand lock 0x%x 0x%x",
+			env_ptn->start, env_ptn->length);
+		sprintf(unlock, "nand unlock 0x%x 0x%x",
+			env_ptn->start, env_ptn->length);
+
+		run_command(unlock, 0);
+	}
+#endif
+	saveenv();
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	if (env_ptn)
+		run_command(lock, 0);
+#endif
+}
+
+int check_parts_values(struct fastboot_ptentry *ptn)
+{
+	char var[64];
+
+	sprintf(var, "%s_nand_offset", ptn->name);
+	if (!getenv(var))
+		return 1;
+
+	sprintf(var, "%s_nand_size", ptn->name);
+	if (!getenv(var))
+		return 1;
+
+	return 0;
+}
+
+static int write_to_ptn(struct fastboot_ptentry *ptn)
+{
+	int ret = 1;
+	char length[32];
+	char write_type[32];
+	int repeat, repeat_max;
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	char lock[128];
+	char unlock[128];
+#endif
+	char write[128];
+	char erase[128];
+
+	printf("flashing '%s'\n", ptn->name);
+
+	/* Which flavor of write to use */
+	if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_I)
+		sprintf(write_type, "write.i");
+#ifdef CONFIG_CMD_NAND_TRIMFFS
+	else if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_TRIMFFS)
+		sprintf(write_type, "write.trimffs");
+#endif
+	else
+		sprintf(write_type, "write");
+
+	/* Some flashing requires writing the same data in multiple,
+	   consecutive flash partitions */
+	repeat_max = 1;
+	if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_REPEAT_MASK) {
+		if (ptn->flags &
+		    FASTBOOT_PTENTRY_FLAGS_WRITE_CONTIGUOUS_BLOCK) {
+			printf("Warning can not do both 'contiguous block' "
+				"and 'repeat' writes for for partition '%s'\n", ptn->name);
+			printf("Ignoring repeat flag\n");
+		} else {
+			repeat_max = ptn->flags &
+				FASTBOOT_PTENTRY_FLAGS_REPEAT_MASK;
+		}
+	}
+
+	/* Unlock the whole partition instead of trying to
+	   manage special cases */
+	sprintf(length, "0x%x", ptn->length * repeat_max);
+
+	for (repeat = 0; repeat < repeat_max; repeat++) {
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+		sprintf(lock, "nand lock 0x%x %s",
+			ptn->start + (repeat * ptn->length), length);
+		sprintf(unlock, "nand unlock 0x%x %s",
+			ptn->start + (repeat * ptn->length), length);
+#endif
+		sprintf(erase, "nand erase 0x%x %s",
+			ptn->start + (repeat * ptn->length), length);
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+		run_command(unlock, 0);
+#endif
+		run_command(erase, 0);
+
+		if ((ptn->flags &
+		     FASTBOOT_PTENTRY_FLAGS_WRITE_NEXT_GOOD_BLOCK) &&
+		    (ptn->flags &
+		     FASTBOOT_PTENTRY_FLAGS_WRITE_CONTIGUOUS_BLOCK)) {
+			/* Both can not be true */
+			printf("Warning can not do 'next good block' and \
+				'contiguous block' for partition '%s'\n",
+				ptn->name);
+			printf("Ignoring these flags\n");
+		} else if (ptn->flags &
+			   FASTBOOT_PTENTRY_FLAGS_WRITE_NEXT_GOOD_BLOCK) {
+			/* Keep writing until you get a good block
+			   transfer_buffer should already be aligned */
+			if (interface.nand_block_size) {
+				unsigned int blocks = download_bytes /
+					interface.nand_block_size;
+				unsigned int i = 0;
+				unsigned int offset = 0;
+
+				while (i < blocks) {
+					/* Check for overflow */
+					if (offset >= ptn->length)
+						break;
+
+					/* download's address only advance
+					   if last write was successful */
+
+					/* nand's address always advances */
+					sprintf(write, "nand %s 0x%p 0x%x 0x%x", write_type,
+						interface.transfer_buffer +
+						(i * interface.nand_block_size),
+						ptn->start + (repeat * ptn->length) + offset,
+						interface.nand_block_size);
+
+					ret = run_command(write, 0);
+					if (ret)
+						break;
+					else
+						i++;
+
+					/* Go to next nand block */
+					offset += interface.nand_block_size;
+				}
+			} else {
+				printf("Warning nand block size can not be 0 \
+					when using 'next good block' for \
+					partition '%s'\n", ptn->name);
+				printf("Ignoring write request\n");
+			}
+		} else if (ptn->flags &
+			 FASTBOOT_PTENTRY_FLAGS_WRITE_CONTIGUOUS_BLOCK) {
+			/* Keep writing until you get a good block
+			   transfer_buffer should already be aligned */
+			if (interface.nand_block_size) {
+				if (0 == nand_curr_device) {
+					nand_info_t *nand;
+					unsigned long off;
+					unsigned int ok_start;
+
+					nand = &nand_info[nand_curr_device];
+
+					printf("\nDevice %d bad blocks:\n",
+					       nand_curr_device);
+
+					/* Initialize the ok_start to the
+					   start of the partition
+					   Then try to find a block large
+					   enough for the download */
+					ok_start = ptn->start;
+
+					/* It is assumed that the start and
+					   length are multiples of block size */
+					for (off = ptn->start;
+					     off < ptn->start + ptn->length;
+					     off += nand->erasesize) {
+						if (nand_block_isbad(nand, off)) {
+							/* Reset the ok_start
+							   to the next block */
+							ok_start = off +
+								nand->erasesize;
+						}
+
+						/* Check if we have enough
+						   blocks */
+						if ((ok_start - off) >=
+						    download_bytes)
+							break;
+					}
+
+					/* Check if there is enough space */
+					if (ok_start + download_bytes <=
+					    ptn->start + ptn->length) {
+
+						sprintf(write, "nand %s 0x%p 0x%x 0x%x", write_type,
+							interface.transfer_buffer,
+							ok_start,
+							download_bytes);
+
+						ret = run_command(write, 0);
+
+						/* Save the results into an
+						   environment variable on the
+						   format
+						   ptn_name + 'offset'
+						   ptn_name + 'size'  */
+						if (ret) {
+							/* failed */
+							save_parts_values(ptn, ptn->start, 0);
+						} else {
+							/* success */
+							save_parts_values(ptn, ok_start, download_bytes);
+						}
+					} else {
+						printf("Error could not find enough contiguous space "
+							"in partition '%s'\n", ptn->name);
+						printf("Ignoring write request\n");
+					}
+				} else {
+					/* TBD : Generalize flash handling */
+					printf("Error only handling 1 NAND per board");
+					printf("Ignoring write request\n");
+				}
+			} else {
+				printf("Warning nand block size can not be 0 \
+					when using 'continuous block' for \
+					partition '%s'\n", ptn->name);
+				printf("Ignoring write request\n");
+			}
+		} else {
+			/* Normal case */
+			sprintf(write, "nand %s 0x%p 0x%x 0x%x", write_type,
+							interface.transfer_buffer,
+							ptn->start + (repeat * ptn->length),
+							download_bytes);
+#ifdef CONFIG_CMD_NAND_TRIMFFS
+			if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_TRIMFFS) {
+				sprintf(write, "nand %s 0x%p 0x%x 0x%x", write_type,
+							interface.transfer_buffer,
+							ptn->start + (repeat * ptn->length),
+							download_bytes_unpadded);
+			}
+#endif
+
+			ret = run_command(write, 0);
+
+			if (0 == repeat) {
+				if (ret) /* failed */
+					save_parts_values(ptn, ptn->start, 0);
+				else     /* success */
+					save_parts_values(ptn, ptn->start,
+							  download_bytes);
+			}
+		}
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+		run_command(lock, 0);
+#endif
+
+		if (ret)
+			break;
+	}
+
+	return ret;
+}
+#else
+static void save_env(struct fastboot_ptentry *ptn,
+		     char *var, char *val)
+{
+	setenv(var, val);
+	saveenv();
+}
+#endif
+
+/* When save = 0, just parse.  The input is unchanged
+   When save = 1, parse and do the save.  The input is changed */
+static int parse_env(void *ptn, char *err_string, int save, int debug)
+{
+	int ret = 1;
+	unsigned int sets = 0;
+	unsigned int comment_start = 0;
+	char *var = NULL;
+	char *var_end = NULL;
+	char *val = NULL;
+	char *val_end = NULL;
+	unsigned int i;
+
+	char *buff = (char *)interface.transfer_buffer;
+	unsigned int size = download_bytes_unpadded;
+
+	/* The input does not have to be null terminated.
+	   This will cause a problem in the corner case
+	   where the last line does not have a new line.
+	   Put a null after the end of the input.
+
+	   WARNING : Input buffer is assumed to be bigger
+	   than the size of the input */
+	if (save)
+		buff[size] = 0;
+
+	for (i = 0; i < size; i++) {
+
+		if (NULL == var) {
+
+			/*
+			 * Check for comments, comment ok only on
+			 * mostly empty lines
+			 */
+			if (buff[i] == '#')
+				comment_start = 1;
+
+			if (comment_start) {
+				if  ((buff[i] == '\r') ||
+				     (buff[i] == '\n')) {
+					comment_start = 0;
+				}
+			} else {
+				if (!((buff[i] == ' ') ||
+				      (buff[i] == '\t') ||
+				      (buff[i] == '\r') ||
+				      (buff[i] == '\n'))) {
+					/*
+					 * Normal whitespace before the
+					 * variable
+					 */
+					var = &buff[i];
+				}
+			}
+
+		} else if (((NULL == var_end) || (NULL == val)) &&
+			   ((buff[i] == '\r') || (buff[i] == '\n'))) {
+
+			/* This is the case when a variable
+			   is unset. */
+
+			if (save) {
+				/* Set the var end to null so the
+				   normal string routines will work
+
+				   WARNING : This changes the input */
+				buff[i] = '\0';
+
+				save_env(ptn, var, val);
+
+				if (debug)
+					printf("Unsetting %s\n", var);
+			}
+
+			/* Clear the variable so state is parse is back
+			   to initial. */
+			var = NULL;
+			var_end = NULL;
+			sets++;
+		} else if (NULL == var_end) {
+			if ((buff[i] == ' ') ||
+			    (buff[i] == '\t'))
+				var_end = &buff[i];
+		} else if (NULL == val) {
+			if (!((buff[i] == ' ') ||
+			      (buff[i] == '\t')))
+				val = &buff[i];
+		} else if (NULL == val_end) {
+			if ((buff[i] == '\r') ||
+			    (buff[i] == '\n')) {
+				/* look for escaped cr or ln */
+				if ('\\' == buff[i - 1]) {
+					/* check for dos */
+					if ((buff[i] == '\r') &&
+					    (buff[i+1] == '\n'))
+						buff[i + 1] = ' ';
+					buff[i - 1] = buff[i] = ' ';
+				} else {
+					val_end = &buff[i];
+				}
+			}
+		} else {
+			sprintf(err_string, "Internal Error");
+
+			if (debug)
+				printf("Internal error at %s %d\n",
+				       __FILE__, __LINE__);
+			return 1;
+		}
+		/* Check if a var / val pair is ready */
+		if (NULL != val_end) {
+			if (save) {
+				/* Set the end's with nulls so
+				   normal string routines will
+				   work.
+
+				   WARNING : This changes the input */
+				*var_end = '\0';
+				*val_end = '\0';
+
+				save_env(ptn, var, val);
+
+				if (debug)
+					printf("Setting %s %s\n", var, val);
+			}
+
+			/* Clear the variable so state is parse is back
+			   to initial. */
+			var = NULL;
+			var_end = NULL;
+			val = NULL;
+			val_end = NULL;
+
+			sets++;
+		}
+	}
+
+	/* Corner case
+	   Check for the case that no newline at end of the input */
+	if ((NULL != var) &&
+	    (NULL == val_end)) {
+		if (save) {
+			/* case of val / val pair */
+			if (var_end)
+				*var_end = '\0';
+			/* else case handled by setting 0 past
+			   the end of buffer.
+			   Similar for val_end being null */
+			save_env(ptn, var, val);
+
+			if (debug) {
+				if (var_end)
+					printf("Trailing Setting %s %s\n", var, val);
+				else
+					printf("Trailing Unsetting %s\n", var);
+			}
+		}
+		sets++;
+	}
+	/* Did we set anything ? */
+	if (0 == sets)
+		sprintf(err_string, "No variables set");
+	else
+		ret = 0;
+
+	return ret;
+}
+
+static int saveenv_to_ptn(struct fastboot_ptentry *ptn, char *err_string)
+{
+	int ret = 1;
+	int save = 0;
+	int debug = 0;
+
+	/* err_string is only 32 bytes
+	   Initialize with a generic error message. */
+	sprintf(err_string, "%s", "Unknown Error");
+
+	/* Parse the input twice.
+	   Only save to the enviroment if the entire input if correct */
+	save = 0;
+	if (0 == parse_env(ptn, err_string, save, debug)) {
+		save = 1;
+		ret = parse_env(ptn, err_string, save, debug);
+	}
+	return ret;
+}
+
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+
+static void process_flash_nand(const char *cmdbuf, char *response)
+{
+	if (download_bytes) {
+		struct fastboot_ptentry *ptn;
+
+		ptn = fastboot_flash_find_ptn(cmdbuf);
+		if (ptn == 0) {
+			sprintf(response, "FAILpartition does not exist");
+		} else if ((download_bytes > ptn->length) &&
+			   !(ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_ENV)) {
+			sprintf(response, "FAILimage too large for partition");
+			/* TODO : Improve check for yaffs write */
+		} else {
+			/* Check if this is not really a flash write
+			   but rather a saveenv */
+			if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_ENV) {
+				/* Since the response can only be 64 bytes,
+				   there is no point in having a large error message. */
+				char err_string[32];
+				if (saveenv_to_ptn(ptn, &err_string[0])) {
+					printf("savenv '%s' failed : %s\n",
+						ptn->name, err_string);
+					sprintf(response, "FAIL%s", err_string);
+				} else {
+					printf("partition '%s' saveenv-ed\n", ptn->name);
+					sprintf(response, "OKAY");
+				}
+			} else {
+				/* Normal case */
+				if (write_to_ptn(ptn)) {
+					printf("flashing '%s' failed\n", ptn->name);
+					sprintf(response, "FAILfailed to flash partition");
+				} else {
+					printf("partition '%s' flashed\n", ptn->name);
+					sprintf(response, "OKAY");
+				}
+			}
+		}
+	} else {
+		sprintf(response, "FAILno image downloaded");
+	}
+
+}
+#endif
+
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+static void process_flash_sata(const char *cmdbuf, char *response)
+{
+	if (download_bytes) {
+		struct fastboot_ptentry *ptn;
+
+		/* Next is the partition name */
+		ptn = fastboot_flash_find_ptn(cmdbuf);
+		if (ptn == 0) {
+			printf("Partition:'%s' does not exist\n", ptn->name);
+			sprintf(response, "FAILpartition does not exist");
+		} else if ((download_bytes >
+			   ptn->length * MMC_SATA_BLOCK_SIZE) &&
+				!(ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_ENV)) {
+			printf("Image too large for the partition\n");
+			sprintf(response, "FAILimage too large for partition");
+		} else if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_ENV) {
+			/* Since the response can only be 64 bytes,
+			   there is no point in having a large error message. */
+			char err_string[32];
+			if (saveenv_to_ptn(ptn, &err_string[0])) {
+				printf("savenv '%s' failed : %s\n", ptn->name, err_string);
+				sprintf(response, "FAIL%s", err_string);
+			} else {
+				printf("partition '%s' saveenv-ed\n", ptn->name);
+				sprintf(response, "OKAY");
+			}
+		} else {
+			unsigned int temp;
+			char sata_write[128];
+
+			/* block count */
+			temp = (download_bytes +
+				MMC_SATA_BLOCK_SIZE - 1) /
+					MMC_SATA_BLOCK_SIZE;
+
+			sprintf(sata_write, "sata write 0x%x 0x%x 0x%x",
+				(unsigned int)interface.transfer_buffer,
+				ptn->start,
+				temp);
+
+			if (run_command(sata_write, 0)) {
+				printf("Writing '%s' FAILED!\n",
+					 ptn->name);
+				sprintf(response,
+				       "FAIL: Write partition");
+			} else {
+				printf("Writing '%s' DONE!\n",
+					ptn->name);
+				sprintf(response, "OKAY");
+			}
+		}
+	} else {
+		sprintf(response, "FAILno image downloaded");
+	}
+
+}
+#endif
+
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+static int is_sparse_partition(struct fastboot_ptentry *ptn)
+{
+	 if (ptn && (!strncmp(ptn->name,
+				 FASTBOOT_PARTITION_SYSTEM, strlen(FASTBOOT_PARTITION_SYSTEM))
+				 || !strncmp(ptn->name,
+				 FASTBOOT_PARTITION_DATA, strlen(FASTBOOT_PARTITION_DATA)))) {
+		printf("support sparse flash partition for %s\n", ptn->name);
+		return 1;
+	 } else
+		 return 0;
+}
+
+void write_sparse_image(block_dev_desc_t *dev_desc,
+		disk_partition_t *info, const char *part_name,
+		void *data, unsigned sz, char *response)
+{
+	lbaint_t blk;
+	lbaint_t blkcnt;
+	lbaint_t blks;
+	uint32_t bytes_written = 0;
+	unsigned int chunk;
+	unsigned int chunk_data_sz;
+	uint32_t *fill_buf = NULL;
+	uint32_t fill_val;
+	sparse_header_t *sparse_header;
+	chunk_header_t *chunk_header;
+	uint32_t total_blocks = 0;
+	int i;
+
+	/* Read and skip over sparse image header */
+	sparse_header = (sparse_header_t *) data;
+
+	data += sparse_header->file_hdr_sz;
+	if (sparse_header->file_hdr_sz > sizeof(sparse_header_t)) {
+		/*
+		 * Skip the remaining bytes in a header that is longer than
+		 * we expected.
+		 */
+		data += (sparse_header->file_hdr_sz - sizeof(sparse_header_t));
+	}
+
+	debug("=== Sparse Image Header ===\n");
+	debug("magic: 0x%x\n", sparse_header->magic);
+	debug("major_version: 0x%x\n", sparse_header->major_version);
+	debug("minor_version: 0x%x\n", sparse_header->minor_version);
+	debug("file_hdr_sz: %d\n", sparse_header->file_hdr_sz);
+	debug("chunk_hdr_sz: %d\n", sparse_header->chunk_hdr_sz);
+	debug("blk_sz: %d\n", sparse_header->blk_sz);
+	debug("total_blks: %d\n", sparse_header->total_blks);
+	debug("total_chunks: %d\n", sparse_header->total_chunks);
+
+	/* verify sparse_header->blk_sz is an exact multiple of info->blksz */
+	if (sparse_header->blk_sz !=
+	    (sparse_header->blk_sz & ~(info->blksz - 1))) {
+		printf("%s: Sparse image block size issue [%u]\n",
+		       __func__, sparse_header->blk_sz);
+		fastboot_fail(response, "sparse image block size issue");
+		return;
+	}
+
+	puts("Flashing Sparse Image\n");
+
+	/* Start processing chunks */
+	blk = info->start;
+	for (chunk = 0; chunk < sparse_header->total_chunks; chunk++) {
+		/* Read and skip over chunk header */
+		chunk_header = (chunk_header_t *) data;
+		data += sizeof(chunk_header_t);
+
+		if (chunk_header->chunk_type != CHUNK_TYPE_RAW) {
+			debug("=== Chunk Header ===\n");
+			debug("chunk_type: 0x%x\n", chunk_header->chunk_type);
+			debug("chunk_data_sz: 0x%x\n", chunk_header->chunk_sz);
+			debug("total_size: 0x%x\n", chunk_header->total_sz);
+		}
+
+		if (sparse_header->chunk_hdr_sz > sizeof(chunk_header_t)) {
+			/*
+			 * Skip the remaining bytes in a header that is longer
+			 * than we expected.
+			 */
+			data += (sparse_header->chunk_hdr_sz -
+				 sizeof(chunk_header_t));
+		}
+
+		chunk_data_sz = sparse_header->blk_sz * chunk_header->chunk_sz;
+		blkcnt = chunk_data_sz / info->blksz;
+		switch (chunk_header->chunk_type) {
+		case CHUNK_TYPE_RAW:
+			if (chunk_header->total_sz !=
+			    (sparse_header->chunk_hdr_sz + chunk_data_sz)) {
+				fastboot_fail(response,
+					"Bogus chunk size for chunk type Raw");
+				return;
+			}
+
+			if (blk + blkcnt > info->start + info->size) {
+				printf(
+				    "%s: Request would exceed partition size!\n",
+				    __func__);
+				fastboot_fail(response,
+				    "Request would exceed partition size!");
+				return;
+			}
+
+			blks = dev_desc->block_write(dev_desc, blk, blkcnt,
+						     data);
+			if (blks != blkcnt) {
+				printf("%s: Write failed " LBAFU "\n",
+				       __func__, blks);
+				fastboot_fail(response, "flash write failure");
+				return;
+			}
+			blk += blkcnt;
+			bytes_written += blkcnt * info->blksz;
+			total_blocks += chunk_header->chunk_sz;
+			data += chunk_data_sz;
+			break;
+
+		case CHUNK_TYPE_FILL:
+			if (chunk_header->total_sz !=
+			    (sparse_header->chunk_hdr_sz + sizeof(uint32_t))) {
+				fastboot_fail(response,
+					"Bogus chunk size for chunk type FILL");
+				return;
+			}
+
+			fill_buf = (uint32_t *)
+				   memalign(ARCH_DMA_MINALIGN,
+					    ROUNDUP(info->blksz,
+						    ARCH_DMA_MINALIGN));
+			if (!fill_buf) {
+				fastboot_fail(response,
+					"Malloc failed for: CHUNK_TYPE_FILL");
+				return;
+			}
+
+			fill_val = *(uint32_t *)data;
+			data = (char *) data + sizeof(uint32_t);
+
+			for (i = 0; i < (info->blksz / sizeof(fill_val)); i++)
+				fill_buf[i] = fill_val;
+
+			if (blk + blkcnt > info->start + info->size) {
+				printf(
+				    "%s: Request would exceed partition size!\n",
+				    __func__);
+				fastboot_fail(response,
+				    "Request would exceed partition size!");
+				return;
+			}
+
+			for (i = 0; i < blkcnt; i++) {
+				blks = dev_desc->block_write(dev_desc,
+							     blk, 1, fill_buf);
+				if (blks != 1) {
+					printf(
+					    "%s: Write failed, block # " LBAFU "\n",
+					    __func__, blkcnt);
+					fastboot_fail(response, "flash write failure");
+					free(fill_buf);
+					return;
+				}
+				blk++;
+			}
+			bytes_written += blkcnt * info->blksz;
+			total_blocks += chunk_data_sz / sparse_header->blk_sz;
+
+			free(fill_buf);
+			break;
+
+		case CHUNK_TYPE_DONT_CARE:
+			blk += blkcnt;
+			total_blocks += chunk_header->chunk_sz;
+			break;
+
+		case CHUNK_TYPE_CRC32:
+			if (chunk_header->total_sz !=
+			    sparse_header->chunk_hdr_sz) {
+				fastboot_fail(response,
+					"Bogus chunk size for chunk type Dont Care");
+				return;
+			}
+			total_blocks += chunk_header->chunk_sz;
+			data += chunk_data_sz;
+			break;
+
+		default:
+			printf("%s: Unknown chunk type: %x\n", __func__,
+			       chunk_header->chunk_type);
+			fastboot_fail(response, "Unknown chunk type");
+			return;
+		}
+	}
+
+	debug("Wrote %d blocks, expected to write %d blocks\n",
+	      total_blocks, sparse_header->total_blks);
+	printf("........ wrote %u bytes to '%s'\n", bytes_written, part_name);
+
+	if (total_blocks != sparse_header->total_blks)
+		fastboot_fail(response, "sparse image write failure");
+
+	fastboot_okay(response, "");
+	return;
+}
+
+static void process_flash_mmc(const char *cmdbuf, char *response)
+{
+	if (download_bytes) {
+		struct fastboot_ptentry *ptn;
+
+		/* Next is the partition name */
+		ptn = fastboot_flash_find_ptn(cmdbuf);
+		if (ptn == 0) {
+			printf("Partition:'%s' does not exist\n", ptn->name);
+			sprintf(response, "FAILpartition does not exist");
+		} else if ((download_bytes >
+			   ptn->length * MMC_SATA_BLOCK_SIZE) &&
+				!(ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_ENV)) {
+			printf("Image too large for the partition\n");
+			sprintf(response, "FAILimage too large for partition");
+		} else if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_ENV) {
+			/* Since the response can only be 64 bytes,
+			   there is no point in having a large error message. */
+			char err_string[32];
+			if (saveenv_to_ptn(ptn, &err_string[0])) {
+				printf("savenv '%s' failed : %s\n", ptn->name, err_string);
+				sprintf(response, "FAIL%s", err_string);
+			} else {
+				printf("partition '%s' saveenv-ed\n", ptn->name);
+				sprintf(response, "OKAY");
+			}
+		} else {
+			unsigned int temp;
+
+			char mmc_dev[128];
+			char mmc_write[128];
+			int mmcret;
+
+			printf("writing to partition '%s'\n", ptn->name);
+
+			if (ptn->partition_id != FASTBOOT_MMC_NONE_PARTITION_ID)
+				sprintf(mmc_dev, "mmc dev %x %x",
+					fastboot_devinfo.dev_id, /*slot no*/
+					ptn->partition_id /*part no*/);
+			else
+				sprintf(mmc_dev, "mmc dev %x",
+					fastboot_devinfo.dev_id /*slot no*/);
+
+			if (is_sparse_partition(ptn) &&
+				is_sparse_image(interface.transfer_buffer)) {
+				int mmc_no = 0;
+				struct mmc *mmc;
+				block_dev_desc_t *dev_desc;
+				disk_partition_t info;
+				mmc_no = fastboot_devinfo.dev_id;
+
+				printf("sparse flash target is MMC:%d\n", mmc_no);
+				mmc = find_mmc_device(mmc_no);
+				if (mmc && mmc_init(mmc))
+					printf("MMC card init failed!\n");
+
+				dev_desc = get_dev("mmc", mmc_no);
+				if (NULL == dev_desc) {
+					printf("** Block device MMC %d not supported\n",
+						mmc_no);
+					return;
+				}
+
+				if (get_partition_info(dev_desc,
+			       ptn->partition_index, &info)) {
+					printf("Bad partition index:%d for partition:%s\n",
+					ptn->partition_index, ptn->name);
+					return;
+				}
+
+				printf("writing to partition '%s' for sparse, buffer size %d\n",
+						ptn->name, download_bytes);
+
+				write_sparse_image(dev_desc, &info, ptn->name,
+						interface.transfer_buffer, download_bytes, response);
+			} else {
+				/* block count */
+				temp = (download_bytes +
+					    MMC_SATA_BLOCK_SIZE - 1) /
+					    MMC_SATA_BLOCK_SIZE;
+
+				sprintf(mmc_write, "mmc write 0x%x 0x%x 0x%x",
+						(unsigned int)interface.transfer_buffer, /*source*/
+						ptn->start, /*dest*/
+						temp /*length*/);
+
+				printf("Initializing '%s'\n", ptn->name);
+
+				mmcret = run_command(mmc_dev, 0);
+				if (mmcret)
+					sprintf(response, "FAIL:Init of MMC card");
+				else
+					sprintf(response, "OKAY");
+
+				printf("Writing '%s'\n", ptn->name);
+				if (run_command(mmc_write, 0)) {
+					printf("Writing '%s' FAILED!\n", ptn->name);
+					sprintf(response, "FAIL: Write partition");
+				} else {
+					printf("Writing '%s' DONE!\n", ptn->name);
+					sprintf(response, "OKAY");
+				}
+			}
+		}
+	} else {
+		sprintf(response, "FAILno image downloaded");
+	}
+}
+
+#endif
+
+
+static int rx_process_erase(const char *cmdbuf, char *response)
+{
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	struct fastboot_ptentry *ptn;
+
+	ptn = fastboot_flash_find_ptn(cmdbuf);
+	if (ptn == 0) {
+		sprintf(response, "FAILpartition does not exist");
+	} else {
+		int status, repeat, repeat_max;
+
+		printf("erasing '%s'\n", ptn->name);
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+		char lock[128];
+		char unlock[128];
+#endif
+		char erase[128];
+
+		repeat_max = 1;
+		if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_REPEAT_MASK)
+			repeat_max = ptn->flags & FASTBOOT_PTENTRY_FLAGS_REPEAT_MASK;
+
+		for (repeat = 0; repeat < repeat_max;
+			repeat++) {
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+			sprintf(lock, "nand lock 0x%x 0x%x",
+				ptn->start + (repeat * ptn->length),
+				ptn->length);
+			sprintf(unlock, "nand unlock 0x%x 0x%x",
+				ptn->start + (repeat * ptn->length),
+				ptn->length);
+#endif
+			sprintf(erase, "nand erase 0x%x 0x%x",
+				ptn->start + (repeat * ptn->length),
+				ptn->length);
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+			run_command(unlock, 0);
+#endif
+			status = run_command(erase, 0);
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+			run_command(lock, 0);
+#endif
+
+			if (status)
+				break;
+		}
+
+		if (status) {
+			sprintf(response,
+				   "FAILfailed to erase partition");
+		} else {
+			printf("partition '%s' erased\n", ptn->name);
+			sprintf(response, "OKAY");
+		}
+	}
+	return 0;
+#else
+	printf("Not support erase command for EMMC\n");
+	return -1;
+#endif
+
+}
+
+static void rx_process_flash(const char *cmdbuf, char *response)
+{
+	switch (fastboot_devinfo.type) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case DEV_SATA:
+		process_flash_sata(cmdbuf, response);
+		break;
+#endif
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case DEV_MMC:
+		process_flash_mmc(cmdbuf, response);
+		break;
+#endif
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case DEV_NAND:
+		process_flash_nand(cmdbuf, response);
+		break;
+#endif
+	default:
+		printf("Not support flash command for current device %d\n",
+			fastboot_devinfo.type);
+		sprintf(response,
+			   "FAILfailed to flash device");
+		break;
+	}
+}
+
+
+static void parameters_setup(void)
+{
+	interface.nand_block_size = 0;
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	nand_info_t *nand = &nand_info[0];
+	if (nand)
+		interface.nand_block_size = nand->writesize;
+#endif
+	interface.transfer_buffer =
+				(unsigned char *)CONFIG_FASTBOOT_BUF_ADDR;
+	interface.transfer_buffer_size =
+				CONFIG_FASTBOOT_BUF_SIZE;
+}
+
+static struct fastboot_ptentry ptable[MAX_PTN];
+static unsigned int pcount;
+struct fastboot_device_info fastboot_devinfo;
+
+/*
+   Get mmc control number from passed string, eg, "mmc1" mean device 1. Only
+   support "mmc0" to "mmc9" currently. It will be treated as device 0 for
+   other string.
+*/
+static int _fastboot_get_mmc_no(char *env_str)
+{
+	int digit = 0;
+	unsigned char a;
+
+	if (env_str && (strlen(env_str) >= 4) &&
+	    !strncmp(env_str, "mmc", 3)) {
+		a = env_str[3];
+		if (a >= '0' && a <= '9')
+			digit = a - '0';
+	}
+
+	return digit;
+}
+static int _fastboot_setup_dev(void)
+{
+	char *fastboot_env;
+	fastboot_env = getenv("fastboot_dev");
+
+	if (fastboot_env) {
+		if (!strcmp(fastboot_env, "sata")) {
+			fastboot_devinfo.type = DEV_SATA;
+			fastboot_devinfo.dev_id = 0;
+		} else if (!strcmp(fastboot_env, "nand")) {
+			fastboot_devinfo.type = DEV_NAND;
+			fastboot_devinfo.dev_id = 0;
+		} else if (!strncmp(fastboot_env, "mmc", 3)) {
+			fastboot_devinfo.type = DEV_MMC;
+			fastboot_devinfo.dev_id = _fastboot_get_mmc_no(fastboot_env);
+		}
+	} else {
+		return 1;
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA) \
+	|| defined(CONFIG_FASTBOOT_STORAGE_MMC)
+/**
+   @mmc_dos_partition_index: the partition index in mbr.
+   @mmc_partition_index: the boot partition or user partition index,
+   not related to the partition table.
+ */
+static int _fastboot_parts_add_ptable_entry(int ptable_index,
+				      int mmc_dos_partition_index,
+				      int mmc_partition_index,
+				      const char *name,
+				      block_dev_desc_t *dev_desc,
+				      struct fastboot_ptentry *ptable)
+{
+	disk_partition_t info;
+	strcpy(ptable[ptable_index].name, name);
+
+	if (get_partition_info(dev_desc,
+			       mmc_dos_partition_index, &info)) {
+		printf("Bad partition index:%d for partition:%s\n",
+		       mmc_dos_partition_index, name);
+		return -1;
+	} else {
+		ptable[ptable_index].start = info.start;
+		ptable[ptable_index].length = info.size;
+		ptable[ptable_index].partition_id = mmc_partition_index;
+		ptable[ptable_index].partition_index = mmc_dos_partition_index;
+	}
+	return 0;
+}
+
+static int _fastboot_parts_load_from_ptable(void)
+{
+	int i;
+#ifdef CONFIG_CMD_SATA
+	int sata_device_no;
+#endif
+
+	/* mmc boot partition: -1 means no partition, 0 user part., 1 boot part.
+	 * default is no partition, for emmc default user part, except emmc*/
+	int boot_partition = FASTBOOT_MMC_NONE_PARTITION_ID;
+    int user_partition = FASTBOOT_MMC_NONE_PARTITION_ID;
+
+	struct mmc *mmc;
+	block_dev_desc_t *dev_desc;
+	struct fastboot_ptentry ptable[PTN_DATA_INDEX + 1];
+
+	/* sata case in env */
+	if (fastboot_devinfo.type == DEV_SATA) {
+#ifdef CONFIG_CMD_SATA
+		puts("flash target is SATA\n");
+		if (sata_initialize())
+			return -1;
+		sata_device_no = CONFIG_FASTBOOT_SATA_NO;
+		if (sata_device_no >= CONFIG_SYS_SATA_MAX_DEVICE) {
+			printf("Unknown SATA(%d) device for fastboot\n",
+				sata_device_no);
+			return -1;
+		}
+		dev_desc = sata_get_dev(sata_device_no);
+#else /*! CONFIG_CMD_SATA*/
+		puts("SATA isn't buildin\n");
+		return -1;
+#endif /*! CONFIG_CMD_SATA*/
+	} else if (fastboot_devinfo.type == DEV_MMC) {
+		int mmc_no = 0;
+		mmc_no = fastboot_devinfo.dev_id;
+
+		printf("flash target is MMC:%d\n", mmc_no);
+		mmc = find_mmc_device(mmc_no);
+		if (mmc && mmc_init(mmc))
+			printf("MMC card init failed!\n");
+
+		dev_desc = get_dev("mmc", mmc_no);
+		if (NULL == dev_desc) {
+			printf("** Block device MMC %d not supported\n",
+				mmc_no);
+			return -1;
+		}
+
+		/* multiple boot paritions for eMMC 4.3 later */
+		if (mmc->part_config != MMCPART_NOAVAILABLE) {
+			boot_partition = FASTBOOT_MMC_BOOT_PARTITION_ID;
+			user_partition = FASTBOOT_MMC_USER_PARTITION_ID;
+		}
+	} else {
+		printf("Can't setup partition table on this device %d\n",
+			fastboot_devinfo.type);
+		return -1;
+	}
+
+	memset((char *)ptable, 0,
+		    sizeof(struct fastboot_ptentry) * (PTN_DATA_INDEX + 1));
+	/* MBR */
+	strcpy(ptable[PTN_MBR_INDEX].name, "mbr");
+	ptable[PTN_MBR_INDEX].start = ANDROID_MBR_OFFSET / dev_desc->blksz;
+	ptable[PTN_MBR_INDEX].length = ANDROID_MBR_SIZE / dev_desc->blksz;
+	ptable[PTN_MBR_INDEX].partition_id = user_partition;
+	/* Bootloader */
+	strcpy(ptable[PTN_BOOTLOADER_INDEX].name, FASTBOOT_PARTITION_BOOTLOADER);
+	ptable[PTN_BOOTLOADER_INDEX].start =
+				ANDROID_BOOTLOADER_OFFSET / dev_desc->blksz;
+	ptable[PTN_BOOTLOADER_INDEX].length =
+				 ANDROID_BOOTLOADER_SIZE / dev_desc->blksz;
+	ptable[PTN_BOOTLOADER_INDEX].partition_id = boot_partition;
+
+	_fastboot_parts_add_ptable_entry(PTN_KERNEL_INDEX,
+				   CONFIG_ANDROID_BOOT_PARTITION_MMC,
+				   user_partition,
+				   FASTBOOT_PARTITION_BOOT , dev_desc, ptable);
+	_fastboot_parts_add_ptable_entry(PTN_RECOVERY_INDEX,
+				   CONFIG_ANDROID_RECOVERY_PARTITION_MMC,
+				   user_partition,
+				   FASTBOOT_PARTITION_RECOVERY, dev_desc, ptable);
+	_fastboot_parts_add_ptable_entry(PTN_SYSTEM_INDEX,
+				   CONFIG_ANDROID_SYSTEM_PARTITION_MMC,
+				   user_partition,
+				   FASTBOOT_PARTITION_SYSTEM, dev_desc, ptable);
+	_fastboot_parts_add_ptable_entry(PTN_DATA_INDEX,
+				   CONFIG_ANDROID_DATA_PARTITION_MMC,
+				   user_partition,
+				   FASTBOOT_PARTITION_DATA, dev_desc, ptable);
+
+	for (i = 0; i <= PTN_DATA_INDEX; i++)
+		fastboot_flash_add_ptn(&ptable[i]);
+
+	return 0;
+}
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA || CONFIG_FASTBOOT_STORAGE_MMC*/
+
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+static unsigned long long _memparse(char *ptr, char **retptr)
+{
+	char *endptr;	/* local pointer to end of parsed string */
+
+	unsigned long ret = simple_strtoul(ptr, &endptr, 0);
+
+	switch (*endptr) {
+	case 'M':
+	case 'm':
+		ret <<= 10;
+	case 'K':
+	case 'k':
+		ret <<= 10;
+		endptr++;
+	default:
+		break;
+	}
+
+	if (retptr)
+		*retptr = endptr;
+
+	return ret;
+}
+
+static int _fastboot_parts_add_env_entry(char *s, char **retptr)
+{
+	unsigned long size;
+	unsigned long offset = 0;
+	char *name;
+	int name_len;
+	int delim;
+	unsigned int flags;
+	struct fastboot_ptentry part;
+
+	size = _memparse(s, &s);
+	if (0 == size) {
+		printf("Error:FASTBOOT size of parition is 0\n");
+		return 1;
+	}
+
+	/* fetch partition name and flags */
+	flags = 0; /* this is going to be a regular partition */
+	delim = 0;
+	/* check for offset */
+	if (*s == '@') {
+		s++;
+		offset = _memparse(s, &s);
+	} else {
+		printf("Error:FASTBOOT offset of parition is not given\n");
+		return 1;
+	}
+
+	/* now look for name */
+	if (*s == '(')
+		delim = ')';
+
+	if (delim) {
+		char *p;
+
+		name = ++s;
+		p = strchr((const char *)name, delim);
+		if (!p) {
+			printf("Error:FASTBOOT no closing %c found in partition name\n",
+				delim);
+			return 1;
+		}
+		name_len = p - name;
+		s = p + 1;
+	} else {
+		printf("Error:FASTBOOT no partition name for \'%s\'\n", s);
+		return 1;
+	}
+
+	/* check for options */
+	while (1) {
+		if (strncmp(s, "i", 1) == 0) {
+			flags |= FASTBOOT_PTENTRY_FLAGS_WRITE_I;
+			s += 1;
+		} else if (strncmp(s, "ubifs", 5) == 0) {
+			/* ubifs */
+			flags |= FASTBOOT_PTENTRY_FLAGS_WRITE_TRIMFFS;
+			s += 5;
+		} else {
+			break;
+		}
+		if (strncmp(s, "|", 1) == 0)
+			s += 1;
+	}
+
+	/* enter this partition (offset will be calculated later if it is zero at this point) */
+	part.length = size;
+	part.start = offset;
+	part.flags = flags;
+
+	if (name) {
+		if (name_len >= sizeof(part.name)) {
+			printf("Error:FASTBOOT partition name is too long\n");
+			return 1;
+		}
+		strncpy(&part.name[0], name, name_len);
+		/* name is not null terminated */
+		part.name[name_len] = '\0';
+	} else {
+		printf("Error:FASTBOOT no name\n");
+		return 1;
+	}
+
+	fastboot_flash_add_ptn(&part);
+
+	/*if the nand partitions envs are not initialized, try to init them*/
+	if (check_parts_values(&part))
+		save_parts_values(&part, part.start, part.length);
+
+	/* return (updated) pointer command line string */
+	*retptr = s;
+
+	/* return partition table */
+	return 0;
+}
+
+static int _fastboot_parts_load_from_env(void)
+{
+	char fbparts[FASTBOOT_FBPARTS_ENV_MAX_LEN], *env;
+
+	env = getenv("fbparts");
+	if (env) {
+		unsigned int len;
+		len = strlen(env);
+		if (len && len < FASTBOOT_FBPARTS_ENV_MAX_LEN) {
+			char *s, *e;
+
+			memcpy(&fbparts[0], env, len + 1);
+			printf("Fastboot: Adding partitions from environment\n");
+			s = &fbparts[0];
+			e = s + len;
+			while (s < e) {
+				if (_fastboot_parts_add_env_entry(s, &s)) {
+					printf("Error:Fastboot: Abort adding partitions\n");
+					pcount = 0;
+					return 1;
+				}
+				/* Skip a bunch of delimiters */
+				while (s < e) {
+					if ((' ' == *s) ||
+					    ('\t' == *s) ||
+					    ('\n' == *s) ||
+					    ('\r' == *s) ||
+					    (',' == *s)) {
+						s++;
+					} else {
+						break;
+					}
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+static void _fastboot_load_partitions(void)
+{
+	pcount = 0;
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	_fastboot_parts_load_from_env();
+#elif defined(CONFIG_FASTBOOT_STORAGE_SATA) \
+	|| defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	_fastboot_parts_load_from_ptable();
+#endif
+}
+
+/*
+ * Android style flash utilties */
+void fastboot_flash_add_ptn(struct fastboot_ptentry *ptn)
+{
+	if (pcount < MAX_PTN) {
+		memcpy(ptable + pcount, ptn, sizeof(struct fastboot_ptentry));
+		pcount++;
+	}
+}
+
+void fastboot_flash_dump_ptn(void)
+{
+	unsigned int n;
+	for (n = 0; n < pcount; n++) {
+		struct fastboot_ptentry *ptn = ptable + n;
+		printf("ptn %d name='%s' start=%d len=%d\n",
+			n, ptn->name, ptn->start, ptn->length);
+	}
+}
+
+
+struct fastboot_ptentry *fastboot_flash_find_ptn(const char *name)
+{
+	unsigned int n;
+
+	for (n = 0; n < pcount; n++) {
+		/* Make sure a substring is not accepted */
+		if (strlen(name) == strlen(ptable[n].name)) {
+			if (0 == strcmp(ptable[n].name, name))
+				return ptable + n;
+		}
+	}
+
+	printf("can't find partition: %s, dump the partition table\n", name);
+	fastboot_flash_dump_ptn();
+	return 0;
+}
+
+struct fastboot_ptentry *fastboot_flash_get_ptn(unsigned int n)
+{
+	if (n < pcount)
+		return ptable + n;
+	else
+		return 0;
+}
+
+unsigned int fastboot_flash_get_ptn_count(void)
+{
+	return pcount;
+}
+
+/*
+ * CPU and board-specific fastboot initializations.  Aliased function
+ * signals caller to move on
+ */
+static void __def_fastboot_setup(void)
+{
+	/*do nothing here*/
+}
+void board_fastboot_setup(void) \
+	__attribute__((weak, alias("__def_fastboot_setup")));
+
+
+void fastboot_setup(void)
+{
+	struct tag_serialnr serialnr;
+	char serial[17];
+
+	get_board_serial(&serialnr);
+	sprintf(serial, "%u%u", serialnr.high, serialnr.low);
+	g_dnl_set_serialnumber(serial);
+
+	/*execute board relevant initilizations for preparing fastboot */
+	board_fastboot_setup();
+
+	/*get the fastboot dev*/
+	_fastboot_setup_dev();
+
+	/*check if we need to setup recovery*/
+#ifdef CONFIG_ANDROID_RECOVERY
+    check_recovery_mode();
+#endif
+
+	/*load partitions information for the fastboot dev*/
+	_fastboot_load_partitions();
+
+	parameters_setup();
+}
+
+/* export to lib_arm/board.c */
+void check_fastboot(void)
+{
+	if (fastboot_check_and_clean_flag())
+		run_command("fastboot", 0);
+}
+
+#ifdef CONFIG_CMD_BOOTA
+  /* Section for Android bootimage format support
+   * Refer:
+   * http://android.git.kernel.org/?p=platform/system/core.git;a=blob;
+   * f=mkbootimg/bootimg.h
+   */
+
+void
+bootimg_print_image_hdr(struct andr_img_hdr *hdr)
+{
+#ifdef DEBUG
+	int i;
+	printf("   Image magic:   %s\n", hdr->magic);
+
+	printf("   kernel_size:   0x%x\n", hdr->kernel_size);
+	printf("   kernel_addr:   0x%x\n", hdr->kernel_addr);
+
+	printf("   rdisk_size:   0x%x\n", hdr->ramdisk_size);
+	printf("   rdisk_addr:   0x%x\n", hdr->ramdisk_addr);
+
+	printf("   second_size:   0x%x\n", hdr->second_size);
+	printf("   second_addr:   0x%x\n", hdr->second_addr);
+
+	printf("   tags_addr:   0x%x\n", hdr->tags_addr);
+	printf("   page_size:   0x%x\n", hdr->page_size);
+
+	printf("   name:      %s\n", hdr->name);
+	printf("   cmdline:   %s%x\n", hdr->cmdline);
+
+	for (i = 0; i < 8; i++)
+		printf("   id[%d]:   0x%x\n", i, hdr->id[i]);
+#endif
+}
+
+static struct andr_img_hdr boothdr __aligned(ARCH_DMA_MINALIGN);
+
+/* boota <addr> [ mmc0 | mmc1 [ <partition> ] ] */
+int do_boota(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	ulong addr = 0;
+	char *ptn = "boot";
+	int mmcc = -1;
+	struct andr_img_hdr *hdr = &boothdr;
+    ulong image_size;
+#ifdef CONFIG_SECURE_BOOT
+#define IVT_SIZE 0x20
+#define CSF_PAD_SIZE CONFIG_CSF_SIZE
+/* Max of bootimage size to be 16MB */
+#define MAX_ANDROID_BOOT_AUTH_SIZE 0x1000000
+/* Size appended to boot.img with boot_signer */
+#define BOOTIMAGE_SIGNATURE_SIZE 0x100
+#endif
+	int i = 0;
+
+	for (i = 0; i < argc; i++)
+		printf("%s ", argv[i]);
+	printf("\n");
+
+	if (argc < 2)
+		return -1;
+
+	if (!strncmp(argv[1], "mmc", 3))
+		mmcc = simple_strtoul(argv[1]+3, NULL, 10);
+	else
+		addr = simple_strtoul(argv[1], NULL, 16);
+
+	if (argc > 2)
+		ptn = argv[2];
+
+	if (mmcc != -1) {
+#ifdef CONFIG_MMC
+		struct fastboot_ptentry *pte;
+		struct mmc *mmc;
+		disk_partition_t info;
+		block_dev_desc_t *dev_desc = NULL;
+		unsigned sector;
+		unsigned bootimg_sectors;
+
+		memset((void *)&info, 0 , sizeof(disk_partition_t));
+		/* i.MX use MBR as partition table, so this will have
+		   to find the start block and length for the
+		   partition name and register the fastboot pte we
+		   define the partition number of each partition in
+		   config file
+		 */
+		mmc = find_mmc_device(mmcc);
+		if (!mmc) {
+			printf("boota: cannot find '%d' mmc device\n", mmcc);
+			goto fail;
+		}
+		dev_desc = get_dev("mmc", mmcc);
+		if (NULL == dev_desc) {
+			printf("** Block device MMC %d not supported\n", mmcc);
+			goto fail;
+		}
+
+		/* below was i.MX mmc operation code */
+		if (mmc_init(mmc)) {
+			printf("mmc%d init failed\n", mmcc);
+			goto fail;
+		}
+
+		pte = fastboot_flash_find_ptn(ptn);
+		if (!pte) {
+			printf("boota: cannot find '%s' partition\n", ptn);
+			goto fail;
+		}
+
+		if (mmc->block_dev.block_read(dev_desc, pte->start,
+					      1, (void *)hdr) < 0) {
+			printf("boota: mmc failed to read bootimg header\n");
+			goto fail;
+		}
+
+		if (android_image_check_header(hdr)) {
+			printf("boota: bad boot image magic\n");
+			goto fail;
+		}
+
+		image_size = android_image_get_end(hdr) - (ulong)hdr;
+		bootimg_sectors = image_size/512;
+
+#ifdef CONFIG_SECURE_BOOT
+		/* Default boot.img should be padded to 0x1000
+		   before appended with IVT&CSF data. Set the threshold of
+		   boot image for athendication as 16MB
+		*/
+		image_size += BOOTIMAGE_SIGNATURE_SIZE;
+		image_size = ALIGN(image_size, 0x1000);
+		if (image_size > MAX_ANDROID_BOOT_AUTH_SIZE) {
+			printf("The image size is too large for athenticated boot!\n");
+			return 1;
+		}
+		/* Make sure all data boot.img + IVT + CSF been read to memory */
+		bootimg_sectors = image_size/512 +
+			ALIGN(IVT_SIZE + CSF_PAD_SIZE, 512)/512;
+#endif
+
+		if (mmc->block_dev.block_read(dev_desc, pte->start,
+					bootimg_sectors,
+					(void *)load_addr) < 0) {
+			printf("boota: mmc failed to read kernel\n");
+			goto fail;
+		}
+		/* flush cache after read */
+		flush_cache((ulong)load_addr, bootimg_sectors * 512); /* FIXME */
+
+		addr = load_addr;
+
+#ifdef CONFIG_SECURE_BOOT
+		extern uint32_t authenticate_image(uint32_t ddr_start,
+				uint32_t image_size);
+
+		if (authenticate_image(load_addr, image_size)) {
+			printf("Authenticate OK\n");
+		} else {
+			printf("Authenticate image Fail, Please check\n\n");
+			return 1;
+		}
+#endif /*CONFIG_SECURE_BOOT*/
+
+		sector = pte->start + (hdr->page_size / 512);
+		sector += ALIGN(hdr->kernel_size, hdr->page_size) / 512;
+		if (mmc->block_dev.block_read(dev_desc, sector,
+						(hdr->ramdisk_size / 512) + 1,
+						(void *)hdr->ramdisk_addr) < 0) {
+			printf("boota: mmc failed to read ramdisk\n");
+			goto fail;
+		}
+		/* flush cache after read */
+		flush_cache((ulong)hdr->ramdisk_addr, hdr->ramdisk_size); /* FIXME */
+
+#ifdef CONFIG_OF_LIBFDT
+		/* load the dtb file */
+		if (hdr->second_size && hdr->second_addr) {
+			sector += ALIGN(hdr->ramdisk_size, hdr->page_size) / 512;
+			if (mmc->block_dev.block_read(dev_desc, sector,
+						(hdr->second_size / 512) + 1,
+						(void *)hdr->second_addr) < 0) {
+				printf("boota: mmc failed to dtb\n");
+				goto fail;
+			}
+			/* flush cache after read */
+			flush_cache((ulong)hdr->second_addr, hdr->second_size); /* FIXME */
+		}
+#endif /*CONFIG_OF_LIBFDT*/
+
+#else /*! CONFIG_MMC*/
+		return -1;
+#endif /*! CONFIG_MMC*/
+	} else {
+		unsigned raddr, end;
+#ifdef CONFIG_OF_LIBFDT
+		unsigned fdtaddr = 0;
+#endif
+
+		/* set this aside somewhere safe */
+		memcpy(hdr, (void *)addr, sizeof(*hdr));
+
+		if (android_image_check_header(hdr)) {
+			printf("boota: bad boot image magic\n");
+			return 1;
+		}
+
+		bootimg_print_image_hdr(hdr);
+
+		image_size = hdr->page_size +
+			ALIGN(hdr->kernel_size, hdr->page_size) +
+			ALIGN(hdr->ramdisk_size, hdr->page_size) +
+			ALIGN(hdr->second_size, hdr->page_size);
+
+#ifdef CONFIG_SECURE_BOOT
+		image_size = image_size + BOOTIMAGE_SIGNATURE_SIZE;
+		if (image_size > MAX_ANDROID_BOOT_AUTH_SIZE) {
+			printf("The image size is too large for athenticated boot!\n");
+			return 1;
+		}
+#endif /*CONFIG_SECURE_BOOT*/
+
+#ifdef CONFIG_SECURE_BOOT
+		extern uint32_t authenticate_image(uint32_t ddr_start,
+				uint32_t image_size);
+
+		if (authenticate_image(addr, image_size)) {
+			printf("Authenticate OK\n");
+		} else {
+			printf("Authenticate image Fail, Please check\n\n");
+			return 1;
+		}
+#endif
+
+		raddr = addr + hdr->page_size;
+		raddr += ALIGN(hdr->kernel_size, hdr->page_size);
+		end = raddr + hdr->ramdisk_size;
+#ifdef CONFIG_OF_LIBFDT
+		if (hdr->second_size) {
+			fdtaddr = raddr + ALIGN(hdr->ramdisk_size, hdr->page_size);
+			end = fdtaddr + hdr->second_size;
+		}
+#endif /*CONFIG_OF_LIBFDT*/
+
+		if (raddr != hdr->ramdisk_addr) {
+			/*check overlap*/
+			if (((hdr->ramdisk_addr >= addr) &&
+					(hdr->ramdisk_addr <= end)) ||
+				((addr >= hdr->ramdisk_addr) &&
+					(addr <= hdr->ramdisk_addr + hdr->ramdisk_size))) {
+				printf("Fail: boota address overlap with ramdisk address\n");
+				return 1;
+			}
+			memmove((void *) hdr->ramdisk_addr,
+				(void *)raddr, hdr->ramdisk_size);
+		}
+
+#ifdef CONFIG_OF_LIBFDT
+		if (hdr->second_size && fdtaddr != hdr->second_addr) {
+			/*check overlap*/
+			if (((hdr->second_addr >= addr) &&
+					(hdr->second_addr <= end)) ||
+				((addr >= hdr->second_addr) &&
+					(addr <= hdr->second_addr + hdr->second_size))) {
+				printf("Fail: boota address overlap with FDT address\n");
+				return 1;
+			}
+			memmove((void *) hdr->second_addr,
+				(void *)fdtaddr, hdr->second_size);
+		}
+#endif /*CONFIG_OF_LIBFDT*/
+	}
+
+	printf("kernel   @ %08x (%d)\n", hdr->kernel_addr, hdr->kernel_size);
+	printf("ramdisk  @ %08x (%d)\n", hdr->ramdisk_addr, hdr->ramdisk_size);
+#ifdef CONFIG_OF_LIBFDT
+	if (hdr->second_size)
+		printf("fdt      @ %08x (%d)\n", hdr->second_addr, hdr->second_size);
+#endif /*CONFIG_OF_LIBFDT*/
+
+
+	char boot_addr_start[12];
+	char ramdisk_addr[25];
+	char fdt_addr[12];
+
+	char *bootm_args[] = { "bootm", boot_addr_start, ramdisk_addr, fdt_addr};
+
+	sprintf(boot_addr_start, "0x%lx", addr);
+	sprintf(ramdisk_addr, "0x%x:0x%x", hdr->ramdisk_addr, hdr->ramdisk_size);
+	sprintf(fdt_addr, "0x%x", hdr->second_addr);
+
+	do_bootm(NULL, 0, 4, bootm_args);
+
+	/* This only happens if image is somehow faulty so we start over */
+	do_reset(NULL, 0, 0, NULL);
+
+	return 1;
+
+fail:
+#ifdef CONFIG_FSL_FASTBOOT
+	return run_command("fastboot", 0);
+#else /*! CONFIG_FSL_FASTBOOT*/
+	return -1;
+#endif /*! CONFIG_FSL_FASTBOOT*/
+}
+
+U_BOOT_CMD(
+	boota,	3,	1,	do_boota,
+	"boota   - boot android bootimg from memory\n",
+	"[<addr> | mmc0 | mmc1 | mmc2 | mmcX] [<partition>]\n    "
+	"- boot application image stored in memory or mmc\n"
+	"\t'addr' should be the address of boot image "
+	"which is zImage+ramdisk.img\n"
+	"\t'mmcX' is the mmc device you store your boot.img, "
+	"which will read the boot.img from 1M offset('/boot' partition)\n"
+	"\t 'partition' (optional) is the partition id of your device, "
+	"if no partition give, will going to 'boot' partition\n"
+);
+#endif	/* CONFIG_CMD_BOOTA */
+#endif
+
 static void rx_handler_command(struct usb_ep *ep, struct usb_request *req);
 static int strcmp_l1(const char *s1, const char *s2);
 
@@ -412,6 +2277,8 @@
 			strncat(response, s, chars_left);
 		else
 			strcpy(response, "FAILValue not set");
+	} else if (!strcmp_l1("partition-type", cmd)) {
+		strcpy(response, "FAILVariable not implemented");
 	} else {
 		printf("WARNING: unknown variable: %s\n", cmd);
 		strcpy(response, "FAILVariable not implemented");
@@ -481,6 +2348,40 @@
 		fastboot_tx_write_str(response);
 
 		printf("\ndownloading of %d bytes finished\n", download_bytes);
+
+#ifdef CONFIG_FSL_FASTBOOT
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+		/* Pad to block length
+		   In most cases, padding the download to be
+		   block aligned is correct. The exception is
+		   when the following flash writes to the oob
+		   area.  This happens when the image is a
+		   YAFFS image.  Since we do not know what
+		   the download is until it is flashed,
+		   go ahead and pad it, but save the true
+		   size in case if should have
+		   been unpadded */
+		download_bytes_unpadded = download_bytes;
+		if (interface.nand_block_size) {
+			if (download_bytes %
+				interface.nand_block_size) {
+				unsigned int pad =
+					interface.nand_block_size -
+					(download_bytes % interface.nand_block_size);
+				unsigned int i;
+
+				for (i = 0; i < pad; i++) {
+					if (download_bytes >=
+						interface.transfer_buffer_size)
+						break;
+
+					interface.transfer_buffer[download_bytes] = 0;
+					download_bytes++;
+				}
+			}
+		}
+#endif
+#endif
 	} else {
 		max = is_high_speed ? hs_ep_out.wMaxPacketSize :
 				fs_ep_out.wMaxPacketSize;
@@ -525,7 +2426,11 @@
 static void do_bootm_on_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	char boot_addr_start[12];
+#ifdef CONFIG_FSL_FASTBOOT
+	char *bootm_args[] = { "boota", boot_addr_start, NULL };
+#else
 	char *bootm_args[] = { "bootm", boot_addr_start, NULL };
+#endif
 
 	puts("Booting kernel..\n");
 
@@ -567,6 +2472,10 @@
 	}
 
 	strcpy(response, "FAILno flash device defined");
+
+#ifdef CONFIG_FSL_FASTBOOT
+	rx_process_flash(cmd, response);
+#else
 #ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
 	fb_mmc_flash_write(cmd, fastboot_flash_session_id,
 			   (void *)CONFIG_FASTBOOT_BUF_ADDR,
@@ -577,6 +2486,7 @@
 			    (void *)CONFIG_FASTBOOT_BUF_ADDR,
 			    download_bytes, response);
 #endif
+#endif
 	fastboot_flash_session_id++;
 	fastboot_tx_write_str(response);
 }
@@ -619,22 +2529,43 @@
 
 	strcpy(response, "FAILno flash device defined");
 
+#ifdef CONFIG_FSL_FASTBOOT
+	rx_process_erase(cmd, response);
+#else
 #ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
 	fb_mmc_erase(cmd, response);
 #endif
 #ifdef CONFIG_FASTBOOT_FLASH_NAND_DEV
 	fb_nand_erase(cmd, response);
 #endif
+#endif
 	fastboot_tx_write_str(response);
 }
 #endif
 
+#ifdef CONFIG_FSL_FASTBOOT
+static void cb_reboot_bootloader(struct usb_ep *ep, struct usb_request *req)
+{
+	fastboot_tx_write_str("OKAY");
+
+	udelay(1000000);
+	fastboot_enable_flag();
+	do_reset(NULL, 0, 0, NULL);
+}
+#endif
+
 struct cmd_dispatch_info {
 	char *cmd;
 	void (*cb)(struct usb_ep *ep, struct usb_request *req);
 };
 
 static const struct cmd_dispatch_info cmd_dispatch_info[] = {
+#ifdef CONFIG_FSL_FASTBOOT
+	{
+		.cmd = "reboot-bootloader",
+		.cb = cb_reboot_bootloader,
+	},
+#endif
 	{
 		.cmd = "reboot",
 		.cb = cb_reboot,
diff -urN u-boot-2016.03/drivers/usb/host/ehci-hcd.c ebf_6ull_uboot/drivers/usb/host/ehci-hcd.c
--- u-boot-2016.03/drivers/usb/host/ehci-hcd.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/usb/host/ehci-hcd.c	2021-04-16 14:42:16.320589210 +0800
@@ -2,6 +2,7 @@
  * Copyright (c) 2007-2008, Juniper Networks, Inc.
  * Copyright (c) 2008, Excito Elektronik i Skåne AB
  * Copyright (c) 2008, Michael Trimarchi <trimarchimichael@yahoo.it>
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
  *
  * All rights reserved.
  *
@@ -210,6 +211,9 @@
 		return -EINVAL;
 
 	cmd = ehci_readl(&ctrl->hcor->or_usbcmd);
+	/* If not run, directly return */
+	if (!(cmd & CMD_RUN))
+		return 0;
 	cmd &= ~(CMD_PSE | CMD_ASE);
 	ehci_writel(&ctrl->hcor->or_usbcmd, cmd);
 	ret = handshake(&ctrl->hcor->or_usbsts, STS_ASS | STS_PSS, 0,
diff -urN u-boot-2016.03/drivers/usb/host/ehci-mx6.c ebf_6ull_uboot/drivers/usb/host/ehci-mx6.c
--- u-boot-2016.03/drivers/usb/host/ehci-mx6.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/usb/host/ehci-mx6.c	2021-04-16 14:42:16.320589210 +0800
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2009 Daniel Mack <daniel@caiaq.de>
- * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -15,6 +15,7 @@
 #include <asm/arch/imx-regs.h>
 #include <asm/arch/clock.h>
 #include <asm/imx-common/iomux-v3.h>
+#include <asm/arch/sys_proto.h>
 
 #include "ehci.h"
 
@@ -194,8 +195,9 @@
 	u32 reserve1[10];
 	u32 phy_cfg1;
 	u32 phy_cfg2;
+	u32 reserve2[1];
 	u32 phy_status;
-	u32 reserve2[4];
+	u32 reserve3[4];
 	u32 adp_cfg1;
 	u32 adp_cfg2;
 	u32 adp_status;
@@ -207,8 +209,8 @@
 			(0x10000 * index) + USBNC_OFFSET);
 	void __iomem *phy_cfg2 = (void __iomem *)(&usbnc->phy_cfg2);
 
-	/* Enable usb_otg_id detection */
-	setbits_le32(phy_cfg2, USBNC_PHYCFG2_ACAENB);
+	/* Clear the ACAENB to enable usb_otg_id detection, otherwise it is the ACA detection enabled */
+	clrbits_le32(phy_cfg2, USBNC_PHYCFG2_ACAENB);
 }
 
 int usb_phy_mode(int port)
@@ -313,6 +315,15 @@
 
 	if (index > 3)
 		return -EINVAL;
+
+#if defined(CONFIG_MX6)
+	if (mx6_usb_fused(USB_BASE_ADDR + (0x200 * index))) {
+		printf("USB@0x%x is fused, disable it\n",
+			USB_BASE_ADDR + (0x200 * index));
+		return -2;
+	}
+#endif
+
 	enable_usboh3_clk(1);
 	mdelay(1);
 
diff -urN u-boot-2016.03/drivers/video/cfb_console.c ebf_6ull_uboot/drivers/video/cfb_console.c
--- u-boot-2016.03/drivers/video/cfb_console.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/video/cfb_console.c	2021-04-16 14:42:16.324589232 +0800
@@ -2,6 +2,8 @@
  * (C) Copyright 2002 ELTEC Elektronik AG
  * Frank Gottschling <fgottschling@eltec.de>
  *
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -395,7 +397,7 @@
 __weak int board_cfb_skip(void)
 {
 	/* As default, don't skip cfb init */
-	return 0;
+	return 1;
 }
 
 static void video_drawchars(int xx, int yy, unsigned char *s, int count)
@@ -1978,16 +1980,31 @@
 
 	sprintf(info, " %s", version_string);
 
-	space = (VIDEO_LINE_LEN / 2 - VIDEO_INFO_X) / VIDEO_FONT_WIDTH;
+	space = (VIDEO_COLS - VIDEO_INFO_X) / VIDEO_FONT_WIDTH;
 	len = strlen(info);
 
 	if (len > space) {
-		video_drawchars(VIDEO_INFO_X, VIDEO_INFO_Y,
-				(uchar *) info, space);
-		video_drawchars(VIDEO_INFO_X + VIDEO_FONT_WIDTH,
-				VIDEO_INFO_Y + VIDEO_FONT_HEIGHT,
-				(uchar *) info + space, len - space);
-		y_off = 1;
+		int xx = VIDEO_INFO_X, yy = VIDEO_INFO_Y;
+		uchar *p = (uchar *) info;
+		while (len) {
+			if (len > space) {
+				video_drawchars(xx, yy, p, space);
+				len -= space;
+
+				p = (uchar *) p + space;
+
+				if (!y_off) {
+					xx += VIDEO_FONT_WIDTH;
+					space--;
+				}
+				yy += VIDEO_FONT_HEIGHT;
+
+				y_off++;
+			} else {
+				video_drawchars(xx, yy, p, len);
+				len = 0;
+			}
+		}
 	} else
 		video_drawstring(VIDEO_INFO_X, VIDEO_INFO_Y, (uchar *) info);
 
@@ -2159,12 +2176,12 @@
 	}
 	eorx = fgx ^ bgx;
 
-	video_clear();
+	//video_clear();
 
 #ifdef CONFIG_VIDEO_LOGO
 	/* Plot the logo and get start point of console */
 	debug("Video: Drawing the logo ...\n");
-	video_console_address = video_logo();
+	video_console_address = video_logo();    // delete logo
 #else
 	video_console_address = video_fb_address;
 #endif
diff -urN u-boot-2016.03/drivers/video/ipu_common.c ebf_6ull_uboot/drivers/video/ipu_common.c
--- u-boot-2016.03/drivers/video/ipu_common.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/video/ipu_common.c	2021-04-16 14:42:16.324589232 +0800
@@ -6,7 +6,7 @@
  *
  * Linux IPU driver for MX51:
  *
- * (C) Copyright 2005-2010 Freescale Semiconductor, Inc.
+ * (C) Copyright 2005-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -19,6 +19,7 @@
 #include <asm/errno.h>
 #include <asm/arch/imx-regs.h>
 #include <asm/arch/crm_regs.h>
+#include <div64.h>
 #include "ipu.h"
 #include "ipu_regs.h"
 
@@ -127,6 +128,10 @@
 {
 	if (clk && clk->set_rate)
 		clk->set_rate(clk, rate);
+
+	if (!clk)
+		return 0;
+
 	return clk->rate;
 }
 
@@ -214,15 +219,69 @@
 #define CONFIG_SYS_LDB_CLOCK 65000000
 #endif
 
-static struct clk ldb_clk = {
+#if defined(CONFIG_MX6) || defined(CONFIG_MX53)
+static int clk_ldb_clk_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg |= MXC_CCM_CCGR_CG_MASK << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+
+	return 0;
+}
+
+static void clk_ldb_clk_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGR_CG_MASK << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+}
+
+static struct clk ldb_clk[2] = {
+	{
+	.name = "ldb_clk",
+	.id = 0,
+	.rate = CONFIG_SYS_LDB_CLOCK,
+#ifdef CONFIG_MX6
+	.enable_reg = (u32 *)(CCM_BASE_ADDR +
+		offsetof(struct mxc_ccm_reg, CCGR3)),
+	.enable_shift = MXC_CCM_CCGR3_LDB_DI0_OFFSET,
+#else
+	.enable_reg = (u32 *)(CCM_BASE_ADDR +
+		offsetof(struct mxc_ccm_reg, CCGR6)),
+	.enable_shift = MXC_CCM_CCGR6_LDB_DI0_OFFSET,
+#endif
+	.enable = clk_ldb_clk_enable,
+	.disable = clk_ldb_clk_disable,
+	.usecount = 0,
+	}, {
 	.name = "ldb_clk",
+	.id = 1,
 	.rate = CONFIG_SYS_LDB_CLOCK,
+#ifdef CONFIG_MX6
+	.enable_reg = (u32 *)(CCM_BASE_ADDR +
+		offsetof(struct mxc_ccm_reg, CCGR3)),
+	.enable_shift = MXC_CCM_CCGR3_LDB_DI1_OFFSET,
+#else
+	.enable_reg = (u32 *)(CCM_BASE_ADDR +
+		offsetof(struct mxc_ccm_reg, CCGR6)),
+	.enable_shift = MXC_CCM_CCGR6_LDB_DI1_OFFSET,
+#endif
+	.enable = clk_ldb_clk_enable,
+	.disable = clk_ldb_clk_disable,
 	.usecount = 0,
+	}
 };
+#endif
 
 /* Globals */
 struct clk *g_ipu_clk;
-struct clk *g_ldb_clk;
+#if defined(CONFIG_MX6) || defined(CONFIG_MX53)
+struct clk *g_ldb_clk[2];
+#endif
 unsigned char g_ipu_clk_enabled;
 struct clk *g_di_clk[2];
 struct clk *g_pixel_clk[2];
@@ -275,50 +334,80 @@
 
 static void ipu_pixel_clk_recalc(struct clk *clk)
 {
-	u32 div = __raw_readl(DI_BS_CLKGEN0(clk->id));
-	if (div == 0)
-		clk->rate = 0;
-	else
-		clk->rate = (clk->parent->rate * 16) / div;
+	u32 div;
+	u64 final_rate = (unsigned long long)clk->parent->rate * 16;
+
+	div = __raw_readl(DI_BS_CLKGEN0(clk->id));
+	debug("read BS_CLKGEN0 div:%d, final_rate:%lld, prate:%ld\n",
+			div, final_rate, clk->parent->rate);
+
+	clk->rate = 0;
+	if (div != 0) {
+		do_div(final_rate, div);
+		clk->rate = final_rate;
+	}
 }
 
 static unsigned long ipu_pixel_clk_round_rate(struct clk *clk,
 	unsigned long rate)
 {
-	u32 div, div1;
-	u32 tmp;
+	u64 div, final_rate;
+	u32 remainder;
+	u64 parent_rate = (unsigned long long)clk->parent->rate * 16;
+
 	/*
 	 * Calculate divider
 	 * Fractional part is 4 bits,
 	 * so simply multiply by 2^4 to get fractional part.
 	 */
-	tmp = (clk->parent->rate * 16);
-	div = tmp / rate;
-
+	div = parent_rate;
+	remainder = do_div(div, rate);
+	/* Round the divider value */
+	if (remainder > (rate/2))
+		div++;
 	if (div < 0x10)            /* Min DI disp clock divider is 1 */
 		div = 0x10;
 	if (div & ~0xFEF)
 		div &= 0xFF8;
 	else {
-		div1 = div & 0xFE0;
-		if ((tmp/div1 - tmp/div) < rate / 4)
-			div = div1;
-		else
-			div &= 0xFF8;
+		/* Round up divider if it gets us closer to desired pix clk */
+		if ((div & 0xC) == 0xC) {
+			div += 0x10;
+			div &= ~0xF;
+		}
 	}
-	return (clk->parent->rate * 16) / div;
+	final_rate = parent_rate;
+	do_div(final_rate, div);
+
+	return final_rate;
 }
 
 static int ipu_pixel_clk_set_rate(struct clk *clk, unsigned long rate)
 {
-	u32 div = (clk->parent->rate * 16) / rate;
+	u64 div, parent_rate;
+	u32 remainder;
+
+	parent_rate = (unsigned long long)clk->parent->rate * 16;
+	div = parent_rate;
+	remainder = do_div(div, rate);
+	/* Round the divider value */
+	if (remainder > (rate/2))
+		div++;
+
+	/* Round up divider if it gets us closer to desired pix clk */
+	if ((div & 0xC) == 0xC) {
+		div += 0x10;
+		div &= ~0xF;
+	}
+	if (div > 0x1000)
+		debug("Overflow, DI_BS_CLKGEN0 div:0x%x\n", (u32)div);
 
 	__raw_writel(div, DI_BS_CLKGEN0(clk->id));
 
 	/* Setup pixel clock timing */
+	/* Down time is half of period */
 	__raw_writel((div / 16) << 16, DI_BS_CLKGEN1(clk->id));
 
-	clk->rate = (clk->parent->rate * 16) / div;
 	return 0;
 }
 
@@ -345,8 +434,10 @@
 
 	if (parent == g_ipu_clk)
 		di_gen &= ~DI_GEN_DI_CLK_EXT;
-	else if (!IS_ERR(g_di_clk[clk->id]) && parent == g_ldb_clk)
+#if defined(CONFIG_MX6) || defined(CONFIG_MX53)
+	else if (!IS_ERR(g_di_clk[clk->id]) && parent == g_ldb_clk[clk->id])
 		di_gen |= DI_GEN_DI_CLK_EXT;
+#endif
 	else
 		return -EINVAL;
 
@@ -440,8 +531,12 @@
 
 	g_ipu_clk = &ipu_clk;
 	debug("ipu_clk = %u\n", clk_get_rate(g_ipu_clk));
-	g_ldb_clk = &ldb_clk;
-	debug("ldb_clk = %u\n", clk_get_rate(g_ldb_clk));
+#if defined(CONFIG_MX6) || defined(CONFIG_MX53)
+	g_ldb_clk[0] = &ldb_clk[0];
+	g_ldb_clk[1] = &ldb_clk[1];
+	debug("ldb_clk[0] = %u\n", clk_get_rate(g_ldb_clk[0]));
+	debug("ldb_clk[1] = %u\n", clk_get_rate(g_ldb_clk[1]));
+#endif
 	ipu_reset();
 
 	clk_set_parent(g_pixel_clk[0], g_ipu_clk);
@@ -1202,7 +1297,8 @@
 /* should be removed when clk framework is availiable */
 int ipu_set_ldb_clock(int rate)
 {
-	ldb_clk.rate = rate;
+	ldb_clk[0].rate = rate;
+	ldb_clk[1].rate = rate;
 
 	return 0;
 }
diff -urN u-boot-2016.03/drivers/video/ipu_disp.c ebf_6ull_uboot/drivers/video/ipu_disp.c
--- u-boot-2016.03/drivers/video/ipu_disp.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/video/ipu_disp.c	2021-04-16 14:42:16.324589232 +0800
@@ -6,7 +6,7 @@
  *
  * Linux IPU driver for MX51:
  *
- * (C) Copyright 2005-2010 Freescale Semiconductor, Inc.
+ * (C) Copyright 2005-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -48,7 +48,9 @@
 int g_di1_tvout;
 
 extern struct clk *g_ipu_clk;
-extern struct clk *g_ldb_clk;
+#if defined(CONFIG_MX6) || defined(CONFIG_MX53)
+extern struct clk *g_ldb_clk[2];
+#endif
 extern struct clk *g_di_clk[2];
 extern struct clk *g_pixel_clk[2];
 
@@ -643,6 +645,9 @@
 	__raw_writel(reg, DC_WR_CH_CONF(dc_chan));
 
 	clk_enable(g_pixel_clk[di]);
+#if defined(CONFIG_MX6) || defined(CONFIG_MX53)
+	clk_enable(g_ldb_clk[di]);
+#endif
 }
 
 static unsigned char dc_swap;
@@ -733,6 +738,9 @@
 		/* Clock is already off because it must be done quickly, but
 		   we need to fix the ref count */
 		clk_disable(g_pixel_clk[g_dc_di_assignment[dc_chan]]);
+#if defined(CONFIG_MX6) || defined(CONFIG_MX53)
+		clk_disable(g_ldb_clk[g_dc_di_assignment[dc_chan]]);
+#endif
 	}
 }
 
@@ -883,7 +891,9 @@
 				udelay(10000);
 			}
 		}
-		clk_set_parent(g_pixel_clk[disp], g_ldb_clk);
+#if defined(CONFIG_MX6) || defined(CONFIG_MX53)
+		clk_set_parent(g_pixel_clk[disp], g_ldb_clk[disp]);
+#endif
 	} else {
 		if (clk_get_usecount(g_pixel_clk[disp]) != 0)
 			clk_set_parent(g_pixel_clk[disp], g_ipu_clk);
diff -urN u-boot-2016.03/drivers/video/Makefile ebf_6ull_uboot/drivers/video/Makefile
--- u-boot-2016.03/drivers/video/Makefile	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/video/Makefile	2021-04-16 14:42:16.324589232 +0800
@@ -67,5 +67,10 @@
 
 obj-${CONFIG_VIDEO_TEGRA124} += tegra124/
 obj-${CONFIG_VIDEO_ROCKCHIP} += rockchip/
+obj-$(CONFIG_MXC_EPDC) += mxc_epdc_fb.o
+obj-$(CONFIG_VIDEO_VADC) += mxc_vadc.o
+obj-$(CONFIG_VIDEO_CSI) += mxc_csi.o
+obj-$(CONFIG_VIDEO_PXP) += mxc_pxp.o
+obj-$(CONFIG_VIDEO_GIS) += mxc_gis.o
 
 obj-y += bridge/
diff -urN u-boot-2016.03/drivers/video/mxc_csi.c ebf_6ull_uboot/drivers/video/mxc_csi.c
--- u-boot-2016.03/drivers/video/mxc_csi.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/drivers/video/mxc_csi.c	2021-04-16 14:42:16.324589232 +0800
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*!
+ * @file fsl_csi.c, this file is derived from mx27_csi.c
+ *
+ * @brief mx25 CMOS Sensor interface functions
+ *
+ * @ingroup CSI
+ */
+#include <common.h>
+#include <malloc.h>
+
+#include <asm/arch/imx-regs.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+
+#include <linux/string.h>
+#include <linux/list.h>
+
+#include "mxc_csi.h"
+
+enum {
+	STD_NTSC = 0,
+	STD_PAL,
+};
+
+void __iomem *csi_regbase;
+
+static void csihw_reset_frame_count(void)
+{
+	__raw_writel(__raw_readl(CSI_CSICR3) | BIT_FRMCNT_RST, CSI_CSICR3);
+}
+
+static void csihw_reset(void)
+{
+	csihw_reset_frame_count();
+	__raw_writel(CSICR1_RESET_VAL, CSI_CSICR1);
+	__raw_writel(CSICR2_RESET_VAL, CSI_CSICR2);
+	__raw_writel(CSICR3_RESET_VAL, CSI_CSICR3);
+}
+
+/*!
+ * csi_init_interface
+ *    Init csi interface
+ */
+void csi_init_interface(void)
+{
+	unsigned int val = 0;
+	unsigned int imag_para;
+
+	val |= BIT_SOF_POL;
+	val |= BIT_REDGE;
+	val |= BIT_GCLK_MODE;
+	val |= BIT_HSYNC_POL;
+	val |= BIT_FCC;
+	val |= 1 << SHIFT_MCLKDIV;
+	val |= BIT_MCLKEN;
+	__raw_writel(val, CSI_CSICR1);
+
+	imag_para = (640 << 16) | 960;
+	__raw_writel(imag_para, CSI_CSIIMAG_PARA);
+
+	val = 0x1010;
+	val |= BIT_DMA_REFLASH_RFF;
+	__raw_writel(val, CSI_CSICR3);
+}
+
+void csi_format_swap16(bool enable)
+{
+	unsigned int val;
+
+	val = __raw_readl(CSI_CSICR1);
+	if (enable) {
+		val |= BIT_PACK_DIR;
+		val |= BIT_SWAP16_EN;
+	} else {
+		val &= ~BIT_PACK_DIR;
+		val &= ~BIT_SWAP16_EN;
+	}
+
+	__raw_writel(val, CSI_CSICR1);
+}
+
+void csi_enable_int(int arg)
+{
+	unsigned long cr1 = __raw_readl(CSI_CSICR1);
+
+	if (arg == 1) {
+		/* still capture needs DMA intterrupt */
+		cr1 |= BIT_FB1_DMA_DONE_INTEN;
+		cr1 |= BIT_FB2_DMA_DONE_INTEN;
+	}
+	__raw_writel(cr1, CSI_CSICR1);
+}
+
+void csi_disable_int(void)
+{
+	unsigned long cr1 = __raw_readl(CSI_CSICR1);
+
+	cr1 &= ~BIT_FB1_DMA_DONE_INTEN;
+	cr1 &= ~BIT_FB2_DMA_DONE_INTEN;
+	__raw_writel(cr1, CSI_CSICR1);
+}
+
+void csi_enable(int arg)
+{
+	unsigned long cr = __raw_readl(CSI_CSICR18);
+
+	if (arg == 1)
+		cr |= BIT_CSI_ENABLE;
+	else
+		cr &= ~BIT_CSI_ENABLE;
+	__raw_writel(cr, CSI_CSICR18);
+}
+
+void csi_buf_stride_set(u32 stride)
+{
+	__raw_writel(stride, CSI_CSIFBUF_PARA);
+}
+
+void csi_deinterlace_enable(bool enable)
+{
+	unsigned long cr18 = __raw_readl(CSI_CSICR18);
+
+	if (enable == true)
+		cr18 |= BIT_DEINTERLACE_EN;
+	else
+		cr18 &= ~BIT_DEINTERLACE_EN;
+
+	__raw_writel(cr18, CSI_CSICR18);
+}
+
+void csi_deinterlace_mode(int mode)
+{
+	unsigned long cr18 = __raw_readl(CSI_CSICR18);
+
+	if (mode == STD_NTSC)
+		cr18 |= BIT_NTSC_EN;
+	else
+		cr18 &= ~BIT_NTSC_EN;
+
+	__raw_writel(cr18, CSI_CSICR18);
+}
+
+void csi_tvdec_enable(bool enable)
+{
+	unsigned long cr18 = __raw_readl(CSI_CSICR18);
+	unsigned long cr1 = __raw_readl(CSI_CSICR1);
+
+	if (enable == true) {
+		cr18 |= (BIT_TVDECODER_IN_EN | BIT_BASEADDR_SWITCH_EN);
+		cr1 |= BIT_CCIR_MODE | BIT_EXT_VSYNC;
+		cr1 &= ~(BIT_SOF_POL | BIT_REDGE);
+	} else {
+		cr18 &= ~(BIT_TVDECODER_IN_EN | BIT_BASEADDR_SWITCH_EN);
+		cr1 &= ~(BIT_CCIR_MODE | BIT_EXT_VSYNC);
+		cr1 |= BIT_SOF_POL | BIT_REDGE;
+	}
+
+	__raw_writel(cr18, CSI_CSICR18);
+	__raw_writel(cr1, CSI_CSICR1);
+}
+
+void csi_set_32bit_imagpara(int width, int height)
+{
+	int imag_para = 0;
+	unsigned long cr3 = __raw_readl(CSI_CSICR3);
+
+	imag_para = (width << 16) | height;
+	__raw_writel(imag_para, CSI_CSIIMAG_PARA);
+
+
+	/* reflash the embeded DMA controller */
+	__raw_writel(cr3 | BIT_DMA_REFLASH_RFF, CSI_CSICR3);
+}
+
+void csi_set_16bit_imagpara(int width, int height)
+{
+	int imag_para = 0;
+	unsigned long cr3 = __raw_readl(CSI_CSICR3);
+
+	imag_para = (width << 16) | (height * 2);
+	__raw_writel(imag_para, CSI_CSIIMAG_PARA);
+
+	/* reflash the embeded DMA controller */
+	__raw_writel(cr3 | BIT_DMA_REFLASH_RFF, CSI_CSICR3);
+}
+
+void csi_set_12bit_imagpara(int width, int height)
+{
+	int imag_para = 0;
+	unsigned long cr3 = __raw_readl(CSI_CSICR3);
+
+	imag_para = (width << 16) | (height * 3 / 2);
+	__raw_writel(imag_para, CSI_CSIIMAG_PARA);
+
+	/* reflash the embeded DMA controller */
+	__raw_writel(cr3 | BIT_DMA_REFLASH_RFF, CSI_CSICR3);
+}
+
+void csi_dmareq_rff_enable(void)
+{
+	unsigned long cr3 = __raw_readl(CSI_CSICR3);
+
+	cr3 |= BIT_DMA_REQ_EN_RFF;
+	cr3 |= BIT_HRESP_ERR_EN;
+	__raw_writel(cr3, CSI_CSICR3);
+}
+
+void csi_dmareq_rff_disable(void)
+{
+	unsigned long cr3 = __raw_readl(CSI_CSICR3);
+
+	cr3 &= ~BIT_DMA_REQ_EN_RFF;
+	cr3 &= ~BIT_HRESP_ERR_EN;
+	__raw_writel(cr3, CSI_CSICR3);
+}
+
+void csi_disable(void)
+{
+	csi_dmareq_rff_disable();
+	csi_disable_int();
+	csi_buf_stride_set(0);
+	csi_deinterlace_enable(false);
+	csi_tvdec_enable(false);
+	csi_enable(0);
+}
+
+void csi_config(struct csi_conf_param *csi_conf)
+{
+	csi_regbase = (u32 *)CSI1_BASE_ADDR;
+
+	csihw_reset();
+
+	csi_init_interface();
+	csi_dmareq_rff_disable();
+
+	switch (csi_conf->bpp) {
+	case 32:
+		csi_set_32bit_imagpara(csi_conf->width, csi_conf->height);
+		break;
+	case 16:
+		csi_set_16bit_imagpara(csi_conf->width, csi_conf->height);
+		break;
+	default:
+		printf(" %s case not supported, bpp=%d\n",
+				__func__, csi_conf->bpp);
+		return;
+	}
+
+	__raw_writel((u32)csi_conf->fb0addr, CSI_CSIDMASA_FB1);
+	__raw_writel((u32)csi_conf->fb1addr, CSI_CSIDMASA_FB2);
+
+	csi_buf_stride_set(0);
+	if (csi_conf->btvmode) {
+		/* Enable csi PAL/NTSC deinterlace mode */
+		csi_buf_stride_set(csi_conf->width);
+		csi_deinterlace_mode(csi_conf->std);
+		csi_deinterlace_enable(true);
+		csi_tvdec_enable(true);
+	}
+
+	/* start csi */
+	csi_dmareq_rff_enable();
+	csi_enable_int(1);
+	csi_enable(1);
+}
+
diff -urN u-boot-2016.03/drivers/video/mxc_csi.h ebf_6ull_uboot/drivers/video/mxc_csi.h
--- u-boot-2016.03/drivers/video/mxc_csi.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/drivers/video/mxc_csi.h	2021-04-16 14:42:16.324589232 +0800
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*!
+ * @file mxc_csi.h
+ *
+ * @brief mxc CMOS Sensor interface functions
+ *
+ * @ingroup CSI
+ */
+
+#ifndef MXC_CSI_H
+#define MXC_CSI_H
+
+/* reset values */
+#define CSICR1_RESET_VAL	0x40000800
+#define CSICR2_RESET_VAL	0x0
+#define CSICR3_RESET_VAL	0x0
+
+/* csi control reg 1 */
+#define BIT_SWAP16_EN		(0x1 << 31)
+#define BIT_EXT_VSYNC		(0x1 << 30)
+#define BIT_EOF_INT_EN		(0x1 << 29)
+#define BIT_PRP_IF_EN		(0x1 << 28)
+#define BIT_CCIR_MODE		(0x1 << 27)
+#define BIT_COF_INT_EN		(0x1 << 26)
+#define BIT_SF_OR_INTEN		(0x1 << 25)
+#define BIT_RF_OR_INTEN		(0x1 << 24)
+#define BIT_SFF_DMA_DONE_INTEN  (0x1 << 22)
+#define BIT_STATFF_INTEN	(0x1 << 21)
+#define BIT_FB2_DMA_DONE_INTEN  (0x1 << 20)
+#define BIT_FB1_DMA_DONE_INTEN  (0x1 << 19)
+#define BIT_RXFF_INTEN		(0x1 << 18)
+#define BIT_SOF_POL		(0x1 << 17)
+#define BIT_SOF_INTEN		(0x1 << 16)
+#define BIT_MCLKDIV		(0xF << 12)
+#define BIT_HSYNC_POL		(0x1 << 11)
+#define BIT_CCIR_EN		(0x1 << 10)
+#define BIT_MCLKEN		(0x1 << 9)
+#define BIT_FCC			(0x1 << 8)
+#define BIT_PACK_DIR		(0x1 << 7)
+#define BIT_CLR_STATFIFO	(0x1 << 6)
+#define BIT_CLR_RXFIFO		(0x1 << 5)
+#define BIT_GCLK_MODE		(0x1 << 4)
+#define BIT_INV_DATA		(0x1 << 3)
+#define BIT_INV_PCLK		(0x1 << 2)
+#define BIT_REDGE		(0x1 << 1)
+#define BIT_PIXEL_BIT		(0x1 << 0)
+
+#define SHIFT_MCLKDIV		12
+
+/* control reg 3 */
+#define BIT_FRMCNT		(0xFFFF << 16)
+#define BIT_FRMCNT_RST		(0x1 << 15)
+#define BIT_DMA_REFLASH_RFF	(0x1 << 14)
+#define BIT_DMA_REFLASH_SFF	(0x1 << 13)
+#define BIT_DMA_REQ_EN_RFF	(0x1 << 12)
+#define BIT_DMA_REQ_EN_SFF	(0x1 << 11)
+#define BIT_STATFF_LEVEL	(0x7 << 8)
+#define BIT_HRESP_ERR_EN	(0x1 << 7)
+#define BIT_RXFF_LEVEL		(0x7 << 4)
+#define BIT_TWO_8BIT_SENSOR	(0x1 << 3)
+#define BIT_ZERO_PACK_EN	(0x1 << 2)
+#define BIT_ECC_INT_EN		(0x1 << 1)
+#define BIT_ECC_AUTO_EN		(0x1 << 0)
+
+#define SHIFT_FRMCNT		16
+
+/* csi status reg */
+#define BIT_SFF_OR_INT		(0x1 << 25)
+#define BIT_RFF_OR_INT		(0x1 << 24)
+#define BIT_DMA_TSF_DONE_SFF	(0x1 << 22)
+#define BIT_STATFF_INT		(0x1 << 21)
+#define BIT_DMA_TSF_DONE_FB2	(0x1 << 20)
+#define BIT_DMA_TSF_DONE_FB1	(0x1 << 19)
+#define BIT_RXFF_INT		(0x1 << 18)
+#define BIT_EOF_INT		(0x1 << 17)
+#define BIT_SOF_INT		(0x1 << 16)
+#define BIT_F2_INT		(0x1 << 15)
+#define BIT_F1_INT		(0x1 << 14)
+#define BIT_COF_INT		(0x1 << 13)
+#define BIT_HRESP_ERR_INT	(0x1 << 7)
+#define BIT_ECC_INT		(0x1 << 1)
+#define BIT_DRDY		(0x1 << 0)
+
+/* csi control reg 18 */
+#define BIT_CSI_ENABLE			(0x1 << 31)
+#define BIT_BASEADDR_SWITCH_SEL	(0x1 << 5)
+#define BIT_BASEADDR_SWITCH_EN	(0x1 << 4)
+#define BIT_PARALLEL24_EN		(0x1 << 3)
+#define BIT_DEINTERLACE_EN		(0x1 << 2)
+#define BIT_TVDECODER_IN_EN		(0x1 << 1)
+#define BIT_NTSC_EN				(0x1 << 0)
+
+#define CSI_MCLK_VF		1
+#define CSI_MCLK_ENC		2
+#define CSI_MCLK_RAW		4
+#define CSI_MCLK_I2C		8
+
+#define CSI_CSICR1				(csi_regbase)
+#define CSI_CSICR2				(csi_regbase + 0x4)
+#define CSI_CSICR3				(csi_regbase + 0x8)
+#define CSI_STATFIFO			(csi_regbase + 0xC)
+#define CSI_CSIRXFIFO			(csi_regbase + 0x10)
+#define CSI_CSIRXCNT			(csi_regbase + 0x14)
+#define CSI_CSISR				(csi_regbase + 0x18)
+#define CSI_CSIDBG				(csi_regbase + 0x1C)
+#define CSI_CSIDMASA_STATFIFO	(csi_regbase + 0x20)
+#define CSI_CSIDMATS_STATFIFO	(csi_regbase + 0x24)
+#define CSI_CSIDMASA_FB1		(csi_regbase + 0x28)
+#define CSI_CSIDMASA_FB2		(csi_regbase + 0x2C)
+#define CSI_CSIFBUF_PARA		(csi_regbase + 0x30)
+#define CSI_CSIIMAG_PARA		(csi_regbase + 0x34)
+#define CSI_CSICR18				(csi_regbase + 0x48)
+#define CSI_CSICR19				(csi_regbase + 0x4c)
+
+struct mxs_csi_regs {
+	u32 csi_csicr1;				/* 0x0 */
+	u32 csi_csicr2;				/* 0x4 */
+	u32 csi_csicr3;				/* 0x8 */
+	u32 csi_statfifo;			/* 0xC */
+	u32 csi_csirxfifo;			/* 0x10 */
+	u32 csi_csirxcnt;			/* 0x14 */
+	u32 csi_csisr;				/* 0x18 */
+	u32 csi_csidbg;				/* 0x1C */
+	u32 csi_csidmasa_statfifo;	/* 0x20 */
+	u32 csi_csidmats_statfifo;	/* 0x24 */
+	u32 csi_csidmasa_fb1;		/* 0x28 */
+	u32 csi_csidmasa_fb2;		/* 0x2C */
+	u32 csi_csifbuf_para;		/* 0x30 */
+	u32 csi_csiimag_para;		/* 0x34 */
+	u32 reserver[4];
+	u32 csi_csicr18;			/* 0x48 */
+	u32 csi_csicr19;			/* 0x4c */
+};
+
+struct csi_conf_param {
+	unsigned short width;
+	unsigned short height;
+	unsigned int pixel_fmt;
+	unsigned int bpp;
+	bool btvmode;
+	unsigned int std;
+	void *fb0addr;
+	void *fb1addr;
+};
+
+void csi_config(struct csi_conf_param *csi_conf);
+void csi_disable(void);
+#endif
diff -urN u-boot-2016.03/drivers/video/mxc_epdc_fb.c ebf_6ull_uboot/drivers/video/mxc_epdc_fb.c
--- u-boot-2016.03/drivers/video/mxc_epdc_fb.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/drivers/video/mxc_epdc_fb.c	2021-04-16 14:42:16.324589232 +0800
@@ -0,0 +1,464 @@
+/*
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+/*
+ * Based on STMP378X LCDIF
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+#include <common.h>
+#include <lcd.h>
+#include <linux/list.h>
+#include <linux/err.h>
+#include <linux/types.h>
+#include <malloc.h>
+
+#include <mxc_epdc_fb.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void *lcd_base;			/* Start of framebuffer memory	*/
+void *lcd_console_address;	/* Start of console buffer	*/
+
+int lcd_color_fg;
+int lcd_color_bg;
+
+short console_col;
+short console_row;
+
+int rev;
+
+void lcd_initcolregs(void)
+{
+}
+
+void lcd_setcolreg(ushort regno, ushort red, ushort green, ushort blue)
+{
+}
+
+#define TEMP_USE_DEFAULT 8
+
+#define UPDATE_MODE_PARTIAL			0x0
+#define UPDATE_MODE_FULL			0x1
+
+#define TRUE 1
+#define FALSE 0
+
+#define msleep(a)	udelay(a * 1000)
+
+
+/********************************************************
+ * Start Low-Level EPDC Functions
+ ********************************************************/
+
+static inline void epdc_set_screen_res(u32 width, u32 height)
+{
+	u32 val = (height << EPDC_RES_VERTICAL_OFFSET) | width;
+
+	REG_WR(EPDC_BASE, EPDC_RES, val);
+}
+
+static inline void epdc_set_update_coord(u32 x, u32 y)
+{
+	u32 val = (y << EPDC_UPD_CORD_YCORD_OFFSET) | x;
+
+	REG_WR(EPDC_BASE, EPDC_UPD_CORD, val);
+}
+
+static inline void epdc_set_update_dimensions(u32 width, u32 height)
+{
+	u32 val = (height << EPDC_UPD_SIZE_HEIGHT_OFFSET) | width;
+
+	REG_WR(EPDC_BASE, EPDC_UPD_SIZE, val);
+}
+
+static void epdc_submit_update(u32 lut_num, u32 waveform_mode, u32 update_mode,
+			       int use_test_mode, u32 np_val)
+{
+	u32 reg_val = 0;
+
+	if (use_test_mode) {
+		reg_val |=
+			((np_val << EPDC_UPD_FIXED_FIXNP_OFFSET) &
+			EPDC_UPD_FIXED_FIXNP_MASK) | EPDC_UPD_FIXED_FIXNP_EN;
+
+		REG_WR(EPDC_BASE, EPDC_UPD_FIXED, reg_val);
+
+		reg_val = EPDC_UPD_CTRL_USE_FIXED;
+	} else {
+		REG_WR(EPDC_BASE, EPDC_UPD_FIXED, reg_val);
+	}
+
+	reg_val |=
+		((lut_num << EPDC_UPD_CTRL_LUT_SEL_OFFSET) &
+		EPDC_UPD_CTRL_LUT_SEL_MASK) |
+		((waveform_mode << EPDC_UPD_CTRL_WAVEFORM_MODE_OFFSET) &
+		EPDC_UPD_CTRL_WAVEFORM_MODE_MASK) |
+		update_mode;
+
+	REG_WR(EPDC_BASE, EPDC_UPD_CTRL, reg_val);
+}
+
+static inline int epdc_is_lut_active(u32 lut_num)
+{
+	u32 val = REG_RD(EPDC_BASE, EPDC_STATUS_LUTS);
+	int is_active = val & (1 << lut_num) ? TRUE : FALSE;
+
+	return is_active;
+}
+
+static void epdc_set_horizontal_timing(u32 horiz_start, u32 horiz_end,
+				       u32 hsync_width, u32 hsync_line_length)
+{
+	u32 reg_val =
+		((hsync_width << EPDC_TCE_HSCAN1_LINE_SYNC_WIDTH_OFFSET) &
+		EPDC_TCE_HSCAN1_LINE_SYNC_WIDTH_MASK)
+		| ((hsync_line_length << EPDC_TCE_HSCAN1_LINE_SYNC_OFFSET) &
+		EPDC_TCE_HSCAN1_LINE_SYNC_MASK);
+	REG_WR(EPDC_BASE, EPDC_TCE_HSCAN1, reg_val);
+
+	reg_val =
+		((horiz_start << EPDC_TCE_HSCAN2_LINE_BEGIN_OFFSET) &
+		EPDC_TCE_HSCAN2_LINE_BEGIN_MASK)
+		| ((horiz_end << EPDC_TCE_HSCAN2_LINE_END_OFFSET) &
+		EPDC_TCE_HSCAN2_LINE_END_MASK);
+	REG_WR(EPDC_BASE, EPDC_TCE_HSCAN2, reg_val);
+}
+
+static void epdc_set_vertical_timing(u32 vert_start, u32 vert_end,
+					u32 vsync_width)
+{
+	u32 reg_val =
+		((vert_start << EPDC_TCE_VSCAN_FRAME_BEGIN_OFFSET) &
+		EPDC_TCE_VSCAN_FRAME_BEGIN_MASK)
+		| ((vert_end << EPDC_TCE_VSCAN_FRAME_END_OFFSET) &
+		EPDC_TCE_VSCAN_FRAME_END_MASK)
+		| ((vsync_width << EPDC_TCE_VSCAN_FRAME_SYNC_OFFSET) &
+		EPDC_TCE_VSCAN_FRAME_SYNC_MASK);
+	REG_WR(EPDC_BASE, EPDC_TCE_VSCAN, reg_val);
+}
+
+static void epdc_init_settings(void)
+{
+	u32 reg_val;
+	int num_ce;
+
+	/* EPDC_CTRL */
+	reg_val = REG_RD(EPDC_BASE, EPDC_CTRL);
+	reg_val &= ~EPDC_CTRL_UPD_DATA_SWIZZLE_MASK;
+	reg_val |= EPDC_CTRL_UPD_DATA_SWIZZLE_NO_SWAP;
+	reg_val &= ~EPDC_CTRL_LUT_DATA_SWIZZLE_MASK;
+	reg_val |= EPDC_CTRL_LUT_DATA_SWIZZLE_NO_SWAP;
+	REG_SET(EPDC_BASE, EPDC_CTRL, reg_val);
+
+	/* EPDC_FORMAT - 2bit TFT and 4bit Buf pixel format */
+	reg_val = EPDC_FORMAT_TFT_PIXEL_FORMAT_2BIT
+		| EPDC_FORMAT_BUF_PIXEL_FORMAT_P4N
+		| ((0x0 << EPDC_FORMAT_DEFAULT_TFT_PIXEL_OFFSET) &
+		EPDC_FORMAT_DEFAULT_TFT_PIXEL_MASK);
+	REG_WR(EPDC_BASE, EPDC_FORMAT, reg_val);
+
+	/* EPDC_FIFOCTRL (disabled) */
+	reg_val =
+		((100 << EPDC_FIFOCTRL_FIFO_INIT_LEVEL_OFFSET) &
+		EPDC_FIFOCTRL_FIFO_INIT_LEVEL_MASK)
+		| ((200 << EPDC_FIFOCTRL_FIFO_H_LEVEL_OFFSET) &
+		EPDC_FIFOCTRL_FIFO_H_LEVEL_MASK)
+		| ((100 << EPDC_FIFOCTRL_FIFO_L_LEVEL_OFFSET) &
+		EPDC_FIFOCTRL_FIFO_L_LEVEL_MASK);
+	REG_WR(EPDC_BASE, EPDC_FIFOCTRL, reg_val);
+
+	/* EPDC_TEMP - Use default temperature */
+	REG_WR(EPDC_BASE, EPDC_TEMP, TEMP_USE_DEFAULT);
+
+	/* EPDC_RES */
+	epdc_set_screen_res(panel_info.vl_col, panel_info.vl_row);
+
+	/*
+	 * EPDC_TCE_CTRL
+	 * VSCAN_HOLDOFF = 4
+	 * VCOM_MODE = MANUAL
+	 * VCOM_VAL = 0
+	 * DDR_MODE = DISABLED
+	 * LVDS_MODE_CE = DISABLED
+	 * LVDS_MODE = DISABLED
+	 * DUAL_SCAN = DISABLED
+	 * SDDO_WIDTH = 8bit
+	 * PIXELS_PER_SDCLK = 4
+	 */
+	reg_val =
+		((panel_info.epdc_data.epdc_timings.vscan_holdoff <<
+			EPDC_TCE_CTRL_VSCAN_HOLDOFF_OFFSET) &
+			EPDC_TCE_CTRL_VSCAN_HOLDOFF_MASK)
+		| EPDC_TCE_CTRL_PIXELS_PER_SDCLK_4;
+	REG_WR(EPDC_BASE, EPDC_TCE_CTRL, reg_val);
+
+	/* EPDC_TCE_HSCAN */
+	epdc_set_horizontal_timing(panel_info.vl_left_margin,
+				panel_info.vl_right_margin,
+				panel_info.vl_hsync,
+				panel_info.vl_hsync);
+
+	/* EPDC_TCE_VSCAN */
+	epdc_set_vertical_timing(panel_info.vl_upper_margin,
+				 panel_info.vl_lower_margin,
+				 panel_info.vl_vsync);
+
+	/* EPDC_TCE_OE */
+	reg_val =
+		((panel_info.epdc_data.epdc_timings.sdoed_width <<
+			EPDC_TCE_OE_SDOED_WIDTH_OFFSET) &
+			EPDC_TCE_OE_SDOED_WIDTH_MASK)
+		| ((panel_info.epdc_data.epdc_timings.sdoed_delay <<
+			EPDC_TCE_OE_SDOED_DLY_OFFSET) &
+			EPDC_TCE_OE_SDOED_DLY_MASK)
+		| ((panel_info.epdc_data.epdc_timings.sdoez_width <<
+			EPDC_TCE_OE_SDOEZ_WIDTH_OFFSET) &
+			EPDC_TCE_OE_SDOEZ_WIDTH_MASK)
+		| ((panel_info.epdc_data.epdc_timings.sdoez_delay <<
+			EPDC_TCE_OE_SDOEZ_DLY_OFFSET) &
+			EPDC_TCE_OE_SDOEZ_DLY_MASK);
+	REG_WR(EPDC_BASE, EPDC_TCE_OE, reg_val);
+
+	/* EPDC_TCE_TIMING1 */
+	REG_WR(EPDC_BASE, EPDC_TCE_TIMING1, 0x0);
+
+	/* EPDC_TCE_TIMING2 */
+	reg_val =
+		((panel_info.epdc_data.epdc_timings.gdclk_hp_offs <<
+			EPDC_TCE_TIMING2_GDCLK_HP_OFFSET) &
+			EPDC_TCE_TIMING2_GDCLK_HP_MASK)
+		| ((panel_info.epdc_data.epdc_timings.gdsp_offs <<
+			EPDC_TCE_TIMING2_GDSP_OFFSET_OFFSET) &
+			EPDC_TCE_TIMING2_GDSP_OFFSET_MASK);
+	REG_WR(EPDC_BASE, EPDC_TCE_TIMING2, reg_val);
+
+	/* EPDC_TCE_TIMING3 */
+	reg_val =
+		((panel_info.epdc_data.epdc_timings.gdoe_offs <<
+			EPDC_TCE_TIMING3_GDOE_OFFSET_OFFSET) &
+			EPDC_TCE_TIMING3_GDOE_OFFSET_MASK)
+		| ((panel_info.epdc_data.epdc_timings.gdclk_offs <<
+			EPDC_TCE_TIMING3_GDCLK_OFFSET_OFFSET) &
+			EPDC_TCE_TIMING3_GDCLK_OFFSET_MASK);
+	REG_WR(EPDC_BASE, EPDC_TCE_TIMING3, reg_val);
+
+	/*
+	 * EPDC_TCE_SDCFG
+	 * SDCLK_HOLD = 1
+	 * SDSHR = 1
+	 * NUM_CE = 1
+	 * SDDO_REFORMAT = FLIP_PIXELS
+	 * SDDO_INVERT = DISABLED
+	 * PIXELS_PER_CE = display horizontal resolution
+	 */
+	num_ce = panel_info.epdc_data.epdc_timings.num_ce;
+	if (num_ce == 0)
+		num_ce = 1;
+	reg_val = EPDC_TCE_SDCFG_SDCLK_HOLD | EPDC_TCE_SDCFG_SDSHR
+		| ((num_ce << EPDC_TCE_SDCFG_NUM_CE_OFFSET) & EPDC_TCE_SDCFG_NUM_CE_MASK)
+		| EPDC_TCE_SDCFG_SDDO_REFORMAT_FLIP_PIXELS
+		| ((panel_info.vl_col << EPDC_TCE_SDCFG_PIXELS_PER_CE_OFFSET) &
+		EPDC_TCE_SDCFG_PIXELS_PER_CE_MASK);
+	REG_WR(EPDC_BASE, EPDC_TCE_SDCFG, reg_val);
+
+	/*
+	 * EPDC_TCE_GDCFG
+	 * GDRL = 1
+	 * GDOE_MODE = 0;
+	 * GDSP_MODE = 0;
+	 */
+	reg_val = EPDC_TCE_SDCFG_GDRL;
+	REG_WR(EPDC_BASE, EPDC_TCE_GDCFG, reg_val);
+
+	/*
+	 * EPDC_TCE_POLARITY
+	 * SDCE_POL = ACTIVE LOW
+	 * SDLE_POL = ACTIVE HIGH
+	 * SDOE_POL = ACTIVE HIGH
+	 * GDOE_POL = ACTIVE HIGH
+	 * GDSP_POL = ACTIVE LOW
+	 */
+	reg_val = EPDC_TCE_POLARITY_SDLE_POL_ACTIVE_HIGH
+		| EPDC_TCE_POLARITY_SDOE_POL_ACTIVE_HIGH
+		| EPDC_TCE_POLARITY_GDOE_POL_ACTIVE_HIGH;
+	REG_WR(EPDC_BASE, EPDC_TCE_POLARITY, reg_val);
+
+	/* EPDC_IRQ_MASK */
+	REG_WR(EPDC_BASE, EPDC_IRQ_MASK,
+		EPDC_IRQ_TCE_UNDERRUN_IRQ);
+
+	/*
+	 * EPDC_GPIO
+	 * PWRCOM = ?
+	 * PWRCTRL = ?
+	 * BDR = ?
+	 */
+	reg_val = ((0 << EPDC_GPIO_PWRCTRL_OFFSET) & EPDC_GPIO_PWRCTRL_MASK)
+		| ((0 << EPDC_GPIO_BDR_OFFSET) & EPDC_GPIO_BDR_MASK);
+	REG_WR(EPDC_BASE, EPDC_GPIO, reg_val);
+}
+
+static void draw_mode0(void)
+{
+	int i;
+
+	/* Program EPDC update to process buffer */
+	epdc_set_update_coord(0, 0);
+	epdc_set_update_dimensions(panel_info.vl_col, panel_info.vl_row);
+	epdc_submit_update(0, panel_info.epdc_data.wv_modes.mode_init,
+				UPDATE_MODE_FULL, FALSE, 0);
+
+	debug("Mode0 update - Waiting for LUT to complete...\n");
+
+	/* Will timeout after ~4-5 seconds */
+
+	for (i = 0; i < 40; i++) {
+		if (!epdc_is_lut_active(0)) {
+			debug("Mode0 init complete\n");
+			return;
+		}
+		msleep(100);
+	}
+
+	debug("Mode0 init failed!\n");
+
+}
+
+static void draw_splash_screen(void)
+{
+	int i;
+	int lut_num = 0;
+
+	/* Program EPDC update to process buffer */
+	epdc_set_update_coord(0, 0);
+	epdc_set_update_dimensions(panel_info.vl_col, panel_info.vl_row);
+	epdc_submit_update(lut_num, panel_info.epdc_data.wv_modes.mode_gc16,
+		UPDATE_MODE_FULL, FALSE, 0);
+
+	for (i = 0; i < 40; i++) {
+		if (!epdc_is_lut_active(lut_num)) {
+			debug("Splash screen update complete\n");
+			return;
+		}
+		msleep(100);
+	}
+	debug("Splash screen update failed!\n");
+}
+
+void lcd_enable(void)
+{
+	if (board_setup_logo_file(lcd_base)) {
+		debug("Load logo failed!\n");
+		return;
+	}
+
+	epdc_power_on();
+
+	flush_cache((ulong)lcd_base, panel_info.vl_col * panel_info.vl_row);
+
+	/* Draw data to display */
+	draw_mode0();
+
+	draw_splash_screen();
+}
+
+void lcd_disable(void)
+{
+	debug("lcd_disable\n");
+
+	/* Disable clocks to EPDC */
+	REG_SET(EPDC_BASE, EPDC_CTRL, EPDC_CTRL_CLKGATE);
+}
+
+void lcd_panel_disable(void)
+{
+	epdc_power_off();
+}
+
+void lcd_ctrl_init(void *lcdbase)
+{
+	unsigned int val;
+
+	/*
+	 * We rely on lcdbase being a physical address, i.e., either MMU off,
+	 * or 1-to-1 mapping. Might want to add some virt2phys here.
+	 */
+	if (!lcdbase)
+		return;
+
+	panel_info.epdc_data.working_buf_addr = (u_long)memalign(ARCH_DMA_MINALIGN,
+		panel_info.vl_col * panel_info.vl_row * 2);
+
+	if (!panel_info.epdc_data.working_buf_addr) {
+		printf("EPDC: Error allocating working buffer!\n");
+		return;
+	}
+
+	panel_info.epdc_data.waveform_buf_addr = (u_long)memalign(ARCH_DMA_MINALIGN,
+		CONFIG_WAVEFORM_BUF_SIZE);
+
+	if (!panel_info.epdc_data.waveform_buf_addr) {
+		printf("EPDC: Error allocating waveform buffer!\n");
+		return;
+	}
+
+	lcd_color_fg = 0xFF;
+	lcd_color_bg = 0xFF;
+
+	/* Reset */
+	REG_SET(EPDC_BASE, EPDC_CTRL, EPDC_CTRL_SFTRST);
+	while (!(REG_RD(EPDC_BASE, EPDC_CTRL) & EPDC_CTRL_CLKGATE))
+		;
+	REG_CLR(EPDC_BASE, EPDC_CTRL, EPDC_CTRL_SFTRST);
+
+	/* Enable clock gating (clear to enable) */
+	REG_CLR(EPDC_BASE, EPDC_CTRL, EPDC_CTRL_CLKGATE);
+	while (REG_RD(EPDC_BASE, EPDC_CTRL) &
+	       (EPDC_CTRL_SFTRST | EPDC_CTRL_CLKGATE))
+		;
+
+	debug("resolution %dx%d, bpp %d\n", (int)panel_info.vl_col,
+		(int)panel_info.vl_row, NBITS(panel_info.vl_bpix));
+
+	/* Get EPDC version */
+	val = REG_RD(EPDC_BASE, EPDC_VERSION);
+	rev = ((val & EPDC_VERSION_MAJOR_MASK) >>
+				EPDC_VERSION_MAJOR_OFFSET) * 10
+			+ ((val & EPDC_VERSION_MINOR_MASK) >>
+				EPDC_VERSION_MINOR_OFFSET);
+
+	/* Set framebuffer pointer */
+	REG_WR(EPDC_BASE, EPDC_UPD_ADDR, (u32)lcdbase);
+
+	/* Set Working Buffer pointer */
+	REG_WR(EPDC_BASE, EPDC_WB_ADDR, panel_info.epdc_data.working_buf_addr);
+	if (rev > 20)
+		REG_WR(EPDC_BASE, EPDC_WB_ADDR_TCE, panel_info.epdc_data.working_buf_addr);
+
+	/* Get waveform data address and offset */
+	if (board_setup_waveform_file(panel_info.epdc_data.waveform_buf_addr)) {
+		printf("Can't load waveform data!\n");
+		return;
+	}
+
+	/* Set Waveform Buffer pointer */
+	REG_WR(EPDC_BASE, EPDC_WVADDR,
+		panel_info.epdc_data.waveform_buf_addr);
+
+	/* Initialize EPDC, passing pointer to EPDC registers */
+	epdc_init_settings();
+
+	lcd_base = lcdbase;
+
+	return;
+}
+
+ulong calc_fbsize(void)
+{
+	return panel_info.vl_row * panel_info.vl_col * 2 \
+		* NBITS(panel_info.vl_bpix) / 8;
+}
+
diff -urN u-boot-2016.03/drivers/video/mxc_gis.c ebf_6ull_uboot/drivers/video/mxc_gis.c
--- u-boot-2016.03/drivers/video/mxc_gis.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/drivers/video/mxc_gis.c	2021-04-16 14:42:16.324589232 +0800
@@ -0,0 +1,406 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <video_fb.h>
+
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/fb.h>
+#include <gis.h>
+#include <mxsfb.h>
+
+#include "mxc_gis.h"
+#include "mxc_csi.h"
+#include "mxc_pxp.h"
+#include "mxc_vadc.h"
+
+#define CHANNEL_OFFSET 36
+#define COMMAND_OFFSET 8
+#define REG_OFFSET 4
+#define COMMAND_OPCODE_SHIFT 8
+
+enum {
+	CMD_SET_ACC = 0,
+	CMD_WR_DATA,
+	CMD_WR_ACC,
+	CMD_WR_ALU,
+	CMD_MOV_ACC,
+	CMD_RD_DATA,
+	CMD_RD_ALU,
+	CMD_WR_FB_CSI,
+	CMD_WR_FB_PXP_IN,
+	CMD_WR_FB_PXP_OUT,
+	CMD_WR_FB_LCDIF,
+};
+
+enum {
+	ALU_AND = 0,
+	ALU_OR,
+	ALU_XOR,
+	ALU_ADD,
+	ALU_SUB,
+};
+
+enum {
+	CH_MAPPING_CSI_ISR = 0,
+	CH_MAPPING_CSI_FB_UPDATE,
+	CH_MAPPING_PXP_ISR,
+	CH_MAPPING_LCDIF_FB_UPDATE,
+	CH_MAPPING_PXP_KICK,
+	CH_MAPPING_CHANNEL_UNUSED = 0xf,
+};
+
+enum {
+	LCDIF1_SEL = 0x10,
+	LCDIF0_SEL = 0x8,
+	PXP_SEL    = 0x4,
+	CSI1_SEL   = 0x2,
+	CSI0_SEL   = 0x1,
+};
+
+struct command_opcode {
+	unsigned opcode:4;
+	unsigned alu:3;
+	unsigned acc_neg:1;
+};
+
+struct command_param {
+	union {
+		struct command_opcode cmd_bits;
+		u8  cmd_opc;
+	};
+	u32 addr;
+	u32 data;
+};
+
+struct channel_param {
+	u32 ch_num;
+	u32 ch_map;
+	u32 cmd_num;
+	struct command_param cmd_data[4];
+};
+
+static void *csibuf0, *csibuf1, *fb0, *fb1;
+static struct mxs_gis_regs *gis_regs;
+static struct mxs_pxp_regs *pxp_regs;
+static struct mxs_csi_regs *csi_regs;
+static struct mxs_lcdif_regs *lcdif_regs;
+static u32 lcdif_sel;
+static bool gis_running;
+
+static void config_channel(struct channel_param *ch)
+{
+	u32 val, i;
+	u32 reg_offset;
+
+	/* Config channel map and command */
+	switch (ch->ch_num) {
+	case 0:
+		val = readl(&gis_regs->hw_gis_config0);
+		val &= ~(GIS_CONFIG0_CH0_MAPPING_MASK | GIS_CONFIG0_CH0_NUM_MASK);
+		val |= ch->ch_map << GIS_CONFIG0_CH0_MAPPING_SHIFT;
+		val |= ch->cmd_num << GIS_CONFIG0_CH0_NUM_SHIFT;
+		writel(val, &gis_regs->hw_gis_config0);
+		break;
+	case 1:
+		val = readl(&gis_regs->hw_gis_config0);
+		val &= ~(GIS_CONFIG0_CH1_MAPPING_MASK | GIS_CONFIG0_CH1_NUM_MASK);
+		val |= ch->ch_map << GIS_CONFIG0_CH1_MAPPING_SHIFT;
+		val |= ch->cmd_num << GIS_CONFIG0_CH1_NUM_SHIFT;
+		writel(val, &gis_regs->hw_gis_config0);
+		break;
+	case 2:
+		val = readl(&gis_regs->hw_gis_config0);
+		val &= ~(GIS_CONFIG0_CH2_MAPPING_MASK | GIS_CONFIG0_CH2_NUM_MASK);
+		val |= ch->ch_map << GIS_CONFIG0_CH2_MAPPING_SHIFT;
+		val |= ch->cmd_num << GIS_CONFIG0_CH2_NUM_SHIFT;
+		writel(val, &gis_regs->hw_gis_config0);
+		break;
+	case 3:
+		val = readl(&gis_regs->hw_gis_config0);
+		val &= ~(GIS_CONFIG0_CH3_MAPPING_MASK | GIS_CONFIG0_CH3_NUM_MASK);
+		val |= ch->ch_map << GIS_CONFIG0_CH3_MAPPING_SHIFT;
+		val |= ch->cmd_num << GIS_CONFIG0_CH3_NUM_SHIFT;
+		writel(val, &gis_regs->hw_gis_config0);
+		break;
+	case 4:
+		val = readl(&gis_regs->hw_gis_config1);
+		val &= ~(GIS_CONFIG1_CH4_MAPPING_MASK | GIS_CONFIG1_CH4_NUM_MASK);
+		val |= ch->ch_map << GIS_CONFIG1_CH4_MAPPING_SHIFT;
+		val |= ch->cmd_num << GIS_CONFIG1_CH4_NUM_SHIFT;
+		writel(val, &gis_regs->hw_gis_config1);
+		break;
+	case 5:
+		val = readl(&gis_regs->hw_gis_config1);
+		val &= ~(GIS_CONFIG1_CH5_MAPPING_MASK | GIS_CONFIG1_CH5_NUM_MASK);
+		val |= ch->ch_map << GIS_CONFIG1_CH5_MAPPING_SHIFT;
+		val |= ch->cmd_num << GIS_CONFIG1_CH5_NUM_SHIFT;
+		writel(val, &gis_regs->hw_gis_config1);
+		break;
+	default:
+		printf("Error channel num\n");
+	}
+
+	/* Config command  */
+	for (i = 0; i < ch->cmd_num; i++) {
+		val = readl(&gis_regs->hw_gis_ch0_ctrl + ch->ch_num * CHANNEL_OFFSET);
+		val &= ~(0xFF << (COMMAND_OPCODE_SHIFT * i));
+		val |= ch->cmd_data[i].cmd_opc << (COMMAND_OPCODE_SHIFT * i);
+		writel(val, &gis_regs->hw_gis_ch0_ctrl + ch->ch_num * CHANNEL_OFFSET);
+
+		reg_offset = ch->ch_num * CHANNEL_OFFSET + i * COMMAND_OFFSET;
+		writel(ch->cmd_data[i].addr, &gis_regs->hw_gis_ch0_addr0 + reg_offset);
+		writel(ch->cmd_data[i].data, &gis_regs->hw_gis_ch0_data0 + reg_offset);
+	}
+}
+
+static void gis_channel_init(void)
+{
+	struct channel_param ch;
+	int ret;
+	u32 addr0, data0, addr1, data1;
+	u32 val;
+
+	/* Restart the GIS block */
+	ret = mxs_reset_block(&gis_regs->hw_gis_ctrl_reg);
+	if (ret) {
+		debug("MXS GIS: Block reset timeout\n");
+		return;
+	}
+
+	writel((u32)csibuf0, &gis_regs->hw_gis_fb0);
+	writel((u32)csibuf1, &gis_regs->hw_gis_fb1);
+	writel((u32)fb0, &gis_regs->hw_gis_pxp_fb0);
+	writel((u32)fb1, &gis_regs->hw_gis_pxp_fb1);
+
+	/* Config channel 0 -- CSI clean interrupt  */
+	addr0 = (u32)&csi_regs->csi_csisr;
+	data0 = BIT_DMA_TSF_DONE_FB1 | BIT_DMA_TSF_DONE_FB2 | BIT_SOF_INT;
+	ch.ch_num = 0;
+	ch.ch_map = CH_MAPPING_CSI_ISR;
+	ch.cmd_num = 1;
+	ch.cmd_data[0].cmd_bits.opcode = CMD_WR_DATA;
+	ch.cmd_data[0].cmd_bits.alu = ALU_AND;
+	ch.cmd_data[0].cmd_bits.acc_neg = GIS_CH_CTRL_CMD_ACC_NO_NEGATE;
+	ch.cmd_data[0].addr = CSI0_SEL << GIS_CH_ADDR_SEL_SHIFT | addr0;
+	ch.cmd_data[0].data = data0;
+	config_channel(&ch);
+
+	/* Config channel 1 -- CSI set next framebuffer addr  */
+	addr0 = (u32)&csi_regs->csi_csidmasa_fb1;
+	data0 = (u32)&csi_regs->csi_csidmasa_fb2;
+	ch.ch_num = 1;
+	ch.ch_map = CH_MAPPING_CSI_FB_UPDATE;
+	ch.cmd_num = 1;
+	ch.cmd_data[0].cmd_bits.opcode = CMD_WR_FB_CSI;
+	ch.cmd_data[0].cmd_bits.alu = ALU_AND;
+	ch.cmd_data[0].cmd_bits.acc_neg = GIS_CH_CTRL_CMD_ACC_NO_NEGATE;
+	ch.cmd_data[0].addr = CSI0_SEL << GIS_CH_ADDR_SEL_SHIFT | addr0;
+	ch.cmd_data[0].data = data0;
+	config_channel(&ch);
+
+	/* Config channel 2 -- PXP clear interrupt and set framebuffer */
+	addr0 = (u32)&pxp_regs->pxp_stat_clr;
+	data0 = BM_PXP_STAT_IRQ;
+	addr1 = (u32)&pxp_regs->pxp_out_buf;
+	data1 = 0;
+	ch.ch_num = 2;
+	ch.ch_map = CH_MAPPING_PXP_ISR;
+	ch.cmd_num = 2;
+	ch.cmd_data[0].cmd_bits.opcode = CMD_WR_DATA;
+	ch.cmd_data[0].cmd_bits.alu = ALU_AND;
+	ch.cmd_data[0].cmd_bits.acc_neg = GIS_CH_CTRL_CMD_ACC_NO_NEGATE;
+	ch.cmd_data[0].addr = PXP_SEL << GIS_CH_ADDR_SEL_SHIFT | addr0;
+	ch.cmd_data[0].data = data0;
+	ch.cmd_data[1].cmd_bits.opcode = CMD_WR_FB_PXP_OUT;
+	ch.cmd_data[1].cmd_bits.alu = ALU_AND;
+	ch.cmd_data[1].cmd_bits.acc_neg = GIS_CH_CTRL_CMD_ACC_NO_NEGATE;
+	ch.cmd_data[1].addr = PXP_SEL << GIS_CH_ADDR_SEL_SHIFT | addr1;
+	ch.cmd_data[1].data = data1;
+	config_channel(&ch);
+
+	/* Config channel 3 -- LCDIF set framebuffer to display */
+	addr0 = (u32)&lcdif_regs->hw_lcdif_next_buf;
+	data0 = 0;
+	ch.ch_num = 3;
+	ch.ch_map = CH_MAPPING_LCDIF_FB_UPDATE;
+	ch.cmd_num = 1;
+	ch.cmd_data[0].cmd_bits.opcode = CMD_WR_FB_LCDIF;
+	ch.cmd_data[0].cmd_bits.alu = ALU_AND;
+	ch.cmd_data[0].cmd_bits.acc_neg = GIS_CH_CTRL_CMD_ACC_NO_NEGATE;
+	ch.cmd_data[0].addr = ((lcdif_sel == 0) ? LCDIF0_SEL : LCDIF1_SEL) << GIS_CH_ADDR_SEL_SHIFT | addr0;
+	ch.cmd_data[0].data = data0;
+	config_channel(&ch);
+
+	/* Config channel 4 -- PXP kick to process next framebuffer */
+	addr0 = (u32)&pxp_regs->pxp_ps_buf;
+	data0 = 0;
+	addr1 = (u32)&pxp_regs->pxp_ctrl;
+	data1 = BM_PXP_CTRL_IRQ_ENABLE | BM_PXP_CTRL_ENABLE;
+	ch.ch_num = 4;
+	ch.ch_map = CH_MAPPING_PXP_KICK;
+	ch.cmd_num = 2;
+	ch.cmd_data[0].cmd_bits.opcode = CMD_WR_FB_PXP_IN;
+	ch.cmd_data[0].cmd_bits.alu = ALU_AND;
+	ch.cmd_data[0].cmd_bits.acc_neg = GIS_CH_CTRL_CMD_ACC_NO_NEGATE;
+	ch.cmd_data[0].addr = PXP_SEL << GIS_CH_ADDR_SEL_SHIFT | addr0;
+	ch.cmd_data[0].data = data0;
+	ch.cmd_data[1].cmd_bits.opcode = CMD_WR_DATA;
+	ch.cmd_data[1].cmd_bits.alu = ALU_AND;
+	ch.cmd_data[1].cmd_bits.acc_neg = GIS_CH_CTRL_CMD_ACC_NO_NEGATE;
+	ch.cmd_data[1].addr = PXP_SEL << GIS_CH_ADDR_SEL_SHIFT | addr1;
+	ch.cmd_data[1].data = data1;
+	config_channel(&ch);
+
+	/* start gis  */
+	val = readl(&gis_regs->hw_gis_ctrl);
+	if (lcdif_sel == 1)
+		val |= GIS_CTRL_ENABLE_SET | GIS_CTRL_LCDIF_SEL_LCDIF1;
+	else
+		val |= GIS_CTRL_ENABLE_SET | GIS_CTRL_LCDIF_SEL_LCDIF0;
+	writel(val, &gis_regs->hw_gis_ctrl);
+}
+
+void mxc_disable_gis(void)
+{
+	u32 val;
+
+	if (!gis_running)
+		return;
+
+	/* Stop gis */
+	val = GIS_CTRL_SFTRST_SET | GIS_CTRL_CLK_GATE_SET;
+	writel(val, &gis_regs->hw_gis_ctrl);
+
+	/* Stop pxp */
+	mxs_reset_block(&pxp_regs->pxp_ctrl_reg);
+	val = BM_PXP_CTRL_SFTRST | BM_PXP_CTRL_CLKGATE;
+	writel(val , &pxp_regs->pxp_ctrl);
+
+	csi_disable();
+
+	vadc_power_down();
+}
+
+void mxc_enable_gis(void)
+{
+	struct sensor_data sensor;
+	struct csi_conf_param csi_conf;
+	struct pxp_config_data pxp_conf;
+	struct display_panel panel;
+	u32 csimemsize, pxpmemsize;
+	char const *gis_input = getenv("gis");
+
+#ifdef CONFIG_MX6
+	if (check_module_fused(MX6_MODULE_CSI)) {
+		printf("CSI@0x%x is fused, disable it\n", CSI1_BASE_ADDR);
+		return;
+	}
+#endif
+
+#ifdef CONFIG_MX6
+	if (check_module_fused(MX6_MODULE_PXP)) {
+		printf("PXP@0x%x is fused, disable it\n", PXP_BASE_ADDR);
+		return;
+	}
+#endif
+
+	gis_regs = (struct mxs_gis_regs *)GIS_BASE_ADDR;
+	pxp_regs = (struct mxs_pxp_regs *)PXP_BASE_ADDR;
+	csi_regs = (struct mxs_csi_regs *)CSI1_BASE_ADDR;
+
+	gis_running = false;
+
+	if (!strcmp(gis_input, "vadc")) {
+		printf("gis input --- vadc\n");
+		/* vadc_in 0 */
+		vadc_config(0);
+
+		/* Get vadc mode */
+		vadc_get_std(&sensor);
+	} else {
+		printf("gis input --- No input\n");
+		return;
+	}
+
+	/* Get display mode */
+	mxs_lcd_get_panel(&panel);
+
+	lcdif_regs = (struct mxs_lcdif_regs *)panel.reg_base;
+	if (panel.reg_base == LCDIF2_BASE_ADDR)
+		lcdif_sel = 1;
+	else
+		lcdif_sel = 0;
+
+	/* Allocate csi buffer */
+	if (sensor.pixel_fmt == FMT_YUV444) {
+		csimemsize = sensor.width * sensor.height * 4;
+		csi_conf.bpp = 32;
+	} else {
+		csimemsize = sensor.width * sensor.height * 2;
+		csi_conf.bpp = 16;
+	}
+
+	pxpmemsize = panel.width * panel.height * panel.gdfbytespp;
+	csibuf0 = malloc(csimemsize);
+	csibuf1 = malloc(csimemsize);
+	fb0 = malloc(pxpmemsize);
+	fb1 = malloc(pxpmemsize);
+	if (!csibuf0 || !csibuf1 || !fb0 || !fb1) {
+		printf("MXSGIS: Error allocating csibuffer!\n");
+		return;
+	}
+	/* Wipe framebuffer */
+	memset(csibuf0, 0, csimemsize);
+	memset(csibuf1, 0, csimemsize);
+	memset(fb0, 0, pxpmemsize);
+	memset(fb1, 0, pxpmemsize);
+
+	/*config csi  */
+	csi_conf.width = sensor.width;
+	csi_conf.height = sensor.height;
+	csi_conf.btvmode = true;
+	csi_conf.std = sensor.std_id;
+	csi_conf.fb0addr = csibuf0;
+	csi_conf.fb1addr = csibuf1;
+	csi_config(&csi_conf);
+
+	/* config pxp */
+	pxp_conf.s0_param.pixel_fmt = sensor.pixel_fmt;
+	pxp_conf.s0_param.width = sensor.width;
+	pxp_conf.s0_param.height = sensor.height;
+	pxp_conf.s0_param.stride = sensor.width * csi_conf.bpp/8;
+	pxp_conf.s0_param.paddr = csibuf0;
+
+	switch (panel.gdfindex) {
+	case GDF_32BIT_X888RGB:
+		pxp_conf.out_param.pixel_fmt = FMT_RGB888;
+		break;
+	case GDF_16BIT_565RGB:
+		pxp_conf.out_param.pixel_fmt = FMT_RGB565;
+		break;
+	default:
+		printf("GIS unsupported format!");
+	}
+
+	pxp_conf.out_param.width = panel.width;
+	pxp_conf.out_param.height = panel.height;
+	pxp_conf.out_param.stride = pxp_conf.out_param.width * panel.gdfbytespp;
+	pxp_conf.out_param.paddr = fb0;
+	pxp_config(&pxp_conf);
+
+	gis_running = true;
+
+	/* Config gis */
+	gis_channel_init();
+}
diff -urN u-boot-2016.03/drivers/video/mxc_gis.h ebf_6ull_uboot/drivers/video/mxc_gis.h
--- u-boot-2016.03/drivers/video/mxc_gis.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/drivers/video/mxc_gis.h	2021-04-16 14:42:16.324589232 +0800
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef MXC_GIS_H
+#define MXC_GIS_H
+
+#include <asm/imx-common/regs-common.h>
+
+struct mxs_gis_regs {
+	mxs_reg_32(hw_gis_ctrl)				/* 0x00 */
+	mxs_reg_32(hw_gis_config0)			/* 0x10 */
+	mxs_reg_32(hw_gis_config1)			/* 0x20 */
+	mxs_reg_32(hw_gis_fb0)				/* 0x30 */
+	mxs_reg_32(hw_gis_fb1)				/* 0x40 */
+	mxs_reg_32(hw_gis_pxp_fb0)			/* 0x50 */
+	mxs_reg_32(hw_gis_pxp_fb1)			/* 0x60 */
+
+	mxs_reg_32(hw_gis_ch0_ctrl)			/* 0x70 */
+	mxs_reg_32(hw_gis_ch0_addr0)		/* 0x80 */
+	mxs_reg_32(hw_gis_ch0_data0)		/* 0x90 */
+	mxs_reg_32(hw_gis_ch0_addr1)		/* 0xa0 */
+	mxs_reg_32(hw_gis_ch0_data1)		/* 0xb0 */
+	mxs_reg_32(hw_gis_ch0_addr2)		/* 0xc0 */
+	mxs_reg_32(hw_gis_ch0_data2)		/* 0xd0 */
+	mxs_reg_32(hw_gis_ch0_addr3)		/* 0xe0 */
+	mxs_reg_32(hw_gis_ch0_data3)		/* 0xf0 */
+
+	mxs_reg_32(hw_gis_ch1_ctrl)			/* 0x100 */
+	mxs_reg_32(hw_gis_ch1_addr0)		/* 0x110 */
+	mxs_reg_32(hw_gis_ch1_data0)		/* 0x120 */
+	mxs_reg_32(hw_gis_ch1_addr1)		/* 0x130 */
+	mxs_reg_32(hw_gis_ch1_data1)		/* 0x140 */
+	mxs_reg_32(hw_gis_ch1_addr2)		/* 0x150 */
+	mxs_reg_32(hw_gis_ch1_data2)		/* 0x160 */
+	mxs_reg_32(hw_gis_ch1_addr3)		/* 0x170 */
+	mxs_reg_32(hw_gis_ch1_data3)		/* 0x180 */
+
+	mxs_reg_32(hw_gis_ch2_ctrl)			/* 0x190 */
+	mxs_reg_32(hw_gis_ch2_addr0)		/* 0x1a0 */
+	mxs_reg_32(hw_gis_ch2_data0)		/* 0x1b0 */
+	mxs_reg_32(hw_gis_ch2_addr1)		/* 0x1c0 */
+	mxs_reg_32(hw_gis_ch2_data1)		/* 0x1d0 */
+	mxs_reg_32(hw_gis_ch2_addr2)		/* 0x1e0 */
+	mxs_reg_32(hw_gis_ch2_data2)		/* 0x1f0 */
+	mxs_reg_32(hw_gis_ch2_addr3)		/* 0x200 */
+	mxs_reg_32(hw_gis_ch2_data3)		/* 0x210 */
+
+	mxs_reg_32(hw_gis_ch3_ctrl)			/* 0x220 */
+	mxs_reg_32(hw_gis_ch3_addr0)		/* 0x230 */
+	mxs_reg_32(hw_gis_ch3_data0)		/* 0x240 */
+	mxs_reg_32(hw_gis_ch3_addr1)		/* 0x250 */
+	mxs_reg_32(hw_gis_ch3_data1)		/* 0x260 */
+	mxs_reg_32(hw_gis_ch3_addr2)		/* 0x270 */
+	mxs_reg_32(hw_gis_ch3_data2)		/* 0x280 */
+	mxs_reg_32(hw_gis_ch3_addr3)		/* 0x290 */
+	mxs_reg_32(hw_gis_ch3_data3)		/* 0x2a0 */
+
+	mxs_reg_32(hw_gis_ch4_ctrl)			/* 0x2b0 */
+	mxs_reg_32(hw_gis_ch4_addr0)		/* 0x2c0 */
+	mxs_reg_32(hw_gis_ch4_data0)		/* 0x2d0 */
+	mxs_reg_32(hw_gis_ch4_addr1)		/* 0x2e0 */
+	mxs_reg_32(hw_gis_ch4_data1)		/* 0x2f0 */
+	mxs_reg_32(hw_gis_ch4_addr2)		/* 0x300 */
+	mxs_reg_32(hw_gis_ch4_data2)		/* 0x310 */
+	mxs_reg_32(hw_gis_ch4_addr3)		/* 0x320 */
+	mxs_reg_32(hw_gis_ch4_data3)		/* 0x330 */
+
+	mxs_reg_32(hw_gis_ch5_ctrl)			/* 0x340 */
+	mxs_reg_32(hw_gis_ch5_addr0)		/* 0x350 */
+	mxs_reg_32(hw_gis_ch5_data0)		/* 0x360 */
+	mxs_reg_32(hw_gis_ch5_addr1)		/* 0x370 */
+	mxs_reg_32(hw_gis_ch5_data1)		/* 0x380 */
+	mxs_reg_32(hw_gis_ch5_addr2)		/* 0x390 */
+	mxs_reg_32(hw_gis_ch5_data2)		/* 0x3a0 */
+	mxs_reg_32(hw_gis_ch5_addr3)		/* 0x3b0 */
+	mxs_reg_32(hw_gis_ch5_data3)		/* 0x3c0 */
+
+	mxs_reg_32(hw_gis_debug0)			/* 0x3d0 */
+	mxs_reg_32(hw_gis_debug1)			/* 0x3e0 */
+	mxs_reg_32(hw_gis_version)			/* 0x3f0 */
+};
+
+/* register bit */
+#define GIS_CTRL_SFTRST_CLR				0
+#define GIS_CTRL_SFTRST_SET				(1 << 31)
+#define GIS_CTRL_CLK_GATE_CLR			0
+#define GIS_CTRL_CLK_GATE_SET			(1 << 30)
+#define GIS_CTRL_LCDIF1_IRQ_POL_LOW		0
+#define GIS_CTRL_LCDIF1_IRQ_POL_HIGH	(1 << 8)
+#define GIS_CTRL_LCDIF0_IRQ_POL_LOW		0
+#define GIS_CTRL_LCDIF0_IRQ_POL_HIGH	(1 << 7)
+#define GIS_CTRL_PXP_IRQ_POL_LOW		0
+#define GIS_CTRL_PXP_IRQ_POL_HIGH		(1 << 6)
+#define GIS_CTRL_CSI1_IRQ_POL_LOW		0
+#define GIS_CTRL_CSI1_IRQ_POL_HIGH		(1 << 5)
+#define GIS_CTRL_CSI0_IRQ_POL_LOW		0
+#define GIS_CTRL_CSI0_IRQ_POL_HIGH		(1 << 4)
+#define GIS_CTRL_CSI_SEL_CSI0			0
+#define GIS_CTRL_CSI_SEL_CSI1			(1 << 3)
+#define GIS_CTRL_LCDIF_SEL_LCDIF0		0
+#define GIS_CTRL_LCDIF_SEL_LCDIF1		(1 << 2)
+#define GIS_CTRL_FB_START_FB0			0
+#define GIS_CTRL_FB_START_FB1			(1 << 1)
+#define GIS_CTRL_ENABLE_CLR				0
+#define GIS_CTRL_ENABLE_SET				(1 << 0)
+
+#define GIS_CONFIG0_CH3_NUM_MASK		(0x7 << 27)
+#define GIS_CONFIG0_CH3_NUM_SHIFT		27
+#define GIS_CONFIG0_CH3_MAPPING_MASK	(0x7 << 24)
+#define GIS_CONFIG0_CH3_MAPPING_SHIFT	24
+#define GIS_CONFIG0_CH2_NUM_MASK		(0x7 << 19)
+#define GIS_CONFIG0_CH2_NUM_SHIFT		19
+#define GIS_CONFIG0_CH2_MAPPING_MASK	(0x7 << 16)
+#define GIS_CONFIG0_CH2_MAPPING_SHIFT	16
+#define GIS_CONFIG0_CH1_NUM_MASK		(0x7 << 11)
+#define GIS_CONFIG0_CH1_NUM_SHIFT		11
+#define GIS_CONFIG0_CH1_MAPPING_MASK	(0x7 << 8)
+#define GIS_CONFIG0_CH1_MAPPING_SHIFT	8
+#define GIS_CONFIG0_CH0_NUM_MASK		(0x7 << 3)
+#define GIS_CONFIG0_CH0_NUM_SHIFT		3
+#define GIS_CONFIG0_CH0_MAPPING_MASK	(0x7 << 0)
+#define GIS_CONFIG0_CH0_MAPPING_SHIFT	0
+
+#define GIS_CONFIG1_CH5_NUM_MASK		(0x7 << 11)
+#define GIS_CONFIG1_CH5_NUM_SHIFT		11
+#define GIS_CONFIG1_CH5_MAPPING_MASK	(0x7 << 8)
+#define GIS_CONFIG1_CH5_MAPPING_SHIFT	8
+#define GIS_CONFIG1_CH4_NUM_MASK		(0x7 << 3)
+#define GIS_CONFIG1_CH4_NUM_SHIFT		3
+#define GIS_CONFIG1_CH4_MAPPING_MASK	(0x7 << 0)
+#define GIS_CONFIG1_CH4_MAPPING_SHIFT	0
+
+#define GIS_CH_CTRL_CMD3_ACC_MASK		(0x1 << 31)
+#define GIS_CH_CTRL_CMD3_ACC_SHIFT		31
+#define GIS_CH_CTRL_CMD3_ALU_MASK		(0x7 << 28)
+#define GIS_CH_CTRL_CMD3_ALU_SHIFT		28
+#define GIS_CH_CTRL_CMD3_OPCODE_MASK	(0xF << 24)
+#define GIS_CH_CTRL_CMD3_OPCODE_SHIFT	24
+#define GIS_CH_CTRL_CMD2_ACC_MASK		(0x1 << 23)
+#define GIS_CH_CTRL_CMD2_ACC_SHIFT		23
+#define GIS_CH_CTRL_CMD2_ALU_MASK		(0xF << 20)
+#define GIS_CH_CTRL_CMD2_ALU_SHIFT		20
+#define GIS_CH_CTRL_CMD2_OPCODE_MASK	(0xF << 16)
+#define GIS_CH_CTRL_CMD2_OPCODE_SHIFT	16
+#define GIS_CH_CTRL_CMD1_ACC_MASK		(0x1 << 15)
+#define GIS_CH_CTRL_CMD1_ACC_SHIFT		15
+#define GIS_CH_CTRL_CMD1_ALU_MASK		(0x7 << 12)
+#define GIS_CH_CTRL_CMD1_ALU_SHIFT		12
+#define GIS_CH_CTRL_CMD1_OPCODE_MASK	(0xF << 8)
+#define GIS_CH_CTRL_CMD1_OPCODE_SHIFT	8
+#define GIS_CH_CTRL_CMD0_ACC_MASK		(0x1 << 7)
+#define GIS_CH_CTRL_CMD0_ACC_SHIFT		7
+#define GIS_CH_CTRL_CMD0_ALU_MASK		(0x7 << 4)
+#define GIS_CH_CTRL_CMD0_ALU_SHIFT		4
+#define GIS_CH_CTRL_CMD0_OPCODE_MASK	(0xF << 0)
+#define GIS_CH_CTRL_CMD0_OPCODE_SHIFT	0
+
+#define GIS_CH_CTRL_CMD_ACC_NO_NEGATE	0
+#define GIS_CH_CTRL_CMD_ACC_NEGATE		1
+
+#define GIS_CH_ADDR_SEL_MASK			(0xF8 << 27)
+#define GIS_CH_ADDR_SEL_LCDIF1			(0x1 << 31)
+#define GIS_CH_ADDR_SEL_LCDIF0			(0x1 << 30)
+#define GIS_CH_ADDR_SEL_PXP				(0x1 << 29)
+#define GIS_CH_ADDR_SEL_CSI1			(0x1 << 28)
+#define GIS_CH_ADDR_SEL_CSI0			(0x1 << 27)
+#define GIS_CH_ADDR_SEL_SHIFT			27
+#define GIS_CH_ADDR_ADDR_MASK			0x7FFFFFF
+#define GIS_CH_ADDR_ADDR_SHIFT			0
+
+#endif
+
diff -urN u-boot-2016.03/drivers/video/mxc_pxp.c ebf_6ull_uboot/drivers/video/mxc_pxp.c
--- u-boot-2016.03/drivers/video/mxc_pxp.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/drivers/video/mxc_pxp.c	2021-04-16 14:42:16.324589232 +0800
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+
+#include <linux/string.h>
+#include <linux/list.h>
+#include <gis.h>
+
+#include "mxc_pxp.h"
+
+#define BV_PXP_OUT_CTRL_FORMAT__RGB888	  0x4
+#define BV_PXP_OUT_CTRL_FORMAT__RGB555	  0xC
+#define BV_PXP_OUT_CTRL_FORMAT__RGB444	  0xD
+#define BV_PXP_OUT_CTRL_FORMAT__RGB565	  0xE
+#define BV_PXP_OUT_CTRL_FORMAT__YUV1P444  0x10
+#define BV_PXP_OUT_CTRL_FORMAT__UYVY1P422 0x12
+#define BV_PXP_OUT_CTRL_FORMAT__VYUY1P422 0x13
+
+#define BV_PXP_PS_CTRL_FORMAT__RGB888	 0x4
+#define BV_PXP_PS_CTRL_FORMAT__RGB565	 0xE
+#define BV_PXP_PS_CTRL_FORMAT__YUV1P444  0x10
+#define BV_PXP_PS_CTRL_FORMAT__UYVY1P422 0x12
+#define BV_PXP_PS_CTRL_FORMAT__VYUY1P422 0x13
+
+#define BP_PXP_PS_CTRL_SWAP 5
+#define BM_PXP_PS_CTRL_SWAP 0x000000E0
+#define BF_PXP_PS_CTRL_SWAP(v)  \
+	(((v) << 5) & BM_PXP_PS_CTRL_SWAP)
+
+#define PXP_DOWNSCALE_THRESHOLD     0x4000
+
+static void pxp_set_ctrl(struct pxp_config_data *pxp_conf)
+{
+	u32 ctrl;
+	u32 fmt_ctrl;
+	int need_swap = 0;   /* to support YUYV and YVYU formats */
+	struct mxs_pxp_regs *regs = (struct mxs_pxp_regs *)PXP_BASE_ADDR;
+
+	/* Configure S0 input format */
+	switch (pxp_conf->s0_param.pixel_fmt) {
+	case FMT_YUV444:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__YUV1P444;
+		break;
+	case FMT_UYVY:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__UYVY1P422;
+		break;
+	case FMT_YUYV:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__UYVY1P422;
+		need_swap = 1;
+	default:
+		fmt_ctrl = 0;
+	}
+
+	ctrl = BF_PXP_PS_CTRL_FORMAT(fmt_ctrl) | BF_PXP_PS_CTRL_SWAP(need_swap);
+	writel(ctrl, &regs->pxp_ps_ctrl);
+
+	/* Configure output format based on out_channel format */
+	switch (pxp_conf->out_param.pixel_fmt) {
+	case FMT_RGB565:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__RGB565;
+		break;
+	case FMT_RGB888:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__RGB888;
+		break;
+	default:
+		fmt_ctrl = 0;
+	}
+
+	ctrl = BF_PXP_OUT_CTRL_FORMAT(fmt_ctrl);
+	writel(ctrl, &regs->pxp_out_ctrl);
+}
+
+static int pxp_set_scaling(struct pxp_config_data *pxp_conf)
+{
+	int ret = 0;
+	u32 xscale, yscale, s0scale;
+	u32 decx, decy, xdec = 0, ydec = 0;
+	struct pxp_layer_param *s0_params = &pxp_conf->s0_param;
+	struct pxp_layer_param *out_params = &pxp_conf->out_param;
+	struct mxs_pxp_regs *regs = (struct mxs_pxp_regs *)PXP_BASE_ADDR;
+
+	decx = s0_params->width / out_params->width;
+	decy = s0_params->height / out_params->height;
+	if (decx > 1) {
+		if (decx >= 2 && decx < 4) {
+			decx = 2;
+			xdec = 1;
+		} else if (decx >= 4 && decx < 8) {
+			decx = 4;
+			xdec = 2;
+		} else if (decx >= 8) {
+			decx = 8;
+			xdec = 3;
+		}
+		xscale = s0_params->width * 0x1000 /
+			 (out_params->width * decx);
+	} else {
+		if ((s0_params->pixel_fmt == FMT_YUYV) ||
+		    (s0_params->pixel_fmt == FMT_UYVY) ||
+		    (s0_params->pixel_fmt == FMT_YUV444))
+			xscale = (s0_params->width - 1) * 0x1000 /
+				 (out_params->width - 1);
+		else
+			xscale = (s0_params->width - 2) * 0x1000 /
+				 (out_params->width - 1);
+	}
+	if (decy > 1) {
+		if (decy >= 2 && decy < 4) {
+			decy = 2;
+			ydec = 1;
+		} else if (decy >= 4 && decy < 8) {
+			decy = 4;
+			ydec = 2;
+		} else if (decy >= 8) {
+			decy = 8;
+			ydec = 3;
+		}
+		yscale = s0_params->height * 0x1000 /
+			 (out_params->height * decy);
+	} else
+		yscale = (s0_params->height - 1) * 0x1000 /
+			 (out_params->height - 1);
+
+	writel((xdec << 10) | (ydec << 8), &regs->pxp_ps_ctrl);
+
+	if (xscale > PXP_DOWNSCALE_THRESHOLD)
+		xscale = PXP_DOWNSCALE_THRESHOLD;
+	if (yscale > PXP_DOWNSCALE_THRESHOLD)
+		yscale = PXP_DOWNSCALE_THRESHOLD;
+	s0scale = BF_PXP_PS_SCALE_YSCALE(yscale) |
+		BF_PXP_PS_SCALE_XSCALE(xscale);
+	writel(s0scale, &regs->pxp_ps_scale);
+
+	pxp_set_ctrl(pxp_conf);
+
+	return ret;
+}
+
+void pxp_power_down(void)
+{
+	struct mxs_pxp_regs *regs = (struct mxs_pxp_regs *)PXP_BASE_ADDR;
+	u32 val;
+
+	val = BM_PXP_CTRL_SFTRST | BM_PXP_CTRL_CLKGATE;
+	writel(val , &regs->pxp_ctrl);
+}
+
+void pxp_config(struct pxp_config_data *pxp_conf)
+{
+	struct mxs_pxp_regs *regs = (struct mxs_pxp_regs *)PXP_BASE_ADDR;
+
+	/* reset */
+	mxs_reset_block(&regs->pxp_ctrl_reg);
+
+	/* output buffer */
+	if (pxp_conf->out_param.pixel_fmt == FMT_RGB888)
+		writel(BV_PXP_OUT_CTRL_FORMAT__RGB888, &regs->pxp_out_ctrl);
+	else
+		writel(BV_PXP_OUT_CTRL_FORMAT__RGB565, &regs->pxp_out_ctrl);
+
+	writel((u32)pxp_conf->out_param.paddr, &regs->pxp_out_buf);
+
+	writel(pxp_conf->out_param.stride, &regs->pxp_out_pitch);
+	writel((pxp_conf->out_param.width - 1) << 16 |
+			(pxp_conf->out_param.height - 1),
+			&regs->pxp_out_lrc);
+
+	/* scale needed  */
+	writel(0, &regs->pxp_out_ps_ulc);
+	writel((pxp_conf->out_param.width - 1) << 16 |
+			(pxp_conf->out_param.height - 1),
+			&regs->pxp_out_ps_lrc);
+	pxp_set_scaling(pxp_conf);
+
+	writel(0, &regs->pxp_out_as_ulc);
+	writel(0, &regs->pxp_out_as_lrc);
+
+	/* input buffer */
+	if (pxp_conf->s0_param.pixel_fmt == FMT_YUV444)
+		writel(BV_PXP_PS_CTRL_FORMAT__YUV1P444, &regs->pxp_ps_ctrl);
+	else if (pxp_conf->s0_param.pixel_fmt == FMT_YUYV)
+		writel(BV_PXP_PS_CTRL_FORMAT__UYVY1P422 | BF_PXP_PS_CTRL_SWAP(1),
+				&regs->pxp_ps_ctrl);
+	else if (pxp_conf->s0_param.pixel_fmt == FMT_UYVY)
+		writel(BV_PXP_PS_CTRL_FORMAT__UYVY1P422, &regs->pxp_ps_ctrl);
+	else
+		printf("%s, unsupport fmt\n", __func__);
+
+	writel((u32)pxp_conf->s0_param.paddr, &regs->pxp_ps_buf);
+	writel(pxp_conf->s0_param.stride, &regs->pxp_ps_pitch);
+	writel(0, &regs->pxp_ps_background);
+	writel(0x84ab01f0, &regs->pxp_csc1_coef0);
+	writel(0x01980204, &regs->pxp_csc1_coef1);
+	writel(0x0730079c, &regs->pxp_csc1_coef2);
+
+	/* pxp start  */
+	writel(BM_PXP_CTRL_IRQ_ENABLE | BM_PXP_CTRL_ENABLE, &regs->pxp_ctrl);
+}
diff -urN u-boot-2016.03/drivers/video/mxc_pxp.h ebf_6ull_uboot/drivers/video/mxc_pxp.h
--- u-boot-2016.03/drivers/video/mxc_pxp.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/drivers/video/mxc_pxp.h	2021-04-16 14:42:16.324589232 +0800
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef MXC_PXP_H
+#define MXC_PXP_H
+
+#include <asm/imx-common/regs-common.h>
+
+struct mxs_pxp_regs{
+	mxs_reg_32(pxp_ctrl)           /* 0x00  */
+	mxs_reg_32(pxp_stat)           /* 0x10  */
+	mxs_reg_32(pxp_out_ctrl)       /* 0x20  */
+	mxs_reg_32(pxp_out_buf)        /* 0x30  */
+	mxs_reg_32(pxp_out_buf2)       /* 0x40  */
+	mxs_reg_32(pxp_out_pitch)      /* 0x50  */
+	mxs_reg_32(pxp_out_lrc)        /* 0x60  */
+	mxs_reg_32(pxp_out_ps_ulc)     /* 0x70  */
+	mxs_reg_32(pxp_out_ps_lrc)     /* 0x80  */
+	mxs_reg_32(pxp_out_as_ulc)     /* 0x90  */
+	mxs_reg_32(pxp_out_as_lrc)     /* 0xa0  */
+	mxs_reg_32(pxp_ps_ctrl)        /* 0xb0  */
+	mxs_reg_32(pxp_ps_buf)         /* 0xc0  */
+	mxs_reg_32(pxp_ps_ubuf)        /* 0xd0  */
+	mxs_reg_32(pxp_ps_vbuf)        /* 0xe0  */
+	mxs_reg_32(pxp_ps_pitch)       /* 0xf0  */
+	mxs_reg_32(pxp_ps_background)  /* 0x100 */
+	mxs_reg_32(pxp_ps_scale)       /* 0x110 */
+	mxs_reg_32(pxp_ps_offset)      /* 0x120 */
+	mxs_reg_32(pxp_ps_clrkeylow)   /* 0x130 */
+	mxs_reg_32(pxp_ps_clrkeyhigh)  /* 0x140 */
+	mxs_reg_32(pxp_as_ctrl)        /* 0x150 */
+	mxs_reg_32(pxp_as_buf)         /* 0x160 */
+	mxs_reg_32(pxp_as_pitch)       /* 0x170 */
+	mxs_reg_32(pxp_as_clrkeylow)   /* 0x180 */
+	mxs_reg_32(pxp_as_clrkeyhigh)  /* 0x190 */
+	mxs_reg_32(pxp_csc1_coef0)     /* 0x1a0 */
+	mxs_reg_32(pxp_csc1_coef1)     /* 0x1b0 */
+	mxs_reg_32(pxp_csc1_coef2)     /* 0x1c0 */
+	mxs_reg_32(pxp_csc2_ctrl)      /* 0x1d0 */
+	mxs_reg_32(pxp_csc2_coef0)     /* 0x1e0 */
+	mxs_reg_32(pxp_csc2_coef1)     /* 0x1f0 */
+	mxs_reg_32(pxp_csc2_coef2)     /* 0x200 */
+	mxs_reg_32(pxp_csc2_coef3)     /* 0x210 */
+	mxs_reg_32(pxp_csc2_coef4)     /* 0x220 */
+	mxs_reg_32(pxp_csc2_coef5)     /* 0x230 */
+	mxs_reg_32(pxp_lut_ctrl)       /* 0x240 */
+	mxs_reg_32(pxp_lut_addr)       /* 0x250 */
+	mxs_reg_32(pxp_lut_data)       /* 0x260 */
+	mxs_reg_32(pxp_lut_extmem)     /* 0x270 */
+	mxs_reg_32(pxp_cfa)            /* 0x280 */
+	mxs_reg_32(pxp_hist_ctrl)      /* 0x290 */
+	mxs_reg_32(pxp_hist2_param)    /* 0x2a0 */
+	mxs_reg_32(pxp_hist4_param)    /* 0x2b0 */
+	mxs_reg_32(pxp_hist8_param0)   /* 0x2c0 */
+	mxs_reg_32(pxp_hist8_param1)   /* 0x2d0 */
+	mxs_reg_32(pxp_hist16_param0)  /* 0x2e0 */
+	mxs_reg_32(pxp_hist16_param1)  /* 0x2f0 */
+	mxs_reg_32(pxp_hist16_param2)  /* 0x300 */
+	mxs_reg_32(pxp_hist16_param3)  /* 0x310 */
+	mxs_reg_32(pxp_power)          /* 0x320 */
+	uint32_t	reserved1[4*13];
+	mxs_reg_32(pxp_next)           /* 0x400 */
+};
+
+#define BM_PXP_CTRL_IRQ_ENABLE 0x00000002
+#define BM_PXP_CTRL_ENABLE 0x00000001
+
+#define BM_PXP_STAT_IRQ 0x00000001
+
+#define BP_PXP_OUT_CTRL_FORMAT	    0
+#define BM_PXP_OUT_CTRL_FORMAT 0x0000001F
+#define BF_PXP_OUT_CTRL_FORMAT(v)  \
+	(((v) << 0) & BM_PXP_OUT_CTRL_FORMAT)
+
+#define HW_PXP_PS_SCALE	(0x00000110)
+
+#define BM_PXP_PS_SCALE_RSVD2 0x80000000
+#define BP_PXP_PS_SCALE_YSCALE	    16
+#define BM_PXP_PS_SCALE_YSCALE 0x7FFF0000
+#define BF_PXP_PS_SCALE_YSCALE(v)  \
+	(((v) << 16) & BM_PXP_PS_SCALE_YSCALE)
+#define BM_PXP_PS_SCALE_RSVD1 0x00008000
+#define BP_PXP_PS_SCALE_XSCALE	    0
+#define BM_PXP_PS_SCALE_XSCALE 0x00007FFF
+#define BF_PXP_PS_SCALE_XSCALE(v)  \
+	(((v) << 0) & BM_PXP_PS_SCALE_XSCALE)
+
+#define BP_PXP_PS_CTRL_SWAP 5
+#define BM_PXP_PS_CTRL_SWAP 0x000000E0
+#define BF_PXP_PS_CTRL_SWAP(v)  \
+	(((v) << 5) & BM_PXP_PS_CTRL_SWAP)
+#define BP_PXP_PS_CTRL_FORMAT	   0
+#define BM_PXP_PS_CTRL_FORMAT 0x0000001F
+#define BF_PXP_PS_CTRL_FORMAT(v)  \
+	(((v) << 0) & BM_PXP_PS_CTRL_FORMAT)
+#define BM_PXP_CTRL_SFTRST 0x80000000
+#define BM_PXP_CTRL_CLKGATE 0x40000000
+
+struct pxp_layer_param {
+	unsigned short width;
+	unsigned short height;
+	unsigned short stride; /* aka pitch */
+	unsigned int pixel_fmt;
+	void *paddr;
+};
+
+struct pxp_config_data {
+	struct pxp_layer_param s0_param;
+	struct pxp_layer_param out_param;
+};
+
+void pxp_config(struct pxp_config_data *pxp_conf);
+
+#endif
diff -urN u-boot-2016.03/drivers/video/mxc_vadc.c ebf_6ull_uboot/drivers/video/mxc_vadc.c
--- u-boot-2016.03/drivers/video/mxc_vadc.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/drivers/video/mxc_vadc.c	2021-04-16 14:42:16.324589232 +0800
@@ -0,0 +1,373 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/clock.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+
+#include <linux/string.h>
+#include <linux/list.h>
+#include <gis.h>
+
+#include "mxc_vadc.h"
+
+#define reg32_write(addr, val) __raw_writel(val, addr)
+#define reg32_read(addr)       __raw_readl(addr)
+#define reg32setbit(addr, bitpos) \
+	reg32_write((addr), (reg32_read((addr)) | (1<<(bitpos))))
+
+#define reg32clrbit(addr, bitpos) \
+	reg32_write((addr), (reg32_read((addr)) & (0xFFFFFFFF ^ (1<<(bitpos)))))
+
+void __iomem *vafe_regbase;
+void __iomem *vdec_regbase;
+
+enum {
+	STD_NTSC = 0,
+	STD_PAL,
+};
+
+/* Video format structure. */
+struct video_fmt_t{
+	int v4l2_id;		/* Video for linux ID. */
+	char name[16];		/* Name (e.g., "NTSC", "PAL", etc.) */
+	u16 active_width;	/* Active width. */
+	u16 active_height;	/* Active height. */
+};
+
+/* Description of video formats supported.
+ *
+ *  PAL: active=720x576.
+ *  NTSC:active=720x480.
+ */
+static struct video_fmt_t video_fmts[] = {
+	/* NTSC */
+	{
+	 .v4l2_id = STD_NTSC,
+	 .name = "NTSC",
+	 .active_width = 720,
+	 .active_height = 480,
+	 },
+	/* (B, G, H, I, N) PAL */
+	{
+	 .v4l2_id = STD_PAL,
+	 .name = "PAL",
+	 .active_width = 720,
+	 .active_height = 576,
+	 },
+};
+
+static void afe_voltage_clampingmode(void)
+{
+	reg32_write(AFE_CLAMP, 0x07);
+	reg32_write(AFE_CLMPAMP, 0x60);
+	reg32_write(AFE_CLMPDAT, 0xF0);
+}
+
+static void afe_alwayson_clampingmode(void)
+{
+	reg32_write(AFE_CLAMP, 0x15);
+	reg32_write(AFE_CLMPDAT, 0x08);
+	reg32_write(AFE_CLMPAMP, 0x00);
+}
+
+static void afe_init(void)
+{
+	reg32_write(AFE_PDBUF, 0x1f);
+	reg32_write(AFE_PDADC, 0x0f);
+	reg32_write(AFE_PDSARH, 0x01);
+	reg32_write(AFE_PDSARL, 0xff);
+	reg32_write(AFE_PDADCRFH, 0x01);
+	reg32_write(AFE_PDADCRFL, 0xff);
+	reg32_write(AFE_ICTRL, 0x3a);
+	reg32_write(AFE_ICTLSTG, 0x1e);
+
+	reg32_write(AFE_RCTRLSTG, 0x1e);
+	reg32_write(AFE_INPBUF, 0x035);
+	reg32_write(AFE_INPFLT, 0x02);
+	reg32_write(AFE_ADCDGN, 0x40);
+	reg32_write(AFE_TSTSEL, 0x10);
+
+	reg32_write(AFE_ACCTST, 0x07);
+
+	reg32_write(AFE_BGREG, 0x08);
+
+	reg32_write(AFE_ADCGN, 0x09);
+
+	/* set current controlled clamping
+	* always on, low current */
+	reg32_write(AFE_CLAMP, 0x11);
+	reg32_write(AFE_CLMPAMP, 0x08);
+}
+
+static void vdec_mode_timing_init(u32 std)
+{
+	if (std == STD_NTSC) {
+		/* NTSC 720x480 */
+		printf("NTSC\n");
+		reg32_write(VDEC_HACTS, 0x66);
+		reg32_write(VDEC_HACTE, 0x24);
+
+		reg32_write(VDEC_VACTS, 0x29);
+		reg32_write(VDEC_VACTE, 0x04);
+
+		/* set V Position */
+		reg32_write(VDEC_VRTPOS, 0x2);
+	} else if (std == STD_PAL) {
+		/* PAL 720x576 */
+		printf("PAL\n");
+		reg32_write(VDEC_HACTS, 0x66);
+		reg32_write(VDEC_HACTE, 0x24);
+
+		reg32_write(VDEC_VACTS, 0x29);
+		reg32_write(VDEC_VACTE, 0x04);
+
+		/* set V Position */
+		reg32_write(VDEC_VRTPOS, 0x6);
+	} else
+		printf("Error not support video mode\n");
+
+	/* set H Position */
+	reg32_write(VDEC_HZPOS, 0x60);
+
+	/* set H ignore start */
+	reg32_write(VDEC_HSIGS, 0xf8);
+
+	/* set H ignore end */
+	reg32_write(VDEC_HSIGE, 0x18);
+}
+
+/*
+* vdec_init()
+* Initialises the VDEC registers
+* Returns: nothing
+*/
+static void vdec_init(struct sensor_data *vadc)
+{
+	/* Get work mode PAL or NTSC
+	 * delay 500ms wait vdec detect input format*/
+	udelay(500*1000);
+	vadc_get_std(vadc);
+
+	vdec_mode_timing_init(vadc->std_id);
+
+	/* vcr detect threshold high, automatic detections */
+	reg32_write(VDEC_VSCON2, 0);
+
+	reg32_write(VDEC_BASE + 0x110, 0x01);
+
+	/* set the noramp mode on the Hloop PLL. */
+	reg32_write(VDEC_BASE+(0x14*4), 0x10);
+
+	/* set the YC relative delay.*/
+	reg32_write(VDEC_YCDEL, 0x90);
+
+	/* setup the Hpll */
+	reg32_write(VDEC_BASE+(0x13*4), 0x13);
+
+	/* setup the 2d comb */
+	/* set the gain of the Hdetail output to 3
+	 * set the notch alpha gain to 1 */
+	reg32_write(VDEC_CFC2, 0x34);
+
+	/* setup various 2d comb bits.*/
+	reg32_write(VDEC_BASE+(0x02*4), 0x01);
+	reg32_write(VDEC_BASE+(0x03*4), 0x18);
+	reg32_write(VDEC_BASE+(0x04*4), 0x34);
+
+	/* set the start of the burst gate */
+	reg32_write(VDEC_BRSTGT, 0x30);
+
+	/* set 1f motion gain */
+	reg32_write(VDEC_BASE+(0x0f*4), 0x20);
+
+	/* set the 1F chroma motion detector thresh for colour reverse detection */
+	reg32_write(VDEC_THSH1, 0x02);
+	reg32_write(VDEC_BASE+(0x4a*4), 0x20);
+	reg32_write(VDEC_BASE+(0x4b*4), 0x08);
+
+	reg32_write(VDEC_BASE+(0x4c*4), 0x08);
+
+	/* set the threshold for the narrow/wide adaptive chroma BW */
+	reg32_write(VDEC_BASE+(0x20*4), 0x20);
+
+	/* turn up the colour with the new colour gain reg */
+	/* hue: */
+	reg32_write(VDEC_HUE, 0x00);
+
+	/* cbgain: 22 B4 */
+	reg32_write(VDEC_CBGN, 0xb4);
+	/* cr gain 80 */
+	reg32_write(VDEC_CRGN, 0x80);
+	/* luma gain (contrast) */
+	reg32_write(VDEC_CNTR, 0x80);
+
+	/* setup the signed black level register, brightness */
+	reg32_write(VDEC_BRT, 0x00);
+
+	/* filter the standard detection
+	 * enable the comb for the ntsc443 */
+	reg32_write(VDEC_STDDBG, 0x23);
+
+	/* setup chroma kill thresh for no chroma */
+	reg32_write(VDEC_CHBTH, 0x0);
+
+	/* set chroma loop to wider BW
+	 * no set it to normal BW. i fixed the bw problem.*/
+	reg32_write(VDEC_YCDEL, 0x00);
+
+	/* set the compensation in the chroma loop for the Hloop
+	 * set the ratio for the nonarithmetic 3d comb modes.*/
+	reg32_write(VDEC_BASE + (0x1d*4), 0x90);
+
+	/* set the threshold for the nonarithmetic mode for the 2d comb
+	 * the higher the value the more Fc Fh offset we will tolerate before turning off the comb. */
+	reg32_write(VDEC_BASE + (0x33*4), 0xa0);
+
+	/* setup the bluescreen output colour */
+	reg32_write(VDEC_BASE + (0x3d*4), 35);
+	reg32_write(VDEC_BLSCRCR, 114);
+	reg32_write(VDEC_BLSCRCB, 212);
+
+	/* disable the active blanking */
+	reg32_write(VDEC_BASE + (0x15*4), 0x02);
+
+	/* setup the luma agc for automatic gain. */
+	reg32_write(VDEC_LMAGC2, 0x5e);
+	reg32_write(VDEC_BASE + (0x40*4), 0x81);
+
+	/* setup chroma agc */
+	reg32_write(VDEC_CHAGC2, 0xa0);
+	reg32_write(VDEC_CHAGC1, 0x01);
+
+	/* setup the MV thresh lower nibble
+	 * setup the sync top cap, upper nibble */
+	reg32_write(VDEC_BASE + (0x3a*4), 0x80);
+	reg32_write(VDEC_SHPIMP, 0x00);
+
+	/* setup the vsync block */
+	reg32_write(VDEC_VSCON1, 0x87);
+
+	/* set the nosignal threshold
+	 * set the vsync threshold */
+	reg32_write(VDEC_VSSGTH, 0x35);
+
+	/* set length for min hphase filter (or saturate limit if saturate is chosen) */
+	reg32_write(VDEC_BASE + (0x45*4), 0x40);
+
+	/* enable the internal resampler,
+	 * select min filter not saturate for hphase noise filter for vcr detect.
+	 * enable vcr pause mode different field lengths */
+	reg32_write(VDEC_BASE + (0x46*4), 0x90);
+
+	/* disable VCR detection, lock to the Hsync rather than the Vsync */
+	reg32_write(VDEC_VSCON2, 0x04);
+
+	/* set tiplevel goal for dc clamp. */
+	reg32_write(VDEC_BASE + (0x3c*4), 0xB0);
+
+	/* override SECAM detection and force SECAM off */
+	reg32_write(VDEC_BASE + (0x2f*4), 0x20);
+
+	/* Set r3d_hardblend in 3D control2 reg */
+	reg32_write(VDEC_BASE + (0x0c*4), 0x04);
+}
+
+/* set Input selector & input pull-downs */
+static void vadc_select_input(int vadc_in)
+{
+	switch (vadc_in) {
+	case 0:
+		reg32_write(AFE_INPFLT, 0x02);
+		reg32_write(AFE_OFFDRV, 0x00);
+		reg32_write(AFE_INPCONFIG, 0x1e);
+		break;
+	case 1:
+		reg32_write(AFE_INPFLT, 0x02);
+		reg32_write(AFE_OFFDRV, 0x00);
+		reg32_write(AFE_INPCONFIG, 0x2d);
+		break;
+	case 2:
+		reg32_write(AFE_INPFLT, 0x02);
+		reg32_write(AFE_OFFDRV, 0x00);
+		reg32_write(AFE_INPCONFIG, 0x4b);
+		break;
+	case 3:
+		reg32_write(AFE_INPFLT, 0x02);
+		reg32_write(AFE_OFFDRV, 0x00);
+		reg32_write(AFE_INPCONFIG, 0x87);
+		break;
+	default:
+		printf("error video input %d\n", vadc_in);
+	}
+}
+
+/*!
+ * Return attributes of current video standard.
+ * Since this device autodetects the current standard, this function also
+ * sets the values that need to be changed if the standard changes.
+ * There is no set std equivalent function.
+ *
+ *  @return		None.
+ */
+void vadc_get_std(struct sensor_data *vadc)
+{
+	int tmp;
+	int idx;
+
+	/* Read PAL mode detected result */
+	tmp = reg32_read(VDEC_VIDMOD);
+	tmp &= (VDEC_VIDMOD_PAL_MASK | VDEC_VIDMOD_M625_MASK);
+
+	if (tmp)
+		idx = STD_PAL;
+	else
+		idx = STD_NTSC;
+
+	vadc->std_id = idx;
+	vadc->pixel_fmt = FMT_YUV444;
+	vadc->width = video_fmts[idx].active_width;
+	vadc->height = video_fmts[idx].active_height;
+}
+
+void vadc_config(u32 vadc_in)
+{
+	struct sensor_data vadc;
+
+	/* map vafe,vdec,gpr,gpc address  */
+	vafe_regbase = (u32 *)VADC_BASE_ADDR;
+	vdec_regbase = (u32 *)VDEC_BASE_ADDR;
+
+	vadc_power_up();
+
+	/* clock config for vadc */
+	reg32_write(VDEC_BASE + 0x320, 0xe3);
+	reg32_write(VDEC_BASE + 0x324, 0x38);
+	reg32_write(VDEC_BASE + 0x328, 0x8e);
+	reg32_write(VDEC_BASE + 0x32c, 0x23);
+	mxs_set_vadcclk();
+
+	afe_init();
+
+	/* select Video Input 0-3 */
+	vadc_select_input(vadc_in);
+
+	afe_voltage_clampingmode();
+
+	vdec_init(&vadc);
+
+	/*
+	* current control loop will move sinewave input off below
+	* the bottom of the signal range visible when the testbus is viewed as magnitude,
+	* so have to break before this point while capturing ENOB data:
+	*/
+	afe_alwayson_clampingmode();
+}
+
diff -urN u-boot-2016.03/drivers/video/mxc_vadc.h ebf_6ull_uboot/drivers/video/mxc_vadc.h
--- u-boot-2016.03/drivers/video/mxc_vadc.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/drivers/video/mxc_vadc.h	2021-04-16 14:42:16.324589232 +0800
@@ -0,0 +1,230 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef MXC_VADC_H
+#define MXC_VADC_H
+
+/*** define base address ***/
+#define VDEC_BASE vdec_regbase
+#define AFE_BASE vafe_regbase
+
+/* AFE - Register offsets */
+#define AFE_BLOCK_ID_OFFSET				0x00000000
+#define AFE_PDBUF_OFFSET				0x00000004
+#define AFE_SWRST_OFFSET				0x00000008
+#define AFE_TSTSEL_OFFSET				0x0000000c
+#define AFE_TSTMSC_OFFSET				0x00000010
+#define AFE_ENPADIO_OFFSET				0x00000014
+#define AFE_BGREG_OFFSET				0x00000018
+#define AFE_ACCESSAR_ID_OFFSET			0x00000400
+#define AFE_PDADC_OFFSET				0x00000404
+#define AFE_PDSARH_OFFSET				0x00000408
+#define AFE_PDSARL_OFFSET				0x0000040C
+#define AFE_PDADCRFH_OFFSET				0x00000410
+#define AFE_PDADCRFL_OFFSET				0x00000414
+#define AFE_ACCTST_OFFSET				0x00000418
+#define AFE_ADCGN_OFFSET				0x0000041C
+#define AFE_ICTRL_OFFSET				0x00000420
+#define AFE_ICTLSTG_OFFSET				0x00000424
+#define AFE_RCTRLSTG_OFFSET				0x00000428
+#define AFE_TCTRLSTG_OFFSET				0x0000042c
+#define AFE_REFMOD_OFFSET				0x00000430
+#define AFE_REFTRIML_OFFSET				0x00000434
+#define AFE_REFTRIMH_OFFSET				0x00000438
+#define AFE_ADCR_OFFSET					0x0000043c
+#define AFE_DUMMY0_OFFSET				0x00000440
+#define AFE_DUMMY1_OFFSET				0x00000444
+#define AFE_DUMMY2_OFFSET				0x00000448
+#define AFE_DACAMP_OFFSET				0x0000044c
+#define AFE_CLMPTST_OFFSET				0x00000450
+#define AFE_CLMPDAT_OFFSET				0x00000454
+#define AFE_CLMPAMP_OFFSET				0x00000458
+#define AFE_CLAMP_OFFSET				0x0000045c
+#define AFE_INPBUF_OFFSET				0x00000460
+#define AFE_INPFLT_OFFSET				0x00000464
+#define AFE_ADCDGN_OFFSET				0x00000468
+#define AFE_OFFDRV_OFFSET				0x0000046c
+#define AFE_INPCONFIG_OFFSET			0x00000470
+#define AFE_PROGDELAY_OFFSET			0x00000474
+#define AFE_ADCOMT_OFFSET				0x00000478
+#define AFE_ALGDELAY_OFFSET				0x0000047c
+#define AFE_ACC_ID_OFFSET				0x00000800
+#define AFE_ACCSTA_OFFSET				0x00000804
+#define AFE_ACCNOSLI_OFFSET				0x00000808
+#define AFE_ACCCALCON_OFFSET			0x0000080c
+#define AFE_BWEWRICTRL_OFFSET			0x00000810
+#define AFE_SELSLI_OFFSET				0x00000814
+#define AFE_SELBYT_OFFSET				0x00000818
+#define AFE_REDVAL_OFFSET				0x00000820
+#define AFE_WRIBYT_OFFSET				0x00000824
+
+/* AFE Register per module */
+#define AFE_BLOCK_ID			(AFE_BASE + AFE_BLOCK_ID_OFFSET)
+#define AFE_PDBUF				(AFE_BASE + AFE_PDBUF_OFFSET)
+#define AFE_SWRST				(AFE_BASE + AFE_SWRST_OFFSET)
+#define AFE_TSTSEL				(AFE_BASE + AFE_TSTSEL_OFFSET)
+#define AFE_TSTMSC				(AFE_BASE + AFE_TSTMSC_OFFSET)
+#define AFE_ENPADIO				(AFE_BASE + AFE_ENPADIO_OFFSET)
+#define AFE_BGREG				(AFE_BASE + AFE_BGREG_OFFSET)
+#define AFE_ACCESSAR_ID			(AFE_BASE + AFE_ACCESSAR_ID_OFFSET)
+#define AFE_PDADC				(AFE_BASE + AFE_PDADC_OFFSET)
+#define AFE_PDSARH			    (AFE_BASE + AFE_PDSARH_OFFSET)
+#define AFE_PDSARL			    (AFE_BASE + AFE_PDSARL_OFFSET)
+#define AFE_PDADCRFH			(AFE_BASE + AFE_PDADCRFH_OFFSET)
+#define AFE_PDADCRFL			(AFE_BASE + AFE_PDADCRFL_OFFSET)
+#define AFE_ACCTST				(AFE_BASE + AFE_ACCTST_OFFSET)
+#define AFE_ADCGN				(AFE_BASE + AFE_ADCGN_OFFSET)
+#define AFE_ICTRL				(AFE_BASE + AFE_ICTRL_OFFSET)
+#define AFE_ICTLSTG				(AFE_BASE + AFE_ICTLSTG_OFFSET)
+#define AFE_RCTRLSTG			(AFE_BASE + AFE_RCTRLSTG_OFFSET)
+#define AFE_TCTRLSTG			(AFE_BASE + AFE_TCTRLSTG_OFFSET)
+#define AFE_REFMOD				(AFE_BASE + AFE_REFMOD_OFFSET)
+#define AFE_REFTRIML			(AFE_BASE + AFE_REFTRIML_OFFSET)
+#define AFE_REFTRIMH			(AFE_BASE + AFE_REFTRIMH_OFFSET)
+#define AFE_ADCR				(AFE_BASE + AFE_ADCR_OFFSET)
+#define AFE_DUMMY0				(AFE_BASE + AFE_DUMMY0_OFFSET)
+#define AFE_DUMMY1				(AFE_BASE + AFE_DUMMY1_OFFSET)
+#define AFE_DUMMY2				(AFE_BASE + AFE_DUMMY2_OFFSET)
+#define AFE_DACAMP				(AFE_BASE + AFE_DACAMP_OFFSET)
+#define AFE_CLMPTST				(AFE_BASE + AFE_CLMPTST_OFFSET)
+#define AFE_CLMPDAT				(AFE_BASE + AFE_CLMPDAT_OFFSET)
+#define AFE_CLMPAMP				(AFE_BASE + AFE_CLMPAMP_OFFSET)
+#define AFE_CLAMP				(AFE_BASE + AFE_CLAMP_OFFSET)
+#define AFE_INPBUF				(AFE_BASE + AFE_INPBUF_OFFSET)
+#define AFE_INPFLT				(AFE_BASE + AFE_INPFLT_OFFSET)
+#define AFE_ADCDGN				(AFE_BASE + AFE_ADCDGN_OFFSET)
+#define AFE_OFFDRV				(AFE_BASE + AFE_OFFDRV_OFFSET)
+#define AFE_INPCONFIG			(AFE_BASE + AFE_INPCONFIG_OFFSET)
+#define AFE_PROGDELAY			(AFE_BASE + AFE_PROGDELAY_OFFSET)
+#define AFE_ADCOMT				(AFE_BASE + AFE_ADCOMT_OFFSET)
+#define AFE_ALGDELAY			(AFE_BASE + AFE_ALGDELAY_OFFSET)
+#define AFE_ACC_ID				(AFE_BASE + AFE_ACC_ID_OFFSET)
+#define AFE_ACCSTA				(AFE_BASE + AFE_ACCSTA_OFFSET)
+#define AFE_ACCNOSLI			(AFE_BASE + AFE_ACCNOSLI_OFFSET)
+#define AFE_ACCCALCON			(AFE_BASE + AFE_ACCCALCON_OFFSET)
+#define AFE_BWEWRICTRL			(AFE_BASE + AFE_BWEWRICTRL_OFFSET)
+#define AFE_SELSLI				(AFE_BASE + AFE_SELSLI_OFFSET)
+#define AFE_SELBYT				(AFE_BASE + AFE_SELBYT_OFFSET)
+#define AFE_REDVAL				(AFE_BASE + AFE_REDVAL_OFFSET)
+#define AFE_WRIBYT				(AFE_BASE + AFE_WRIBYT_OFFSET)
+
+/* VDEC - Register offsets */
+#define VDEC_CFC1_OFFSET                0x00000000
+#define VDEC_CFC2_OFFSET                0x00000004
+#define VDEC_BRSTGT_OFFSET              0x00000024
+#define VDEC_HZPOS_OFFSET               0x00000040
+#define VDEC_VRTPOS_OFFSET              0x00000044
+#define VDEC_HVSHIFT_OFFSET             0x00000054
+#define VDEC_HSIGS_OFFSET               0x00000058
+#define VDEC_HSIGE_OFFSET               0x0000005C
+#define VDEC_VSCON1_OFFSET              0x00000060
+#define VDEC_VSCON2_OFFSET              0x00000064
+#define VDEC_YCDEL_OFFSET               0x0000006C
+#define VDEC_AFTCLP_OFFSET              0x00000070
+#define VDEC_DCOFF_OFFSET               0x00000078
+#define VDEC_CSID_OFFSET                0x00000084
+#define VDEC_CBGN_OFFSET                0x00000088
+#define VDEC_CRGN_OFFSET                0x0000008C
+#define VDEC_CNTR_OFFSET                0x00000090
+#define VDEC_BRT_OFFSET                 0x00000094
+#define VDEC_HUE_OFFSET                 0x00000098
+#define VDEC_CHBTH_OFFSET               0x0000009C
+#define VDEC_SHPIMP_OFFSET              0x000000A4
+#define VDEC_CHPLLIM_OFFSET             0x000000A8
+#define VDEC_VIDMOD_OFFSET              0x000000AC
+#define VDEC_VIDSTS_OFFSET              0x000000B0
+#define VDEC_NOISE_OFFSET               0x000000B4
+#define VDEC_STDDBG_OFFSET              0x000000B8
+#define VDEC_MANOVR_OFFSET              0x000000BC
+#define VDEC_VSSGTH_OFFSET              0x000000C8
+#define VDEC_DBGFBH_OFFSET              0x000000D0
+#define VDEC_DBGFBL_OFFSET              0x000000D4
+#define VDEC_HACTS_OFFSET               0x000000D8
+#define VDEC_HACTE_OFFSET               0x000000DC
+#define VDEC_VACTS_OFFSET               0x000000E0
+#define VDEC_VACTE_OFFSET               0x000000E4
+#define VDEC_HSTIP_OFFSET               0x000000EC
+#define VDEC_BLSCRY_OFFSET              0x000000F4
+#define VDEC_BLSCRCR_OFFSET             0x000000F8
+#define VDEC_BLSCRCB_OFFSET             0x000000FC
+#define VDEC_LMAGC2_OFFSET              0x00000104
+#define VDEC_CHAGC1_OFFSET              0x00000108
+#define VDEC_CHAGC2_OFFSET              0x0000010C
+#define VDEC_MINTH_OFFSET               0x00000114
+#define VDEC_VFRQOH_OFFSET              0x0000011C
+#define VDEC_VFRQOL_OFFSET              0x00000120
+#define VDEC_THSH1_OFFSET               0x00000124
+#define VDEC_THSH2_OFFSET               0x00000128
+#define VDEC_NCHTH_OFFSET               0x0000012C
+#define VDEC_TH1F_OFFSET                0x00000130
+
+/* VDEC Register per module */
+#define VDEC_CFC1                        (VDEC_BASE + VDEC_CFC1_OFFSET)
+#define VDEC_CFC2                        (VDEC_BASE + VDEC_CFC2_OFFSET)
+#define VDEC_BRSTGT                      (VDEC_BASE + VDEC_BRSTGT_OFFSET)
+#define VDEC_HZPOS                       (VDEC_BASE + VDEC_HZPOS_OFFSET)
+#define VDEC_VRTPOS                      (VDEC_BASE + VDEC_VRTPOS_OFFSET)
+#define VDEC_HVSHIFT                     (VDEC_BASE + VDEC_HVSHIFT_OFFSET)
+#define VDEC_HSIGS                       (VDEC_BASE + VDEC_HSIGS_OFFSET)
+#define VDEC_HSIGE                       (VDEC_BASE + VDEC_HSIGE_OFFSET)
+#define VDEC_VSCON1                      (VDEC_BASE + VDEC_VSCON1_OFFSET)
+#define VDEC_VSCON2                      (VDEC_BASE + VDEC_VSCON2_OFFSET)
+#define VDEC_YCDEL                       (VDEC_BASE + VDEC_YCDEL_OFFSET)
+#define VDEC_AFTCLP                      (VDEC_BASE + VDEC_AFTCLP_OFFSET)
+#define VDEC_DCOFF                       (VDEC_BASE + VDEC_DCOFF_OFFSET)
+#define VDEC_CSID                        (VDEC_BASE + VDEC_CSID_OFFSET)
+#define VDEC_CBGN                        (VDEC_BASE + VDEC_CBGN_OFFSET)
+#define VDEC_CRGN                        (VDEC_BASE + VDEC_CRGN_OFFSET)
+#define VDEC_CNTR                        (VDEC_BASE + VDEC_CNTR_OFFSET)
+#define VDEC_BRT                         (VDEC_BASE + VDEC_BRT_OFFSET)
+#define VDEC_HUE                         (VDEC_BASE + VDEC_HUE_OFFSET)
+#define VDEC_CHBTH                       (VDEC_BASE + VDEC_CHBTH_OFFSET)
+#define VDEC_SHPIMP                      (VDEC_BASE + VDEC_SHPIMP_OFFSET)
+#define VDEC_CHPLLIM                     (VDEC_BASE + VDEC_CHPLLIM_OFFSET)
+#define VDEC_VIDMOD                      (VDEC_BASE + VDEC_VIDMOD_OFFSET)
+#define VDEC_VIDSTS                      (VDEC_BASE + VDEC_VIDSTS_OFFSET)
+#define VDEC_NOISE                       (VDEC_BASE + VDEC_NOISE_OFFSET)
+#define VDEC_STDDBG                      (VDEC_BASE + VDEC_STDDBG_OFFSET)
+#define VDEC_MANOVR                      (VDEC_BASE + VDEC_MANOVR_OFFSET)
+#define VDEC_VSSGTH                      (VDEC_BASE + VDEC_VSSGTH_OFFSET)
+#define VDEC_DBGFBH                      (VDEC_BASE + VDEC_DBGFBH_OFFSET)
+#define VDEC_DBGFBL                      (VDEC_BASE + VDEC_DBGFBL_OFFSET)
+#define VDEC_HACTS                       (VDEC_BASE + VDEC_HACTS_OFFSET)
+#define VDEC_HACTE                       (VDEC_BASE + VDEC_HACTE_OFFSET)
+#define VDEC_VACTS                       (VDEC_BASE + VDEC_VACTS_OFFSET)
+#define VDEC_VACTE                       (VDEC_BASE + VDEC_VACTE_OFFSET)
+#define VDEC_HSTIP                       (VDEC_BASE + VDEC_HSTIP_OFFSET)
+#define VDEC_BLSCRY                      (VDEC_BASE + VDEC_BLSCRY_OFFSET)
+#define VDEC_BLSCRCR                     (VDEC_BASE + VDEC_BLSCRCR_OFFSET)
+#define VDEC_BLSCRCB                     (VDEC_BASE + VDEC_BLSCRCB_OFFSET)
+#define VDEC_LMAGC2                      (VDEC_BASE + VDEC_LMAGC2_OFFSET)
+#define VDEC_CHAGC1                      (VDEC_BASE + VDEC_CHAGC1_OFFSET)
+#define VDEC_CHAGC2                      (VDEC_BASE + VDEC_CHAGC2_OFFSET)
+#define VDEC_MINTH                       (VDEC_BASE + VDEC_MINTH_OFFSET)
+#define VDEC_VFRQOH                      (VDEC_BASE + VDEC_VFRQOH_OFFSET)
+#define VDEC_VFRQOL                      (VDEC_BASE + VDEC_VFRQOL_OFFSET)
+#define VDEC_THSH1                       (VDEC_BASE + VDEC_THSH1_OFFSET)
+#define VDEC_THSH2                       (VDEC_BASE + VDEC_THSH2_OFFSET)
+#define VDEC_NCHTH                       (VDEC_BASE + VDEC_NCHTH_OFFSET)
+#define VDEC_TH1F                        (VDEC_BASE + VDEC_TH1F_OFFSET)
+
+#define VDEC_VIDMOD_M625_SHIFT            4
+#define VDEC_VIDMOD_M625_MASK             (1 << VDEC_VIDMOD_M625_SHIFT)
+
+#define VDEC_VIDMOD_PAL_SHIFT             7
+#define VDEC_VIDMOD_PAL_MASK              (1 << VDEC_VIDMOD_PAL_SHIFT)
+
+struct sensor_data {
+	u32 width;
+	u32 height;
+	u32 pixel_fmt;
+	u32 std_id;
+};
+
+void vadc_config(u32 vadc_in);
+void vadc_get_std(struct sensor_data *vadc);
+
+#endif
diff -urN u-boot-2016.03/drivers/video/mxsfb.c ebf_6ull_uboot/drivers/video/mxsfb.c
--- u-boot-2016.03/drivers/video/mxsfb.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/video/mxsfb.c	2021-04-16 14:42:16.324589232 +0800
@@ -3,6 +3,8 @@
  *
  * Copyright (C) 2011-2013 Marek Vasut <marex@denx.de>
  *
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 #include <common.h>
@@ -18,6 +20,14 @@
 #include <asm/imx-common/dma.h>
 
 #include "videomodes.h"
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/fb.h>
+#include <mxsfb.h>
+
+#ifdef CONFIG_VIDEO_GIS
+#include <gis.h>
+#endif
 
 #define	PS2KHZ(ps)	(1000000000UL / (ps))
 
@@ -35,6 +45,31 @@
 {
 }
 
+static int setup;
+static struct fb_videomode fbmode;
+static int depth;
+
+int mxs_lcd_panel_setup(struct fb_videomode mode, int bpp,
+	uint32_t base_addr)
+{
+	fbmode = mode;
+	depth  = bpp;
+	panel.isaBase  = base_addr;
+
+	setup = 1;
+
+	return 0;
+}
+
+void mxs_lcd_get_panel(struct display_panel *dispanel)
+{
+	dispanel->width = fbmode.xres;
+	dispanel->height = fbmode.yres;
+	dispanel->reg_base = panel.isaBase;
+	dispanel->gdfindex = panel.gdfIndex;
+	dispanel->gdfbytespp = panel.gdfBytesPP;
+}
+
 /*
  * DENX M28EVK:
  * setenv videomode
@@ -50,12 +85,12 @@
 static void mxs_lcd_init(GraphicDevice *panel,
 			struct ctfb_res_modes *mode, int bpp)
 {
-	struct mxs_lcdif_regs *regs = (struct mxs_lcdif_regs *)MXS_LCDIF_BASE;
+	struct mxs_lcdif_regs *regs = (struct mxs_lcdif_regs *)(panel->isaBase);
 	uint32_t word_len = 0, bus_width = 0;
 	uint8_t valid_data = 0;
 
 	/* Kick in the LCDIF clock */
-	mxs_set_lcdclk(MXS_LCDIF_BASE, PS2KHZ(mode->pixclock));
+	mxs_set_lcdclk(panel->isaBase, PS2KHZ(mode->pixclock));
 
 	/* Restart the LCDIF block */
 	mxs_reset_block(&regs->hw_lcdif_ctrl_reg);
@@ -133,9 +168,13 @@
 
 void lcdif_power_down(void)
 {
-	struct mxs_lcdif_regs *regs = (struct mxs_lcdif_regs *)MXS_LCDIF_BASE;
+	struct mxs_lcdif_regs *regs = (struct mxs_lcdif_regs *)(panel.isaBase);
 	int timeout = 1000000;
 
+#ifdef CONFIG_MX6
+	if (check_module_fused(MX6_MODULE_LCDIF))
+		return;
+#endif
 	writel(panel.frameAdrs, &regs->hw_lcdif_cur_buf_reg);
 	writel(panel.frameAdrs, &regs->hw_lcdif_next_buf_reg);
 	writel(LCDIF_CTRL1_VSYNC_EDGE_IRQ, &regs->hw_lcdif_ctrl1_clr);
@@ -157,19 +196,43 @@
 
 	puts("Video: ");
 
-	/* Suck display configuration from "videomode" variable */
-	penv = getenv("videomode");
-	if (!penv) {
-		puts("MXSFB: 'videomode' variable not set!\n");
-		return NULL;
-	}
+	if (!setup) {
 
-	bpp = video_get_params(&mode, penv);
+		/* Suck display configuration from "videomode" variable */
+		penv = getenv("videomode");
+		if (!penv) {
+			printf("MXSFB: 'videomode' variable not set!\n");
+			return NULL;
+		}
+
+		bpp = video_get_params(&mode, penv);
+		panel.isaBase  = MXS_LCDIF_BASE;
+	} else {
+		mode.xres = fbmode.xres;
+		mode.yres = fbmode.yres;
+		mode.pixclock = fbmode.pixclock;
+		mode.left_margin = fbmode.left_margin;
+		mode.right_margin = fbmode.right_margin;
+		mode.upper_margin = fbmode.upper_margin;
+		mode.lower_margin = fbmode.lower_margin;
+		mode.hsync_len = fbmode.hsync_len;
+		mode.vsync_len = fbmode.vsync_len;
+		mode.sync = fbmode.sync;
+		mode.vmode = fbmode.vmode;
+		bpp = depth;
+	}
 
+#ifdef CONFIG_MX6
+	if (check_module_fused(MX6_MODULE_LCDIF)) {
+		printf("LCDIF@0x%x is fused, disable it\n", MXS_LCDIF_BASE);
+		return NULL;
+	}
+#endif
 	/* fill in Graphic device struct */
 	sprintf(panel.modeIdent, "%dx%dx%d",
 			mode.xres, mode.yres, bpp);
 
+
 	panel.winSizeX = mode.xres;
 	panel.winSizeY = mode.yres;
 	panel.plnSizeX = mode.xres;
@@ -196,6 +259,7 @@
 
 	panel.memSize = mode.xres * mode.yres * panel.gdfBytesPP;
 
+
 	/* Allocate framebuffer */
 	fb = memalign(ARCH_DMA_MINALIGN,
 		      roundup(panel.memSize, ARCH_DMA_MINALIGN));
@@ -237,5 +301,10 @@
 	mxs_dma_circ_start(MXS_DMA_CHANNEL_AHB_APBH_LCDIF, &desc);
 #endif
 
+#ifdef CONFIG_VIDEO_GIS
+	/* Entry for GIS */
+	mxc_enable_gis();
+#endif
+
 	return (void *)&panel;
 }
diff -urN u-boot-2016.03/drivers/watchdog/imx_watchdog.c ebf_6ull_uboot/drivers/watchdog/imx_watchdog.c
--- u-boot-2016.03/drivers/watchdog/imx_watchdog.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/drivers/watchdog/imx_watchdog.c	2021-04-16 14:42:16.328589252 +0800
@@ -9,6 +9,7 @@
 #include <watchdog.h>
 #include <asm/arch/imx-regs.h>
 #include <fsl_wdog.h>
+#include <asm/arch/sys_proto.h>
 
 #ifdef CONFIG_IMX_WATCHDOG
 void hw_watchdog_reset(void)
@@ -43,7 +44,10 @@
 {
 	struct watchdog_regs *wdog = (struct watchdog_regs *)WDOG1_BASE_ADDR;
 
-	clrsetbits_le16(&wdog->wcr, WCR_WT_MSK, WCR_WDE);
+	if (is_cpu_type(MXC_CPU_MX7D))
+		clrsetbits_le16(&wdog->wcr, WCR_WT_MSK, (WCR_WDE | WCR_SRS));
+	else
+		clrsetbits_le16(&wdog->wcr, WCR_WT_MSK, WCR_WDE);
 
 	writew(0x5555, &wdog->wsr);
 	writew(0xaaaa, &wdog->wsr);	/* load minimum 1/2 second timeout */
diff -urN u-boot-2016.03/.git/config ebf_6ull_uboot/.git/config
--- u-boot-2016.03/.git/config	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/config	2021-04-16 14:42:13.932576852 +0800
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = git@github.com:Embedfire/ebf_6ull_uboot.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -urN u-boot-2016.03/.git/description ebf_6ull_uboot/.git/description
--- u-boot-2016.03/.git/description	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/description	2021-04-16 14:42:13.912576749 +0800
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -urN u-boot-2016.03/.git/HEAD ebf_6ull_uboot/.git/HEAD
--- u-boot-2016.03/.git/HEAD	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/HEAD	2021-04-16 14:42:13.932576852 +0800
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -urN u-boot-2016.03/.git/hooks/applypatch-msg.sample ebf_6ull_uboot/.git/hooks/applypatch-msg.sample
--- u-boot-2016.03/.git/hooks/applypatch-msg.sample	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/hooks/applypatch-msg.sample	2021-04-16 14:42:13.912576749 +0800
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
+test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
+:
diff -urN u-boot-2016.03/.git/hooks/commit-msg.sample ebf_6ull_uboot/.git/hooks/commit-msg.sample
--- u-boot-2016.03/.git/hooks/commit-msg.sample	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/hooks/commit-msg.sample	2021-04-16 14:42:13.912576749 +0800
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -urN u-boot-2016.03/.git/hooks/fsmonitor-watchman.sample ebf_6ull_uboot/.git/hooks/fsmonitor-watchman.sample
--- u-boot-2016.03/.git/hooks/fsmonitor-watchman.sample	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/hooks/fsmonitor-watchman.sample	2021-04-16 14:42:13.912576749 +0800
@@ -0,0 +1,114 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+use IPC::Open2;
+
+# An example hook script to integrate Watchman
+# (https://facebook.github.io/watchman/) with git to speed up detecting
+# new and modified files.
+#
+# The hook is passed a version (currently 1) and a time in nanoseconds
+# formatted as a string and outputs to stdout all files that have been
+# modified since the given time. Paths must be relative to the root of
+# the working tree and separated by a single NUL.
+#
+# To enable this hook, rename this file to "query-watchman" and set
+# 'git config core.fsmonitor .git/hooks/query-watchman'
+#
+my ($version, $time) = @ARGV;
+
+# Check the hook interface version
+
+if ($version == 1) {
+	# convert nanoseconds to seconds
+	$time = int $time / 1000000000;
+} else {
+	die "Unsupported query-fsmonitor hook version '$version'.\n" .
+	    "Falling back to scanning...\n";
+}
+
+my $git_work_tree;
+if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+	$git_work_tree = Win32::GetCwd();
+	$git_work_tree =~ tr/\\/\//;
+} else {
+	require Cwd;
+	$git_work_tree = Cwd::cwd();
+}
+
+my $retry = 1;
+
+launch_watchman();
+
+sub launch_watchman {
+
+	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
+	    or die "open2() failed: $!\n" .
+	    "Falling back to scanning...\n";
+
+	# In the query expression below we're asking for names of files that
+	# changed since $time but were not transient (ie created after
+	# $time but no longer exist).
+	#
+	# To accomplish this, we're using the "since" generator to use the
+	# recency index to select candidate nodes and "fields" to limit the
+	# output to file names only. Then we're using the "expression" term to
+	# further constrain the results.
+	#
+	# The category of transient files that we want to ignore will have a
+	# creation clock (cclock) newer than $time_t value and will also not
+	# currently exist.
+
+	my $query = <<"	END";
+		["query", "$git_work_tree", {
+			"since": $time,
+			"fields": ["name"],
+			"expression": ["not", ["allof", ["since", $time, "cclock"], ["not", "exists"]]]
+		}]
+	END
+
+	print CHLD_IN $query;
+	close CHLD_IN;
+	my $response = do {local $/; <CHLD_OUT>};
+
+	die "Watchman: command returned no output.\n" .
+	    "Falling back to scanning...\n" if $response eq "";
+	die "Watchman: command returned invalid output: $response\n" .
+	    "Falling back to scanning...\n" unless $response =~ /^\{/;
+
+	my $json_pkg;
+	eval {
+		require JSON::XS;
+		$json_pkg = "JSON::XS";
+		1;
+	} or do {
+		require JSON::PP;
+		$json_pkg = "JSON::PP";
+	};
+
+	my $o = $json_pkg->new->utf8->decode($response);
+
+	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
+		print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
+		$retry--;
+		qx/watchman watch "$git_work_tree"/;
+		die "Failed to make watchman watch '$git_work_tree'.\n" .
+		    "Falling back to scanning...\n" if $? != 0;
+
+		# Watchman will always return all files on the first query so
+		# return the fast "everything is dirty" flag to git and do the
+		# Watchman query just to get it over with now so we won't pay
+		# the cost in git to look up each individual file.
+		print "/\0";
+		eval { launch_watchman() };
+		exit 0;
+	}
+
+	die "Watchman: $o->{error}.\n" .
+	    "Falling back to scanning...\n" if $o->{error};
+
+	binmode STDOUT, ":utf8";
+	local $, = "\0";
+	print @{$o->{files}};
+}
diff -urN u-boot-2016.03/.git/hooks/post-update.sample ebf_6ull_uboot/.git/hooks/post-update.sample
--- u-boot-2016.03/.git/hooks/post-update.sample	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/hooks/post-update.sample	2021-04-16 14:42:13.912576749 +0800
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -urN u-boot-2016.03/.git/hooks/pre-applypatch.sample ebf_6ull_uboot/.git/hooks/pre-applypatch.sample
--- u-boot-2016.03/.git/hooks/pre-applypatch.sample	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/hooks/pre-applypatch.sample	2021-04-16 14:42:13.912576749 +0800
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+precommit="$(git rev-parse --git-path hooks/pre-commit)"
+test -x "$precommit" && exec "$precommit" ${1+"$@"}
+:
diff -urN u-boot-2016.03/.git/hooks/pre-commit.sample ebf_6ull_uboot/.git/hooks/pre-commit.sample
--- u-boot-2016.03/.git/hooks/pre-commit.sample	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/hooks/pre-commit.sample	2021-04-16 14:42:13.912576749 +0800
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -urN u-boot-2016.03/.git/hooks/prepare-commit-msg.sample ebf_6ull_uboot/.git/hooks/prepare-commit-msg.sample
--- u-boot-2016.03/.git/hooks/prepare-commit-msg.sample	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/hooks/prepare-commit-msg.sample	2021-04-16 14:42:13.912576749 +0800
@@ -0,0 +1,42 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples. The first one removes the
+# "# Please enter the commit message..." help message.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+COMMIT_MSG_FILE=$1
+COMMIT_SOURCE=$2
+SHA1=$3
+
+/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
+
+# case "$COMMIT_SOURCE,$SHA1" in
+#  ,|template,)
+#    /usr/bin/perl -i.bak -pe '
+#       print "\n" . `git diff --cached --name-status -r`
+# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
+#  *) ;;
+# esac
+
+# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
+# if test -z "$COMMIT_SOURCE"
+# then
+#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
+# fi
diff -urN u-boot-2016.03/.git/hooks/pre-push.sample ebf_6ull_uboot/.git/hooks/pre-push.sample
--- u-boot-2016.03/.git/hooks/pre-push.sample	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/hooks/pre-push.sample	2021-04-16 14:42:13.912576749 +0800
@@ -0,0 +1,53 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo >&2 "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -urN u-boot-2016.03/.git/hooks/pre-rebase.sample ebf_6ull_uboot/.git/hooks/pre-rebase.sample
--- u-boot-2016.03/.git/hooks/pre-rebase.sample	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/hooks/pre-rebase.sample	2021-04-16 14:42:13.912576749 +0800
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up to date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+<<\DOC_END
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
+
+DOC_END
diff -urN u-boot-2016.03/.git/hooks/pre-receive.sample ebf_6ull_uboot/.git/hooks/pre-receive.sample
--- u-boot-2016.03/.git/hooks/pre-receive.sample	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/hooks/pre-receive.sample	2021-04-16 14:42:13.912576749 +0800
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to make use of push options.
+# The example simply echoes all push options that start with 'echoback='
+# and rejects all pushes when the "reject" push option is used.
+#
+# To enable this hook, rename this file to "pre-receive".
+
+if test -n "$GIT_PUSH_OPTION_COUNT"
+then
+	i=0
+	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
+	do
+		eval "value=\$GIT_PUSH_OPTION_$i"
+		case "$value" in
+		echoback=*)
+			echo "echo from the pre-receive-hook: ${value#*=}" >&2
+			;;
+		reject)
+			exit 1
+		esac
+		i=$((i + 1))
+	done
+fi
diff -urN u-boot-2016.03/.git/hooks/update.sample ebf_6ull_uboot/.git/hooks/update.sample
--- u-boot-2016.03/.git/hooks/update.sample	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/hooks/update.sample	2021-04-16 14:42:13.912576749 +0800
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to block unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
二进制文件 u-boot-2016.03/.git/index 和 ebf_6ull_uboot/.git/index 不同
diff -urN u-boot-2016.03/.git/info/exclude ebf_6ull_uboot/.git/info/exclude
--- u-boot-2016.03/.git/info/exclude	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/info/exclude	2021-04-16 14:42:13.912576749 +0800
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -urN u-boot-2016.03/.git/logs/HEAD ebf_6ull_uboot/.git/logs/HEAD
--- u-boot-2016.03/.git/logs/HEAD	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/logs/HEAD	2021-04-16 14:42:13.932576852 +0800
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 d48487689c49f2c29013374689decbbb5bf1459d hejiawencc <hjw0415@outlook.com> 1618545506 +0800	clone: from git@github.com:Embedfire/ebf_6ull_uboot.git
diff -urN u-boot-2016.03/.git/logs/refs/heads/master ebf_6ull_uboot/.git/logs/refs/heads/master
--- u-boot-2016.03/.git/logs/refs/heads/master	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/logs/refs/heads/master	2021-04-16 14:42:13.932576852 +0800
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 d48487689c49f2c29013374689decbbb5bf1459d hejiawencc <hjw0415@outlook.com> 1618545506 +0800	clone: from git@github.com:Embedfire/ebf_6ull_uboot.git
diff -urN u-boot-2016.03/.git/logs/refs/remotes/origin/HEAD ebf_6ull_uboot/.git/logs/refs/remotes/origin/HEAD
--- u-boot-2016.03/.git/logs/refs/remotes/origin/HEAD	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/logs/refs/remotes/origin/HEAD	2021-04-16 14:42:13.932576852 +0800
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 d48487689c49f2c29013374689decbbb5bf1459d hejiawencc <hjw0415@outlook.com> 1618545506 +0800	clone: from git@github.com:Embedfire/ebf_6ull_uboot.git
二进制文件 u-boot-2016.03/.git/objects/pack/pack-38dce304c82f2c22126bcef26dc18244f87e7025.idx 和 ebf_6ull_uboot/.git/objects/pack/pack-38dce304c82f2c22126bcef26dc18244f87e7025.idx 不同
二进制文件 u-boot-2016.03/.git/objects/pack/pack-38dce304c82f2c22126bcef26dc18244f87e7025.pack 和 ebf_6ull_uboot/.git/objects/pack/pack-38dce304c82f2c22126bcef26dc18244f87e7025.pack 不同
diff -urN u-boot-2016.03/.git/packed-refs ebf_6ull_uboot/.git/packed-refs
--- u-boot-2016.03/.git/packed-refs	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/packed-refs	2021-04-16 14:42:13.932576852 +0800
@@ -0,0 +1,2 @@
+# pack-refs with: peeled fully-peeled sorted 
+d48487689c49f2c29013374689decbbb5bf1459d refs/remotes/origin/master
diff -urN u-boot-2016.03/.git/refs/heads/master ebf_6ull_uboot/.git/refs/heads/master
--- u-boot-2016.03/.git/refs/heads/master	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/refs/heads/master	2021-04-16 14:42:13.912576749 +0800
@@ -0,0 +1 @@
+d48487689c49f2c29013374689decbbb5bf1459d
diff -urN u-boot-2016.03/.git/refs/remotes/origin/HEAD ebf_6ull_uboot/.git/refs/remotes/origin/HEAD
--- u-boot-2016.03/.git/refs/remotes/origin/HEAD	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/.git/refs/remotes/origin/HEAD	2021-04-16 14:42:13.912576749 +0800
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -urN u-boot-2016.03/.gitignore ebf_6ull_uboot/.gitignore
--- u-boot-2016.03/.gitignore	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/.gitignore	1970-01-01 08:00:00.000000000 +0800
@@ -1,86 +0,0 @@
-#
-# NOTE! Don't add files that are generated in specific
-# subdirectories here. Add them in the ".gitignore" file
-# in that subdirectory instead.
-#
-# Normal rules
-#
-.*
-*.o
-*.o.*
-*.a
-*.s
-*.su
-*.mod.c
-*.i
-*.lst
-*.order
-*.elf
-*.swp
-*.bin
-*.patch
-*.cfgtmp
-
-# host programs on Cygwin
-*.exe
-
-# Build tree
-/build-*
-
-#
-# Top-level generic files
-#
-/MLO*
-/SPL
-/System.map
-/u-boot*
-/boards.cfg
-
-#
-# git files that we don't want to ignore even it they are dot-files
-#
-!.gitignore
-!.mailmap
-
-#
-# Generated files
-#
-/LOG
-/spl/
-/tpl/
-/defconfig
-
-#
-# Generated include files
-#
-/include/config/
-/include/generated/
-
-# stgit generated dirs
-patches-*
-.stgit-edit.txt
-
-# quilt's files
-patches
-series
-
-# gdb files
-.gdb_history
-
-# cscope files
-cscope.*
-
-# tags files
-/tags
-/ctags
-/etags
-
-# gnu global files
-GPATH
-GRTAGS
-GSYMS
-GTAGS
-
-*.orig
-*~
-\#*#
diff -urN u-boot-2016.03/include/autoconf.mk ebf_6ull_uboot/include/autoconf.mk
--- u-boot-2016.03/include/autoconf.mk	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/autoconf.mk	2021-04-16 14:42:17.792596829 +0800
@@ -0,0 +1,152 @@
+CONFIG_BOOTM_NETBSD=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_MXC_USB_FLAGS=0
+CONFIG_IMX_CONFIG="board/freescale/mx6ullevk/imximage.cfg"
+CONFIG_BOOTM_VXWORKS=y
+CONFIG_SYS_MAX_NAND_DEVICE=y
+CONFIG_SYS_LONGHELP=y
+CONFIG_SYS_NAND_5_ADDR_CYCLE=y
+CONFIG_IS_MODULE(option)="config_enabled(CONFIG_VAL(option ##_MODULE))"
+CONFIG_SYS_LOAD_ADDR=$(CONFIG_LOADADDR)
+CONFIG_DISPLAY_BOARDINFO=y
+CONFIG_CMD_CACHE=y
+CONFIG_POWER_PFUZE3000_I2C_ADDR=0x08
+CONFIG_STACKSIZE="SZ_128K"
+CONFIG_BOOTDELAY=0
+CONFIG_SYS_NAND_BASE=0x40000000
+CONFIG_SYS_HELP_CMD_WIDTH=8
+CONFIG_NR_DRAM_BANKS=y
+CONFIG_FS_FAT=y
+CONFIG_BOOTM_RTEMS=y
+CONFIG_SYS_CBSIZE=512
+CONFIG_SYS_NAND_ONFI_DETECTION=y
+CONFIG_EHCI_HCD_INIT_AFTER_RESET=y
+CONFIG_BOOTM_LINUX=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_MII=y
+CONFIG_CMD_FAT=y
+CONFIG_SYS_CACHELINE_SIZE=64
+CONFIG_MMC=y
+CONFIG_REVISION_TAG=y
+CONFIG_SYS_FSL_CLK=y
+CONFIG_SYS_FSL_SEC_ADDR="CAAM_BASE_ADDR"
+CONFIG_SYSCOUNTER_TIMER=y
+CONFIG_ZERO_BOOTDELAY_CHECK=y
+CONFIG_ENV_OFFSET="(60 << 20)"
+CONFIG_MXC_OCOTP=y
+CONFIG_ENV_OVERWRITE=y
+CONFIG_ENV_SIZE=$(CONFIG_ENV_SECT_SIZE)
+CONFIG_INITRD_TAG=y
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_CMD_PING=y
+CONFIG_SYS_MALLOC_LEN="(16 * SZ_1M)"
+CONFIG_CMD_MEMTEST=y
+CONFIG_SYS_MMC_ENV_DEV=y
+CONFIG_SYS_I2C_SPEED=100000
+CONFIG_SYS_BOOTM_LEN=0x1000000
+CONFIG_SYS_TEXT_BASE=0x87800000
+CONFIG_MXC_GPT_HCLK=y
+CONFIG_MXC_UART=y
+CONFIG_ENV_SECT_SIZE="(128 << 10)"
+CONFIG_SYS_BARGSIZE=$(CONFIG_SYS_CBSIZE)
+CONFIG_BOOTM_PLAN9=y
+CONFIG_IS_BUILTIN(option)="config_enabled(CONFIG_VAL(option))"
+CONFIG_MXC_USB_PORTSC="(PORT_PTS_UTMI | PORT_PTS_PTW)"
+CONFIG_CMD_NAND=y
+CONFIG_SYS_FSL_JR0_ADDR="(CAAM_BASE_ADDR + 0x1000)"
+CONFIG_POWER_I2C=y
+CONFIG_SYS_MAXARGS=32
+CONFIG_SYS_PBSIZE="(CONFIG_SYS_CBSIZE + 128)"
+CONFIG_FEC_XCV_TYPE="RMII"
+CONFIG_MXC_GPIO=y
+CONFIG_BOARDDIR="board/freescale/mx6ullevk"
+CONFIG_POWER=y
+CONFIG_BOUNCE_BUFFER=y
+CONFIG_OF_LIBFDT=y
+CONFIG_SYS_MAX_FLASH_SECT=512
+CONFIG_PHYLIB=y
+CONFIG_BOARD_POSTCLK_INIT=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_CMD_USB=y
+CONFIG_MFG_ENV_SETTINGS="mfgtool_args=setenv bootargs console=${console},${baudrate} " CONFIG_BOOTARGS_CMA_SIZE "rdinit=/linuxrc g_mass_storage.stall=0 g_mass_storage.removable=1 g_mass_storage.file=/fat g_mass_storage.ro=1 g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF g_mass_storage.iSerialNumber=" CONFIG_MFG_NAND_PARTITION "clk_ignore_unused 0initrd_addr=0x838000000initrd_high=0xffffffff0bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};0"
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_USB_EHCI=y
+CONFIG_ZLIB=y
+CONFIG_LOADADDR=0x80800000
+CONFIG_ETHPRIME="FEC"
+CONFIG_CMD_BOOTZ=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_SYS_MMC_IMG_LOAD_PART=y
+CONFIG_FSL_USDHC=y
+CONFIG_FEC_ENET_DEV=y
+CONFIG_DOS_PARTITION=y
+CONFIG_GZIP=y
+CONFIG_SC_TIMER_CLK=8000000
+CONFIG_SYS_FSL_ESDHC_ADDR="USDHC2_BASE_ADDR"
+CONFIG_SYS_INIT_RAM_SIZE="IRAM_SIZE"
+CONFIG_IOMUX_LPSR=y
+CONFIG_FEC_MXC_PHYADDR=0x1
+CONFIG_SYS_BAUDRATE_TABLE="{ 9600, 19200, 38400, 57600, 115200 }"
+CONFIG_VAL(option)="config_val(option)"
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_SYS_HUSH_PARSER=y
+CONFIG_MFG_NAND_PARTITION="mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
+CONFIG_SYS_SDRAM_BASE="PHYS_SDRAM"
+CONFIG_IMAGE_FORMAT_LEGACY=y
+CONFIG_SYS_BOOT_RAMDISK_HIGH=y
+CONFIG_CMD_DHCP=y
+CONFIG_ENV_IS_IN_NAND=y
+CONFIG_SYS_FSL_USDHC_NUM=2
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_GENERIC_MMC=y
+CONFIG_SYS_INIT_SP_OFFSET="(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)"
+CONFIG_SYS_I2C=y
+CONFIG_SYS_INIT_RAM_ADDR="IRAM_BASE_ADDR"
+CONFIG_EXTRA_ENV_SETTINGS="CONFIG_MFG_ENV_SETTINGS "panel=TFT50AB0splashimage=0x820000000fdt_addr=0x830000000fdt_high=0xffffffff0console=ttymxc00bootargs=console=ttymxc0,115200 ubi.mtd=3 root=ubi0:rootfs rw rootfstype=ubifs " CONFIG_BOOTARGS_CMA_SIZE "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)0bootcmd=nand read ${loadaddr} 0x4000000 0x800000;nand read ${fdt_addr} 0x5000000 0x100000;bootz ${loadaddr} - ${fdt_addr}0""
+CONFIG_SYS_INIT_SP_ADDR="(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)"
+CONFIG_FSL_ESDHC=y
+CONFIG_IMX_THERMAL=y
+CONFIG_BAUDRATE=115200
+CONFIG_CMD_BMODE=y
+CONFIG_CMDLINE_TAG=y
+CONFIG_MXC_UART_BASE="UART1_BASE"
+CONFIG_USB_HOST_ETHER=y
+CONFIG_PARTITIONS=y
+CONFIG_CMD_NAND_TRIMFFS=y
+CONFIG_CMD_I2C=y
+CONFIG_SYS_MMC_ENV_PART=0
+CONFIG_FEC_MXC=y
+CONFIG_NAND_MXS=y
+CONFIG_USB_MAX_CONTROLLER_COUNT=2
+CONFIG_SYS_NO_FLASH=y
+CONFIG_SYS_DEF_EEPROM_ADDR=0
+CONFIG_FS_EXT4=y
+CONFIG_SYS_USE_NAND=y
+CONFIG_SYS_MEMTEST_END="(CONFIG_SYS_MEMTEST_START + 0x8000000)"
+CONFIG_POWER_PFUZE3000=y
+CONFIG_USB_STORAGE=y
+CONFIG_APBH_DMA=y
+CONFIG_USB_EHCI_MX6=y
+CONFIG_APBH_DMA_BURST8=y
+CONFIG_DISPLAY_CPUINFO=y
+CONFIG_BOOTARGS_CMA_SIZE=y
+CONFIG_MMCROOT="/dev/mmcblk1p2"
+CONFIG_SETUP_MEMORY_TAGS=y
+CONFIG_EXT4_WRITE=y
+CONFIG_SYS_MEMTEST_START=0x80000000
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CONS_INDEX=y
+CONFIG_LMB=y
+CONFIG_APBH_DMA_BURST=y
+CONFIG_SYS_I2C_MXC=y
+CONFIG_PHY_MICREL=y
+CONFIG_IS_ENABLED(option)="(config_enabled(CONFIG_VAL(option)) || config_enabled(CONFIG_VAL(option ##_MODULE)))"
+CONFIG_SYS_BOOT_NAND=y
+CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
+CONFIG_SYS_I2C_MXC_I2C1=y
+CONFIG_SYS_I2C_MXC_I2C2=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_FUSE=y
diff -urN u-boot-2016.03/include/autoconf.mk.dep ebf_6ull_uboot/include/autoconf.mk.dep
--- u-boot-2016.03/include/autoconf.mk.dep	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/autoconf.mk.dep	2021-04-16 14:42:17.792596829 +0800
@@ -0,0 +1,176 @@
+include/config/auto.conf: include/common.h include/linux/kconfig.h \
+ include/generated/autoconf.h include/config.h include/config_defaults.h \
+ include/config_uncmd_spl.h include/configs/mx6ullevk.h \
+ arch/arm/include/asm/arch/imx-regs.h \
+ arch/arm/include/asm/imx-common/regs-lcdif.h \
+ arch/arm/include/asm/imx-common/regs-common.h include/linux/types.h \
+ include/linux/posix_types.h include/linux/stddef.h \
+ arch/arm/include/asm/posix_types.h arch/arm/include/asm/types.h \
+ /usr/lib/gcc/arm-none-eabi/6.3.1/include/stdbool.h include/linux/sizes.h \
+ include/configs/mx6_common.h arch/arm/include/asm/imx-common/gpio.h \
+ arch/arm/include/asm/config.h include/config_fallbacks.h \
+ include/asm-offsets.h include/linux/bitops.h include/linux/compiler.h \
+ include/linux/compiler-gcc.h arch/arm/include/asm/bitops.h \
+ arch/arm/include/asm/proc-armv/system.h \
+ include/asm-generic/bitops/__fls.h include/asm-generic/bitops/__ffs.h \
+ include/asm-generic/bitops/fls.h include/asm-generic/bitops/fls64.h \
+ include/linux/string.h arch/arm/include/asm/string.h \
+ include/linux/linux_string.h include/linux/stringify.h \
+ arch/arm/include/asm/ptrace.h arch/arm/include/asm/proc-armv/ptrace.h \
+ /usr/lib/gcc/arm-none-eabi/6.3.1/include/stdarg.h include/linux/kernel.h \
+ include/part.h include/ide.h include/common.h include/flash.h \
+ include/image.h include/compiler.h \
+ /usr/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h \
+ arch/arm/include/asm/byteorder.h include/linux/byteorder/little_endian.h \
+ include/linux/byteorder/swab.h include/linux/byteorder/generic.h \
+ include/lmb.h arch/arm/include/asm/u-boot.h include/asm-generic/u-boot.h \
+ include/command.h include/linker_lists.h \
+ arch/arm/include/asm/global_data.h include/asm-generic/global_data.h \
+ include/membuff.h include/linux/list.h include/linux/poison.h \
+ include/display_options.h arch/arm/include/asm/mach-types.h \
+ arch/arm/include/asm/setup.h arch/arm/include/asm/u-boot-arm.h \
+ include/uuid.h include/vsprintf.h include/u-boot/crc.h include/net.h \
+ arch/arm/include/asm/cache.h arch/arm/include/asm/system.h \
+ include/bootstage.h include/environment.h
+
+include/linux/kconfig.h:
+
+include/generated/autoconf.h:
+
+include/config.h:
+
+include/config_defaults.h:
+
+include/config_uncmd_spl.h:
+
+include/configs/mx6ullevk.h:
+
+arch/arm/include/asm/arch/imx-regs.h:
+
+arch/arm/include/asm/imx-common/regs-lcdif.h:
+
+arch/arm/include/asm/imx-common/regs-common.h:
+
+include/linux/types.h:
+
+include/linux/posix_types.h:
+
+include/linux/stddef.h:
+
+arch/arm/include/asm/posix_types.h:
+
+arch/arm/include/asm/types.h:
+
+/usr/lib/gcc/arm-none-eabi/6.3.1/include/stdbool.h:
+
+include/linux/sizes.h:
+
+include/configs/mx6_common.h:
+
+arch/arm/include/asm/imx-common/gpio.h:
+
+arch/arm/include/asm/config.h:
+
+include/config_fallbacks.h:
+
+include/asm-offsets.h:
+
+include/linux/bitops.h:
+
+include/linux/compiler.h:
+
+include/linux/compiler-gcc.h:
+
+arch/arm/include/asm/bitops.h:
+
+arch/arm/include/asm/proc-armv/system.h:
+
+include/asm-generic/bitops/__fls.h:
+
+include/asm-generic/bitops/__ffs.h:
+
+include/asm-generic/bitops/fls.h:
+
+include/asm-generic/bitops/fls64.h:
+
+include/linux/string.h:
+
+arch/arm/include/asm/string.h:
+
+include/linux/linux_string.h:
+
+include/linux/stringify.h:
+
+arch/arm/include/asm/ptrace.h:
+
+arch/arm/include/asm/proc-armv/ptrace.h:
+
+/usr/lib/gcc/arm-none-eabi/6.3.1/include/stdarg.h:
+
+include/linux/kernel.h:
+
+include/part.h:
+
+include/ide.h:
+
+include/common.h:
+
+include/flash.h:
+
+include/image.h:
+
+include/compiler.h:
+
+/usr/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h:
+
+arch/arm/include/asm/byteorder.h:
+
+include/linux/byteorder/little_endian.h:
+
+include/linux/byteorder/swab.h:
+
+include/linux/byteorder/generic.h:
+
+include/lmb.h:
+
+arch/arm/include/asm/u-boot.h:
+
+include/asm-generic/u-boot.h:
+
+include/command.h:
+
+include/linker_lists.h:
+
+arch/arm/include/asm/global_data.h:
+
+include/asm-generic/global_data.h:
+
+include/membuff.h:
+
+include/linux/list.h:
+
+include/linux/poison.h:
+
+include/display_options.h:
+
+arch/arm/include/asm/mach-types.h:
+
+arch/arm/include/asm/setup.h:
+
+arch/arm/include/asm/u-boot-arm.h:
+
+include/uuid.h:
+
+include/vsprintf.h:
+
+include/u-boot/crc.h:
+
+include/net.h:
+
+arch/arm/include/asm/cache.h:
+
+arch/arm/include/asm/system.h:
+
+include/bootstage.h:
+
+include/environment.h:
diff -urN u-boot-2016.03/include/common.h ebf_6ull_uboot/include/common.h
--- u-boot-2016.03/include/common.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/common.h	2021-04-16 14:42:17.780596765 +0800
@@ -342,6 +342,9 @@
 int do_tftpb(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
 
 /* common/cmd_fat.c */
+int do_fat_size(cmd_tbl_t *, int, int, char * const []);
+
+/* common/cmd_fat.c */
 int do_fat_fsload(cmd_tbl_t *, int, int, char * const []);
 
 /* common/cmd_ext2.c */
diff -urN u-boot-2016.03/include/config/auto.conf ebf_6ull_uboot/include/config/auto.conf
--- u-boot-2016.03/include/config/auto.conf	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/config/auto.conf	2021-04-16 14:42:17.792596829 +0800
@@ -0,0 +1,80 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2016.03 Configuration
+#
+CONFIG_CMD_BOOTM=y
+CONFIG_CMD_EDITENV=y
+CONFIG_SYS_GENERIC_BOARD=y
+CONFIG_CMD_CONSOLE=y
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_IMLS=y
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_ARCH_MX6=y
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+CONFIG_CMD_BDI=y
+CONFIG_ARM=y
+CONFIG_CREATE_ARCH_SYMLINK=y
+CONFIG_DM_SEQ_ALIAS=y
+CONFIG_SYS_VENDOR="freescale"
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_MISC=y
+CONFIG_SYS_CPU="armv7"
+CONFIG_BOOTSTAGE_USER_COUNT=20
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_DM_THERMAL=y
+CONFIG_CMD_FLASH=y
+CONFIG_REGEX=y
+CONFIG_CMD_ENV_EXISTS=y
+CONFIG_CMD_SETEXPR=y
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_HAVE_GENERIC_BOARD=y
+CONFIG_DISK=y
+CONFIG_CMD_EXPORTENV=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ullevk/imximage.cfg,SYS_BOOT_NAND"
+CONFIG_CMD_CRC32=y
+CONFIG_ROM_UNIFIED_SECTIONS=y
+CONFIG_SYS_BOARD="mx6ullevk"
+CONFIG_SYS_CONFIG_NAME="mx6ullevk"
+CONFIG_CMD_NFS=y
+CONFIG_NET=y
+CONFIG_DM_WARN=y
+CONFIG_CMD_GO=y
+CONFIG_SYS_MALLOC_CLEAR_ON_INIT=y
+CONFIG_CMD_IMI=y
+CONFIG_SYS_HZ=1000
+CONFIG_CPU_V7=y
+CONFIG_SUPPORT_OF_CONTROL=y
+CONFIG_DM_STDIO=y
+CONFIG_LOCALVERSION=""
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_RUN=y
+CONFIG_MX6=y
+CONFIG_SYS_PROMPT="=> "
+CONFIG_CMD_MEMORY=y
+CONFIG_CMD_XIMG=y
+CONFIG_CMD_ECHO=y
+CONFIG_SYS_L2CACHE_OFF=y
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SYS_ARCH="arm"
+CONFIG_CMD_DM=y
+CONFIG_HAS_VBAR=y
+CONFIG_EXPERT=y
+CONFIG_MX6ULL=y
+CONFIG_SYS_SOC="mx6"
+CONFIG_MX6UL=y
+CONFIG_CMD_ITEST=y
+CONFIG_CMD_GPIO=y
+CONFIG_BOOTSTAGE_STASH_SIZE=4096
+CONFIG_CMD_LOADS=y
+CONFIG_TARGET_MX6ULL_14X14_EVK=y
+CONFIG_CMD_NET=y
+CONFIG_CMD_FPGA=y
+CONFIG_DEFAULT_DEVICE_TREE=""
+CONFIG_NET_TFTP_VARS=y
+CONFIG_DM=y
+CONFIG_HAS_THUMB2=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_CMD_ELF=y
+CONFIG_CMD_SOURCE=y
diff -urN u-boot-2016.03/include/config/auto.conf.cmd ebf_6ull_uboot/include/config/auto.conf.cmd
--- u-boot-2016.03/include/config/auto.conf.cmd	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/config/auto.conf.cmd	2021-04-16 14:42:17.792596829 +0800
@@ -0,0 +1,620 @@
+deps_config := \
+	test/env/Kconfig \
+	test/dm/Kconfig \
+	test/Kconfig \
+	lib/efi/Kconfig \
+	lib/rsa/Kconfig \
+	lib/dhry/Kconfig \
+	lib/Kconfig \
+	fs/cramfs/Kconfig \
+	fs/ubifs/Kconfig \
+	fs/jffs2/Kconfig \
+	fs/fat/Kconfig \
+	fs/reiserfs/Kconfig \
+	fs/ext4/Kconfig \
+	fs/Kconfig \
+	drivers/watchdog/Kconfig \
+	drivers/video/bridge/Kconfig \
+	drivers/video/fonts/Kconfig \
+	drivers/video/Kconfig \
+	drivers/usb/emul/Kconfig \
+	drivers/usb/musb-new/Kconfig \
+	drivers/usb/host/Kconfig \
+	drivers/usb/Kconfig \
+	drivers/tpm/Kconfig \
+	drivers/timer/Kconfig \
+	drivers/thermal/Kconfig \
+	drivers/spi/Kconfig \
+	drivers/sound/Kconfig \
+	drivers/serial/Kconfig \
+	drivers/rtc/Kconfig \
+	drivers/remoteproc/Kconfig \
+	drivers/ram/Kconfig \
+	drivers/pwm/Kconfig \
+	drivers/power/regulator/Kconfig \
+	drivers/power/pmic/Kconfig \
+	drivers/power/Kconfig \
+	drivers/pinctrl/uniphier/Kconfig \
+	drivers/pinctrl/nxp/Kconfig \
+	drivers/pinctrl/Kconfig \
+	drivers/pcmcia/Kconfig \
+	drivers/pci/Kconfig \
+	drivers/net/Kconfig \
+	drivers/mtd/spi/Kconfig \
+	drivers/mtd/nand/Kconfig \
+	drivers/mtd/Kconfig \
+	drivers/mmc/Kconfig \
+	drivers/misc/Kconfig \
+	drivers/led/Kconfig \
+	drivers/input/Kconfig \
+	drivers/i2c/muxes/Kconfig \
+	drivers/i2c/Kconfig \
+	drivers/hwmon/Kconfig \
+	drivers/gpio/Kconfig \
+	drivers/dma/Kconfig \
+	drivers/dfu/Kconfig \
+	drivers/demo/Kconfig \
+	drivers/crypto/fsl/Kconfig \
+	drivers/crypto/Kconfig \
+	drivers/cpu/Kconfig \
+	drivers/clk/uniphier/Kconfig \
+	drivers/clk/Kconfig \
+	drivers/block/Kconfig \
+	drivers/adc/Kconfig \
+	drivers/core/Kconfig \
+	drivers/Kconfig \
+	net/Kconfig \
+	dts/Kconfig \
+	cmd/Kconfig \
+	common/Kconfig \
+	arch/x86/lib/efi/Kconfig \
+	arch/x86/cpu/queensbay/Kconfig \
+	arch/x86/cpu/quark/Kconfig \
+	arch/x86/cpu/qemu/Kconfig \
+	arch/x86/cpu/ivybridge/Kconfig \
+	arch/x86/cpu/coreboot/Kconfig \
+	arch/x86/cpu/baytrail/Kconfig \
+	board/intel/minnowmax/Kconfig \
+	board/intel/galileo/Kconfig \
+	board/intel/crownbay/Kconfig \
+	board/intel/cougarcanyon2/Kconfig \
+	board/intel/bayleybay/Kconfig \
+	board/intel/Kconfig \
+	board/google/chromebox_panther/Kconfig \
+	board/google/chromebook_link/Kconfig \
+	board/google/Kconfig \
+	board/emulation/qemu-x86/Kconfig \
+	board/emulation/Kconfig \
+	board/efi/efi-x86/Kconfig \
+	board/efi/Kconfig \
+	board/coreboot/coreboot/Kconfig \
+	board/coreboot/Kconfig \
+	arch/x86/Kconfig \
+	board/gaisler/grsim_leon2/Kconfig \
+	board/gaisler/grsim/Kconfig \
+	board/gaisler/gr_xc3s_1500/Kconfig \
+	board/gaisler/gr_ep2s60/Kconfig \
+	board/gaisler/gr_cpci_ax2000/Kconfig \
+	arch/sparc/Kconfig \
+	board/shmin/Kconfig \
+	board/renesas/sh7785lcr/Kconfig \
+	board/renesas/sh7763rdp/Kconfig \
+	board/renesas/sh7757lcr/Kconfig \
+	board/renesas/sh7753evb/Kconfig \
+	board/renesas/sh7752evb/Kconfig \
+	board/renesas/rsk7269/Kconfig \
+	board/renesas/rsk7264/Kconfig \
+	board/renesas/rsk7203/Kconfig \
+	board/renesas/r7780mp/Kconfig \
+	board/renesas/r2dplus/Kconfig \
+	board/renesas/r0p7734/Kconfig \
+	board/renesas/ecovec/Kconfig \
+	board/renesas/ap325rxa/Kconfig \
+	board/renesas/MigoR/Kconfig \
+	board/ms7750se/Kconfig \
+	board/ms7722se/Kconfig \
+	board/ms7720se/Kconfig \
+	board/mpr2/Kconfig \
+	board/espt/Kconfig \
+	board/alphaproject/ap_sh4a_4a/Kconfig \
+	arch/sh/Kconfig \
+	arch/sandbox/Kconfig \
+	board/xilinx/ppc440-generic/Kconfig \
+	board/xilinx/ppc405-generic/Kconfig \
+	board/xes/xpedite1000/Kconfig \
+	board/t3corp/Kconfig \
+	board/mpl/pip405/Kconfig \
+	board/mpl/mip405/Kconfig \
+	board/mosaixtech/icon/Kconfig \
+	board/liebherr/lwmon5/Kconfig \
+	board/gdsys/intip/Kconfig \
+	board/gdsys/gdppc440etx/Kconfig \
+	board/gdsys/dlvision/Kconfig \
+	board/gdsys/405ex/Kconfig \
+	board/gdsys/405ep/Kconfig \
+	board/esd/vom405/Kconfig \
+	board/esd/pmc440/Kconfig \
+	board/esd/pmc405de/Kconfig \
+	board/esd/plu405/Kconfig \
+	board/esd/cpci405/Kconfig \
+	board/esd/cpci2dp/Kconfig \
+	board/amcc/yucca/Kconfig \
+	board/amcc/yosemite/Kconfig \
+	board/amcc/walnut/Kconfig \
+	board/amcc/sequoia/Kconfig \
+	board/amcc/redwood/Kconfig \
+	board/amcc/makalu/Kconfig \
+	board/amcc/luan/Kconfig \
+	board/amcc/kilauea/Kconfig \
+	board/amcc/katmai/Kconfig \
+	board/amcc/canyonlands/Kconfig \
+	board/amcc/bubinga/Kconfig \
+	board/amcc/bamboo/Kconfig \
+	board/amcc/acadia/Kconfig \
+	arch/powerpc/cpu/ppc4xx/Kconfig \
+	board/tqc/tqm8xx/Kconfig \
+	arch/powerpc/cpu/mpc8xx/Kconfig \
+	board/xes/xpedite517x/Kconfig \
+	board/sbc8641d/Kconfig \
+	board/freescale/mpc8641hpcn/Kconfig \
+	board/freescale/mpc8610hpcd/Kconfig \
+	arch/powerpc/cpu/mpc86xx/Kconfig \
+	board/Arcturus/ucp1020/Kconfig \
+	board/xes/xpedite550x/Kconfig \
+	board/xes/xpedite537x/Kconfig \
+	board/xes/xpedite520x/Kconfig \
+	board/varisys/cyrus/Kconfig \
+	board/socrates/Kconfig \
+	board/sbc8548/Kconfig \
+	board/keymile/kmp204x/Kconfig \
+	board/gdsys/p1022/Kconfig \
+	board/freescale/t4rdb/Kconfig \
+	board/freescale/t4qds/Kconfig \
+	board/freescale/t208xrdb/Kconfig \
+	board/freescale/t208xqds/Kconfig \
+	board/freescale/t104xrdb/Kconfig \
+	board/freescale/t1040qds/Kconfig \
+	board/freescale/t102xrdb/Kconfig \
+	board/freescale/t102xqds/Kconfig \
+	board/freescale/qemu-ppce500/Kconfig \
+	board/freescale/p2041rdb/Kconfig \
+	board/freescale/p1_twr/Kconfig \
+	board/freescale/p1_p2_rdb_pc/Kconfig \
+	board/freescale/p1023rdb/Kconfig \
+	board/freescale/p1022ds/Kconfig \
+	board/freescale/p1010rdb/Kconfig \
+	board/freescale/mpc8572ds/Kconfig \
+	board/freescale/mpc8569mds/Kconfig \
+	board/freescale/mpc8568mds/Kconfig \
+	board/freescale/mpc8560ads/Kconfig \
+	board/freescale/mpc8555cds/Kconfig \
+	board/freescale/mpc8548cds/Kconfig \
+	board/freescale/mpc8544ds/Kconfig \
+	board/freescale/mpc8541cds/Kconfig \
+	board/freescale/mpc8540ads/Kconfig \
+	board/freescale/mpc8536ds/Kconfig \
+	board/freescale/corenet_ds/Kconfig \
+	board/freescale/c29xpcie/Kconfig \
+	board/freescale/bsc9132qds/Kconfig \
+	board/freescale/bsc9131rdb/Kconfig \
+	board/freescale/b4860qds/Kconfig \
+	arch/powerpc/cpu/mpc85xx/Kconfig \
+	board/gdsys/mpc8308/Kconfig \
+	board/ve8313/Kconfig \
+	board/tqc/tqm834x/Kconfig \
+	board/sbc8349/Kconfig \
+	board/mpc8308_p1m/Kconfig \
+	board/keymile/km83xx/Kconfig \
+	board/ids/ids8313/Kconfig \
+	board/freescale/mpc837xerdb/Kconfig \
+	board/freescale/mpc837xemds/Kconfig \
+	board/freescale/mpc8349itx/Kconfig \
+	board/freescale/mpc8349emds/Kconfig \
+	board/freescale/mpc832xemds/Kconfig \
+	board/freescale/mpc8323erdb/Kconfig \
+	board/freescale/mpc8315erdb/Kconfig \
+	board/freescale/mpc8313erdb/Kconfig \
+	board/freescale/mpc8308rdb/Kconfig \
+	board/esd/vme8349/Kconfig \
+	arch/powerpc/cpu/mpc83xx/Kconfig \
+	board/keymile/km82xx/Kconfig \
+	arch/powerpc/cpu/mpc8260/Kconfig \
+	board/v38b/Kconfig \
+	board/tqc/tqm5200/Kconfig \
+	board/phytec/pcm030/Kconfig \
+	board/munices/Kconfig \
+	board/motionpro/Kconfig \
+	board/jupiter/Kconfig \
+	board/ipek01/Kconfig \
+	board/intercontrol/digsy_mtc/Kconfig \
+	board/inka4x0/Kconfig \
+	board/ifm/o2dnt2/Kconfig \
+	board/cm5200/Kconfig \
+	board/canmb/Kconfig \
+	board/a4m072/Kconfig \
+	board/a3m071/Kconfig \
+	arch/powerpc/cpu/mpc5xxx/Kconfig \
+	board/mpl/pati/Kconfig \
+	arch/powerpc/cpu/mpc5xx/Kconfig \
+	board/pdm360ng/Kconfig \
+	board/ifm/ac14xx/Kconfig \
+	board/freescale/mpc5121ads/Kconfig \
+	board/esd/mecp5123/Kconfig \
+	board/davedenx/aria/Kconfig \
+	arch/powerpc/cpu/mpc512x/Kconfig \
+	arch/powerpc/Kconfig \
+	board/openrisc/openrisc-generic/Kconfig \
+	arch/openrisc/Kconfig \
+	arch/nios2/Kconfig \
+	board/AndesTech/adp-ag101p/Kconfig \
+	arch/nds32/Kconfig \
+	board/microchip/pic32mzda/Kconfig \
+	arch/mips/mach-pic32/Kconfig \
+	board/qemu-mips/Kconfig \
+	board/pb1x00/Kconfig \
+	board/micronas/vct/Kconfig \
+	board/imgtec/malta/Kconfig \
+	board/dbau1x00/Kconfig \
+	arch/mips/Kconfig \
+	board/xilinx/microblaze-generic/Kconfig \
+	arch/microblaze/Kconfig \
+	board/sysam/amcore/Kconfig \
+	board/freescale/m548xevb/Kconfig \
+	board/freescale/m547xevb/Kconfig \
+	board/freescale/m54455evb/Kconfig \
+	board/freescale/m54451evb/Kconfig \
+	board/freescale/m54418twr/Kconfig \
+	board/freescale/m5373evb/Kconfig \
+	board/freescale/m5329evb/Kconfig \
+	board/freescale/m53017evb/Kconfig \
+	board/freescale/m5282evb/Kconfig \
+	board/freescale/m5275evb/Kconfig \
+	board/freescale/m5272c3/Kconfig \
+	board/freescale/m5253evbe/Kconfig \
+	board/freescale/m5253demo/Kconfig \
+	board/freescale/m5249evb/Kconfig \
+	board/freescale/m5235evb/Kconfig \
+	board/freescale/m52277evb/Kconfig \
+	board/freescale/m5208evbe/Kconfig \
+	board/cobra5272/Kconfig \
+	board/astro/mcf5373l/Kconfig \
+	board/BuS/eb_cpu5282/Kconfig \
+	arch/m68k/Kconfig \
+	board/tcm-bf537/Kconfig \
+	board/tcm-bf518/Kconfig \
+	board/pr1/Kconfig \
+	board/ip04/Kconfig \
+	board/ibf-dsp561/Kconfig \
+	board/dnp5370/Kconfig \
+	board/cm-bf561/Kconfig \
+	board/cm-bf548/Kconfig \
+	board/cm-bf537u/Kconfig \
+	board/cm-bf537e/Kconfig \
+	board/cm-bf533/Kconfig \
+	board/cm-bf527/Kconfig \
+	board/br4/Kconfig \
+	board/blackvme/Kconfig \
+	board/blackstamp/Kconfig \
+	board/bf609-ezkit/Kconfig \
+	board/bf561-ezkit/Kconfig \
+	board/bf561-acvilon/Kconfig \
+	board/bf548-ezkit/Kconfig \
+	board/bf538f-ezkit/Kconfig \
+	board/bf537-stamp/Kconfig \
+	board/bf537-srv1/Kconfig \
+	board/bf537-pnav/Kconfig \
+	board/bf537-minotaur/Kconfig \
+	board/bf533-stamp/Kconfig \
+	board/bf533-ezkit/Kconfig \
+	board/bf527-sdp/Kconfig \
+	board/bf527-ezkit/Kconfig \
+	board/bf527-ad7160-eval/Kconfig \
+	board/bf526-ezbrd/Kconfig \
+	board/bf525-ucr2/Kconfig \
+	board/bf518f-ezbrd/Kconfig \
+	board/bf506f-ezkit/Kconfig \
+	board/bct-brettl2/Kconfig \
+	arch/blackfin/Kconfig \
+	board/in-circuit/grasshopper/Kconfig \
+	board/atmel/atstk1000/Kconfig \
+	board/atmel/atngw100mkii/Kconfig \
+	board/atmel/atngw100/Kconfig \
+	arch/avr32/Kconfig \
+	arch/arm/Kconfig.debug \
+	board/work-microwave/work_92105/Kconfig \
+	board/woodburn/Kconfig \
+	board/vscom/baltos/Kconfig \
+	board/technologic/ts4800/Kconfig \
+	board/toradex/colibri_vf/Kconfig \
+	board/toradex/colibri_pxa270/Kconfig \
+	board/timll/devkit3250/Kconfig \
+	board/ti/ti816x/Kconfig \
+	board/ti/ti814x/Kconfig \
+	board/birdland/bav335x/Kconfig \
+	board/ti/am43xx/Kconfig \
+	board/ti/am335x/Kconfig \
+	board/tcl/sl50/Kconfig \
+	board/syteco/zmx25/Kconfig \
+	board/sunxi/Kconfig \
+	board/st/stv0991/Kconfig \
+	board/spear/x600/Kconfig \
+	board/spear/spear600/Kconfig \
+	board/spear/spear320/Kconfig \
+	board/spear/spear310/Kconfig \
+	board/spear/spear300/Kconfig \
+	board/silica/pengwyn/Kconfig \
+	board/siemens/rut/Kconfig \
+	board/siemens/pxm2/Kconfig \
+	board/siemens/draco/Kconfig \
+	board/schulercontrol/sc_sps_1/Kconfig \
+	board/sandisk/sansa_fuze_plus/Kconfig \
+	board/samsung/smdk2410/Kconfig \
+	board/ppcag/bg0900/Kconfig \
+	board/phytec/pcm052/Kconfig \
+	board/phytec/pcm051/Kconfig \
+	board/olimex/mx23_olinuxino/Kconfig \
+	board/mpl/vcma9/Kconfig \
+	board/isee/igep0033/Kconfig \
+	board/imx31_phycore/Kconfig \
+	board/hisilicon/hikey/Kconfig \
+	board/h2200/Kconfig \
+	board/gumstix/pepper/Kconfig \
+	board/freescale/vf610twr/Kconfig \
+	board/freescale/mx53smd/Kconfig \
+	board/freescale/mx53loco/Kconfig \
+	board/freescale/mx53evk/Kconfig \
+	board/freescale/mx53ard/Kconfig \
+	board/freescale/mx51evk/Kconfig \
+	board/freescale/mx35pdk/Kconfig \
+	board/freescale/mx31pdk/Kconfig \
+	board/freescale/mx31ads/Kconfig \
+	board/freescale/mx28evk/Kconfig \
+	board/freescale/mx25pdk/Kconfig \
+	board/freescale/mx23evk/Kconfig \
+	board/freescale/ls1043ardb/Kconfig \
+	board/freescale/ls1021atwr/Kconfig \
+	board/freescale/ls1043aqds/Kconfig \
+	board/freescale/ls1021aqds/Kconfig \
+	board/freescale/ls2080ardb/Kconfig \
+	board/freescale/ls2080aqds/Kconfig \
+	board/freescale/ls2080a/Kconfig \
+	board/denx/m53evk/Kconfig \
+	board/denx/m28evk/Kconfig \
+	board/creative/xfi3/Kconfig \
+	board/compulab/cm_t43/Kconfig \
+	board/compulab/cm_t335/Kconfig \
+	board/cirrus/edb93xx/Kconfig \
+	board/cavium/thunderx/Kconfig \
+	board/broadcom/bcmnsp/Kconfig \
+	board/broadcom/bcmcygnus/Kconfig \
+	board/broadcom/bcm28155_ap/Kconfig \
+	board/bluegiga/apx4devkit/Kconfig \
+	board/armltd/vexpress64/Kconfig \
+	board/armltd/vexpress/Kconfig \
+	board/armadeus/apf27/Kconfig \
+	board/Marvell/gplugd/Kconfig \
+	board/Marvell/aspenite/Kconfig \
+	board/CarMediaLab/flea3/Kconfig \
+	board/BuR/tseries/Kconfig \
+	board/BuR/kwb/Kconfig \
+	arch/arm/imx-common/Kconfig \
+	arch/arm/cpu/armv8/Kconfig \
+	arch/arm/cpu/armv8/zynqmp/Kconfig \
+	arch/arm/cpu/armv7/Kconfig \
+	arch/arm/mach-zynq/Kconfig \
+	arch/arm/mach-uniphier/Kconfig \
+	board/nvidia/p2571/Kconfig \
+	board/nvidia/p2371-2180/Kconfig \
+	board/nvidia/p2371-0000/Kconfig \
+	board/nvidia/e2220-1170/Kconfig \
+	arch/arm/mach-tegra/tegra210/Kconfig \
+	board/nvidia/venice2/Kconfig \
+	board/nvidia/nyan-big/Kconfig \
+	board/nvidia/jetson-tk1/Kconfig \
+	arch/arm/mach-tegra/tegra124/Kconfig \
+	board/nvidia/dalmore/Kconfig \
+	arch/arm/mach-tegra/tegra114/Kconfig \
+	board/avionic-design/tec-ng/Kconfig \
+	board/toradex/colibri_t30/Kconfig \
+	board/nvidia/cardhu/Kconfig \
+	board/nvidia/beaver/Kconfig \
+	board/toradex/apalis_t30/Kconfig \
+	arch/arm/mach-tegra/tegra30/Kconfig \
+	board/toradex/colibri_t20/Kconfig \
+	board/nvidia/whistler/Kconfig \
+	board/nvidia/ventana/Kconfig \
+	board/compulab/trimslice/Kconfig \
+	board/avionic-design/tec/Kconfig \
+	board/nvidia/seaboard/Kconfig \
+	board/avionic-design/plutux/Kconfig \
+	board/compal/paz00/Kconfig \
+	board/avionic-design/medcom-wide/Kconfig \
+	board/nvidia/harmony/Kconfig \
+	arch/arm/mach-tegra/tegra20/Kconfig \
+	arch/arm/mach-tegra/Kconfig \
+	board/st/stm32f746-disco/Kconfig \
+	arch/arm/mach-stm32/stm32f7/Kconfig \
+	arch/arm/mach-stm32/stm32f1/Kconfig \
+	board/st/stm32f429-discovery/Kconfig \
+	arch/arm/mach-stm32/stm32f4/Kconfig \
+	arch/arm/mach-stm32/Kconfig \
+	arch/arm/mach-socfpga/Kconfig \
+	board/samsung/smdkc100/Kconfig \
+	board/samsung/goni/Kconfig \
+	arch/arm/mach-s5pc1xx/Kconfig \
+	board/kylin/kylin_rk3036/Kconfig \
+	board/evb_rk3036/evb_rk3036/Kconfig \
+	arch/arm/mach-rockchip/rk3036/Kconfig \
+	board/radxa/rock2/Kconfig \
+	board/firefly/firefly-rk3288/Kconfig \
+	board/google/chromebook_jerry/Kconfig \
+	arch/arm/mach-rockchip/rk3288/Kconfig \
+	arch/arm/mach-rockchip/Kconfig \
+	board/renesas/stout/Kconfig \
+	board/renesas/porter/Kconfig \
+	board/renesas/silk/Kconfig \
+	board/renesas/alt/Kconfig \
+	board/kmc/kzm9g/Kconfig \
+	board/renesas/lager/Kconfig \
+	board/renesas/koelsch/Kconfig \
+	board/renesas/gose/Kconfig \
+	board/atmark-techno/armadillo-800eva/Kconfig \
+	arch/arm/cpu/armv7/rmobile/Kconfig \
+	board/LaCie/edminiv2/Kconfig \
+	arch/arm/mach-orion5x/Kconfig \
+	board/ti/am57xx/Kconfig \
+	board/ti/dra7xx/Kconfig \
+	board/ti/omap5_uevm/Kconfig \
+	board/compulab/cm_t54/Kconfig \
+	arch/arm/cpu/armv7/omap5/Kconfig \
+	board/ti/sdp4430/Kconfig \
+	board/ti/panda/Kconfig \
+	board/gumstix/duovero/Kconfig \
+	arch/arm/cpu/armv7/omap4/Kconfig \
+	board/lge/sniper/Kconfig \
+	board/quipos/cairo/Kconfig \
+	board/technexion/twister/Kconfig \
+	board/technexion/tao3530/Kconfig \
+	board/nokia/rx51/Kconfig \
+	board/logicpd/omap3som/Kconfig \
+	board/htkw/mcx/Kconfig \
+	board/corscience/tricorder/Kconfig \
+	board/8dtech/eco5pk/Kconfig \
+	board/pandora/Kconfig \
+	board/ti/am3517crane/Kconfig \
+	board/logicpd/zoom1/Kconfig \
+	board/overo/Kconfig \
+	board/isee/igep00x0/Kconfig \
+	board/ti/evm/Kconfig \
+	board/timll/devkit8000/Kconfig \
+	board/compulab/cm_t3517/Kconfig \
+	board/compulab/cm_t35/Kconfig \
+	board/ti/beagle/Kconfig \
+	board/teejet/mt_ventoux/Kconfig \
+	board/logicpd/am3517evm/Kconfig \
+	arch/arm/cpu/armv7/omap3/Kconfig \
+	board/inversepath/usbarmory/Kconfig \
+	arch/arm/cpu/armv7/mx5/Kconfig \
+	board/freescale/mx6sxscm/Kconfig \
+	board/freescale/mx6dqscm/Kconfig \
+	board/warp/Kconfig \
+	board/wandboard/Kconfig \
+	board/udoo/Kconfig \
+	board/tqc/tqma6/Kconfig \
+	board/technexion/picosom-imx6ul/Kconfig \
+	board/tbs/tbs2910/Kconfig \
+	board/solidrun/mx6cuboxi/Kconfig \
+	board/seco/Kconfig \
+	board/kosagi/novena/Kconfig \
+	board/gateworks/gw_ventana/Kconfig \
+	board/freescale/mx6ullevk/Kconfig \
+	board/freescale/mx6ull_ddr3_arm2/Kconfig \
+	board/freescale/mx6ul_14x14_lpddr2_arm2/Kconfig \
+	board/freescale/mx6ul_14x14_ddr3_arm2/Kconfig \
+	board/freescale/mx6sx_19x19_arm2/Kconfig \
+	board/freescale/mx6sx_17x17_arm2/Kconfig \
+	board/freescale/mx6ul_14x14_evk/Kconfig \
+	board/freescale/mx6sxsabreauto/Kconfig \
+	board/freescale/mx6sxsabresd/Kconfig \
+	board/freescale/mx6sll_arm2/Kconfig \
+	board/freescale/mx6sllevk/Kconfig \
+	board/freescale/mx6slevk/Kconfig \
+	board/freescale/mx6sabresd/Kconfig \
+	board/freescale/mx6qsabreauto/Kconfig \
+	board/freescale/mx6qarm2/Kconfig \
+	board/embest/mx6boards/Kconfig \
+	board/congatec/cgtqmx6eval/Kconfig \
+	board/compulab/cm_fx6/Kconfig \
+	board/boundary/nitrogen6x/Kconfig \
+	board/barco/titanium/Kconfig \
+	board/barco/platinum/Kconfig \
+	board/bachmann/ot1200/Kconfig \
+	board/aristainetos/Kconfig \
+	arch/arm/cpu/armv7/mx6/Kconfig \
+	board/freescale/mx7d_19x19_ddr3_arm2/Kconfig \
+	board/freescale/mx7d_19x19_lpddr3_arm2/Kconfig \
+	board/freescale/mx7d_12x12_ddr3_arm2/Kconfig \
+	board/freescale/mx7d_12x12_lpddr3_arm2/Kconfig \
+	board/freescale/mx7dsabresd/Kconfig \
+	arch/arm/cpu/armv7/mx7/Kconfig \
+	arch/arm/mach-mvebu/Kconfig \
+	board/zyxel/nsa310s/Kconfig \
+	board/Seagate/nas220/Kconfig \
+	board/Seagate/goflexhome/Kconfig \
+	board/Seagate/dockstar/Kconfig \
+	board/raidsonic/ib62x0/Kconfig \
+	board/LaCie/netspace_v2/Kconfig \
+	board/LaCie/net2big_v2/Kconfig \
+	board/keymile/km_arm/Kconfig \
+	board/iomega/iconnect/Kconfig \
+	board/d-link/dns325/Kconfig \
+	board/cloudengines/pogo_e02/Kconfig \
+	board/buffalo/lsxl/Kconfig \
+	board/Marvell/sheevaplug/Kconfig \
+	board/Marvell/guruplug/Kconfig \
+	board/Marvell/dreamplug/Kconfig \
+	board/Marvell/openrd/Kconfig \
+	arch/arm/mach-kirkwood/Kconfig \
+	board/ti/ks2_evm/Kconfig \
+	arch/arm/mach-keystone/Kconfig \
+	arch/arm/mach-integrator/Kconfig \
+	arch/arm/mach-highbank/Kconfig \
+	board/samsung/smdk5420/Kconfig \
+	board/samsung/smdk5250/Kconfig \
+	board/samsung/arndale/Kconfig \
+	board/samsung/odroid/Kconfig \
+	board/samsung/trats2/Kconfig \
+	board/samsung/origen/Kconfig \
+	board/samsung/universal_c210/Kconfig \
+	board/samsung/trats/Kconfig \
+	board/samsung/smdkv310/Kconfig \
+	arch/arm/mach-exynos/Kconfig \
+	board/omicron/calimain/Kconfig \
+	board/davinci/ea20/Kconfig \
+	board/davinci/da8xxevm/Kconfig \
+	board/Barix/ipam390/Kconfig \
+	arch/arm/mach-davinci/Kconfig \
+	arch/arm/mach-bcm283x/Kconfig \
+	board/siemens/smartweb/Kconfig \
+	board/siemens/taurus/Kconfig \
+	board/siemens/corvus/Kconfig \
+	board/ronetix/pm9g45/Kconfig \
+	board/ronetix/pm9263/Kconfig \
+	board/ronetix/pm9261/Kconfig \
+	board/mini-box/picosam9g45/Kconfig \
+	board/l+g/vinco/Kconfig \
+	board/esd/meesc/Kconfig \
+	board/egnite/ethernut5/Kconfig \
+	board/denx/ma5d4evk/Kconfig \
+	board/calao/usb_a9263/Kconfig \
+	board/bluewater/snapper9260/Kconfig \
+	board/atmel/sama5d4ek/Kconfig \
+	board/atmel/sama5d4_xplained/Kconfig \
+	board/atmel/sama5d3xek/Kconfig \
+	board/atmel/sama5d3_xplained/Kconfig \
+	board/atmel/sama5d2_xplained/Kconfig \
+	board/atmel/at91sam9x5ek/Kconfig \
+	board/atmel/at91sam9rlek/Kconfig \
+	board/atmel/at91sam9n12ek/Kconfig \
+	board/atmel/at91sam9m10g45ek/Kconfig \
+	board/atmel/at91sam9263ek/Kconfig \
+	board/atmel/at91sam9261ek/Kconfig \
+	board/atmel/at91sam9260ek/Kconfig \
+	board/atmel/at91rm9200ek/Kconfig \
+	arch/arm/mach-at91/Kconfig \
+	arch/arm/Kconfig \
+	board/synopsys/axs101/Kconfig \
+	board/synopsys/Kconfig \
+	board/abilis/tb100/Kconfig \
+	arch/arc/Kconfig \
+	arch/Kconfig \
+	Kconfig
+
+include/config/auto.conf: \
+	$(deps_config)
+
+ifneq "$(UBOOTVERSION)" "2016.03"
+include/config/auto.conf: FORCE
+endif
+
+$(deps_config): ;
diff -urN u-boot-2016.03/include/config/tristate.conf ebf_6ull_uboot/include/config/tristate.conf
--- u-boot-2016.03/include/config/tristate.conf	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/config/tristate.conf	2021-04-16 14:42:17.792596829 +0800
@@ -0,0 +1,4 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2016.03 Configuration
+#
diff -urN u-boot-2016.03/include/config/uboot.release ebf_6ull_uboot/include/config/uboot.release
--- u-boot-2016.03/include/config/uboot.release	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/config/uboot.release	2021-04-16 14:42:17.792596829 +0800
@@ -0,0 +1 @@
+2016.03-gd484876-dirty
diff -urN u-boot-2016.03/include/config.h ebf_6ull_uboot/include/config.h
--- u-boot-2016.03/include/config.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/config.h	2021-04-16 14:42:17.792596829 +0800
@@ -0,0 +1,9 @@
+/* Automatically generated - do not edit */
+#define CONFIG_IMX_CONFIG	board/freescale/mx6ullevk/imximage.cfg
+#define CONFIG_SYS_BOOT_NAND	1
+#define CONFIG_BOARDDIR board/freescale/mx6ullevk
+#include <config_defaults.h>
+#include <config_uncmd_spl.h>
+#include <configs/mx6ullevk.h>
+#include <asm/config.h>
+#include <config_fallbacks.h>
diff -urN u-boot-2016.03/include/configs/mx6_common.h ebf_6ull_uboot/include/configs/mx6_common.h
--- u-boot-2016.03/include/configs/mx6_common.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6_common.h	2021-04-16 14:42:17.808596912 +0800
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
  * Copyright (c) 2013, NVIDIA CORPORATION.  All rights reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0
@@ -9,9 +10,13 @@
 
 #ifndef CONFIG_MX6UL
 #define CONFIG_ARM_ERRATA_743622
+#if (defined(CONFIG_MX6QP) || defined(CONFIG_MX6Q) ||\
+defined(CONFIG_MX6DL)) && !defined(CONFIG_MX6SOLO)
 #define CONFIG_ARM_ERRATA_751472
 #define CONFIG_ARM_ERRATA_794072
 #define CONFIG_ARM_ERRATA_761320
+#define CONFIG_ARM_ERRATA_845369
+#endif
 
 #ifndef CONFIG_SYS_L2CACHE_OFF
 #define CONFIG_SYS_L2_PL310
@@ -19,10 +24,22 @@
 #endif
 
 #define CONFIG_MP
+#define CONFIG_GPT_TIMER
+#else
+#define CONFIG_SYSCOUNTER_TIMER
+#define CONFIG_SC_TIMER_CLK 8000000 /* 8Mhz */
 #endif
 #define CONFIG_BOARD_POSTCLK_INIT
 #define CONFIG_MXC_GPT_HCLK
 
+#ifdef CONFIG_MX6QP
+#define CONFIG_MX6Q
+#endif
+
+#ifdef CONFIG_MX6SOLO
+#define CONFIG_MX6DL
+#endif
+
 #define CONFIG_SYS_NO_FLASH
 
 #define CONFIG_SYS_BOOTM_LEN	0x1000000
@@ -46,8 +63,8 @@
 #define CONFIG_REVISION_TAG
 
 /* Boot options */
-#if (defined(CONFIG_MX6SX) || defined(CONFIG_MX6SL) || defined(CONFIG_MX6UL))
-#define CONFIG_LOADADDR		0x82000000
+#if (defined(CONFIG_MX6SX) || defined(CONFIG_MX6SL) || defined(CONFIG_MX6UL) || defined(CONFIG_MX6SLL))
+#define CONFIG_LOADADDR		0x80800000
 #ifndef CONFIG_SYS_TEXT_BASE
 #define CONFIG_SYS_TEXT_BASE	0x87800000
 #endif
@@ -60,7 +77,7 @@
 #define CONFIG_SYS_LOAD_ADDR	CONFIG_LOADADDR
 
 #ifndef CONFIG_BOOTDELAY
-#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTDELAY	0
 #endif
 
 /* allow to overwrite serial and ethaddr */
@@ -103,9 +120,14 @@
 #define CONFIG_BOUNCE_BUFFER
 #define CONFIG_FSL_ESDHC
 #define CONFIG_FSL_USDHC
+#define CONFIG_SUPPORT_EMMC_BOOT
 
 /* Fuses */
 #define CONFIG_CMD_FUSE
 #define CONFIG_MXC_OCOTP
 
+/* LDO Bypass */
+#ifndef CONFIG_MX6SLL
+#define CONFIG_LDO_BYPASS_CHECK
+#endif
 #endif
diff -urN u-boot-2016.03/include/configs/mx6dqscm_android.h ebf_6ull_uboot/include/configs/mx6dqscm_android.h
--- u-boot-2016.03/include/configs/mx6dqscm_android.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6dqscm_android.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef MX6DQSCM_ANDROID_H
+#define MX6DQSCM_ANDROID_H
+
+#define CONFIG_CI_UDC
+#define CONFIG_USBD_HS
+#define CONFIG_USB_GADGET_DUALSPEED
+
+#define CONFIG_USB_GADGET
+#define CONFIG_CMD_USB_MASS_STORAGE
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_USB_GADGET_VBUS_DRAW	2
+
+#define CONFIG_G_DNL_VENDOR_NUM		0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM	0x0d02
+#define CONFIG_G_DNL_MANUFACTURER	"FSL"
+
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_CMD_FASTBOOT
+#define CONFIG_ANDROID_BOOT_IMAGE
+#define CONFIG_FASTBOOT_FLASH
+
+#define CONFIG_FSL_FASTBOOT
+#define CONFIG_ANDROID_RECOVERY
+
+#if defined CONFIG_SYS_BOOT_SATA
+#define CONFIG_FASTBOOT_STORAGE_SATA
+#define CONFIG_FASTBOOT_SATA_NO 0
+#else
+#define CONFIG_FASTBOOT_STORAGE_MMC
+#endif
+
+#define CONFIG_ANDROID_MAIN_MMC_BUS 2
+#define CONFIG_ANDROID_BOOT_PARTITION_MMC 1
+#define CONFIG_ANDROID_SYSTEM_PARTITION_MMC 5
+#define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
+#define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
+#define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+
+#define CONFIG_CMD_BOOTA
+#define CONFIG_SUPPORT_RAW_INITRD
+#define CONFIG_SERIAL_TAG
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"splashpos=m,m\0"	  \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+
+#define CONFIG_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#define CONFIG_FASTBOOT_BUF_SIZE   0x19000000
+
+#endif /* MX6DQSCM_ANDROID_H */
diff -urN u-boot-2016.03/include/configs/mx6dqscm.h ebf_6ull_uboot/include/configs/mx6dqscm.h
--- u-boot-2016.03/include/configs/mx6dqscm.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6dqscm.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,560 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6DQ SCM boards.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6DQSCM_CONFIG_H
+#define __MX6DQSCM_CONFIG_H
+
+#include "mx6_common.h"
+
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
+#define CONFIG_IMX_THERMAL
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN           (16 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+
+#define CONFIG_MXC_UART
+
+/* MMC Configs */
+#define CONFIG_SYS_FSL_ESDHC_ADDR      0
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE                    ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define CONFIG_ETHPRIME                 "FEC"
+#define CONFIG_FEC_MXC_PHYADDR          3
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+
+/* Command definition */
+#define CONFIG_CMD_BMODE
+
+#define CONFIG_MACH_TYPE        3980
+#ifdef CONFIG_SCMHVB
+#define CONFIG_MXC_UART_BASE    UART4_BASE
+#define CONFIG_CONSOLE_DEV      "ttymxc3"
+#else
+#define CONFIG_MXC_UART_BASE    UART1_BASE
+#define CONFIG_CONSOLE_DEV      "ttymxc0"
+#endif
+#define CONFIG_MMCROOT          "/dev/mmcblk2p2"  /* SDHC3 */
+
+#if defined(CONFIG_SCMHVB) || defined(CONFIG_SCMEVB)
+#define CONFIG_VIDEO_PRIMARY	" "
+#else
+#define CONFIG_VIDEO_PRIMARY	"video=mxcfb0:dev=hdmi,1920x1080M@60,bpp=32 "
+#endif
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART    1
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS           1
+#define PHYS_SDRAM                     MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE          PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR       IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE       IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+#ifdef CONFIG_SCM_LPDDR2_512MB
+/* 1-Ch 512M */
+#define PHYS_SDRAM_SIZE    (512 * 1024 * 1024)
+#else
+/* Interleave 1GB */
+#define PHYS_SDRAM_SIZE    (1u * 1024 * 1024 * 1024)
+#endif
+
+#if !defined(CONFIG_INTERLEAVING_MODE) && !defined(CONFIG_SCM_LPDDR2_512MB)
+#undef CONFIG_NR_DRAM_BANKS
+#define CONFIG_NR_DRAM_BANKS    2
+#ifdef CONFIG_SCM_LPDDR2_2GB
+/* Fix 2GB */
+#define PHYS_SDRAM_0    MMDC0_ARB_BASE_ADDR    /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1    MMDC1_ARB_BASE_ADDR    /* SDRAM Bank #2 */
+
+#define PHYS_SDRAM_0_SIZE    (1024 * 1024 * 1024)    /* 1024MB */
+#define PHYS_SDRAM_1_SIZE    (1024 * 1024 * 1024)    /* 1024MB */
+
+#else
+/* Fix 1GB */
+#define PHYS_SDRAM_0    MMDC0_ARB_BASE_ADDR    /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1    MMDC1_ARB_BASE_ADDR    /* SDRAM Bank #2 */
+
+#define PHYS_SDRAM_0_SIZE    (512 * 1024 * 1024)    /* 512MB */
+#define PHYS_SDRAM_1_SIZE    (512 * 1024 * 1024)    /* 512MB */
+#endif
+#endif
+
+
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=" CONFIG_CONSOLE_DEV ",115200 " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.file=/fat g_mass_storage.ro=1 " \
+		"g_mass_storage.idVendor=0x066F "\
+		"g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"enable_wait_mode=off "\
+		"\0" \
+	"initrd_addr=0x12C00000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args; "\
+		"bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+
+#ifdef CONFIG_SUPPORT_EMMC_BOOT
+#define EMMC_ENV \
+	"emmcdev=2\0" \
+	"update_emmc_firmware=" \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"if ${get_cmd} ${update_sd_firmware_filename}; then " \
+			"if mmc dev ${emmcdev} 1; then "	\
+				"setexpr fw_sz ${filesize} / 0x200; " \
+				"setexpr fw_sz ${fw_sz} + 1; "	\
+				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
+			"fi; "	\
+		"fi\0"
+#else
+#define EMMC_ENV ""
+#endif
+
+#if defined(CONFIG_SYS_BOOT_SATA)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"fdt_addr=0x18000000\0" \
+	"fdt_high=0xffffffff\0"   \
+	"bootargs=console=" CONFIG_CONSOLE_DEV ",115200 \0"\
+	"bootargs_sata=setenv bootargs ${bootargs} " \
+		"root=/dev/sda1 rootwait rw \0" \
+	"bootcmd_sata=run bootargs_sata; sata init; " \
+		"sata read ${loadaddr} 0x800  0x4000; " \
+		"sata read ${fdt_addr} 0x8000 0x800; " \
+		"bootz ${loadaddr} - ${fdt_addr} \0" \
+		"bootcmd=run bootcmd_sata \0"
+#endif
+
+
+#define CONFIG_SYS_FSL_USDHC_NUM    3
+#define CONFIG_SYS_MMC_ENV_DEV       1  /* SDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART     0  /* user partition */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS        0
+#endif
+
+
+#define CONFIG_ARP_TIMEOUT     200UL
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START       0x10000000
+#define CONFIG_SYS_MEMTEST_END         0x10010000
+#define CONFIG_SYS_MEMTEST_SCRATCH     0x10800000
+
+#define CONFIG_STACKSIZE               (128 * 1024)
+
+/* Environment organization */
+#define CONFIG_ENV_SIZE                 (8 * 1024)
+
+#ifndef CONFIG_SYS_NOSMP
+#define CONFIG_SYS_NOSMP
+#endif
+
+#if defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_SATA
+#define CONFIG_ENV_IS_IN_SATA
+#define CONFIG_CMD_SATA
+#else
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_CMD_SATA
+#define CONFIG_DWC_AHSATA
+#define CONFIG_SYS_SATA_MAX_DEVICE    1
+#define CONFIG_DWC_AHSATA_PORT_ID     0
+#define CONFIG_DWC_AHSATA_BASE_ADDR   SATA_ARB_BASE_ADDR
+#define CONFIG_LBA48
+#define CONFIG_LIBATA
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS   0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#endif
+
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET              (12 * 64 * 1024)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET              (768 * 1024)
+#define CONFIG_ENV_SECT_SIZE           (64 * 1024)
+#define CONFIG_ENV_SPI_BUS             CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS              CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE            CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ          CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_SATA)
+#define CONFIG_ENV_OFFSET              (768 * 1024)
+#define CONFIG_SATA_ENV_DEV            0
+#define CONFIG_SYS_DCACHE_OFF /* remove when sata driver support cache */
+#endif
+
+/* I2C Configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1    /* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2    /* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C3    /* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_SPEED       100000
+
+/* Framebuffer */
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_IPUV3
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#ifdef CONFIG_MX6DL
+#define CONFIG_IPUV3_CLK 198000000
+#else
+#define CONFIG_IPUV3_CLK 264000000
+#endif
+#define CONFIG_IMX_HDMI
+#define CONFIG_IMX_VIDEO_SKIP
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6dqscm_android.h"
+#else
+
+#define CONFIG_CI_UDC
+#define CONFIG_USBD_HS
+#define CONFIG_USB_GADGET_DUALSPEED
+
+#define CONFIG_USB_GADGET
+#define CONFIG_CMD_USB_MASS_STORAGE
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_USB_GADGET_VBUS_DRAW    2
+
+#define CONFIG_G_DNL_VENDOR_NUM      0x0525
+#define CONFIG_G_DNL_PRODUCT_NUM     0xa4a5
+#define CONFIG_G_DNL_MANUFACTURER    "FSL"
+
+/* USB Device Firmware Update support */
+#define CONFIG_CMD_DFU
+#define CONFIG_USB_FUNCTION_DFU
+#define CONFIG_DFU_MMC
+#if defined(CONFIG_SYS_USE_SPINOR)
+#define CONFIG_DFU_SF
+#endif
+
+#endif /* CONFIG_ANDROID_SUPPORT */
+
+/*
+ * imx6 q/dl/solo pcie would be failed to work properly in kernel, if
+ * the pcie module is iniialized/enumerated both in uboot and linux
+ * kernel.
+ * rootcause:imx6 q/dl/solo pcie don't have the reset mechanism.
+ * it is only be RESET by the POR. So, the pcie module only be
+ * initialized/enumerated once in one POR.
+ * Set to use pcie in kernel defaultly, mask the pcie config here.
+ * Remove the mask freely, if the uboot pcie functions, rather than
+ * the kernel's, are required.
+ */
+/* #define CONFIG_CMD_PCI */
+#ifdef CONFIG_CMD_PCI
+#define CONFIG_PCI
+#define CONFIG_PCI_PNP
+#define CONFIG_PCI_SCAN_SHOW
+#define CONFIG_PCIE_IMX
+#define CONFIG_PCIE_IMX_PERST_GPIO    IMX_GPIO_NR(7, 12)
+#define CONFIG_PCIE_IMX_POWER_GPIO    IMX_GPIO_NR(3, 19)
+#endif
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE100
+#define CONFIG_POWER_PFUZE100_I2C_ADDR  0x08
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#ifdef CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC           (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS            0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1 /* Enabled USB controller number */
+#endif
+
+#if !defined(CONFIG_ANDROID_SUPPORT)
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"fdt_addr=0x18000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"console=" CONFIG_CONSOLE_DEV "\0" \
+	"fdt_high=0xffffffff\0"   \
+	"initrd_high=0xffffffff\0" \
+	"mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV) "\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"update_sd_firmware=" \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"if mmc dev ${mmcdev}; then "   \
+			"if ${get_cmd} ${update_sd_firmware_filename}; then " \
+				"setexpr fw_sz ${filesize} / 0x200; " \
+				"setexpr fw_sz ${fw_sz} + 1; "  \
+				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
+			"fi; "  \
+		"fi\0" \
+	EMMC_ENV	  \
+	"smp=" CONFIG_SYS_NOSMP "\0"\
+	"mmcargs=setenv bootargs console=${console},${baudrate} ${smp} " \
+		"root=${mmcroot} " CONFIG_VIDEO_PRIMARY "\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} ${smp} " \
+		"root=/dev/nfs " \
+		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+	"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#undef CONFIG_BOOTCOMMAND
+#define CONFIG_BOOTCOMMAND \
+	"mmc dev ${mmcdev};" \
+	"if mmc rescan; then " \
+		"if run loadbootscript; then " \
+		"run bootscript; " \
+		"else " \
+			"if run loadimage; then " \
+				"run mmcboot; " \
+			"else run netboot; " \
+			"fi; " \
+		"fi; " \
+	"else run netboot; fi"
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#undef CONFIG_ENV_OFFSET
+#define CONFIG_ENV_OFFSET    (448 * 1024)
+#undef CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE (64 * 1024)
+#define CONFIG_INTERNAL_SPI_NOR_PARTITION \
+	"mtdparts=spi0.0:512k(uboot),64k(dtb),7m(linux),-(rootfs) "
+#undef CONFIG_MFG_ENV_SETTINGS
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=" CONFIG_CONSOLE_DEV ",115200 " \
+	"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.file=/fat g_mass_storage.ro=1 " \
+		"g_mass_storage.idVendor=0x066F "\
+		"g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"enable_wait_mode=off "\
+		CONFIG_INTERNAL_SPI_NOR_PARTITION \
+		"\0" \
+	"initrd_addr=0x12C00000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0"
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"fdt_addr=0x18000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"console=" CONFIG_CONSOLE_DEV "\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+	"mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV) "\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"update_sd_firmware=" \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"if mmc dev ${mmcdev}; then "	\
+			"if ${get_cmd} ${update_sd_firmware_filename}; then " \
+				"setexpr fw_sz ${filesize} / 0x200; " \
+				"setexpr fw_sz ${fw_sz} + 1; "	\
+				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
+			"fi; "	\
+		"fi\0" \
+	EMMC_ENV	  \
+	"smp=" CONFIG_SYS_NOSMP "\0"\
+	"mmcargs=setenv bootargs console=${console},${baudrate} ${smp} " \
+		"root=${mmcroot} " CONFIG_VIDEO_PRIMARY "\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} ${smp} " \
+		"root=/dev/nfs " \
+		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+	"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"spinorargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/mtdblock3 rootwait rw " \
+		CONFIG_INTERNAL_SPI_NOR_PARTITION "\0" \
+	"spinorboot=echo Booting from internal SPI-NOR Flash...; " \
+		"run spinorargs; sf probe; " \
+		"sf read 0x12000000 0x90000 0x700000; " \
+		"sf read 0x18000000 0x80000 0x10000; " \
+		"bootz 0x12000000 - 0x18000000"
+
+#undef CONFIG_BOOTCOMMAND
+#define CONFIG_BOOTCOMMAND \
+	"run spinorboot; " \
+	"mmc dev ${mmcdev};" \
+	"if mmc rescan; then " \
+		"if run loadbootscript; then " \
+		"run bootscript; " \
+		"else " \
+			"if run loadimage; then " \
+				"run mmcboot; " \
+			"else run netboot; " \
+			"fi; " \
+		"fi; " \
+	"else run netboot; fi"
+
+#endif
+
+#endif    /* __MX6DQSCM_CONFIG_H */
diff -urN u-boot-2016.03/include/configs/mx6qarm2_android.h ebf_6ull_uboot/include/configs/mx6qarm2_android.h
--- u-boot-2016.03/include/configs/mx6qarm2_android.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6qarm2_android.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef IMX6Q_ARM2_ANDROID_H
+#define IMX6Q_ARM2_ANDROID_H
+
+#define CONFIG_CI_UDC
+#define CONFIG_USBD_HS
+#define CONFIG_USB_GADGET_DUALSPEED
+
+#define CONFIG_USB_GADGET
+#define CONFIG_CMD_USB_MASS_STORAGE
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_USB_GADGET_VBUS_DRAW	2
+
+#define CONFIG_G_DNL_VENDOR_NUM		0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM	0x0d02
+#define CONFIG_G_DNL_MANUFACTURER	"FSL"
+
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_CMD_FASTBOOT
+#define CONFIG_CMD_READ
+#define CONFIG_BCB_SUPPORT
+#define CONFIG_ANDROID_BOOT_IMAGE
+#define CONFIG_FASTBOOT_FLASH
+
+/* For NAND we don't support lock/unlock */
+#ifndef CONFIG_SYS_BOOT_NAND
+#define CONFIG_FASTBOOT_LOCK
+#endif
+
+#define FSL_FASTBOOT_FB_DEV "mmc"
+#define FSL_FASTBOOT_DATA_PART_NUM 4
+#define FSL_FASTBOOT_FB_PART_NUM 11
+#define FSL_FASTBOOT_PR_DATA_PART_NUM 12
+
+#define CONFIG_FSL_CAAM_KB
+#define CONFIG_CMD_FSL_CAAM_KB
+#define CONFIG_SHA1
+#define CONFIG_SHA256
+
+#define CONFIG_FSL_FASTBOOT
+#define CONFIG_ANDROID_RECOVERY
+
+#if defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_FASTBOOT_STORAGE_NAND
+#elif defined CONFIG_SYS_BOOT_SATA
+#define CONFIG_FASTBOOT_STORAGE_SATA
+#else
+#define CONFIG_FASTBOOT_STORAGE_MMC
+#endif
+
+#define CONFIG_ANDROID_MAIN_MMC_BUS 2
+#define CONFIG_ANDROID_BOOT_PARTITION_MMC 1
+#define CONFIG_ANDROID_SYSTEM_PARTITION_MMC 5
+#define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
+#define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
+#define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+#define CONFIG_ANDROID_MISC_PARTITION_MMC 8
+
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+#define ANDROID_FASTBOOT_NAND_PARTS "16m@64m(boot) 16m@80m(recovery) 810m@96m(android_root)ubifs"
+#endif
+
+#define CONFIG_CMD_BOOTA
+#define CONFIG_SUPPORT_RAW_INITRD
+#define CONFIG_SERIAL_TAG
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"splashpos=m,m\0"	  \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+
+#define CONFIG_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#define CONFIG_FASTBOOT_BUF_SIZE   0x19000000
+
+#endif /* IMX6Q_ARM2_ANDROID_H */
diff -urN u-boot-2016.03/include/configs/mx6qarm2.h ebf_6ull_uboot/include/configs/mx6qarm2.h
--- u-boot-2016.03/include/configs/mx6qarm2.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6qarm2.h	2021-04-16 14:42:17.808596912 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6Q Armadillo2 board.
  *
@@ -11,10 +11,25 @@
 
 #include "mx6_common.h"
 
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
+#define CONFIG_IMX_THERMAL
+
 /* Size of malloc() pool */
 #define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 2 * 1024 * 1024)
 
 #define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
 
 #define CONFIG_MXC_UART
 #define CONFIG_MXC_UART_BASE		UART4_BASE
@@ -32,19 +47,26 @@
 #define	CONFIG_FEC_XCV_TYPE		RGMII
 #define CONFIG_FEC_MXC_PHYADDR		0
 
+#if defined(CONFIG_MX6DQ_POP_LPDDR2)
+#define CONFIG_DEFAULT_FDT_FILE "imx6q-pop-arm2.dtb"
+#else
+#define CONFIG_DEFAULT_FDT_FILE "imx6q-arm2.dtb"
+#endif
+
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	"script=boot.scr\0" \
 	"image=zImage\0" \
 	"console=ttymxc3\0" \
-	"fdt_file=imx6q-arm2.dtb\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
 	"fdt_addr=0x18000000\0" \
 	"fdt_high=0xffffffff\0" \
 	"initrd_high=0xffffffff\0" \
 	"boot_fdt=try\0" \
 	"ip_dyn=yes\0" \
-	"mmcdev=1\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
 	"mmcpart=1\0" \
-	"mmcroot=/dev/mmcblk0p2 rootwait rw\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
 	"mmcargs=setenv bootargs console=${console},${baudrate} " \
 		"root=${mmcroot}\0" \
 	"loadbootscript=" \
@@ -109,11 +131,18 @@
 #define CONFIG_ARP_TIMEOUT	200UL
 
 /* Miscellaneous configurable options */
+#define CONFIG_CMD_MEMTEST
 #define CONFIG_SYS_MEMTEST_START	0x10000000
 #define CONFIG_SYS_MEMTEST_END		0x10010000
 
 /* Physical Memory Map */
+#if defined(CONFIG_MX6DQ_POP_LPDDR2)
+#define CONFIG_NR_DRAM_BANKS		2
+#define PHYS_SDRAM_0			MMDC0_ARB_BASE_ADDR
+#define PHYS_SDRAM_1			MMDC1_ARB_BASE_ADDR
+#else
 #define CONFIG_NR_DRAM_BANKS		1
+#endif
 #define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
 
 #define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
@@ -126,10 +155,12 @@
 	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
 
 /* Environment organization */
-#define CONFIG_ENV_OFFSET		(6 * 64 * 1024)
+#define CONFIG_ENV_OFFSET		(12 * 64 * 1024)
 #define CONFIG_ENV_SIZE			(8 * 1024)
 #define CONFIG_ENV_IS_IN_MMC
 #define CONFIG_SYS_MMC_ENV_DEV		1
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user partition */
+#define CONFIG_MMCROOT			"/dev/mmcblk3p2"  /* SDHC4 */
 
 /* USB Configs */
 #define CONFIG_CMD_USB
@@ -145,4 +176,8 @@
 #define CONFIG_USB_MAX_CONTROLLER_COUNT	1
 #endif
 
-#endif				/* __CONFIG_H */
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6qarm2_android.h"
+#endif
+
+#endif                         /* __CONFIG_H */
diff -urN u-boot-2016.03/include/configs/mx6qsabreauto.h ebf_6ull_uboot/include/configs/mx6qsabreauto.h
--- u-boot-2016.03/include/configs/mx6qsabreauto.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6qsabreauto.h	2021-04-16 14:42:17.808596912 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6Q SabreAuto board.
  *
@@ -12,9 +12,15 @@
 #define CONFIG_MACH_TYPE	3529
 #define CONFIG_MXC_UART_BASE	UART4_BASE
 #define CONFIG_CONSOLE_DEV		"ttymxc3"
-#define CONFIG_MMCROOT			"/dev/mmcblk0p2"
+#define CONFIG_MMCROOT			"/dev/mmcblk2p2"  /* SDHC3 */
 #define PHYS_SDRAM_SIZE		(2u * 1024 * 1024 * 1024)
+#ifdef CONFIG_MX6SOLO
+#undef PHYS_SDRAM_SIZE
+#define PHYS_SDRAM_SIZE		(1u * 1024 * 1024 * 1024)
+#endif
 
+/*Since the pin conflicts on EIM D18, disable the USB host if the NOR flash is enabled */
+#if !defined(CONFIG_SYS_USE_SPINOR) && !defined(CONFIG_SYS_USE_EIMNOR)
 /* USB Configs */
 #define CONFIG_CMD_USB
 #define CONFIG_USB_EHCI
@@ -29,53 +35,25 @@
 
 #define CONFIG_PCA953X
 #define CONFIG_SYS_I2C_PCA953X_WIDTH	{ {0x30, 8}, {0x32, 8}, {0x34, 8} }
+#endif
+
+#define CONFIG_SYS_USE_NAND
 
 #include "mx6sabre_common.h"
 
-#undef CONFIG_SYS_NO_FLASH
-#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
-#define CONFIG_SYS_FLASH_SECT_SIZE      (128 * 1024)
-#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
-#define CONFIG_SYS_MAX_FLASH_SECT 256   /* max number of sectors on one chip */
-#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
-#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
-#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
-#define CONFIG_SYS_FLASH_EMPTY_INFO
+#undef CONFIG_MFG_NAND_PARTITION
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=8000000.nor:1m(boot),-(rootfs)\\\\;gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
 
 #define CONFIG_SYS_FSL_USDHC_NUM	2
-#if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_SYS_MMC_ENV_DEV		0
-#endif
+#define CONFIG_SYS_MMC_ENV_DEV		1  /* SDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART                0       /* user partition */
 
-/* I2C Configs */
-#define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
-#define CONFIG_SYS_I2C_MXC
-#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
-#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
-#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
-#define CONFIG_SYS_I2C_SPEED		100000
-
-/* NAND flash command */
-#define CONFIG_CMD_NAND
-#define CONFIG_CMD_NAND_TRIMFFS
-
-/* NAND stuff */
-#define CONFIG_NAND_MXS
-#define CONFIG_SYS_MAX_NAND_DEVICE     1
-#define CONFIG_SYS_NAND_BASE           0x40000000
-#define CONFIG_SYS_NAND_5_ADDR_CYCLE
-#define CONFIG_SYS_NAND_ONFI_DETECTION
-
-/* DMA stuff, needed for GPMI/MXS NAND support */
-#define CONFIG_APBH_DMA
-#define CONFIG_APBH_DMA_BURST
-#define CONFIG_APBH_DMA_BURST8
-
-/* PMIC */
-#define CONFIG_POWER
-#define CONFIG_POWER_I2C
-#define CONFIG_POWER_PFUZE100
-#define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS   1
+#endif
 
 #endif                         /* __MX6QSABREAUTO_CONFIG_H */
diff -urN u-boot-2016.03/include/configs/mx6sabreandroid_common.h ebf_6ull_uboot/include/configs/mx6sabreandroid_common.h
--- u-boot-2016.03/include/configs/mx6sabreandroid_common.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6sabreandroid_common.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef MX6_SABRE_ANDROID_COMMON_H
+#define MX6_SABRE_ANDROID_COMMON_H
+
+#define CONFIG_CI_UDC
+#define CONFIG_USBD_HS
+#define CONFIG_USB_GADGET_DUALSPEED
+
+#define CONFIG_USB_GADGET
+#define CONFIG_CMD_USB_MASS_STORAGE
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_USB_GADGET_VBUS_DRAW	2
+
+#define CONFIG_G_DNL_VENDOR_NUM		0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM	0x0d02
+#define CONFIG_G_DNL_MANUFACTURER	"FSL"
+
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_CMD_FASTBOOT
+#define CONFIG_ANDROID_BOOT_IMAGE
+#define CONFIG_FASTBOOT_FLASH
+
+#define CONFIG_FSL_FASTBOOT
+#define CONFIG_ANDROID_RECOVERY
+
+#if defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_FASTBOOT_STORAGE_NAND
+#elif defined CONFIG_SYS_BOOT_SATA
+#define CONFIG_FASTBOOT_STORAGE_SATA
+#define CONFIG_FASTBOOT_SATA_NO 0
+#else
+#define CONFIG_FASTBOOT_STORAGE_MMC
+#endif
+
+#define CONFIG_ANDROID_MAIN_MMC_BUS 2
+#define CONFIG_ANDROID_BOOT_PARTITION_MMC 1
+#define CONFIG_ANDROID_SYSTEM_PARTITION_MMC 5
+#define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
+#define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
+#define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+#define ANDROID_FASTBOOT_NAND_PARTS "16m@64m(boot) 16m@80m(recovery) 810m@96m(android_root)ubifs"
+#endif
+
+#define CONFIG_CMD_BOOTA
+#define CONFIG_SUPPORT_RAW_INITRD
+#define CONFIG_SERIAL_TAG
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"splashpos=m,m\0"	  \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+
+#define CONFIG_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#define CONFIG_FASTBOOT_BUF_SIZE   0x19000000
+
+#endif /* MX6_SABRE_ANDROID_COMMON_H */
diff -urN u-boot-2016.03/include/configs/mx6sabre_common.h ebf_6ull_uboot/include/configs/mx6sabre_common.h
--- u-boot-2016.03/include/configs/mx6sabre_common.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6sabre_common.h	2021-04-16 14:42:17.808596912 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6Q SabreSD board.
  *
@@ -11,10 +11,22 @@
 
 #include "mx6_common.h"
 
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
 #define CONFIG_IMX_THERMAL
 
 /* Size of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		(10 * SZ_1M)
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
 
 #define CONFIG_BOARD_EARLY_INIT_F
 #define CONFIG_BOARD_LATE_INIT
@@ -37,18 +49,30 @@
 #define CONFIG_PHYLIB
 #define CONFIG_PHY_ATHEROS
 
-#define CONFIG_CMD_SF
-#ifdef CONFIG_CMD_SF
-#define CONFIG_MXC_SPI
-#define CONFIG_SF_DEFAULT_BUS		0
-#define CONFIG_SF_DEFAULT_CS		0
-#define CONFIG_SF_DEFAULT_SPEED		20000000
-#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
-#endif
-
 /* Command definition */
 #define CONFIG_CMD_BMODE
 
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=" CONFIG_CONSOLE_DEV ",115200 " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.file=/fat g_mass_storage.ro=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"enable_wait_mode=off "\
+		CONFIG_MFG_NAND_PARTITION \
+		"\0" \
+		"initrd_addr=0x12C00000\0" \
+		"initrd_high=0xffffffff\0" \
+		"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+
 #ifdef CONFIG_SUPPORT_EMMC_BOOT
 #define EMMC_ENV \
 	"emmcdev=2\0" \
@@ -71,7 +95,46 @@
 
 #define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
 
+#if defined(CONFIG_SYS_BOOT_NAND)
+	/*
+	 * The dts also enables the WEIN NOR which is mtd0.
+	 * So the partions' layout for NAND is:
+	 *     mtd1: 16M      (uboot)
+	 *     mtd2: 16M      (kernel)
+	 *     mtd3: 16M      (dtb)
+	 *     mtd4: left     (rootfs)
+	 */
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"fdt_addr=0x18000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"bootargs=console=" CONFIG_CONSOLE_DEV ",115200 ubi.mtd=5 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#elif defined(CONFIG_SYS_BOOT_SATA)
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		CONFIG_MFG_ENV_SETTINGS \
+		"fdt_addr=0x18000000\0" \
+		"fdt_high=0xffffffff\0"   \
+		"bootargs=console=" CONFIG_CONSOLE_DEV ",115200 \0"\
+		"bootargs_sata=setenv bootargs ${bootargs} " \
+			"root=/dev/sda1 rootwait rw \0" \
+		"bootcmd_sata=run bootargs_sata; sata init; " \
+			"sata read ${loadaddr} 0x800  0x4000; " \
+			"sata read ${fdt_addr} 0x8000 0x800; " \
+			"bootz ${loadaddr} - ${fdt_addr} \0" \
+		"bootcmd=run bootcmd_sata \0"
+
+#else
+
 #define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"epdc_waveform=epdc_splash.bin\0" \
 	"script=boot.scr\0" \
 	"image=zImage\0" \
 	"fdt_file=undefined\0" \
@@ -88,6 +151,7 @@
 	"mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV) "\0" \
 	"mmcpart=1\0" \
 	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
 	"update_sd_firmware=" \
 		"if test ${ip_dyn} = yes; then " \
 			"setenv get_cmd dhcp; " \
@@ -102,7 +166,8 @@
 			"fi; "	\
 		"fi\0" \
 	EMMC_ENV	  \
-	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+	"smp=" CONFIG_SYS_NOSMP "\0"\
+	"mmcargs=setenv bootargs console=${console},${baudrate} ${smp} " \
 		"root=${mmcroot}\0" \
 	"loadbootscript=" \
 		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
@@ -125,7 +190,7 @@
 		"else " \
 			"bootz; " \
 		"fi;\0" \
-	"netargs=setenv bootargs console=${console},${baudrate} " \
+	"netargs=setenv bootargs console=${console},${baudrate} ${smp} " \
 		"root=/dev/nfs " \
 		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
 	"netboot=echo Booting from net ...; " \
@@ -181,9 +246,11 @@
 			"fi; " \
 		"fi; " \
 	"else run netboot; fi"
+#endif
 
 #define CONFIG_ARP_TIMEOUT     200UL
 
+#define CONFIG_CMD_MEMTEST
 #define CONFIG_SYS_MEMTEST_START       0x10000000
 #define CONFIG_SYS_MEMTEST_END         0x10010000
 #define CONFIG_SYS_MEMTEST_SCRATCH     0x10800000
@@ -206,12 +273,116 @@
 /* Environment organization */
 #define CONFIG_ENV_SIZE			(8 * 1024)
 
+#ifndef CONFIG_SYS_NOSMP
+#define CONFIG_SYS_NOSMP
+#endif
+
+#if defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_EIMNOR
+#define CONFIG_SYS_USE_EIMNOR
+#define CONFIG_ENV_IS_IN_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#elif defined CONFIG_SYS_BOOT_SATA
+#define CONFIG_ENV_IS_IN_SATA
+#define CONFIG_CMD_SATA
+#else
 #define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_CMD_SATA
+#define CONFIG_DWC_AHSATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_DWC_AHSATA_PORT_ID	0
+#define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
+#define CONFIG_LBA48
+#define CONFIG_LIBATA
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+#undef CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
+#define CONFIG_SYS_FLASH_SECT_SIZE      (128 * 1024)
+#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT 256   /* max number of sectors on one chip */
+#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
+#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+/* NAND flash command */
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE     1
+#define CONFIG_SYS_NAND_BASE           0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
 
 #if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_ENV_OFFSET		(8 * 64 * 1024)
+#define CONFIG_ENV_OFFSET		(12 * 64 * 1024)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET              (768 * 1024)
+#define CONFIG_ENV_SECT_SIZE           (64 * 1024)
+#define CONFIG_ENV_SPI_BUS             CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS              CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE            CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ          CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_FLASH)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_SIZE                        CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE           CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_OFFSET              (6 * CONFIG_SYS_FLASH_SECT_SIZE)
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET              (60 << 20)
+#define CONFIG_ENV_SECT_SIZE           (128 << 10)
+#define CONFIG_ENV_SIZE                        CONFIG_ENV_SECT_SIZE
+#elif defined(CONFIG_ENV_IS_IN_SATA)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_SATA_ENV_DEV		0
+#define CONFIG_SYS_DCACHE_OFF /* remove when sata driver support cache */
 #endif
 
+/* I2C Configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE100
+#define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
+
 /* Framebuffer */
 #define CONFIG_VIDEO
 #define CONFIG_VIDEO_IPUV3
@@ -225,10 +396,18 @@
 #define CONFIG_BMP_16BPP
 #define CONFIG_VIDEO_LOGO
 #define CONFIG_VIDEO_BMP_LOGO
-#define CONFIG_IPUV3_CLK 260000000
+#ifdef CONFIG_MX6DL
+#define CONFIG_IPUV3_CLK 198000000
+#else
+#define CONFIG_IPUV3_CLK 264000000
+#endif
 #define CONFIG_IMX_HDMI
 #define CONFIG_IMX_VIDEO_SKIP
 
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6sabreandroid_common.h"
+#else
+
 #ifndef CONFIG_SPL
 #define CONFIG_CI_UDC
 #define CONFIG_USBD_HS
@@ -244,17 +423,15 @@
 #define CONFIG_G_DNL_PRODUCT_NUM	0xa4a5
 #define CONFIG_G_DNL_MANUFACTURER	"FSL"
 
-#define CONFIG_USB_FUNCTION_FASTBOOT
-#define CONFIG_CMD_FASTBOOT
-#define CONFIG_ANDROID_BOOT_IMAGE
-#define CONFIG_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
-#define CONFIG_FASTBOOT_BUF_SIZE   0x07000000
-
 /* USB Device Firmware Update support */
 #define CONFIG_CMD_DFU
 #define CONFIG_USB_FUNCTION_DFU
 #define CONFIG_DFU_MMC
+#if defined(CONFIG_SYS_USE_SPINOR)
 #define CONFIG_DFU_SF
 #endif
+#endif
+
+#endif /* CONFIG_ANDROID_SUPPORT */
 
 #endif                         /* __MX6QSABRE_COMMON_CONFIG_H */
diff -urN u-boot-2016.03/include/configs/mx6sabresd.h ebf_6ull_uboot/include/configs/mx6sabresd.h
--- u-boot-2016.03/include/configs/mx6sabresd.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6sabresd.h	2021-04-16 14:42:17.808596912 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6Q SabreSD board.
  *
@@ -18,18 +18,40 @@
 #define CONFIG_MACH_TYPE	3980
 #define CONFIG_MXC_UART_BASE	UART1_BASE
 #define CONFIG_CONSOLE_DEV		"ttymxc0"
-#define CONFIG_MMCROOT			"/dev/mmcblk1p2"
+#define CONFIG_MMCROOT			"/dev/mmcblk2p2"  /* SDHC3 */
 
-#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+#if defined(CONFIG_MX6QP)
+#define PHYS_SDRAM_SIZE		(1u * 1024 * 1024 * 1024)
+#elif defined(CONFIG_MX6Q)
+#define PHYS_SDRAM_SIZE		(1u * 1024 * 1024 * 1024)
+#elif defined(CONFIG_MX6DL)
+#define PHYS_SDRAM_SIZE		(1u * 1024 * 1024 * 1024)
+#elif defined(CONFIG_MX6SOLO)
+#define PHYS_SDRAM_SIZE		(512u * 1024 * 1024)
+#endif
 
 #include "mx6sabre_common.h"
 
 #define CONFIG_SYS_FSL_USDHC_NUM	3
-#if defined(CONFIG_ENV_IS_IN_MMC)
 #define CONFIG_SYS_MMC_ENV_DEV		1	/* SDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART                0       /* user partition */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS   0
 #endif
 
-#define CONFIG_CMD_PCI
+/*
+ * imx6 q/dl/solo pcie would be failed to work properly in kernel, if
+ * the pcie module is iniialized/enumerated both in uboot and linux
+ * kernel.
+ * rootcause:imx6 q/dl/solo pcie don't have the reset mechanism.
+ * it is only be RESET by the POR. So, the pcie module only be
+ * initialized/enumerated once in one POR.
+ * Set to use pcie in kernel defaultly, mask the pcie config here.
+ * Remove the mask freely, if the uboot pcie functions, rather than
+ * the kernel's, are required.
+ */
+/* #define CONFIG_CMD_PCI */
 #ifdef CONFIG_CMD_PCI
 #define CONFIG_PCI
 #define CONFIG_PCI_PNP
@@ -39,21 +61,6 @@
 #define CONFIG_PCIE_IMX_POWER_GPIO	IMX_GPIO_NR(3, 19)
 #endif
 
-/* I2C Configs */
-#define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
-#define CONFIG_SYS_I2C_MXC
-#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
-#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
-#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
-#define CONFIG_SYS_I2C_SPEED		  100000
-
-/* PMIC */
-#define CONFIG_POWER
-#define CONFIG_POWER_I2C
-#define CONFIG_POWER_PFUZE100
-#define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
-
 /* USB Configs */
 #define CONFIG_CMD_USB
 #ifdef CONFIG_CMD_USB
@@ -68,4 +75,25 @@
 #define CONFIG_USB_MAX_CONTROLLER_COUNT	1 /* Enabled USB controller number */
 #endif
 
+/*#define CONFIG_SPLASH_SCREEN*/
+/*#define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_CMD_BMP
+	#define CONFIG_LCD
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+	#undef LCD_TEST_PATTERN
+	/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+	#define LCD_BPP					LCD_MONOCHROME
+	/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+	#define CONFIG_WAVEFORM_BUF_SIZE		0x200000
+#endif /* CONFIG_SPLASH_SCREEN && CONFIG_MXC_EPDC */
+
 #endif                         /* __MX6QSABRESD_CONFIG_H */
diff -urN u-boot-2016.03/include/configs/mx6slevkandroid.h ebf_6ull_uboot/include/configs/mx6slevkandroid.h
--- u-boot-2016.03/include/configs/mx6slevkandroid.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6slevkandroid.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,74 @@
+
+/*
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef MX6SL_EVK_ANDROID_H
+#define MX6SL_EVK_ANDROID_H
+
+#include <asm/imx-common/mxc_key_defs.h>
+
+#define CONFIG_CI_UDC
+#define CONFIG_USBD_HS
+#define CONFIG_USB_GADGET_DUALSPEED
+
+#define CONFIG_USB_GADGET
+#define CONFIG_CMD_USB_MASS_STORAGE
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_USB_GADGET_VBUS_DRAW	2
+
+#define CONFIG_G_DNL_VENDOR_NUM		0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM	0x0d02
+#define CONFIG_G_DNL_MANUFACTURER	"FSL"
+
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_CMD_FASTBOOT
+#define CONFIG_ANDROID_BOOT_IMAGE
+#define CONFIG_FASTBOOT_FLASH
+
+#define CONFIG_FSL_FASTBOOT
+#define CONFIG_ANDROID_RECOVERY
+
+#define CONFIG_FASTBOOT_STORAGE_MMC
+
+#define CONFIG_ANDROID_MAIN_MMC_BUS 2
+#define CONFIG_ANDROID_BOOT_PARTITION_MMC 1
+#define CONFIG_ANDROID_SYSTEM_PARTITION_MMC 5
+#define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
+#define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
+#define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+
+#define CONFIG_CMD_BOOTA
+#define CONFIG_SUPPORT_RAW_INITRD
+#define CONFIG_SERIAL_TAG
+
+/*keyboard mapping*/
+#define CONFIG_VOL_DOWN_KEY     KEY_BACK
+#define CONFIG_POWER_KEY        KEY_5
+
+#define CONFIG_MXC_KPD
+#define CONFIG_MXC_KEYMAPPING \
+	{       \
+		KEY_SELECT, KEY_BACK, KEY_1,     KEY_2, \
+		KEY_3,      KEY_4,    KEY_5,     KEY_MENU, \
+		KEY_6,      KEY_7,    KEY_8,     KEY_9, \
+		KEY_UP,     KEY_LEFT, KEY_RIGHT, KEY_DOWN, \
+	}
+#define CONFIG_MXC_KPD_COLMAX 4
+#define CONFIG_MXC_KPD_ROWMAX 4
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"splashpos=m,m\0"	  \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+
+#define CONFIG_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#define CONFIG_FASTBOOT_BUF_SIZE   0x19000000
+
+#endif
diff -urN u-boot-2016.03/include/configs/mx6slevk.h ebf_6ull_uboot/include/configs/mx6slevk.h
--- u-boot-2016.03/include/configs/mx6slevk.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6slevk.h	2021-04-16 14:42:17.808596912 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013 Freescale Semiconductor, Inc.
+ * Copyright 2013-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6SL EVK board.
  *
@@ -17,19 +17,34 @@
 #include "imx6_spl.h"
 #endif
 
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
 #define MACH_TYPE_MX6SLEVK		4307
 #define CONFIG_MACH_TYPE		MACH_TYPE_MX6SLEVK
 
 /* Size of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		(3 * SZ_1M)
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
 
 #define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
 
 #define CONFIG_MXC_UART
-#define CONFIG_MXC_UART_BASE		UART1_IPS_BASE_ADDR
+#define CONFIG_MXC_UART_BASE		UART1_BASE
 
 /* MMC Configs */
 #define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC2_BASE_ADDR
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#define CONFIG_SYS_MMC_ENV_DEV		1	/* SDHC2*/
 
 /* I2C Configs */
 #define CONFIG_CMD_I2C
@@ -53,24 +68,40 @@
 #define CONFIG_MII
 #define IMX_FEC_BASE			ENET_BASE_ADDR
 #define CONFIG_FEC_XCV_TYPE		RMII
+#define CONFIG_ETHPRIME			"FEC"
 #define CONFIG_FEC_MXC_PHYADDR		0
 
 #define CONFIG_PHYLIB
 #define CONFIG_PHY_SMSC
 
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.file=/fat g_mass_storage.ro=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
 #define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"epdc_waveform=epdc_splash.bin\0" \
 	"script=boot.scr\0" \
 	"image=zImage\0" \
 	"console=ttymxc0\0" \
 	"fdt_high=0xffffffff\0" \
 	"initrd_high=0xffffffff\0" \
 	"fdt_file=imx6sl-evk.dtb\0" \
-	"fdt_addr=0x88000000\0" \
+	"fdt_addr=0x83000000\0" \
 	"boot_fdt=try\0" \
 	"ip_dyn=yes\0" \
-	"mmcdev=1\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
 	"mmcpart=1\0" \
-	"mmcroot=/dev/mmcblk0p2 rootwait rw\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
 	"mmcargs=setenv bootargs console=${console},${baudrate} " \
 		"root=${mmcroot}\0" \
 	"loadbootscript=" \
@@ -133,6 +164,7 @@
 	   "else run netboot; fi"
 
 /* Miscellaneous configurable options */
+#define CONFIG_CMD_MEMTEST
 #define CONFIG_SYS_MEMTEST_START	0x80000000
 #define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + SZ_512M)
 
@@ -154,6 +186,9 @@
 
 /* Environment organization */
 #define CONFIG_ENV_SIZE			SZ_8K
+#define CONFIG_SYS_MMC_ENV_DEV		1   /* USDHC2 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user partition */
+#define CONFIG_MMCROOT			"/dev/mmcblk1p2"  /* USDHC2 */
 
 #if defined CONFIG_SYS_BOOT_SPINOR
 #define CONFIG_ENV_IS_IN_SPI_FLASH
@@ -164,7 +199,7 @@
 #define CONFIG_ENV_SPI_MODE             CONFIG_SF_DEFAULT_MODE
 #define CONFIG_ENV_SPI_MAX_HZ           CONFIG_SF_DEFAULT_SPEED
 #else
-#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
 #define CONFIG_ENV_IS_IN_MMC
 #endif
 
@@ -198,4 +233,29 @@
 
 #define CONFIG_IMX_THERMAL
 
+/*#define CONFIG_SPLASH_SCREEN*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#ifdef CONFIG_SPLASH_SCREEN
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_CMD_BMP
+	#define CONFIG_MXC_EPDC				1
+	#define CONFIG_LCD
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#ifdef CONFIG_MXC_EPDC
+	#undef LCD_TEST_PATTERN
+	#define LCD_BPP					LCD_MONOCHROME
+
+	#define CONFIG_WAVEFORM_BUF_SIZE		0x200000
+#endif
+#endif /* CONFIG_SPLASH_SCREEN */
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6slevkandroid.h"
+#endif
+
 #endif				/* __CONFIG_H */
diff -urN u-boot-2016.03/include/configs/mx6sll_arm2.h ebf_6ull_uboot/include/configs/mx6sll_arm2.h
--- u-boot-2016.03/include/configs/mx6sll_arm2.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6sll_arm2.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,267 @@
+/*
+ * Copyright 2013-2016 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6SL EVK board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#undef CONFIG_CMD_SET
+
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+/* MMC Configs */
+#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC1_BASE_ADDR
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#define CONFIG_SYS_MMC_ENV_DEV		0   /* USDHC1 */
+
+/* I2C Configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_SPEED		  100000
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE100
+#define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.file=/fat g_mass_storage.ro=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"epdc_waveform=epdc_splash.bin\0" \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=imx6sll-lpddr3-arm2.dtb\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=1\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"netboot=echo Booting from net ...; " \
+		"usb start; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+
+/* Miscellaneous configurable options */
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + SZ_128M)
+
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+#ifdef CONFIG_LPDDR2
+#define PHYS_SDRAM_SIZE			SZ_1G
+#else
+#define PHYS_SDRAM_SIZE			SZ_2G
+#endif
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* Environment organization */
+#define CONFIG_ENV_SIZE			SZ_8K
+#define CONFIG_SYS_MMC_ENV_PART		0   /* user partition */
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"  /* USDHC1 */
+
+#ifdef CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#else
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_VIDEO
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#endif
+
+/* Network */
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#ifdef CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC		(PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS		0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
+#endif
+
+#define CONFIG_IMX_THERMAL
+
+#define CONFIG_IOMUX_LPSR
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#define CONFIG_SF_DEFAULT_CS   0
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VIDEO_MXS
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_SW_CURSOR
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_CMD_BMP
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IMX_VIDEO_SKIP
+#endif
+
+
+/*#define CONFIG_MXC_EPDC  1*/
+
+/*
+ * EPDC SPLASH SCREEN Configs
+ */
+#ifdef CONFIG_MXC_EPDC
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_SPLASH_SCREEN
+	#define CONFIG_CMD_BMP
+	#define CONFIG_LCD
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#ifdef CONFIG_MXC_EPDC
+	#undef LCD_TEST_PATTERN
+	#define LCD_BPP					LCD_MONOCHROME
+
+	#define CONFIG_WAVEFORM_BUF_SIZE		0x200000
+#endif
+#endif /* CONFIG_SPLASH_SCREEN */
+
+#endif				/* __CONFIG_H */
diff -urN u-boot-2016.03/include/configs/mx6sllevk.h ebf_6ull_uboot/include/configs/mx6sllevk.h
--- u-boot-2016.03/include/configs/mx6sllevk.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6sllevk.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,235 @@
+/*
+ * Copyright 2013-2016 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6SL EVK board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+/* MMC Configs */
+#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC1_BASE_ADDR
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#define CONFIG_SYS_MMC_ENV_DEV		0   /* USDHC1 */
+
+/* I2C Configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_SPEED		  100000
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE100
+#define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.file=/fat g_mass_storage.ro=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"epdc_waveform=epdc_splash.bin\0" \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=imx6sll-evk.dtb\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=1\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"netboot=echo Booting from net ...; " \
+		"usb start; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+
+/* Miscellaneous configurable options */
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + SZ_128M)
+
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+#define PHYS_SDRAM_SIZE			SZ_2G
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* Environment organization */
+#define CONFIG_ENV_SIZE			SZ_8K
+#define CONFIG_SYS_MMC_ENV_PART		0   /* user partition */
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"  /* USDHC1 */
+
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
+#define CONFIG_ENV_IS_IN_MMC
+
+/* Network */
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#ifdef CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC		(PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS		0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
+#endif
+
+#define CONFIG_IMX_THERMAL
+
+#define CONFIG_IOMUX_LPSR
+
+#define CONFIG_VIDEO
+#ifdef CONFIG_VIDEO
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VIDEO_MXS
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_SW_CURSOR
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_CMD_BMP
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IMX_VIDEO_SKIP
+#endif
+
+
+/*#define CONFIG_MXC_EPDC  1*/
+
+/*
+ * EPDC SPLASH SCREEN Configs
+ */
+#ifdef CONFIG_MXC_EPDC
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_SPLASH_SCREEN
+	#define CONFIG_CMD_BMP
+	#define CONFIG_LCD
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#ifdef CONFIG_MXC_EPDC
+	#undef LCD_TEST_PATTERN
+	#define LCD_BPP					LCD_MONOCHROME
+
+	#define CONFIG_WAVEFORM_BUF_SIZE		0x200000
+#endif
+#endif /* CONFIG_SPLASH_SCREEN */
+
+#endif				/* __CONFIG_H */
diff -urN u-boot-2016.03/include/configs/mx6sx_17x17_arm2.h ebf_6ull_uboot/include/configs/mx6sx_17x17_arm2.h
--- u-boot-2016.03/include/configs/mx6sx_17x17_arm2.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6sx_17x17_arm2.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6SX 17x17 ARM2 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6SX_17X17_ARM2_CONFIG_H
+#define __MX6SX_17X17_ARM2_CONFIG_H
+
+#include "mx6sx_arm2.h"
+
+#ifdef CONFIG_MX6SX_14x14
+#define CONFIG_DEFAULT_FDT_FILE		"imx6sx-14x14-arm2.dtb"
+#else
+#define CONFIG_DEFAULT_FDT_FILE		"imx6sx-17x17-arm2.dtb"
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR  /* Pin conflict between SPI-NOR and SD2 */
+#define CONFIG_SYS_FSL_USDHC_NUM    2
+#define CONFIG_SYS_MMC_ENV_DEV		0   /* USDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk2p2"  /* USDHC3 */
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM    3
+#define CONFIG_SYS_MMC_ENV_DEV		1   /* USDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk2p2"  /* USDHC3 */
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+#undef CONFIG_SYS_FLASH_SECT_SIZE
+#undef CONFIG_SYS_MAX_FLASH_SECT
+#define CONFIG_SYS_FLASH_SECT_SIZE	(256 * 1024)
+#define CONFIG_SYS_MAX_FLASH_SECT 512   /* max number of sectors on one chip */
+#define CONFIG_SYS_FLASH_PROTECTION
+#endif
+
+#endif
diff -urN u-boot-2016.03/include/configs/mx6sx_19x19_arm2.h ebf_6ull_uboot/include/configs/mx6sx_19x19_arm2.h
--- u-boot-2016.03/include/configs/mx6sx_19x19_arm2.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6sx_19x19_arm2.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6SX 19x19 ARM2 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6SX_19X19_ARM2_CONFIG_H
+#define __MX6SX_19X19_ARM2_CONFIG_H
+
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_GIS
+
+#include "mx6sx_arm2.h"
+
+#define CONFIG_DEFAULT_FDT_FILE		"imx6sx-19x19-arm2.dtb"
+#define CONFIG_SYS_FSL_USDHC_NUM    1
+#define CONFIG_SYS_MMC_ENV_DEV		0   /* USDHC1 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"  /* USDHC1 */
+
+#endif
diff -urN u-boot-2016.03/include/configs/mx6sx_arm2.h ebf_6ull_uboot/include/configs/mx6sx_arm2.h
--- u-boot-2016.03/include/configs/mx6sx_arm2.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6sx_arm2.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,374 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6SX ARM2 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6SX_ARM2_CONFIG_H
+#define __MX6SX_ARM2_CONFIG_H
+
+#include <asm/arch/imx-regs.h>
+#include <linux/sizes.h>
+#include "mx6_common.h"
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_DBG_MONITOR
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(32 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+
+#define CONFIG_IMX_THERMAL
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+/* MMC Configs */
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define CONFIG_ETHPRIME                 "FEC"
+#define CONFIG_FEC_MXC_PHYADDR          1
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ATHEROS
+
+/* I2C configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
+
+#define CONFIG_FEC_ENABLE_MAX7322
+/* MAX7322 */
+#ifdef CONFIG_FEC_ENABLE_MAX7322
+#define CONFIG_MAX7322_I2C_ADDR		0x68
+#define CONFIG_MAX7322_I2C_BUS		1
+#endif
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE100
+#define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
+
+#define CONFIG_SYS_AUXCORE_BOOTDATA 0x78000000 /* Set to QSPI2 B flash at default */
+#define CONFIG_CMD_BOOTAUX /* Boot M4 */
+
+#ifdef CONFIG_CMD_BOOTAUX
+#define UPDATE_M4_ENV \
+	"m4image=m4_qspi.bin\0" \
+	"loadm4image=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${m4image}\0" \
+	"update_m4_from_sd=" \
+		"if sf probe 1:0; then " \
+			"if run loadm4image; then " \
+				"setexpr fw_sz ${filesize} + 0xffff; " \
+				"setexpr fw_sz ${fw_sz} / 0x10000; "	\
+				"setexpr fw_sz ${fw_sz} * 0x10000; "	\
+				"sf erase 0x0 ${fw_sz}; " \
+				"sf write ${loadaddr} 0x0 ${filesize}; " \
+			"fi; " \
+		"fi\0" \
+	"m4boot=sf probe 1:0; bootaux "__stringify(CONFIG_SYS_AUXCORE_BOOTDATA)"\0"
+#else
+#define UPDATE_M4_ENV ""
+#endif
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MODE \
+	"panel=Hannstar-XGA\0"
+#else
+#define CONFIG_VIDEO_MODE ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.file=/fat g_mass_storage.ro=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		CONFIG_MFG_NAND_PARTITION \
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"fdt_addr=0x83000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"console=ttymxc0\0" \
+	"bootargs=console=ttymxc0,115200 ubi.mtd=4 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	UPDATE_M4_ENV \
+	CONFIG_VIDEO_MODE \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+#endif
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x10000)
+
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+#define PHYS_SDRAM_SIZE			SZ_1G
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+#define CONFIG_ENV_SIZE			SZ_8K
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_FSL_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#elif defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_EIMNOR
+#define CONFIG_SYS_USE_EIMNOR
+#define CONFIG_ENV_IS_IN_FLASH
+#else
+#define CONFIG_FSL_QSPI   /* Enable the QSPI flash at default */
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+#define CONFIG_QSPI_BASE		QSPI1_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI1_AMBA_BASE
+
+#define CONFIG_CMD_SF
+#define	CONFIG_SPI_FLASH
+#define	CONFIG_SPI_FLASH_STMICRO
+#define	CONFIG_SPI_FLASH_BAR
+#define	CONFIG_SF_DEFAULT_BUS		0
+#define	CONFIG_SF_DEFAULT_CS		0
+#define	CONFIG_SF_DEFAULT_SPEED		40000000
+#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  3
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#define CONFIG_SF_DEFAULT_CS   0
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+#undef CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
+#define CONFIG_SYS_FLASH_SECT_SIZE	(128 * 1024)
+#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT 256   /* max number of sectors on one chip */
+#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
+#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(60 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#elif defined(CONFIG_ENV_IS_IN_FLASH)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_SIZE			CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE		CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_OFFSET		(6 * CONFIG_SYS_FLASH_SECT_SIZE)
+#endif
+
+#define CONFIG_CMD_BMODE
+
+#ifdef CONFIG_VIDEO
+#define	CONFIG_CFB_CONSOLE
+#define	CONFIG_VIDEO_MXS
+#define	CONFIG_VIDEO_LOGO
+#define	CONFIG_VIDEO_SW_CURSOR
+#define	CONFIG_VGA_AS_SINGLE_DEVICE
+#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define	CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define	CONFIG_CMD_BMP
+#define	CONFIG_BMP_16BPP
+#define	CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#ifdef CONFIG_VIDEO_GIS
+#define CONFIG_VIDEO_CSI
+#define CONFIG_VIDEO_PXP
+#define CONFIG_VIDEO_VADC
+#define CONFIG_IMX_VIDEO_SKIP
+#endif
+#endif
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+/*Only enable OTG1, the OTG2 has pin conflicts with PWM and WDOG*/
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1
+
+#endif				/* __CONFIG_H */
diff -urN u-boot-2016.03/include/configs/mx6sxsabreautoandroid.h ebf_6ull_uboot/include/configs/mx6sxsabreautoandroid.h
--- u-boot-2016.03/include/configs/mx6sxsabreautoandroid.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6sxsabreautoandroid.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,65 @@
+
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6SX_SABREAUTO_ANDROID_H
+#define __MX6SX_SABREAUTO_ANDROID_H
+
+#define CONFIG_CI_UDC
+#define CONFIG_USBD_HS
+#define CONFIG_USB_GADGET_DUALSPEED
+
+#define CONFIG_USB_GADGET
+#define CONFIG_CMD_USB_MASS_STORAGE
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_USB_GADGET_VBUS_DRAW	2
+
+#define CONFIG_G_DNL_VENDOR_NUM		0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM	0x0d02
+#define CONFIG_G_DNL_MANUFACTURER	"FSL"
+
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_CMD_FASTBOOT
+#define CONFIG_ANDROID_BOOT_IMAGE
+#define CONFIG_FASTBOOT_FLASH
+
+#define CONFIG_FSL_FASTBOOT
+#define CONFIG_ANDROID_RECOVERY
+
+#if defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_FASTBOOT_STORAGE_NAND
+#else
+#define CONFIG_FASTBOOT_STORAGE_MMC
+#endif
+
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+#define ANDROID_FASTBOOT_NAND_PARTS "16m@64m(boot) 16m@80m(recovery) 810m@96m(android_root)ubifs"
+#endif
+
+#define CONFIG_ANDROID_MAIN_MMC_BUS 2
+#define CONFIG_ANDROID_BOOT_PARTITION_MMC 1
+#define CONFIG_ANDROID_SYSTEM_PARTITION_MMC 5
+#define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
+#define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
+#define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+
+#define CONFIG_CMD_BOOTA
+#define CONFIG_SUPPORT_RAW_INITRD
+#define CONFIG_SERIAL_TAG
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"splashpos=m,m\0"	  \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+
+#define CONFIG_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#define CONFIG_FASTBOOT_BUF_SIZE   0x19000000
+
+#endif
diff -urN u-boot-2016.03/include/configs/mx6sxsabreauto.h ebf_6ull_uboot/include/configs/mx6sxsabreauto.h
--- u-boot-2016.03/include/configs/mx6sxsabreauto.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6sxsabreauto.h	2021-04-16 14:42:17.808596912 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Freescale Semiconductor, Inc.
+ * Copyright 2014-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6SX Sabreauto board.
  *
@@ -12,9 +12,22 @@
 
 #include "mx6_common.h"
 
+#define CONFIG_DBG_MONITOR
+
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
 
 /* Size of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		(3 * SZ_1M)
+#define CONFIG_SYS_MALLOC_LEN		(32 * SZ_1M)
 
 #define CONFIG_BOARD_EARLY_INIT_F
 #define CONFIG_BOARD_LATE_INIT
@@ -22,19 +35,79 @@
 #define CONFIG_MXC_UART
 #define CONFIG_MXC_UART_BASE		UART1_BASE
 
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#define CONFIG_SYS_AUXCORE_BOOTDATA 0x68000000 /* Set to QSPI1 B flash at default */
+#define CONFIG_IMX_BOOTAUX
+
+#ifdef CONFIG_IMX_BOOTAUX
+#define UPDATE_M4_ENV \
+	"m4image=m4_qspi.bin\0" \
+	"loadm4image=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${m4image}\0" \
+	"update_m4_from_sd=" \
+		"if sf probe 1:0; then " \
+			"if run loadm4image; then " \
+				"setexpr fw_sz ${filesize} + 0xffff; " \
+				"setexpr fw_sz ${fw_sz} / 0x10000; "	\
+				"setexpr fw_sz ${fw_sz} * 0x10000; "	\
+				"sf erase 0x0 ${fw_sz}; " \
+				"sf write ${loadaddr} 0x0 ${filesize}; " \
+			"fi; " \
+		"fi\0" \
+	"m4boot=sf probe 1:0; bootaux "__stringify(CONFIG_SYS_AUXCORE_BOOTDATA)"\0"
+#else
+#define UPDATE_M4_ENV ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.file=/fat g_mass_storage.ro=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		CONFIG_MFG_NAND_PARTITION \
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
 #define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"panel=Hannstar-XGA\0" \
+	"fdt_addr=0x83000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"console=ttymxc0\0" \
+	"bootargs=console=ttymxc0,115200 ubi.mtd=6 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	UPDATE_M4_ENV \
+	CONFIG_MFG_ENV_SETTINGS \
 	"script=boot.scr\0" \
 	"image=zImage\0" \
 	"console=ttymxc0\0" \
 	"fdt_high=0xffffffff\0" \
 	"initrd_high=0xffffffff\0" \
 	"fdt_file=imx6sx-sabreauto.dtb\0" \
-	"fdt_addr=0x88000000\0" \
+	"fdt_addr=0x83000000\0" \
 	"boot_fdt=try\0" \
 	"ip_dyn=yes\0" \
-	"mmcdev=0\0" \
+	"panel=Hannstar-XGA\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
 	"mmcpart=1\0" \
-	"mmcroot=/dev/mmcblk0p2 rootwait rw\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
 	"mmcargs=setenv bootargs console=${console},${baudrate} " \
 		"root=${mmcroot}\0" \
 	"loadbootscript=" \
@@ -95,8 +168,10 @@
 			   "fi; " \
 		   "fi; " \
 	   "else run netboot; fi"
+#endif
 
 /* Miscellaneous configurable options */
+#define CONFIG_CMD_MEMTEST
 #define CONFIG_SYS_MEMTEST_START	0x80000000
 #define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x10000)
 
@@ -116,8 +191,36 @@
 #define CONFIG_SYS_INIT_SP_ADDR \
 	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
 
+#if defined CONFIG_SYS_BOOT_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+#define CONFIG_FSL_QSPI   /* Enable the QSPI flash at default */
+#define CONFIG_SYS_USE_NAND  /* Enable the NAND flash at default */
+
+#ifdef CONFIG_FSL_QSPI
+#define CONFIG_QSPI_BASE		QSPI0_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI0_AMBA_BASE
+
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_BAR
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_SF_DEFAULT_BUS		0
+#define CONFIG_SF_DEFAULT_CS		0
+#define CONFIG_SF_DEFAULT_SPEED	40000000
+#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
 /* MMC Configuration */
+#define CONFIG_SYS_FSL_USDHC_NUM	2
 #define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC3_BASE_ADDR
+#define CONFIG_SYS_MMC_ENV_DEV		0  /*USDHC3*/
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk2p2"  /* USDHC3 */
 
 /* I2C Configs */
 #define CONFIG_CMD_I2C
@@ -134,6 +237,7 @@
 #define CONFIG_POWER_PFUZE100
 #define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
 
+#ifdef CONFIG_SYS_USE_NAND
 /* NAND flash command */
 #define CONFIG_CMD_NAND
 #define CONFIG_CMD_NAND_TRIMFFS
@@ -149,6 +253,7 @@
 #define CONFIG_APBH_DMA
 #define CONFIG_APBH_DMA_BURST
 #define CONFIG_APBH_DMA_BURST8
+#endif
 
 /* Network */
 #define CONFIG_CMD_PING
@@ -158,8 +263,15 @@
 #define CONFIG_FEC_MXC
 #define CONFIG_MII
 
+#define CONFIG_FEC_ENET_DEV 1  /* Use onboard ethernet as default */
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x0
+#elif (CONFIG_FEC_ENET_DEV == 1)
 #define IMX_FEC_BASE			ENET2_BASE_ADDR
 #define CONFIG_FEC_MXC_PHYADDR          0x0
+#endif
 
 #define CONFIG_FEC_XCV_TYPE             RGMII
 #define CONFIG_ETHPRIME                 "FEC"
@@ -185,28 +297,54 @@
 
 #define CONFIG_CMD_TIME
 
-#define CONFIG_FSL_QSPI
-#ifdef CONFIG_FSL_QSPI
-#define CONFIG_CMD_SF
-#define CONFIG_SYS_FSL_QSPI_AHB
-#define CONFIG_SF_DEFAULT_BUS		0
-#define CONFIG_SF_DEFAULT_CS		0
-#define CONFIG_SF_DEFAULT_SPEED	40000000
-#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
-#define FSL_QSPI_FLASH_SIZE		SZ_32M
-#define FSL_QSPI_FLASH_NUM		2
-#endif
-
-#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
 #define CONFIG_ENV_SIZE			SZ_8K
-#define CONFIG_ENV_IS_IN_MMC
-
-#define CONFIG_SYS_FSL_USDHC_NUM	2
 #if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_SYS_MMC_ENV_DEV		0  /*USDHC3*/
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(60 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
 #endif
 
+
 #define CONFIG_PCA953X
 #define CONFIG_SYS_I2C_PCA953X_WIDTH	{ {0x30, 8}, {0x32, 8}, {0x34, 8} }
 
+#define CONFIG_CMD_BMODE
+
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_GIS
+#ifdef CONFIG_VIDEO
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VIDEO_MXS
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_SW_CURSOR
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_CMD_BMP
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IMX_VIDEO_SKIP
+#ifdef CONFIG_VIDEO_GIS
+#define CONFIG_VIDEO_CSI
+#define CONFIG_VIDEO_PXP
+#define CONFIG_VIDEO_VADC
+#endif
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6sxsabreautoandroid.h"
+#endif
+
 #endif				/* __CONFIG_H */
diff -urN u-boot-2016.03/include/configs/mx6sxsabresdandroid.h ebf_6ull_uboot/include/configs/mx6sxsabresdandroid.h
--- u-boot-2016.03/include/configs/mx6sxsabresdandroid.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6sxsabresdandroid.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,58 @@
+
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6SX_SABRESD_ANDROID_H
+#define __MX6SX_SABRESD_ANDROID_H
+
+#define CONFIG_CI_UDC
+#define CONFIG_USBD_HS
+#define CONFIG_USB_GADGET_DUALSPEED
+
+#define CONFIG_USB_GADGET
+#define CONFIG_CMD_USB_MASS_STORAGE
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_USB_GADGET_VBUS_DRAW	2
+
+#define CONFIG_G_DNL_VENDOR_NUM		0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM	0x0d02
+#define CONFIG_G_DNL_MANUFACTURER	"FSL"
+
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_CMD_FASTBOOT
+#define CONFIG_ANDROID_BOOT_IMAGE
+#define CONFIG_FASTBOOT_FLASH
+
+#define CONFIG_FSL_FASTBOOT
+#define CONFIG_ANDROID_RECOVERY
+
+#define CONFIG_FASTBOOT_STORAGE_MMC
+
+#define CONFIG_ANDROID_MAIN_MMC_BUS 2
+#define CONFIG_ANDROID_BOOT_PARTITION_MMC 1
+#define CONFIG_ANDROID_SYSTEM_PARTITION_MMC 5
+#define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
+#define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
+#define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+
+#define CONFIG_CMD_BOOTA
+#define CONFIG_SUPPORT_RAW_INITRD
+#define CONFIG_SERIAL_TAG
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"splashpos=m,m\0"	  \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+
+#define CONFIG_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#define CONFIG_FASTBOOT_BUF_SIZE   0x19000000
+
+
+#endif
diff -urN u-boot-2016.03/include/configs/mx6sxsabresd.h ebf_6ull_uboot/include/configs/mx6sxsabresd.h
--- u-boot-2016.03/include/configs/mx6sxsabresd.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6sxsabresd.h	2021-04-16 14:42:17.808596912 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Freescale Semiconductor, Inc.
+ * Copyright 2014-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6SX Sabresd board.
  *
@@ -12,25 +12,40 @@
 
 #include "mx6_common.h"
 
+#define CONFIG_DBG_MONITOR
+
 #ifdef CONFIG_SPL
 #define CONFIG_SPL_LIBCOMMON_SUPPORT
 #define CONFIG_SPL_MMC_SUPPORT
 #include "imx6_spl.h"
 #endif
 
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
 /* Size of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		(3 * SZ_1M)
+#define CONFIG_SYS_MALLOC_LEN		(32 * SZ_1M)
 
 #define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
 
 #define CONFIG_MXC_UART
 #define CONFIG_MXC_UART_BASE		UART1_BASE
 
-#ifdef CONFIG_IMX_BOOTAUX
-/* Set to QSPI2 B flash at default */
-#define CONFIG_SYS_AUXCORE_BOOTDATA 0x78000000
-#define CONFIG_CMD_SETEXPR
+#define CONFIG_SYS_AUXCORE_BOOTDATA 0x78000000 /* Set to QSPI2 B flash at default */
+#define CONFIG_IMX_BOOTAUX
 
+/* When using M4 fastup demo, no need these M4 env, since QSPI is used by M4 */
+#ifndef CONFIG_SYS_AUXCORE_FASTUP
 #define UPDATE_M4_ENV \
 	"m4image=m4_qspi.bin\0" \
 	"loadm4image=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${m4image}\0" \
@@ -49,7 +64,20 @@
 #define UPDATE_M4_ENV ""
 #endif
 
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.file=/fat g_mass_storage.ro=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
 #define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
 	UPDATE_M4_ENV \
 	"script=boot.scr\0" \
 	"image=zImage\0" \
@@ -57,13 +85,14 @@
 	"fdt_high=0xffffffff\0" \
 	"initrd_high=0xffffffff\0" \
 	"fdt_file=imx6sx-sdb.dtb\0" \
-	"fdt_addr=0x88000000\0" \
+	"fdt_addr=0x83000000\0" \
 	"boot_fdt=try\0" \
 	"ip_dyn=yes\0" \
-	"videomode=video=ctfb:x:800,y:480,depth:24,pclk:29850,le:89,ri:164,up:23,lo:10,hs:10,vs:10,sync:0,vmode:0\0" \
-	"mmcdev=2\0" \
+	"panel=Hannstar-XGA\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
 	"mmcpart=1\0" \
-	"mmcroot=/dev/mmcblk0p2 rootwait rw\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
 	"mmcargs=setenv bootargs console=${console},${baudrate} " \
 		"root=${mmcroot}\0" \
 	"loadbootscript=" \
@@ -126,6 +155,7 @@
 	   "else run netboot; fi"
 
 /* Miscellaneous configurable options */
+#define CONFIG_CMD_MEMTEST
 #define CONFIG_SYS_MEMTEST_START	0x80000000
 #define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x10000)
 
@@ -145,7 +175,38 @@
 #define CONFIG_SYS_INIT_SP_ADDR \
 	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
 
+#ifdef CONFIG_SYS_AUXCORE_FASTUP
+/* #define CONFIG_IMX_RDC */   /* Disable the RDC temporarily, will enable it in future */
+#define CONFIG_ENV_IS_IN_MMC  /* Must disable QSPI driver, because M4 run on QSPI */
+#elif defined CONFIG_SYS_BOOT_QSPI
+#define CONFIG_FSL_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#else
+#define CONFIG_FSL_QSPI   /* Enable the QSPI flash at default */
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+#define CONFIG_QSPI_BASE		QSPI1_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI1_AMBA_BASE
+
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_BAR
+#define CONFIG_SPI_FLASH_SPANSION
+#define CONFIG_SPI_FLASH_STMICRO
+#define	CONFIG_SF_DEFAULT_BUS		0
+#define	CONFIG_SF_DEFAULT_CS		0
+#define	CONFIG_SF_DEFAULT_SPEED		40000000
+#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
 /* MMC Configuration */
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#define CONFIG_SYS_MMC_ENV_DEV		2  /*USDHC4*/
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk3p2"  /* USDHC4 */
+
 #define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC4_BASE_ADDR
 
 /* I2C Configs */
@@ -170,8 +231,15 @@
 #define CONFIG_FEC_MXC
 #define CONFIG_MII
 
+#define CONFIG_FEC_ENET_DEV 0
+
+#if (CONFIG_FEC_ENET_DEV == 0)
 #define IMX_FEC_BASE			ENET_BASE_ADDR
 #define CONFIG_FEC_MXC_PHYADDR          0x1
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x2
+#endif
 
 #define CONFIG_FEC_XCV_TYPE             RGMII
 #define CONFIG_ETHPRIME                 "FEC"
@@ -193,7 +261,17 @@
 #define CONFIG_USB_MAX_CONTROLLER_COUNT 2
 #endif
 
-#define CONFIG_CMD_PCI
+/*
+ * The PCIe support in uboot would bring failures in i.MX6SX PCIe
+ * EP/RC validations. Disable PCIe support in uboot here.
+ * RootCause: The bit10(ltssm_en) of GPR12 would be set in uboot,
+ * thus the i.MX6SX PCIe EP would be cheated that the other i.MX6SX
+ * PCIe RC had been configured and trying to setup PCIe link directly,
+ * although the i.MX6SX RC is not properly configured at that time.
+ * PCIe can be supported in uboot, if the i.MX6SX PCIe EP/RC validation
+ * is not running.
+ */
+/* #define CONFIG_CMD_PCI */
 #ifdef CONFIG_CMD_PCI
 #define CONFIG_PCI
 #define CONFIG_PCI_PNP
@@ -207,18 +285,7 @@
 
 #define CONFIG_CMD_TIME
 
-
-#ifdef CONFIG_FSL_QSPI
-#define CONFIG_CMD_SF
-#define CONFIG_SYS_FSL_QSPI_LE
-#define CONFIG_SYS_FSL_QSPI_AHB
-#ifdef CONFIG_MX6SX_SABRESD_REVA
-#define FSL_QSPI_FLASH_SIZE		SZ_16M
-#else
-#define FSL_QSPI_FLASH_SIZE		SZ_32M
-#endif
-#define FSL_QSPI_FLASH_NUM		2
-#endif
+#define CONFIG_CMD_BMODE
 
 #ifndef CONFIG_SPL_BUILD
 #define CONFIG_VIDEO
@@ -235,17 +302,26 @@
 #define CONFIG_BMP_16BPP
 #define CONFIG_VIDEO_BMP_RLE8
 #define CONFIG_VIDEO_BMP_LOGO
-#define MXS_LCDIF_BASE MX6SX_LCDIF1_BASE_ADDR
+#define CONFIG_IMX_VIDEO_SKIP
 #endif
 #endif
 
-#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
 #define CONFIG_ENV_SIZE			SZ_8K
-#define CONFIG_ENV_IS_IN_MMC
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#endif
 
 #define CONFIG_SYS_FSL_USDHC_NUM	3
-#if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_SYS_MMC_ENV_DEV		2  /*USDHC4*/
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6sxsabresdandroid.h"
 #endif
 
 #endif				/* __CONFIG_H */
diff -urN u-boot-2016.03/include/configs/mx6sxscm.h ebf_6ull_uboot/include/configs/mx6sxscm.h
--- u-boot-2016.03/include/configs/mx6sxscm.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6sxscm.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2016 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6SXSCM EVB board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+
+#ifndef __MX6SXSCM_H
+#define __MX6SXSCM_H
+
+#include "mx6sxsabresd.h"
+
+#undef CONFIG_MXC_UART_BASE
+#define CONFIG_MXC_UART_BASE		UART3_BASE
+
+#undef CONFIG_PHY_ATHEROS
+#undef CONFIG_FEC_MXC_PHYADDR
+#define CONFIG_PHY_MICREL
+#define CONFIG_FEC_MXC_PHYADDR          3
+
+/* MMC Configuration */
+/*
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC4_BASE_ADDR
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+*/
+#ifdef CONFIG_512MB_LPDDR2
+#undef PHYS_SDRAM_SIZE
+#define PHYS_SDRAM_SIZE		SZ_512M
+#endif
+
+#if defined CONFIG_512MB_LPDDR2 && defined CONFIG_MX6SXSCM_EMMC
+#define CONFIG_FDT_FILE		"imx6sxscm-epop-evb-ldo.dtb"
+#else
+#define CONFIG_FDT_FILE		"imx6sxscm-1gb-evb-ldo.dtb"
+#endif
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	UPDATE_M4_ENV \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc2\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file="CONFIG_FDT_FILE"\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"panel=Hannstar-XGA\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=1\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+#endif				/* __MX6SXSCM_H */
+
diff -urN u-boot-2016.03/include/configs/mx6ul_14x14_ddr3_arm2.h ebf_6ull_uboot/include/configs/mx6ul_14x14_ddr3_arm2.h
--- u-boot-2016.03/include/configs/mx6ul_14x14_ddr3_arm2.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6ul_14x14_ddr3_arm2.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6UL 14x14 DDR3 ARM2.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __MX6UL_14X14_DDR3_ARM2_CONFIG_H
+#define __MX6UL_14X14_DDR3_ARM2_CONFIG_H
+
+#define CONFIG_DEFAULT_FDT_FILE  "imx6ul-14x14-ddr3-arm2.dtb"
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_EIMNOR
+#define CONFIG_SYS_USE_EIMNOR
+#define CONFIG_ENV_IS_IN_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#define CONFIG_VIDEO
+#define CONFIG_BOOTARGS_CMA_SIZE   ""
+
+#include "mx6ul_arm2.h"
+
+#define PHYS_SDRAM_SIZE			SZ_1G
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#define CONFIG_SF_DEFAULT_CS   0
+#endif
+
+#ifdef CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_ENET_DEV 1
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x1
+#define CONFIG_FEC_XCV_TYPE             RMII
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x2
+#define CONFIG_FEC_XCV_TYPE             MII100
+#endif
+#define CONFIG_ETHPRIME                 "FEC"
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+#endif
+
+#define CONFIG_MODULE_FUSE
+#define CONFIG_OF_SYSTEM_SETUP
+#endif
diff -urN u-boot-2016.03/include/configs/mx6ul_14x14_evk_android.h ebf_6ull_uboot/include/configs/mx6ul_14x14_evk_android.h
--- u-boot-2016.03/include/configs/mx6ul_14x14_evk_android.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6ul_14x14_evk_android.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,65 @@
+
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6UL_EVK_ANDROID_H
+#define __MX6UL_EVK_ANDROID_H
+
+#define CONFIG_CI_UDC
+#define CONFIG_USBD_HS
+#define CONFIG_USB_GADGET_DUALSPEED
+
+#define CONFIG_USB_GADGET
+#define CONFIG_CMD_USB_MASS_STORAGE
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_USB_GADGET_VBUS_DRAW	2
+
+#define CONFIG_G_DNL_VENDOR_NUM		0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM	0x0d02
+#define CONFIG_G_DNL_MANUFACTURER	"FSL"
+
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_CMD_FASTBOOT
+#define CONFIG_ANDROID_BOOT_IMAGE
+#define CONFIG_FASTBOOT_FLASH
+
+#define CONFIG_FSL_FASTBOOT
+#define CONFIG_ANDROID_RECOVERY
+
+#if defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_FASTBOOT_STORAGE_NAND
+#else
+#define CONFIG_FASTBOOT_STORAGE_MMC
+#endif
+
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+#define ANDROID_FASTBOOT_NAND_PARTS "16m@64m(boot) 16m@80m(recovery) 810m@96m(android_root)ubifs"
+#endif
+
+#define CONFIG_ANDROID_MAIN_MMC_BUS 2
+#define CONFIG_ANDROID_BOOT_PARTITION_MMC 1
+#define CONFIG_ANDROID_SYSTEM_PARTITION_MMC 5
+#define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
+#define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
+#define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+
+#define CONFIG_CMD_BOOTA
+#define CONFIG_SUPPORT_RAW_INITRD
+#define CONFIG_SERIAL_TAG
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"splashpos=m,m\0"	  \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+
+#define CONFIG_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#define CONFIG_FASTBOOT_BUF_SIZE   0x19000000
+
+#endif
diff -urN u-boot-2016.03/include/configs/mx6ul_14x14_evk.h ebf_6ull_uboot/include/configs/mx6ul_14x14_evk.h
--- u-boot-2016.03/include/configs/mx6ul_14x14_evk.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6ul_14x14_evk.h	2021-04-16 14:42:17.808596912 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6UL 14x14 EVK board.
  *
@@ -14,12 +14,39 @@
 #include "mx6_common.h"
 #include <asm/imx-common/gpio.h>
 
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+/* uncomment for BEE support, needs to enable CONFIG_CMD_FUSE */
+/* #define CONFIG_CMD_BEE */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
 #define is_mx6ul_9x9_evk()	CONFIG_IS_ENABLED(TARGET_MX6UL_9X9_EVK)
 
+#ifdef CONFIG_TARGET_MX6UL_9X9_EVK
+#define PHYS_SDRAM_SIZE		SZ_256M
+#define CONFIG_BOOTARGS_CMA_SIZE   "cma=96M "
+#else
+#define PHYS_SDRAM_SIZE		SZ_512M
+#define CONFIG_BOOTARGS_CMA_SIZE   ""
+/* DCDC used on 14x14 EVK, no PMIC */
+#undef CONFIG_LDO_BYPASS_CHECK
+#endif
+
 /* SPL options */
-#define CONFIG_SPL_LIBCOMMON_SUPPORT
-#define CONFIG_SPL_MMC_SUPPORT
-#include "imx6_spl.h"
+/* We default not support SPL
+ * #define CONFIG_SPL_LIBCOMMON_SUPPORT
+ * #define CONFIG_SPL_MMC_SUPPORT
+ * #include "imx6_spl.h"
+*/
 
 #define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
 
@@ -40,13 +67,11 @@
 #define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC2_BASE_ADDR
 
 /* NAND pin conflicts with usdhc2 */
-#ifdef CONFIG_NAND_MXS
+#ifdef CONFIG_SYS_USE_NAND
 #define CONFIG_SYS_FSL_USDHC_NUM	1
 #else
 #define CONFIG_SYS_FSL_USDHC_NUM	2
 #endif
-
-#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
 #endif
 
 /* I2C configs */
@@ -67,7 +92,45 @@
 
 #define CONFIG_SYS_MMC_IMG_LOAD_PART	1
 
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+	    CONFIG_BOOTARGS_CMA_SIZE \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.file=/fat g_mass_storage.ro=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		CONFIG_MFG_NAND_PARTITION \
+		"clk_ignore_unused "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"panel=TFT43AB\0" \
+	"fdt_addr=0x83000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"console=ttymxc0\0" \
+	"bootargs=console=ttymxc0,115200 ubi.mtd=4 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		CONFIG_BOOTARGS_CMA_SIZE \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#else
 #define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
 	"script=boot.scr\0" \
 	"image=zImage\0" \
 	"console=ttymxc0\0" \
@@ -77,12 +140,13 @@
 	"fdt_addr=0x83000000\0" \
 	"boot_fdt=try\0" \
 	"ip_dyn=yes\0" \
-	"videomode=video=ctfb:x:480,y:272,depth:24,pclk:108695,le:8,ri:4,up:2,lo:4,hs:41,vs:10,sync:0,vmode:0\0" \
+	"panel=TFT43AB\0" \
 	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
 	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
 	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
 	"mmcautodetect=yes\0" \
 	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		CONFIG_BOOTARGS_CMA_SIZE \
 		"root=${mmcroot}\0" \
 	"loadbootscript=" \
 		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
@@ -106,6 +170,7 @@
 			"bootz; " \
 		"fi;\0" \
 	"netargs=setenv bootargs console=${console},${baudrate} " \
+		CONFIG_BOOTARGS_CMA_SIZE \
 		"root=/dev/nfs " \
 	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
 		"netboot=echo Booting from net ...; " \
@@ -152,6 +217,7 @@
 			   "fi; " \
 		   "fi; " \
 	   "else run netboot; fi"
+#endif
 
 /* Miscellaneous configurable options */
 #define CONFIG_CMD_MEMTEST
@@ -161,7 +227,6 @@
 #define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
 #define CONFIG_SYS_HZ			1000
 
-#define CONFIG_CMDLINE_EDITING
 #define CONFIG_STACKSIZE		SZ_128K
 
 /* Physical Memory Map */
@@ -180,23 +245,27 @@
 /* FLASH and environment organization */
 #define CONFIG_SYS_NO_FLASH
 
-#define CONFIG_ENV_SIZE			SZ_8K
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_FSL_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#define CONFIG_FSL_QSPI
 #define CONFIG_ENV_IS_IN_MMC
-#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#endif
+
 #define CONFIG_SYS_MMC_ENV_DEV		1   /* USDHC2 */
 #define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
 #define CONFIG_MMCROOT			"/dev/mmcblk1p2"  /* USDHC2 */
 
-#define CONFIG_OF_LIBFDT
-#define CONFIG_CMD_BOOTZ
 #define CONFIG_CMD_BMODE
 
-#ifndef CONFIG_SYS_DCACHE_OFF
-#define CONFIG_CMD_CACHE
-#endif
-
-#define CONFIG_FSL_QSPI
 #ifdef CONFIG_FSL_QSPI
+#define CONFIG_QSPI_BASE		QSPI0_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI0_AMBA_BASE
+
 #define CONFIG_CMD_SF
 #define CONFIG_SPI_FLASH
 #define CONFIG_SPI_FLASH_BAR
@@ -205,10 +274,43 @@
 #define CONFIG_SF_DEFAULT_SPEED	40000000
 #define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
 #define CONFIG_SPI_FLASH_STMICRO
-#define FSL_QSPI_FLASH_NUM		1
-#define FSL_QSPI_FLASH_SIZE		SZ_32M
 #endif
 
+/* NAND stuff */
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+#define CONFIG_ENV_SIZE			SZ_8K
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(60 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#endif
+
+
 /* USB Configs */
 #define CONFIG_CMD_USB
 #ifdef CONFIG_CMD_USB
@@ -216,6 +318,8 @@
 #define CONFIG_USB_EHCI_MX6
 #define CONFIG_USB_STORAGE
 #define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
 #define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
 #define CONFIG_MXC_USB_FLAGS   0
 #define CONFIG_USB_MAX_CONTROLLER_COUNT 2
@@ -258,8 +362,15 @@
 #define CONFIG_BMP_16BPP
 #define CONFIG_VIDEO_BMP_RLE8
 #define CONFIG_VIDEO_BMP_LOGO
-#define MXS_LCDIF_BASE MX6UL_LCDIF1_BASE_ADDR
+#define CONFIG_IMX_VIDEO_SKIP
+#endif
 #endif
+
+#define CONFIG_MODULE_FUSE
+#define CONFIG_OF_SYSTEM_SETUP
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6ul_14x14_evk_android.h"
 #endif
 
 #endif
diff -urN u-boot-2016.03/include/configs/mx6ul_14x14_lpddr2_arm2.h ebf_6ull_uboot/include/configs/mx6ul_14x14_lpddr2_arm2.h
--- u-boot-2016.03/include/configs/mx6ul_14x14_lpddr2_arm2.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6ul_14x14_lpddr2_arm2.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6UL 14x14 LPDDR2 ARM2.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __MX6UL_14X14_LPDDR2_ARM2_CONFIG_H
+#define __MX6UL_14X14_LPDDR2_ARM2_CONFIG_H
+
+#define CONFIG_DEFAULT_FDT_FILE  "imx6ul-14x14-lpddr2-arm2.dtb"
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_EIMNOR
+#define CONFIG_SYS_USE_EIMNOR
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_SYS_FLASH_PROTECTION
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#define CONFIG_VIDEO
+#ifdef CONFIG_SYS_BOOT_EIMNOR
+/*
+ * Conflicts with SD1/SD2/VIDEO/ENET
+ * ENET is keeped, since only RXER conflicts.
+ * If removed ENET, we can not boot kernel, since sd1/sd2 is disabled
+ * when support weimnor.
+ */
+#undef CONFIG_FSL_USDHC
+#undef CONFIG_VIDEO
+#endif
+
+#define CONFIG_BOOTARGS_CMA_SIZE   "cma=96M "
+
+#include "mx6ul_arm2.h"
+
+#define PHYS_SDRAM_SIZE			SZ_256M
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  1
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#define CONFIG_SF_DEFAULT_CS   0
+#endif
+
+#ifdef CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_ENET_DEV 1  /* The ENET1 has pin conflict with UART1 */
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x2
+#define CONFIG_FEC_XCV_TYPE             MII100
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x1
+#define CONFIG_FEC_XCV_TYPE             RMII
+#endif
+#define CONFIG_ETHPRIME                 "FEC"
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+#endif
+
+#endif
diff -urN u-boot-2016.03/include/configs/mx6ul_arm2.h ebf_6ull_uboot/include/configs/mx6ul_arm2.h
--- u-boot-2016.03/include/configs/mx6ul_arm2.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6ul_arm2.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,308 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6UL ARM2 common.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __MX6UL_ARM2_CONFIG_H
+#define __MX6UL_ARM2_CONFIG_H
+
+
+#include "mx6_common.h"
+
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+/* I2C configs */
+#define CONFIG_CMD_I2C
+#ifdef CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE100
+#define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
+#endif
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MODE \
+	"panel=MCIMX28LCD\0"
+#else
+#define CONFIG_VIDEO_MODE ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+	    CONFIG_BOOTARGS_CMA_SIZE \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.file=/fat g_mass_storage.ro=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		CONFIG_MFG_NAND_PARTITION \
+		"clk_ignore_unused "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"fdt_addr=0x83000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"console=ttymxc0\0" \
+	"bootargs=console=ttymxc0,115200 ubi.mtd=4 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		CONFIG_BOOTARGS_CMA_SIZE \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+	    CONFIG_BOOTARGS_CMA_SIZE \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+	    CONFIG_BOOTARGS_CMA_SIZE \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+#endif
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x20000000)
+
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+#define CONFIG_ENV_SIZE			SZ_8K
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+#undef CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
+#define CONFIG_SYS_FLASH_SECT_SIZE     (256 * 1024)
+#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT  512   /* max number of sectors on one chip */
+#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
+#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#endif
+
+#ifdef CONFIG_SYS_USE_QSPI
+#define CONFIG_FSL_QSPI    /* enable the QUADSPI driver */
+#define CONFIG_QSPI_BASE		QSPI0_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI0_AMBA_BASE
+
+#define CONFIG_CMD_SF
+#define	CONFIG_SPI_FLASH
+#define	CONFIG_SPI_FLASH_STMICRO
+#define	CONFIG_SPI_FLASH_BAR
+#define	CONFIG_SF_DEFAULT_BUS		0
+#define	CONFIG_SF_DEFAULT_CS		0
+#define	CONFIG_SF_DEFAULT_SPEED		40000000
+#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_FLASH)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_SIZE                        CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE           CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_OFFSET              (6 * CONFIG_SYS_FLASH_SECT_SIZE)
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(60 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#endif
+
+/* MMC Configs */
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#endif
+
+#define CONFIG_SYS_MMC_ENV_DEV		0   /* USDHC1 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"  /* USDHC1 */
+
+#define CONFIG_CMD_BMODE
+
+#ifdef CONFIG_VIDEO
+#define	CONFIG_CFB_CONSOLE
+#define	CONFIG_VIDEO_MXS
+#define	CONFIG_VIDEO_LOGO
+#define	CONFIG_VIDEO_SW_CURSOR
+#define	CONFIG_VGA_AS_SINGLE_DEVICE
+#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define	CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define	CONFIG_CMD_BMP
+#define	CONFIG_BMP_16BPP
+#define	CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IMX_VIDEO_SKIP
+#endif
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#ifdef CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1
+#endif
+
+#endif
diff -urN u-boot-2016.03/include/configs/mx6ull_ddr3_arm2.h ebf_6ull_uboot/include/configs/mx6ull_ddr3_arm2.h
--- u-boot-2016.03/include/configs/mx6ull_ddr3_arm2.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6ull_ddr3_arm2.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6UL 14x14 DDR3 ARM2.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __MX6ULL_DDR3_ARM2_CONFIG_H
+#define __MX6ULL_DDR3_ARM2_CONFIG_H
+
+#define CONFIG_DEFAULT_FDT_FILE  "imx6ull-14x14-ddr3-arm2.dtb"
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#ifndef CONFIG_MX6ULL_DDR3_ARM2_EMMC_REWORK
+#define CONFIG_SYS_USE_QSPI
+#endif
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#define CONFIG_VIDEO
+#define CONFIG_FSL_USDHC
+#define CONFIG_BOOTARGS_CMA_SIZE   ""
+
+#include "mx6ul_arm2.h"
+
+#define CONFIG_IOMUX_LPSR
+
+#define PHYS_SDRAM_SIZE			SZ_1G
+
+/*
+ * TSC pins conflict with I2C1 bus, so after TSC
+ * hardware rework, need to disable i2c1 bus, also
+ * need to disable PMIC and ldo bypass check.
+ */
+#ifdef CONFIG_MX6ULL_DDR3_ARM2_TSC_REWORK
+#undef CONFIG_LDO_BYPASS_CHECK
+#undef CONFIG_SYS_I2C_MXC
+#undef CONFIG_SYS_I2C
+#undef CONFIG_CMD_I2C
+#undef CONFIG_POWER_PFUZE100_I2C_ADDR
+#undef CONFIG_POWER_PFUZE100
+#undef CONFIG_POWER_I2C
+#undef CONFIG_POWER
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#define CONFIG_SF_DEFAULT_CS   0
+#endif
+
+#ifdef CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_ENET_DEV 1
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x1
+#define CONFIG_FEC_XCV_TYPE             RMII
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x2
+#define CONFIG_FEC_XCV_TYPE             MII100
+#endif
+#define CONFIG_ETHPRIME                 "FEC"
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+#define CONFIG_FEC_DMA_MINALIGN		64
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VIDEO_MXS
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_SW_CURSOR
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_CMD_BMP
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IMX_VIDEO_SKIP
+#endif
+
+/* #define CONFIG_SPLASH_SCREEN*/
+/* #define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+/*
+ * Framebuffer and LCD
+ */
+#define	CONFIG_CFB_CONSOLE
+#define CONFIG_CMD_BMP
+#define CONFIG_LCD
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+
+#undef LCD_TEST_PATTERN
+/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+#define LCD_BPP					LCD_MONOCHROME
+/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+#define CONFIG_WAVEFORM_BUF_SIZE		0x400000
+#endif
+
+#endif
diff -urN u-boot-2016.03/include/configs/mx6ullevk.h ebf_6ull_uboot/include/configs/mx6ullevk.h
--- u-boot-2016.03/include/configs/mx6ullevk.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx6ullevk.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,389 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6UL 14x14 EVK board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __MX6ULLEVK_CONFIG_H
+#define __MX6ULLEVK_CONFIG_H
+
+
+#include <asm/arch/imx-regs.h>
+#include <linux/sizes.h>
+#include "mx6_common.h"
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_ZERO_BOOTDELAY_CHECK  /* check for keypress on bootdelay==0 */
+#if 0
+#define CONFIG_AUTOBOOT_KEYED 1
+#define CONFIG_AUTOBOOT_PROMPT "Press enter to abort autoboot in %d seconds"
+#define CONFIG_AUTOBOOT_DELAY_STR "linux"
+#define CONFIG_AUTOBOOT_STOP_STR "\x0d"
+#endif
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
+#define is_mx6ull_9x9_evk()	CONFIG_IS_ENABLED(TARGET_MX6ULL_9X9_EVK)
+
+#ifdef CONFIG_TARGET_MX6ULL_9X9_EVK
+#define PHYS_SDRAM_SIZE		SZ_256M
+#define CONFIG_BOOTARGS_CMA_SIZE   "cma=96M "
+#else
+#define PHYS_SDRAM_SIZE		SZ_512M
+#define CONFIG_BOOTARGS_CMA_SIZE   ""
+/* DCDC used on 14x14 EVK, no PMIC */
+#undef CONFIG_LDO_BYPASS_CHECK
+#endif
+
+/* SPL options */
+/* We default not support SPL
+ * #define CONFIG_SPL_LIBCOMMON_SUPPORT
+ * #define CONFIG_SPL_MMC_SUPPORT
+ * #include "imx6_spl.h"
+*/
+
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+/* MMC Configs */
+#ifdef CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC2_BASE_ADDR
+
+/* NAND pin conflicts with usdhc2 */
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#endif
+#endif
+
+/* I2C configs */
+#define CONFIG_CMD_I2C
+#ifdef CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* PMIC only for 9X9 EVK */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE3000
+#define CONFIG_POWER_PFUZE3000_I2C_ADDR  0x08
+#endif
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+	    CONFIG_BOOTARGS_CMA_SIZE \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.file=/fat g_mass_storage.ro=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		CONFIG_MFG_NAND_PARTITION \
+		"clk_ignore_unused "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"panel=TFT50AB\0" \
+	"splashimage=0x82000000\0" \
+	"fdt_addr=0x83000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"console=ttymxc0\0" \
+	"bootargs=console=ttymxc0,115200 ubi.mtd=3 "  \
+		"root=ubi0:rootfs rw rootfstype=ubifs "		     \
+		CONFIG_BOOTARGS_CMA_SIZE \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"logo=logo.bmp\0" \
+	"splashimage=0x82000000\0" \
+	"splashpos=m,m\0" \
+	"fdt_file=undefined\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"panel=TFT50AB\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		CONFIG_BOOTARGS_CMA_SIZE \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		CONFIG_BOOTARGS_CMA_SIZE \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+		"findfdt="\
+			"if test $fdt_file = undefined; then " \
+				"if test $board_name = EVK && test $board_rev = 9X9; then " \
+					"setenv fdt_file imx6ull-9x9-evk.dtb; fi; " \
+				"if test $board_name = EVK && test $board_rev = 14X14; then " \
+					"setenv fdt_file imx6ull-14x14-evk.dtb; fi; " \
+				"if test $fdt_file = undefined; then " \
+					"echo WARNING: Could not determine dtb to use; fi; " \
+			"fi;\0" \
+		"logo_display="\
+			"fatload mmc ${mmcdev}:${mmcpart} ${splashimage} ${logo}" \
+
+#define CONFIG_BOOTCOMMAND \
+	   "run logo_display;" \
+	   "run findfdt;" \
+	   "mmc dev ${mmcdev};" \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+#endif
+
+/* Miscellaneous configurable options */
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x8000000)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_FSL_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#define CONFIG_FSL_QSPI
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#define CONFIG_SYS_MMC_ENV_DEV		1   /* USDHC2 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk1p2"  /* USDHC2 */
+
+#define CONFIG_CMD_BMODE
+
+#ifdef CONFIG_FSL_QSPI
+#define CONFIG_QSPI_BASE		QSPI0_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI0_AMBA_BASE
+
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_BAR
+#define CONFIG_SF_DEFAULT_BUS		0
+#define CONFIG_SF_DEFAULT_CS		0
+#define CONFIG_SF_DEFAULT_SPEED	40000000
+#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#define CONFIG_SPI_FLASH_STMICRO
+#endif
+
+/* NAND stuff */
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+#define CONFIG_ENV_SIZE			SZ_8K
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(60 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#endif
+
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#ifdef CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#endif
+
+#ifdef CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_ENET_DEV		1    /* 1->0 for net 0*/
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x2
+#define CONFIG_FEC_XCV_TYPE             RMII
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR		0x1
+#define CONFIG_FEC_XCV_TYPE		RMII
+#endif
+#define CONFIG_ETHPRIME			"FEC"
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+#endif
+
+#define CONFIG_IMX_THERMAL
+
+#ifndef CONFIG_SPL_BUILD
+/*#define CONFIG_VIDEO*/
+#ifdef CONFIG_VIDEO
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VIDEO_MXS
+/*#define CONFIG_VIDEO_LOGO*/
+#define CONFIG_VIDEO_SW_CURSOR
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_CMD_BMP
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IMX_VIDEO_SKIP
+#endif
+#endif
+
+#define CONFIG_IOMUX_LPSR
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6ullevk_android.h"
+#endif
+
+#endif
diff -urN u-boot-2016.03/include/configs/mx7_common.h ebf_6ull_uboot/include/configs/mx7_common.h
--- u-boot-2016.03/include/configs/mx7_common.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx7_common.h	2021-04-16 14:42:17.808596912 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX7.
  *
@@ -89,6 +89,7 @@
 #define CONFIG_BOUNCE_BUFFER
 #define CONFIG_FSL_ESDHC
 #define CONFIG_FSL_USDHC
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
 
 /* Fuses */
 #define CONFIG_CMD_FUSE
@@ -98,6 +99,7 @@
  * Default boot linux kernel in no secure mode.
  * If want to boot kernel in secure mode, please define CONFIG_MX7_SEC
  */
+#define CONFIG_MX7_SEC
 #ifndef CONFIG_MX7_SEC
 #define CONFIG_ARMV7_NONSEC
 #define CONFIG_ARMV7_PSCI
diff -urN u-boot-2016.03/include/configs/mx7d_12x12_ddr3_arm2.h ebf_6ull_uboot/include/configs/mx7d_12x12_ddr3_arm2.h
--- u-boot-2016.03/include/configs/mx7d_12x12_ddr3_arm2.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx7d_12x12_ddr3_arm2.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX7D 12x12 DDR3 ARM2 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX7D_12X12_DDR3_ARM2_CONFIG_H
+#define __MX7D_12X12_DDR3_ARM2_CONFIG_H
+
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_SYS_MMC_ENV_DEV		1	/* USDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk1p2"  /* USDHC3 */
+
+#define PHYS_SDRAM_SIZE			SZ_1G
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START        0x80000000
+#define CONFIG_SYS_MEMTEST_END          (CONFIG_SYS_MEMTEST_START + 0x20000000)
+
+#ifdef CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#else
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE3000
+#define CONFIG_POWER_PFUZE3000_I2C_ADDR	0x08
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_ATMEL
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  3
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#define CONFIG_SF_DEFAULT_CS   0
+#endif
+
+#include "mx7d_arm2.h"
+
+#endif
diff -urN u-boot-2016.03/include/configs/mx7d_12x12_lpddr3_arm2.h ebf_6ull_uboot/include/configs/mx7d_12x12_lpddr3_arm2.h
--- u-boot-2016.03/include/configs/mx7d_12x12_lpddr3_arm2.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx7d_12x12_lpddr3_arm2.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX7D 12x12 LPDDR3 ARM2 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX7D_12X12_LPDDR3_ARM2_CONFIG_H
+#define __MX7D_12X12_LPDDR3_ARM2_CONFIG_H
+
+#define CONFIG_SYS_FSL_USDHC_NUM    3
+#define CONFIG_SYS_MMC_ENV_DEV		0   /* USDHC1 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"  /* USDHC1 */
+
+#define PHYS_SDRAM_SIZE			SZ_2G
+
+#define CONFIG_CMD_MII
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define CONFIG_ETHPRIME                 "FEC"
+#define CONFIG_FEC_MXC_PHYADDR          1
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ATHEROS
+
+/* ENET1 */
+#define IMX_FEC_BASE			ENET_IPS_BASE_ADDR
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#else
+#define CONFIG_SYS_USE_QSPI   /* Enable the QSPI flash at default */
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE3000
+#define CONFIG_POWER_PFUZE3000_I2C_ADDR	0x08
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#define CONFIG_SF_DEFAULT_CS   0
+#endif
+
+#define CONFIG_VIDEO
+/* #define CONFIG_SPLASH_SCREEN*/
+/* #define CONFIG_MXC_EPDC*/
+
+#define CONFIG_USE_PLUGIN
+#include "mx7d_arm2.h"
+
+#endif
diff -urN u-boot-2016.03/include/configs/mx7d_19x19_ddr3_arm2.h ebf_6ull_uboot/include/configs/mx7d_19x19_ddr3_arm2.h
--- u-boot-2016.03/include/configs/mx7d_19x19_ddr3_arm2.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx7d_19x19_ddr3_arm2.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX7D 19x19 DDR3 ARM2 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX7D_19X19_DDR3_ARM2_CONFIG_H
+#define __MX7D_19X19_DDR3_ARM2_CONFIG_H
+
+#define CONFIG_SYS_FSL_USDHC_NUM    3
+#define CONFIG_SYS_MMC_ENV_DEV		1   /* USDHC2 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk1p2"  /* USDHC2 */
+
+#define PHYS_SDRAM_SIZE			SZ_1G
+
+#define CONFIG_CMD_MII
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define CONFIG_ETHPRIME                 "FEC"
+#define CONFIG_FEC_MXC_PHYADDR          0
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ATHEROS
+
+/* ENET2 */
+#define IMX_FEC_BASE			ENET2_IPS_BASE_ADDR
+#define CONFIG_FEC_MXC_MDIO_BASE	ENET_IPS_BASE_ADDR
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#else
+#define CONFIG_SYS_USE_QSPI   /* Enable the QSPI flash at default */
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE3000
+#define CONFIG_POWER_PFUZE3000_I2C_ADDR	0x08
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_ATMEL
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#define CONFIG_SF_DEFAULT_CS   0
+#endif
+
+#define CONFIG_VIDEO
+
+#include "mx7d_arm2.h"
+
+#endif
diff -urN u-boot-2016.03/include/configs/mx7d_19x19_lpddr3_arm2.h ebf_6ull_uboot/include/configs/mx7d_19x19_lpddr3_arm2.h
--- u-boot-2016.03/include/configs/mx7d_19x19_lpddr3_arm2.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx7d_19x19_lpddr3_arm2.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX7D 19x19 LPDDR3 ARM2 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX7D_19X19_LPDDR3_ARM2_CONFIG_H
+#define __MX7D_19X19_LPDDR3_ARM2_CONFIG_H
+
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#define CONFIG_SYS_MMC_ENV_DEV		0	/* USDHC1 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"  /* USDHC1 */
+
+#ifdef CONFIG_TARGET_MX7D_19X19_LPDDR2_ARM2
+#define PHYS_SDRAM_SIZE			SZ_512M
+#else
+#define PHYS_SDRAM_SIZE			SZ_2G
+#endif
+
+#define CONFIG_CMD_MII
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define CONFIG_ETHPRIME                 "FEC"
+#define CONFIG_FEC_MXC_PHYADDR          0
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ATHEROS
+
+/* ENET2 */
+#define IMX_FEC_BASE			ENET2_IPS_BASE_ADDR
+#define CONFIG_FEC_MXC_MDIO_BASE	ENET_IPS_BASE_ADDR
+
+/* QSPI conflict with EIMNOR */
+/* FEC0 conflict with EIMNOR */
+/* ECSPI conflict with UART */
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_EIMNOR
+#define CONFIG_SYS_USE_EIMNOR
+#define CONFIG_ENV_IS_IN_FLASH
+#undef CONFIG_FEC_MXC
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#define CONFIG_SYS_USE_EIMNOR
+#undef CONFIG_FEC_MXC
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE3000
+#define CONFIG_POWER_PFUZE3000_I2C_ADDR	0x08
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_ATMEL
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#define CONFIG_SF_DEFAULT_CS   0
+#endif
+
+#include "mx7d_arm2.h"
+
+#endif
diff -urN u-boot-2016.03/include/configs/mx7d_arm2.h ebf_6ull_uboot/include/configs/mx7d_arm2.h
--- u-boot-2016.03/include/configs/mx7d_arm2.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx7d_arm2.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX7D ARM2 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX7D_ARM2_CONFIG_H
+#define __MX7D_ARM2_CONFIG_H
+
+#include "mx7_common.h"
+
+#define CONFIG_DBG_MONITOR
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+#define CONFIG_IMX_THERMAL
+
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+
+#undef CONFIG_BOOTM_NETBSD
+#undef CONFIG_BOOTM_PLAN9
+#undef CONFIG_BOOTM_RTEMS
+
+#undef CONFIG_CMD_EXPORTENV
+#undef CONFIG_CMD_IMPORTENV
+
+/* I2C configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_SPEED		100000
+
+#ifdef CONFIG_IMX_BOOTAUX
+#define CONFIG_SYS_AUXCORE_BOOTDATA 0x68000000 /* Set to QSPI1 B flash at default */
+
+#define UPDATE_M4_ENV \
+	"m4image=m4_qspi.bin\0" \
+	"loadm4image=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${m4image}\0" \
+	"update_m4_from_sd=" \
+		"if sf probe 0:1; then " \
+			"if run loadm4image; then " \
+				"setexpr fw_sz ${filesize} + 0xffff; " \
+				"setexpr fw_sz ${fw_sz} / 0x10000; "	\
+				"setexpr fw_sz ${fw_sz} * 0x10000; "	\
+				"sf erase 0x0 ${fw_sz}; " \
+				"sf write ${loadaddr} 0x0 ${filesize}; " \
+			"fi; " \
+		"fi\0" \
+	"m4boot=sf probe 0:1; bootaux "__stringify(CONFIG_SYS_AUXCORE_BOOTDATA)"\0"
+#else
+#define UPDATE_M4_ENV ""
+#endif
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MODE \
+	"panel=MCIMX28LCD\0"
+#else
+#define CONFIG_VIDEO_MODE ""
+#endif
+
+#ifdef CONFIG_MXC_EPDC
+#define CONFIG_EPDC_WAVEFORM_FILE \
+	"epdc_waveform=epdc_splash.bin\0"
+#else
+#define CONFIG_EPDC_WAVEFORM_FILE ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.file=/fat g_mass_storage.ro=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		CONFIG_MFG_NAND_PARTITION \
+		"clk_ignore_unused "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"fdt_addr=0x83000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"console=ttymxc0\0" \
+	"bootargs=console=ttymxc0,115200 ubi.mtd=5 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	UPDATE_M4_ENV \
+	CONFIG_VIDEO_MODE \
+	CONFIG_EPDC_WAVEFORM_FILE \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+#endif
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+
+#ifndef CONFIG_CMD_MEMTEST
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x40000000)
+#endif
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			SZ_8K
+
+#ifdef CONFIG_SYS_USE_QSPI
+#define CONFIG_FSL_QSPI    /* enable the QUADSPI driver */
+#define CONFIG_QSPI_BASE			QSPI1_IPS_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI0_ARB_BASE_ADDR
+
+#define CONFIG_CMD_SF
+#define	CONFIG_SPI_FLASH
+#define	CONFIG_SPI_FLASH_STMICRO
+#define	CONFIG_SPI_FLASH_BAR
+#define	CONFIG_SF_DEFAULT_BUS		0
+#define	CONFIG_SF_DEFAULT_CS		0
+#define	CONFIG_SF_DEFAULT_SPEED		40000000
+#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+#undef CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
+#define CONFIG_SYS_FLASH_SECT_SIZE	(256 * 1024)
+#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT  512  /* max number of sectors on one chip */
+#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
+#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_PROTECTION
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_FLASH)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_SIZE			CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE		CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_OFFSET		(6 * CONFIG_SYS_FLASH_SECT_SIZE)
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(60 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#endif
+
+#define CONFIG_CMD_BMODE
+
+#ifdef CONFIG_VIDEO
+#define	CONFIG_CFB_CONSOLE
+#define	CONFIG_VIDEO_MXS
+#define	CONFIG_VIDEO_LOGO
+#define	CONFIG_VIDEO_SW_CURSOR
+#define	CONFIG_VGA_AS_SINGLE_DEVICE
+#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define	CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define	CONFIG_CMD_BMP
+#define	CONFIG_BMP_16BPP
+#define	CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IMX_VIDEO_SKIP
+#endif
+
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+/*
+ * Framebuffer and LCD
+ */
+#define	CONFIG_CFB_CONSOLE
+#define CONFIG_CMD_BMP
+#define CONFIG_LCD
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+
+#undef LCD_TEST_PATTERN
+/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+#define LCD_BPP					LCD_MONOCHROME
+/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+#define CONFIG_WAVEFORM_BUF_SIZE		0x400000
+#endif
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX7
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+
+#endif				/* __CONFIG_H */
diff -urN u-boot-2016.03/include/configs/mx7dsabresdandroid.h ebf_6ull_uboot/include/configs/mx7dsabresdandroid.h
--- u-boot-2016.03/include/configs/mx7dsabresdandroid.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx7dsabresdandroid.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,58 @@
+
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX7D_SABRESD_ANDROID_H
+#define __MX7D_SABRESD_ANDROID_H
+
+#define CONFIG_CI_UDC
+#define CONFIG_USBD_HS
+#define CONFIG_USB_GADGET_DUALSPEED
+
+#define CONFIG_USB_GADGET
+#define CONFIG_CMD_USB_MASS_STORAGE
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_USB_GADGET_VBUS_DRAW	2
+
+#define CONFIG_G_DNL_VENDOR_NUM		0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM	0x0d02
+#define CONFIG_G_DNL_MANUFACTURER	"FSL"
+
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_CMD_FASTBOOT
+#define CONFIG_ANDROID_BOOT_IMAGE
+#define CONFIG_FASTBOOT_FLASH
+
+#define CONFIG_FSL_FASTBOOT
+#define CONFIG_ANDROID_RECOVERY
+#define CONFIG_FASTBOOT_STORAGE_MMC
+
+#define CONFIG_ANDROID_MAIN_MMC_BUS 2
+#define CONFIG_ANDROID_BOOT_PARTITION_MMC 1
+#define CONFIG_ANDROID_SYSTEM_PARTITION_MMC 5
+#define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
+#define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
+#define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+
+#define CONFIG_CMD_BOOTA
+#define CONFIG_SUPPORT_RAW_INITRD
+#define CONFIG_SERIAL_TAG
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"splashpos=m,m\0"	  \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+
+
+#define CONFIG_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#define CONFIG_FASTBOOT_BUF_SIZE   0x19000000
+
+
+#endif
diff -urN u-boot-2016.03/include/configs/mx7dsabresd.h ebf_6ull_uboot/include/configs/mx7dsabresd.h
--- u-boot-2016.03/include/configs/mx7dsabresd.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/configs/mx7dsabresd.h	2021-04-16 14:42:17.808596912 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX7D SABRESD board.
  *
@@ -14,9 +14,17 @@
 #define CONFIG_DBG_MONITOR
 #define PHYS_SDRAM_SIZE			SZ_1G
 
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
 /* Uncomment to enable secure boot support */
 /* #define CONFIG_SECURE_BOOT */
-#define CONFIG_CSF_SIZE			0x4000
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
 
 /* Network */
 #define CONFIG_CMD_MII
@@ -24,15 +32,21 @@
 #define CONFIG_MII
 #define CONFIG_FEC_XCV_TYPE             RGMII
 #define CONFIG_ETHPRIME                 "FEC"
-#define CONFIG_FEC_MXC_PHYADDR          0
 
 #define CONFIG_PHYLIB
 #define CONFIG_PHY_BROADCOM
-/* ENET1 */
+
+#define CONFIG_FEC_ENET_DEV 0
+
+#if (CONFIG_FEC_ENET_DEV == 0)
 #define IMX_FEC_BASE			ENET_IPS_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x0
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_IPS_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x1
+#endif
 
-/* MMC Config*/
-#define CONFIG_SYS_FSL_ESDHC_ADDR       0
+#define CONFIG_FEC_MXC_MDIO_BASE	ENET_IPS_BASE_ADDR
 
 /* PMIC */
 #define CONFIG_POWER
@@ -54,14 +68,28 @@
 #define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
 #define CONFIG_SYS_I2C_SPEED		100000
 
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
 #define CONFIG_SUPPORT_EMMC_BOOT	/* eMMC specific */
 #define CONFIG_SYS_MMC_IMG_LOAD_PART	1
 
 #ifdef CONFIG_IMX_BOOTAUX
 /* Set to QSPI1 A flash at default */
-#define CONFIG_SYS_AUXCORE_BOOTDATA 0x60000000
-#define CONFIG_CMD_SETEXPR
+#ifdef CONFIG_SYS_USE_QSPI
+#define CONFIG_SYS_AUXCORE_BOOTDATA 0x60100000 /* Set to QSPI1 A flash, offset 1M */
+#else
+#define CONFIG_SYS_AUXCORE_BOOTDATA 0x7F8000 /* Set to TCML address */
+#endif
 
+#ifdef CONFIG_SYS_USE_QSPI
 #define UPDATE_M4_ENV \
 	"m4image=m4_qspi.bin\0" \
 	"loadm4image=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${m4image}\0" \
@@ -71,21 +99,34 @@
 				"setexpr fw_sz ${filesize} + 0xffff; " \
 				"setexpr fw_sz ${fw_sz} / 0x10000; "	\
 				"setexpr fw_sz ${fw_sz} * 0x10000; "	\
-				"sf erase 0x0 ${fw_sz}; " \
-				"sf write ${loadaddr} 0x0 ${filesize}; " \
+				"sf erase 0x100000 ${fw_sz}; " \
+				"sf write ${loadaddr} 0x100000 ${filesize}; " \
 			"fi; " \
 		"fi\0" \
 	"m4boot=sf probe 0:0; bootaux "__stringify(CONFIG_SYS_AUXCORE_BOOTDATA)"\0"
 #else
+#define UPDATE_M4_ENV \
+	"m4image=m4_qspi.bin\0" \
+	"loadm4image=fatload mmc ${mmcdev}:${mmcpart} "__stringify(CONFIG_SYS_AUXCORE_BOOTDATA)" ${m4image}\0" \
+	"m4boot=run loadm4image; bootaux "__stringify(CONFIG_SYS_AUXCORE_BOOTDATA)"\0"
+#endif
+#else
 #define UPDATE_M4_ENV ""
 #endif
 
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
 #define CONFIG_MFG_ENV_SETTINGS \
 	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
 		"rdinit=/linuxrc " \
 		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
 		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
 		"g_mass_storage.iSerialNumber=\"\" "\
+		CONFIG_MFG_NAND_PARTITION \
 		"clk_ignore_unused "\
 		"\0" \
 	"initrd_addr=0x83800000\0" \
@@ -98,6 +139,21 @@
 		"bootimg part 0 1;"\
 		"rootfs part 0 2\0" \
 
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"panel=TFT43AB\0" \
+	"fdt_addr=0x83000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"console=ttymxc0\0" \
+	"bootargs=console=ttymxc0,115200 ubi.mtd=4 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#else
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	UPDATE_M4_ENV \
 	CONFIG_MFG_ENV_SETTINGS \
@@ -111,7 +167,7 @@
 	"fdt_addr=0x83000000\0" \
 	"boot_fdt=try\0" \
 	"ip_dyn=yes\0" \
-	"videomode=video=ctfb:x:480,y:272,depth:24,pclk:108695,le:8,ri:4,up:2,lo:4,hs:41,vs:10,sync:0,vmode:0\0" \
+	"panel=TFT43AB\0" \
 	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
 	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
 	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
@@ -176,6 +232,7 @@
 			   "fi; " \
 		   "fi; " \
 	   "else run netboot; fi"
+#endif
 
 #define CONFIG_CMD_MEMTEST
 #define CONFIG_SYS_MEMTEST_START	0x80000000
@@ -202,17 +259,17 @@
 /* FLASH and environment organization */
 #define CONFIG_SYS_NO_FLASH
 #define CONFIG_ENV_SIZE			SZ_8K
-#define CONFIG_ENV_IS_IN_MMC
 
 /*
  * If want to use nand, define CONFIG_NAND_MXS and rework board
  * to support nand, since emmc has pin conflicts with nand
  */
-#ifdef CONFIG_NAND_MXS
+#ifdef CONFIG_SYS_USE_NAND
 #define CONFIG_CMD_NAND
 #define CONFIG_CMD_NAND_TRIMFFS
 
 /* NAND stuff */
+#define CONFIG_NAND_MXS
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
 #define CONFIG_SYS_NAND_BASE		0x40000000
 #define CONFIG_SYS_NAND_5_ADDR_CYCLE
@@ -224,13 +281,44 @@
 #define CONFIG_APBH_DMA_BURST8
 #endif
 
-#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
-#ifdef CONFIG_NAND_MXS
+#ifdef CONFIG_SYS_USE_QSPI
+#define CONFIG_FSL_QSPI
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_MACRONIX
+#define CONFIG_SPI_FLASH_BAR
+#define CONFIG_SF_DEFAULT_BUS		0
+#define CONFIG_SF_DEFAULT_CS		0
+#define CONFIG_SF_DEFAULT_SPEED		40000000
+#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#define CONFIG_QSPI_BASE		QSPI1_IPS_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI0_ARB_BASE_ADDR
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(60 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
 #define CONFIG_SYS_FSL_USDHC_NUM	1
 #else
 #define CONFIG_SYS_FSL_USDHC_NUM	2
 #endif
 
+/* MMC Config*/
+#define CONFIG_SYS_FSL_ESDHC_ADDR       0
 #define CONFIG_SYS_MMC_ENV_DEV		0   /* USDHC1 */
 #define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
 #define CONFIG_MMCROOT			"/dev/mmcblk0p2"  /* USDHC1 */
@@ -249,6 +337,55 @@
 
 #define CONFIG_IMX_THERMAL
 
+#define CONFIG_CMD_BMODE
+
+#define CONFIG_VIDEO
+#ifdef CONFIG_VIDEO
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VIDEO_MXS
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_SW_CURSOR
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_CMD_BMP
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IMX_VIDEO_SKIP
+#endif
+
+/* #define CONFIG_SPLASH_SCREEN*/
+/* #define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+/*
+ * Framebuffer and LCD
+ */
+#define	CONFIG_CFB_CONSOLE
+#define CONFIG_CMD_BMP
+#define CONFIG_LCD
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+
+#undef LCD_TEST_PATTERN
+/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+#define LCD_BPP					LCD_MONOCHROME
+/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+#define CONFIG_WAVEFORM_BUF_SIZE		0x400000
+#endif
+
+#if defined(CONFIG_MXC_EPDC) && defined(CONFIG_SYS_USE_QSPI)
+#error "EPDC Pins conflicts QSPI, Either EPDC or QSPI can be enabled!"
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx7dsabresdandroid.h"
+#else
 #define CONFIG_CI_UDC
 #define CONFIG_USBD_HS
 #define CONFIG_USB_GADGET_DUALSPEED
@@ -268,36 +405,6 @@
 #define CONFIG_USB_FUNCTION_DFU
 #define CONFIG_DFU_MMC
 #define CONFIG_DFU_RAM
-
-#define CONFIG_VIDEO
-#ifdef CONFIG_VIDEO
-#define CONFIG_CFB_CONSOLE
-#define CONFIG_VIDEO_MXS
-#define CONFIG_VIDEO_LOGO
-#define CONFIG_VIDEO_SW_CURSOR
-#define CONFIG_VGA_AS_SINGLE_DEVICE
-#define CONFIG_SYS_CONSOLE_IS_IN_ENV
-#define CONFIG_SPLASH_SCREEN
-#define CONFIG_SPLASH_SCREEN_ALIGN
-#define CONFIG_CMD_BMP
-#define CONFIG_BMP_16BPP
-#define CONFIG_VIDEO_BMP_RLE8
-#define CONFIG_VIDEO_BMP_LOGO
-#endif
-
-#ifdef CONFIG_FSL_QSPI
-#define CONFIG_CMD_SF
-#define CONFIG_SPI_FLASH
-#define CONFIG_SPI_FLASH_MACRONIX
-#define CONFIG_SPI_FLASH_BAR
-#define CONFIG_SF_DEFAULT_BUS		0
-#define CONFIG_SF_DEFAULT_CS		0
-#define CONFIG_SF_DEFAULT_SPEED		40000000
-#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
-#define FSL_QSPI_FLASH_NUM		1
-#define FSL_QSPI_FLASH_SIZE		SZ_64M
-#define QSPI0_BASE_ADDR			QSPI1_IPS_BASE_ADDR
-#define QSPI0_AMBA_BASE			QSPI0_ARB_BASE_ADDR
 #endif
 
 #endif	/* __CONFIG_H */
diff -urN u-boot-2016.03/include/configs/picosom-imx6ul.h ebf_6ull_uboot/include/configs/picosom-imx6ul.h
--- u-boot-2016.03/include/configs/picosom-imx6ul.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/configs/picosom-imx6ul.h	2021-04-16 14:42:17.808596912 +0800
@@ -0,0 +1,307 @@
+/*
+ * Copyright (C) 2015 Technexion Ltd.
+ *
+ * Configuration settings for the Technexion PicoSOM i.mx6UL board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __PICOSOM_IMX6UL_CONFIG_H
+#define __PICOSOM_IMX6UL_CONFIG_H
+
+
+#include <asm/arch/imx-regs.h>
+#include <linux/sizes.h>
+#include "mx6_common.h"
+#include <asm/imx-common/gpio.h>
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		MX6UL_UART6_BASE_ADDR
+
+/* MMC Configs */
+#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC1_BASE_ADDR
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+
+#ifdef CONFIG_CMD_NET
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_ENET_DEV 1
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x2
+#define CONFIG_FEC_XCV_TYPE             RMII
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x1  /* need board rework */
+#define CONFIG_FEC_XCV_TYPE             RMII
+#endif
+#define CONFIG_ETHPRIME                 "FEC"
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+#endif
+
+/* I2C configs */
+#define CONFIG_CMD_I2C
+#ifdef CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_SPEED		100000
+#endif
+
+
+#define CONFIG_DEFAULT_FDT_FILE "imx6ul-picosom.dtb"
+#define PHYS_SDRAM_SIZE                        SZ_256M
+#define CONFIG_BOOTARGS_CMA_SIZE   "cma=96M "
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE3000
+#define CONFIG_POWER_PFUZE3000_I2C_ADDR	0x08
+
+
+/* #define CONFIG_VIDEO */
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MODE \
+	"panel=TFT43AB\0"
+#else
+#define CONFIG_VIDEO_MODE ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+	    CONFIG_BOOTARGS_CMA_SIZE \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		CONFIG_MFG_NAND_PARTITION \
+		"clk_ignore_unused "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"fdt_addr=0x83000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"console=ttymxc5\0" \
+	"bootargs=console=ttymxc5,115200 ubi.mtd=3 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		CONFIG_BOOTARGS_CMA_SIZE \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc5\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+	    CONFIG_BOOTARGS_CMA_SIZE \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+#endif
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + (PHYS_SDRAM_SIZE >> 1))
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+#define CONFIG_ENV_SIZE			SZ_8K
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_FSL_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#define CONFIG_FSL_QSPI
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+#define CONFIG_QSPI_BASE		QSPI0_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI0_AMBA_BASE
+
+#define CONFIG_CMD_SF
+#define	CONFIG_SPI_FLASH
+#define	CONFIG_SPI_FLASH_STMICRO
+#define	CONFIG_SPI_FLASH_BAR
+#define	CONFIG_SF_DEFAULT_BUS		0
+#define	CONFIG_SF_DEFAULT_CS		0
+#define	CONFIG_SF_DEFAULT_SPEED		40000000
+#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(384 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(60 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#endif
+
+#define CONFIG_SYS_MMC_ENV_DEV		1   /* USDHC2 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk1p2"  /* USDHC2 */
+
+#define CONFIG_CMD_BMODE
+
+#ifdef CONFIG_VIDEO
+#define	CONFIG_CFB_CONSOLE
+#define	CONFIG_VIDEO_MXS
+#define	CONFIG_VIDEO_LOGO
+#define	CONFIG_VIDEO_SW_CURSOR
+#define	CONFIG_VGA_AS_SINGLE_DEVICE
+#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define	CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define	CONFIG_CMD_BMP
+#define	CONFIG_BMP_16BPP
+#define	CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IMX_VIDEO_SKIP
+#endif
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#ifdef CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6ul_14x14_evk_android.h"
+#endif
+
+#if defined(CONFIG_BRILLO_SUPPORT)
+#include "mx6ul_14x14_evk_brillo.h"
+#endif
+
+#endif
diff -urN u-boot-2016.03/include/configs/warp.h ebf_6ull_uboot/include/configs/warp.h
--- u-boot-2016.03/include/configs/warp.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/configs/warp.h	2021-04-16 14:42:17.812596932 +0800
@@ -22,11 +22,10 @@
 #define CONFIG_BOARD_LATE_INIT
 
 #define CONFIG_MXC_UART
-#define CONFIG_MXC_UART_BASE		UART1_IPS_BASE_ADDR
+#define CONFIG_MXC_UART_BASE		UART1_BASE
 
 /* MMC Configs */
 #define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC2_BASE_ADDR
-#define CONFIG_SYS_FSL_ESDHC_FORCE_VSELECT
 #define CONFIG_SYS_FSL_ESDHC_HAS_DDR_MODE
 #define CONFIG_SUPPORT_EMMC_BOOT
 
diff -urN u-boot-2016.03/include/fsl_esdhc.h ebf_6ull_uboot/include/fsl_esdhc.h
--- u-boot-2016.03/include/fsl_esdhc.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/fsl_esdhc.h	2021-04-16 14:42:17.784596787 +0800
@@ -2,7 +2,7 @@
  * FSL SD/MMC Defines
  *-------------------------------------------------------------------
  *
- * Copyright 2007-2008,2010-2011 Freescale Semiconductor, Inc
+ * Copyright 2007-2008, 2010-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -35,6 +35,12 @@
 #define SYSCTL_RSTC		0x02000000
 #define SYSCTL_RSTD		0x04000000
 
+#define VENDORSPEC_CKEN		0x00004000
+#define VENDORSPEC_PEREN		0x00002000
+#define VENDORSPEC_HCKEN		0x00001000
+#define VENDORSPEC_IPGEN		0x00000800
+#define VENDORSPEC_INIT     0x20007809
+
 #define IRQSTAT			0x0002e030
 #define IRQSTAT_DMAE		(0x10000000)
 #define IRQSTAT_AC12E		(0x01000000)
@@ -175,6 +181,8 @@
 #endif
 	u32	sdhc_clk;
 	u8	max_bus_width;
+	u8	wp_enable;
+	u8	vs18_enable; /*default use 1.8v if this var is not 0*/
 	struct mmc_config cfg;
 };
 
diff -urN u-boot-2016.03/include/fsl_fastboot.h ebf_6ull_uboot/include/fsl_fastboot.h
--- u-boot-2016.03/include/fsl_fastboot.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/fsl_fastboot.h	2021-04-16 14:42:17.784596787 +0800
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef FSL_FASTBOOT_H
+#define FSL_FASTBOOT_H
+
+#define FASTBOOT_PTENTRY_FLAGS_REPEAT(n)              (n & 0x0f)
+#define FASTBOOT_PTENTRY_FLAGS_REPEAT_MASK            0x0000000F
+
+/* Writes happen a block at a time.
+   If the write fails, go to next block
+   NEXT_GOOD_BLOCK and CONTIGOUS_BLOCK can not both be set */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_NEXT_GOOD_BLOCK  0x00000010
+
+/* Find a contiguous block big enough for a the whole file
+   NEXT_GOOD_BLOCK and CONTIGOUS_BLOCK can not both be set */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_CONTIGUOUS_BLOCK 0x00000020
+
+/* Write the file with write.i */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_I                0x00000100
+
+/* Write the file with write.trimffs */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_TRIMFFS          0x00000200
+
+/* Write the file as a series of variable/value pairs
+   using the setenv and saveenv commands */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_ENV              0x00000400
+
+#define FASTBOOT_MMC_BOOT_PARTITION_ID  1
+#define FASTBOOT_MMC_USER_PARTITION_ID  0
+#define FASTBOOT_MMC_NONE_PARTITION_ID -1
+
+#define FASTBOOT_PARTITION_BOOT "boot"
+#define FASTBOOT_PARTITION_RECOVERY "recovery"
+#define FASTBOOT_PARTITION_SYSTEM "system"
+#define FASTBOOT_PARTITION_BOOTLOADER "bootloader"
+#define FASTBOOT_PARTITION_DATA "data"
+
+enum {
+    DEV_SATA,
+    DEV_MMC,
+    DEV_NAND
+};
+
+struct cmd_fastboot_interface {
+	/* This function is called when a buffer has been
+	   recieved from the client app.
+	   The buffer is a supplied by the board layer and must be unmodified.
+	   The buffer_size is how much data is passed in.
+	   Returns 0 on success
+	   Returns 1 on failure
+
+	   Set by cmd_fastboot	*/
+	int (*rx_handler)(const unsigned char *buffer,
+			  unsigned int buffer_size);
+
+	/* This function is called when an exception has
+	   occurred in the device code and the state
+	   off fastboot needs to be reset
+
+	   Set by cmd_fastboot */
+	void (*reset_handler)(void);
+
+	/* A getvar string for the product name
+	   It can have a maximum of 60 characters
+
+	   Set by board	*/
+	char *product_name;
+
+	/* A getvar string for the serial number
+	   It can have a maximum of 60 characters
+
+	   Set by board */
+	char *serial_no;
+
+	/* Nand block size
+	   Supports the write option WRITE_NEXT_GOOD_BLOCK
+
+	   Set by board */
+	unsigned int nand_block_size;
+
+	/* Nand oob size
+	   Set by board */
+	unsigned int nand_oob_size;
+
+	/* Transfer buffer, for handling flash updates
+	   Should be multiple of the nand_block_size
+	   Care should be take so it does not overrun bootloader memory
+	   Controlled by the configure variable CFG_FASTBOOT_TRANSFER_BUFFER
+
+	   Set by board */
+	unsigned char *transfer_buffer;
+
+	/* How big is the transfer buffer
+	   Controlled by the configure variable
+	   CFG_FASTBOOT_TRANSFER_BUFFER_SIZE
+
+	   Set by board	*/
+	unsigned int transfer_buffer_size;
+
+};
+
+/* flash partitions are defined in terms of blocks
+** (flash erase units)
+*/
+struct fastboot_ptentry {
+	/* The logical name for this partition, null terminated */
+	char name[16];
+	/* The start wrt the nand part, must be multiple of nand block size */
+	unsigned int start;
+	/* The length of the partition, must be multiple of nand block size */
+	unsigned int length;
+	/* Controls the details of how operations are done on the partition
+	   See the FASTBOOT_PTENTRY_FLAGS_*'s defined below */
+	unsigned int flags;
+	/* partition id: 0 - normal partition; 1 - boot partition */
+	unsigned int partition_id;
+	/* partition number in block device */
+	unsigned int partition_index;
+};
+
+struct fastboot_device_info {
+	unsigned char type;
+	unsigned char dev_id;
+};
+
+extern struct fastboot_device_info fastboot_devinfo;
+
+/* Prepare the fastboot environments,
+  * should be executed before "fastboot" cmd
+  */
+void fastboot_setup(void);
+
+
+/* The Android-style flash handling */
+
+/* tools to populate and query the partition table */
+void fastboot_flash_add_ptn(struct fastboot_ptentry *ptn);
+struct fastboot_ptentry *fastboot_flash_find_ptn(const char *name);
+struct fastboot_ptentry *fastboot_flash_get_ptn(unsigned n);
+unsigned int fastboot_flash_get_ptn_count(void);
+void fastboot_flash_dump_ptn(void);
+
+
+/* Check the board special boot mode reboot to fastboot mode. */
+int fastboot_check_and_clean_flag(void);
+
+/* Set the flag which reboot to fastboot mode*/
+void fastboot_enable_flag(void);
+
+/*check if fastboot mode is requested by user*/
+void check_fastboot(void);
+
+/*Setup board-relative fastboot environment */
+void board_fastboot_setup(void);
+
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+/*Save parameters for NAND storage partitions */
+void save_parts_values(struct fastboot_ptentry *ptn,
+	unsigned int offset, unsigned int size);
+
+/* Checks parameters for NAND storage partitions
+  * Return 1 if the parameter is not set
+  * Return 0 if the parameter has been set
+  */
+int check_parts_values(struct fastboot_ptentry *ptn);
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+#endif /* FSL_FASTBOOT_H */
diff -urN u-boot-2016.03/include/generated/asm-offsets.h ebf_6ull_uboot/include/generated/asm-offsets.h
--- u-boot-2016.03/include/generated/asm-offsets.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/generated/asm-offsets.h	2021-04-16 14:42:17.816596951 +0800
@@ -0,0 +1,10 @@
+#ifndef __ASM_OFFSETS_H__
+#define __ASM_OFFSETS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ */
+
+
+#endif
diff -urN u-boot-2016.03/include/generated/autoconf.h ebf_6ull_uboot/include/generated/autoconf.h
--- u-boot-2016.03/include/generated/autoconf.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/generated/autoconf.h	2021-04-16 14:42:17.816596951 +0800
@@ -0,0 +1,82 @@
+/*
+ *
+ * Automatically generated file; DO NOT EDIT.
+ * U-Boot 2016.03 Configuration
+ *
+ */
+#define CONFIG_CMD_BOOTM 1
+#define CONFIG_CMD_EDITENV 1
+#define CONFIG_SYS_GENERIC_BOARD 1
+#define CONFIG_CMD_CONSOLE 1
+#define CONFIG_CMD_BOOTD 1
+#define CONFIG_CMD_IMLS 1
+#define CONFIG_BOOTSTAGE_STASH_ADDR 0x0
+#define CONFIG_ARCH_MX6 1
+#define CONFIG_HAVE_PRIVATE_LIBGCC 1
+#define CONFIG_CMD_BDI 1
+#define CONFIG_ARM 1
+#define CONFIG_CREATE_ARCH_SYMLINK 1
+#define CONFIG_DM_SEQ_ALIAS 1
+#define CONFIG_SYS_VENDOR "freescale"
+#define CONFIG_CMD_SAVEENV 1
+#define CONFIG_CMD_MISC 1
+#define CONFIG_SYS_CPU "armv7"
+#define CONFIG_BOOTSTAGE_USER_COUNT 0x20
+#define CONFIG_CC_OPTIMIZE_FOR_SIZE 1
+#define CONFIG_DM_THERMAL 1
+#define CONFIG_CMD_FLASH 1
+#define CONFIG_REGEX 1
+#define CONFIG_CMD_ENV_EXISTS 1
+#define CONFIG_CMD_SETEXPR 1
+#define CONFIG_DM_DEVICE_REMOVE 1
+#define CONFIG_HAVE_GENERIC_BOARD 1
+#define CONFIG_DISK 1
+#define CONFIG_CMD_EXPORTENV 1
+#define CONFIG_SYS_EXTRA_OPTIONS "IMX_CONFIG=board/freescale/mx6ullevk/imximage.cfg,SYS_BOOT_NAND"
+#define CONFIG_CMD_CRC32 1
+#define CONFIG_ROM_UNIFIED_SECTIONS 1
+#define CONFIG_SYS_BOARD "mx6ullevk"
+#define CONFIG_SYS_CONFIG_NAME "mx6ullevk"
+#define CONFIG_CMD_NFS 1
+#define CONFIG_NET 1
+#define CONFIG_DM_WARN 1
+#define CONFIG_CMD_GO 1
+#define CONFIG_SYS_MALLOC_CLEAR_ON_INIT 1
+#define CONFIG_CMD_IMI 1
+#define CONFIG_SYS_HZ 1000
+#define CONFIG_CPU_V7 1
+#define CONFIG_SUPPORT_OF_CONTROL 1
+#define CONFIG_DM_STDIO 1
+#define CONFIG_LOCALVERSION ""
+#define CONFIG_CMD_LOADB 1
+#define CONFIG_CMD_RUN 1
+#define CONFIG_MX6 1
+#define CONFIG_SYS_PROMPT "=> "
+#define CONFIG_CMD_MEMORY 1
+#define CONFIG_CMD_XIMG 1
+#define CONFIG_CMD_ECHO 1
+#define CONFIG_SYS_L2CACHE_OFF 1
+#define CONFIG_LOCALVERSION_AUTO 1
+#define CONFIG_SYS_ARCH "arm"
+#define CONFIG_CMD_DM 1
+#define CONFIG_HAS_VBAR 1
+#define CONFIG_EXPERT 1
+#define CONFIG_MX6ULL 1
+#define CONFIG_SYS_SOC "mx6"
+#define CONFIG_MX6UL 1
+#define CONFIG_CMD_ITEST 1
+#define CONFIG_CMD_GPIO 1
+#define CONFIG_BOOTSTAGE_STASH_SIZE 0x4096
+#define CONFIG_CMD_LOADS 1
+#define CONFIG_TARGET_MX6ULL_14X14_EVK 1
+#define CONFIG_CMD_NET 1
+#define CONFIG_CMD_FPGA 1
+#define CONFIG_DEFAULT_DEVICE_TREE ""
+#define CONFIG_NET_TFTP_VARS 1
+#define CONFIG_DM 1
+#define CONFIG_HAS_THUMB2 1
+#define CONFIG_SYS_MALLOC_F 1
+#define CONFIG_CMD_IMPORTENV 1
+#define CONFIG_SYS_MALLOC_F_LEN 0x400
+#define CONFIG_CMD_ELF 1
+#define CONFIG_CMD_SOURCE 1
diff -urN u-boot-2016.03/include/generated/generic-asm-offsets.h ebf_6ull_uboot/include/generated/generic-asm-offsets.h
--- u-boot-2016.03/include/generated/generic-asm-offsets.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/generated/generic-asm-offsets.h	2021-04-16 14:42:17.816596951 +0800
@@ -0,0 +1,18 @@
+#ifndef __GENERIC_ASM_OFFSETS_H__
+#define __GENERIC_ASM_OFFSETS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ */
+
+#define GENERATED_GBL_DATA_SIZE 256 /* (sizeof(struct global_data) + 15) & ~15	@ */
+#define GENERATED_BD_INFO_SIZE 80 /* (sizeof(struct bd_info) + 15) & ~15	@ */
+#define GD_SIZE 248 /* sizeof(struct global_data)	@ */
+#define GD_BD 0 /* offsetof(struct global_data, bd)	@ */
+#define GD_MALLOC_BASE 188 /* offsetof(struct global_data, malloc_base)	@ */
+#define GD_RELOCADDR 44 /* offsetof(struct global_data, relocaddr)	@ */
+#define GD_RELOC_OFF 64 /* offsetof(struct global_data, reloc_off)	@ */
+#define GD_START_ADDR_SP 60 /* offsetof(struct global_data, start_addr_sp)	@ */
+
+#endif
diff -urN u-boot-2016.03/include/generated/timestamp_autogenerated.h ebf_6ull_uboot/include/generated/timestamp_autogenerated.h
--- u-boot-2016.03/include/generated/timestamp_autogenerated.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/generated/timestamp_autogenerated.h	2021-04-16 14:42:17.816596951 +0800
@@ -0,0 +1,4 @@
+#define U_BOOT_DATE "Apr 16 2021"
+#define U_BOOT_TIME "13:42:13"
+#define U_BOOT_TZ "+0800"
+#define U_BOOT_DMI_DATE "04/16/2021"
diff -urN u-boot-2016.03/include/generated/version_autogenerated.h ebf_6ull_uboot/include/generated/version_autogenerated.h
--- u-boot-2016.03/include/generated/version_autogenerated.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/generated/version_autogenerated.h	2021-04-16 14:42:17.816596951 +0800
@@ -0,0 +1,4 @@
+#define PLAIN_VERSION "2016.03-gd484876-dirty"
+#define U_BOOT_VERSION "U-Boot " PLAIN_VERSION
+#define CC_VERSION_STRING "arm-none-eabi-gcc (15:6.3.1+svn253039-1build1) 6.3.1 20170620"
+#define LD_VERSION_STRING "GNU ld (2.27-9ubuntu1+9) 2.27"
diff -urN u-boot-2016.03/include/gis.h ebf_6ull_uboot/include/gis.h
--- u-boot-2016.03/include/gis.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/gis.h	2021-04-16 14:42:17.784596787 +0800
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef GIS_H
+#define GIS_H
+
+#define FMT_YUV444		0
+#define FMT_YUYV		1
+#define FMT_UYVY		2
+#define FMT_RGB565		3
+#define FMT_RGB888		4
+
+void mxc_enable_gis(void);
+void mxc_disable_gis(void);
+
+#endif
diff -urN u-boot-2016.03/include/image.h ebf_6ull_uboot/include/image.h
--- u-boot-2016.03/include/image.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/image.h	2021-04-16 14:42:17.784596787 +0800
@@ -4,6 +4,8 @@
  * (C) Copyright 2000-2005
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  ********************************************************************
  * NOTE: This header file defines an interface to U-Boot. Including
@@ -1122,6 +1124,8 @@
 			     ulong *os_data, ulong *os_len);
 int android_image_get_ramdisk(const struct andr_img_hdr *hdr,
 			      ulong *rd_data, ulong *rd_len);
+int android_image_get_fdt(const struct andr_img_hdr *hdr,
+			      ulong *fdt_data, ulong *fdt_len);
 ulong android_image_get_end(const struct andr_img_hdr *hdr);
 ulong android_image_get_kload(const struct andr_img_hdr *hdr);
 
diff -urN u-boot-2016.03/include/lcd.h ebf_6ull_uboot/include/lcd.h
--- u-boot-2016.03/include/lcd.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/lcd.h	2021-04-16 14:42:17.784596787 +0800
@@ -31,6 +31,7 @@
 void lcd_ctrl_init(void *lcdbase);
 void lcd_enable(void);
 void lcd_setcolreg(ushort regno, ushort red, ushort green, ushort blue);
+void lcd_initcolregs (void);
 
 /**
  * Set whether we need to flush the dcache when changing the LCD image. This
@@ -49,6 +50,64 @@
 #include <atmel_lcd.h>
 #elif defined(CONFIG_EXYNOS_FB)
 #include <exynos_lcd.h>
+#elif defined(CONFIG_MXC_EPDC)
+
+struct waveform_modes {
+	int mode_init;
+	int mode_du;
+	int mode_gc4;
+	int mode_gc8;
+	int mode_gc16;
+	int mode_gc32;
+};
+
+struct epdc_timing_params {
+    int vscan_holdoff;
+    int sdoed_width;
+    int sdoed_delay;
+    int sdoez_width;
+    int sdoez_delay;
+    int gdclk_hp_offs;
+    int gdsp_offs;
+    int gdoe_offs;
+    int gdclk_offs;
+    int num_ce;
+};
+
+struct epdc_data_struct {
+	/* EPDC buffer pointers */
+	u_long working_buf_addr;
+	u_long waveform_buf_addr;
+
+	/* Waveform mode definitions */
+	struct waveform_modes wv_modes;
+	struct epdc_timing_params epdc_timings;
+};
+
+typedef struct vidinfo {
+	u_long vl_refresh;      /* Refresh Rate Hz */
+	u_long vl_row;          /* resolution in x */
+	u_long vl_col;          /* resolution in y */
+	u_long vl_rot;
+	u_long vl_pixclock;     /* pixel clock in picoseconds */
+	u_long vl_left_margin;  /* Horizontal back porch */
+	u_long vl_right_margin; /* Horizontal front porch */
+	u_long vl_upper_margin; /* Vertical back porch */
+	u_long vl_lower_margin; /* Vertical front porch */
+	u_long vl_hsync;        /* Horizontal sync pulse length */
+	u_long vl_vsync;        /* Vertical sync pulse length */
+	u_long vl_sync;         /* Polarity on data enable */
+	u_long vl_mode;         /* Video Mode */
+	u_long vl_flag;
+	u_char  vl_bpix;
+	ushort  *cmap;
+	struct epdc_data_struct epdc_data;
+} vidinfo_t;
+
+static __maybe_unused ushort *configuration_get_cmap(void)
+{
+	return panel_info.cmap;
+}
 #else
 typedef struct vidinfo {
 	ushort	vl_col;		/* Number of columns (i.e. 160) */
@@ -165,6 +224,16 @@
 #define LCD_BPP			LCD_COLOR8
 #endif
 
+#if LCD_BPP == LCD_MONOCHROME
+# define COLOR_MASK(c)		((c)	  | (c) << 1 | (c) << 2 | (c) << 3 | \
+				 (c) << 4 | (c) << 5 | (c) << 6 | (c) << 7)
+#elif (LCD_BPP == LCD_COLOR8) || (LCD_BPP == LCD_COLOR16) || \
+	(LCD_BPP == LCD_COLOR32)
+# define COLOR_MASK(c)		(c)
+#else
+#error Unsupported LCD BPP.
+#endif
+
 #ifndef LCD_DF
 #define LCD_DF			1
 #endif
@@ -173,7 +242,14 @@
 #define NBITS(bit_code)		(1 << (bit_code))
 #define NCOLORS(bit_code)	(1 << NBITS(bit_code))
 
-#if LCD_BPP == LCD_COLOR8
+#if LCD_BPP == LCD_MONOCHROME
+/*
+ * Simple black/white definitions
+ */
+# define CONSOLE_COLOR_BLACK	0
+# define CONSOLE_COLOR_WHITE	1	/* Must remain last / highest	*/
+
+#elif LCD_BPP == LCD_COLOR8
 # define CONSOLE_COLOR_BLACK	0
 # define CONSOLE_COLOR_RED	1
 # define CONSOLE_COLOR_GREEN	2
diff -urN u-boot-2016.03/include/linux/mtd/nand.h ebf_6ull_uboot/include/linux/mtd/nand.h
--- u-boot-2016.03/include/linux/mtd/nand.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/linux/mtd/nand.h	2021-04-16 14:42:17.820596973 +0800
@@ -5,6 +5,8 @@
  *                        Steven J. Hill <sjhill@realitydiluted.com>
  *		          Thomas Gleixner <tglx@linutronix.de>
  *
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  *
  * Info:
@@ -46,7 +48,7 @@
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
  */
-#define NAND_MAX_OOBSIZE       1216
+#define NAND_MAX_OOBSIZE       1280
 #define NAND_MAX_PAGESIZE      16384
 
 /*
diff -urN u-boot-2016.03/include/mmc.h ebf_6ull_uboot/include/mmc.h
--- u-boot-2016.03/include/mmc.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/mmc.h	2021-04-16 14:42:17.784596787 +0800
@@ -11,6 +11,7 @@
 #define _MMC_H_
 
 #include <linux/list.h>
+#include <linux/sizes.h>
 #include <linux/compiler.h>
 #include <part.h>
 
@@ -107,6 +108,7 @@
 #define SD_CMD_SWITCH_UHS18V		11
 
 #define SD_CMD_APP_SET_BUS_WIDTH	6
+#define SD_CMD_APP_SD_STATUS		13
 #define SD_CMD_ERASE_WR_BLK_START	32
 #define SD_CMD_ERASE_WR_BLK_END		33
 #define SD_CMD_APP_SEND_OP_COND		41
@@ -342,6 +344,12 @@
 	unsigned char part_type;
 };
 
+struct sd_ssr {
+	unsigned int au;		/* In sectors */
+	unsigned int erase_timeout;	/* In milliseconds */
+	unsigned int erase_offset;	/* In milliseconds */
+};
+
 /* TODO struct mmc should be in mmc_private but it's hard to fix right now */
 struct mmc {
 	struct list_head link;
@@ -369,6 +377,7 @@
 	uint write_bl_len;
 	uint erase_grp_size;	/* in 512-byte sectors */
 	uint hc_wp_grp_size;	/* in 512-byte sectors */
+	struct sd_ssr	ssr;	/* SD status register */
 	u64 capacity;
 	u64 capacity_user;
 	u64 capacity_boot;
diff -urN u-boot-2016.03/include/mxc_epdc_fb.h ebf_6ull_uboot/include/mxc_epdc_fb.h
--- u-boot-2016.03/include/mxc_epdc_fb.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/mxc_epdc_fb.h	2021-04-16 14:42:17.788596807 +0800
@@ -0,0 +1,565 @@
+/*
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef __EPDC_REGS_INCLUDED__
+#define __EPDC_REGS_INCLUDED__
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <asm/arch/imx-regs.h>
+
+/*************************************
+ * Register addresses
+ *************************************/
+#define EPDC_BASE			(EPDC_BASE_ADDR)
+
+#define EPDC_CTRL			0x000
+#define EPDC_CTRL_SET			0x004
+#define EPDC_CTRL_CLR			0x008
+#define EPDC_CTRL_TOG		0x00C
+#define EPDC_WVADDR			0x020
+#define EPDC_WB_ADDR			0x030
+#define EPDC_RES			0x040
+#define EPDC_FORMAT			0x050
+#define EPDC_FORMAT_SET			0x054
+#define EPDC_FORMAT_CLR		0x058
+#define EPDC_FORMAT_TOG		0x05C
+#define EPDC_WB_FIELD0			0x060
+#define EPDC_WB_FIELD0_SET		0x064
+#define EPDC_WB_FIELD0_CLR		0x068
+#define EPDC_WB_FIELD0_TOG		0x06C
+#define EPDC_WB_FIELD1			0x070
+#define EPDC_WB_FIELD1_SET		0x074
+#define EPDC_WB_FIELD1_CLR		0x078
+#define EPDC_WB_FIELD1_TOG		0x07C
+#define EPDC_WB_FIELD2			0x080
+#define EPDC_WB_FIELD2_SET		0x084
+#define EPDC_WB_FIELD2_CLR		0x088
+#define EPDC_WB_FIELD2_TOG		0x08C
+#define EPDC_WB_FIELD3			0x090
+#define EPDC_WB_FIELD3_SET		0x094
+#define EPDC_WB_FIELD3_CLR		0x098
+#define EPDC_WB_FIELD3_TOG		0x09C
+#define EPDC_FIFOCTRL			0x0A0
+#define EPDC_FIFOCTRL_SET		0x0A4
+#define EPDC_FIFOCTRL_CLR		0x0A8
+#define EPDC_FIFOCTRL_TOG		0x0AC
+#define EPDC_UPD_ADDR			0x100
+#define EPDC_UPD_STRIDE			0x110
+#define EPDC_UPD_CORD			0x120
+#define EPDC_UPD_SIZE			0x140
+#define EPDC_UPD_CTRL			0x160
+#define EPDC_UPD_FIXED			0x180
+#define EPDC_TEMP			0x1A0
+#define EPDC_AUTOWV_LUT			0x1C0
+#define EPDC_LUT_STANDBY1		0x1E0
+#define EPDC_LUT_STANDBY1_SET		0x1E4
+#define EPDC_LUT_STANDBY1_CLR		0x1E8
+#define EPDC_LUT_STANDBY1_TOG	0x1EC
+#define EPDC_LUT_STANDBY2		0x1F0
+#define EPDC_LUT_STANDBY2_SET		0x1F4
+#define EPDC_LUT_STANDBY2_CLR		0x1F8
+#define EPDC_LUT_STANDBY2_TOG	0x1FC
+#define EPDC_TCE_CTRL			0x200
+#define EPDC_TCE_SDCFG			0x220
+#define EPDC_TCE_GDCFG			0x240
+#define EPDC_TCE_HSCAN1			0x260
+#define EPDC_TCE_HSCAN2			0x280
+#define EPDC_TCE_VSCAN			0x2A0
+#define EPDC_TCE_OE			0x2C0
+#define EPDC_TCE_POLARITY		0x2E0
+#define EPDC_TCE_TIMING1		0x300
+#define EPDC_TCE_TIMING2		0x310
+#define EPDC_TCE_TIMING3		0x320
+#define EPDC_PIGEON_CTRL0		0x380
+#define EPDC_PIGEON_CTRL1		0x390
+#define EPDC_IRQ_MASK1			0x3C0
+#define EPDC_IRQ_MASK1_SET		0x3C4
+#define EPDC_IRQ_MASK1_CLR		0x3C8
+#define EPDC_IRQ_MASK1_TOG		0x3CC
+#define EPDC_IRQ_MASK2			0x3D0
+#define EPDC_IRQ_MASK2_SET		0x3D4
+#define EPDC_IRQ_MASK2_CLR		0x3D8
+#define EPDC_IRQ_MASK2_TOG		0x3DC
+#define EPDC_IRQ1			0x3E0
+#define EPDC_IRQ1_SET			0x3E4
+#define EPDC_IRQ1_CLR			0x3E8
+#define EPDC_IRQ1_TOG		0x3EC
+#define EPDC_IRQ2			0x3F0
+#define EPDC_IRQ2_SET			0x3F4
+#define EPDC_IRQ2_CLR			0x3F8
+#define EPDC_IRQ2_TOG		0x3FC
+#define EPDC_IRQ_MASK			0x400
+#define EPDC_IRQ_MASK_SET		0x404
+#define EPDC_IRQ_MASK_CLR		0x408
+#define EPDC_IRQ_MASK_TOG		0x40C
+#define EPDC_IRQ			0x420
+#define EPDC_IRQ_SET			0x424
+#define EPDC_IRQ_CLR			0x428
+#define EPDC_IRQ_TOG			0x42C
+#define EPDC_STATUS_LUTS		0x440
+#define EPDC_STATUS_LUTS_SET		0x444
+#define EPDC_STATUS_LUTS_CLR		0x448
+#define EPDC_STATUS_LUTS_TOG		0x44C
+#define EPDC_STATUS_LUTS2		0x450
+#define EPDC_STATUS_LUTS2_SET		0x454
+#define EPDC_STATUS_LUTS2_CLR		0x458
+#define EPDC_STATUS_LUTS2_TOG	0x45C
+#define EPDC_STATUS_NEXTLUT		0x460
+#define EPDC_STATUS_COL			0x480
+#define EPDC_STATUS_COL2		0x490
+#define EPDC_STATUS			0x4A0
+#define EPDC_STATUS_SET			0x4A4
+#define EPDC_STATUS_CLR		0x4A8
+#define EPDC_STATUS_TOG		0x4AC
+#define EPDC_UPD_COL_CORD		0x4C0
+#define EPDC_UPD_COL_SIZE		0x4E0
+#define EPDC_DEBUG			0x500
+#define EPDC_DEBUG_LUT			0x530
+#define EPDC_HIST1_PARAM		0x600
+#define EPDC_HIST2_PARAM		0x610
+#define EPDC_HIST4_PARAM		0x620
+#define EPDC_HIST8_PARAM0		0x630
+#define EPDC_HIST8_PARAM1		0x640
+#define EPDC_HIST16_PARAM0		0x650
+#define EPDC_HIST16_PARAM1		0x660
+#define EPDC_HIST16_PARAM2		0x670
+#define EPDC_HIST16_PARAM3		0x680
+#define EPDC_GPIO			0x700
+#define EPDC_VERSION			0x7F0
+#define EPDC_PIGEON_0_0			0x800
+#define EPDC_PIGEON_0_1			0x810
+#define EPDC_PIGEON_0_2			0x820
+#define EPDC_PIGEON_1_0			0x840
+#define EPDC_PIGEON_1_1			0x850
+#define EPDC_PIGEON_1_2			0x860
+#define EPDC_PIGEON_2_0			0x880
+#define EPDC_PIGEON_2_1			0x890
+#define EPDC_PIGEON_2_2			0x8A0
+#define EPDC_PIGEON_3_0			0x8C0
+#define EPDC_PIGEON_3_1			0x8D0
+#define EPDC_PIGEON_3_2			0x8E0
+#define EPDC_PIGEON_4_0			0x900
+#define EPDC_PIGEON_4_1			0x910
+#define EPDC_PIGEON_4_2			0x920
+#define EPDC_PIGEON_5_0			0x940
+#define EPDC_PIGEON_5_1			0x950
+#define EPDC_PIGEON_5_2			0x960
+#define EPDC_PIGEON_6_0			0x980
+#define EPDC_PIGEON_6_1			0x990
+#define EPDC_PIGEON_6_2			0x9A0
+#define EPDC_PIGEON_7_0			0x9C0
+#define EPDC_PIGEON_7_1			0x9D0
+#define EPDC_PIGEON_7_2			0x9E0
+#define EPDC_PIGEON_8_0			0xA00
+#define EPDC_PIGEON_8_1			0xA10
+#define EPDC_PIGEON_8_2			0xA20
+#define EPDC_PIGEON_9_0			0xA40
+#define EPDC_PIGEON_9_1			0xA50
+#define EPDC_PIGEON_9_2			0xA60
+#define EPDC_PIGEON_10_0		0xA80
+#define EPDC_PIGEON_10_1		0xA90
+#define EPDC_PIGEON_10_2		0xAA0
+#define EPDC_PIGEON_11_0		0xAC0
+#define EPDC_PIGEON_11_1		0xAD0
+#define EPDC_PIGEON_11_2		0xAE0
+#define EPDC_PIGEON_12_0		0xB00
+#define EPDC_PIGEON_12_1		0xB10
+#define EPDC_PIGEON_12_2		0xB20
+#define EPDC_PIGEON_13_0		0xB40
+#define EPDC_PIGEON_13_1		0xB50
+#define EPDC_PIGEON_13_2		0xB60
+#define EPDC_PIGEON_14_0		0xB80
+#define EPDC_PIGEON_14_1		0xB90
+#define EPDC_PIGEON_14_2		0xBA0
+#define EPDC_PIGEON_15_0		0xBC0
+#define EPDC_PIGEON_15_1		0xBD0
+#define EPDC_PIGEON_15_2		0xBE0
+#define EPDC_PIGEON_16_0		0xC00
+#define EPDC_PIGEON_16_1		0xC10
+#define EPDC_PIGEON_16_2		0xC20
+#if defined(CONFIG_MX7) || defined(CONFIG_MX6ULL) || defined(CONFIG_MX6SLL)
+#define EPDC_WB_ADDR_TCE		0x010
+#else
+#define EPDC_WB_ADDR_TCE		0xC10
+#endif
+
+#define REG_RD(base, reg) \
+	(*(volatile unsigned int *)((base) + (reg)))
+#define REG_WR(base, reg, value) \
+	((*(volatile unsigned int *)((base) + (reg))) = (value))
+#define REG_SET(base, reg, value) \
+	((*(volatile unsigned int *)((base) + (reg ## _SET))) = (value))
+#define REG_CLR(base, reg, value) \
+	((*(volatile unsigned int *)((base) + (reg ## _CLR))) = (value))
+#define REG_TOG(base, reg, value) \
+	((*(volatile unsigned int *)((base) + (reg ## _TOG))) = (value))
+/*
+ * Register field definitions
+ */
+
+enum {
+/* EPDC_CTRL field values */
+	EPDC_CTRL_SFTRST = 0x80000000,
+	EPDC_CTRL_CLKGATE = 0x40000000,
+	EPDC_CTRL_SRAM_POWERDOWN = 0x100,
+	EPDC_CTRL_UPD_DATA_SWIZZLE_MASK = 0xC0,
+	EPDC_CTRL_UPD_DATA_SWIZZLE_NO_SWAP = 0,
+	EPDC_CTRL_UPD_DATA_SWIZZLE_ALL_BYTES_SWAP = 0x40,
+	EPDC_CTRL_UPD_DATA_SWIZZLE_HWD_SWAP = 0x80,
+	EPDC_CTRL_UPD_DATA_SWIZZLE_HWD_BYTE_SWAP = 0xC0,
+	EPDC_CTRL_LUT_DATA_SWIZZLE_MASK = 0x30,
+	EPDC_CTRL_LUT_DATA_SWIZZLE_NO_SWAP = 0,
+	EPDC_CTRL_LUT_DATA_SWIZZLE_ALL_BYTES_SWAP = 0x10,
+	EPDC_CTRL_LUT_DATA_SWIZZLE_HWD_SWAP = 0x20,
+	EPDC_CTRL_LUT_DATA_SWIZZLE_HWD_BYTE_SWAP = 0x30,
+	EPDC_CTRL_BURST_LEN_8_8 = 0x1,
+	EPDC_CTRL_BURST_LEN_8_16 = 0,
+
+/* EPDC_RES field values */
+	EPDC_RES_VERTICAL_MASK = 0x1FFF0000,
+	EPDC_RES_VERTICAL_OFFSET = 16,
+	EPDC_RES_HORIZONTAL_MASK = 0x1FFF,
+	EPDC_RES_HORIZONTAL_OFFSET = 0,
+
+/* EPDC_FORMAT field values */
+	EPDC_FORMAT_BUF_PIXEL_SCALE_ROUND = 0x1000000,
+	EPDC_FORMAT_DEFAULT_TFT_PIXEL_MASK = 0xFF0000,
+	EPDC_FORMAT_DEFAULT_TFT_PIXEL_OFFSET = 16,
+	EPDC_FORMAT_WB_ADDR_NO_COPY = 0x4000,
+	EPDC_FORMAT_WB_TYPE_MASK = 0x3000,
+	EPDC_FORMAT_WB_TYPE_OFFSET = 12,
+	EPDC_FORMAT_WB_TYPE_WB_INTERNAL = 0x0,
+	EPDC_FORMAT_WB_TYPE_WB_WAVEFORM = 0x1000,
+	EPDC_FORMAT_WB_TYPE_WB_EXTERNAL16 = 0x2000,
+	EPDC_FORMAT_WB_TYPE_WB_EXTERNAL32 = 0x3000,
+	EPDC_FORMAT_WB_COMPRESS = 0x800,
+	EPDC_FORMAT_BUF_PIXEL_FORMAT_MASK = 0x700,
+	EPDC_FORMAT_BUF_PIXEL_FORMAT_P2N = 0x200,
+	EPDC_FORMAT_BUF_PIXEL_FORMAT_P3N = 0x300,
+	EPDC_FORMAT_BUF_PIXEL_FORMAT_P4N = 0x400,
+	EPDC_FORMAT_BUF_PIXEL_FORMAT_P5N = 0x500,
+	EPDC_FORMAT_TFT_PIXEL_FORMAT_2BIT = 0x0,
+	EPDC_FORMAT_TFT_PIXEL_FORMAT_2BIT_VCOM = 0x1,
+	EPDC_FORMAT_TFT_PIXEL_FORMAT_4BIT = 0x2,
+	EPDC_FORMAT_TFT_PIXEL_FORMAT_4BIT_VCOM = 0x3,
+
+/* EPDC_WB_FIELD field values */
+	EPDC_WB_FIELD_FIXED_MASK = 0xFF000000,
+	EPDC_WB_FIELD_FIXED_OFFSET = 24,
+	EPDC_WB_FIELD_USE_FIXED_MASK = 0x30000,
+	EPDC_WB_FIELD_USE_FIXED_OFFSET = 16,
+	EPDC_WB_FIELD_USE_FIXED_NO_FIXED = 0x0,
+	EPDC_WB_FIELD_USE_FIXED_USE_FIXED = 0x1,
+	EPDC_WB_FIELD_USE_FIXED_NE_FIXED = 0x2,
+	EPDC_WB_FIELD_USE_FIXED_EQ_FIXED = 0x3,
+	EPDC_WB_FIELD_USAGE_MASK = 0xE000,
+	EPDC_WB_FIELD_USAGE_OFFSET = 13,
+	EPDC_WB_FIELD_USAGE_NOT_USED = 0x0,
+	EPDC_WB_FIELD_USAGE_PARTIAL = 0x3,
+	EPDC_WB_FIELD_USAGE_LUT = 0x4,
+	EPDC_WB_FIELD_USAGE_CP = 0x5,
+	EPDC_WB_FIELD_USAGE_NP = 0x6,
+	EPDC_WB_FIELD_USAGE_PTS = 0x7,
+	EPDC_WB_FIELD_FROM_MASK = 0x1F00,
+	EPDC_WB_FIELD_FROM_OFFSET = 8,
+	EPDC_WB_FIELD_TO_MASK = 0xF0,
+	EPDC_WB_FIELD_TO_OFFSET = 4,
+	EPDC_WB_FIELD_LEN_MASK = 0xF,
+	EPDC_WB_FIELD_LEN_OFFSET = 0,
+
+/* EPDC_FIFOCTRL field values */
+	EPDC_FIFOCTRL_ENABLE_PRIORITY = 0x80000000,
+	EPDC_FIFOCTRL_FIFO_INIT_LEVEL_MASK = 0xFF0000,
+	EPDC_FIFOCTRL_FIFO_INIT_LEVEL_OFFSET = 16,
+	EPDC_FIFOCTRL_FIFO_H_LEVEL_MASK = 0xFF00,
+	EPDC_FIFOCTRL_FIFO_H_LEVEL_OFFSET = 8,
+	EPDC_FIFOCTRL_FIFO_L_LEVEL_MASK = 0xFF,
+	EPDC_FIFOCTRL_FIFO_L_LEVEL_OFFSET = 0,
+
+/* EPDC_UPD_CORD field values */
+	EPDC_UPD_CORD_YCORD_MASK = 0x1FFF0000,
+	EPDC_UPD_CORD_YCORD_OFFSET = 16,
+	EPDC_UPD_CORD_XCORD_MASK = 0x1FFF,
+	EPDC_UPD_CORD_XCORD_OFFSET = 0,
+
+/* EPDC_UPD_SIZE field values */
+	EPDC_UPD_SIZE_HEIGHT_MASK = 0x1FFF0000,
+	EPDC_UPD_SIZE_HEIGHT_OFFSET = 16,
+	EPDC_UPD_SIZE_WIDTH_MASK = 0x1FFF,
+	EPDC_UPD_SIZE_WIDTH_OFFSET = 0,
+
+/* EPDC_UPD_CTRL field values */
+	EPDC_UPD_CTRL_USE_FIXED = 0x80000000,
+#if defined(CONFIG_MX7) || defined(CONFIG_MX6ULL) || defined(CONFIG_MX6SLL)
+	EPDC_UPD_CTRL_LUT_SEL_MASK = 0x3F0000,
+#else
+	EPDC_UPD_CTRL_LUT_SEL_MASK = 0xF0000,
+#endif
+	EPDC_UPD_CTRL_LUT_SEL_OFFSET = 16,
+	EPDC_UPD_CTRL_WAVEFORM_MODE_MASK = 0xFF00,
+	EPDC_UPD_CTRL_WAVEFORM_MODE_OFFSET = 8,
+	EPDC_UPD_CTRL_NO_LUT_CANCEL = 0x10,
+	EPDC_UPD_CTRL_AUTOWV_PAUSE = 0x8,
+	EPDC_UPD_CTRL_AUTOWV = 0x4,
+	EPDC_UPD_CTRL_DRY_RUN = 0x2,
+	EPDC_UPD_CTRL_UPDATE_MODE_FULL = 0x1,
+
+/* EPDC_UPD_FIXED field values */
+	EPDC_UPD_FIXED_FIXNP_EN = 0x80000000,
+	EPDC_UPD_FIXED_FIXCP_EN = 0x40000000,
+	EPDC_UPD_FIXED_FIXNP_MASK = 0xFF00,
+	EPDC_UPD_FIXED_FIXNP_OFFSET = 8,
+	EPDC_UPD_FIXED_FIXCP_MASK = 0xFF,
+	EPDC_UPD_FIXED_FIXCP_OFFSET = 0,
+
+/* EPDC_AUTOWV_LUT field values */
+	EPDC_AUTOWV_LUT_DATA_MASK = 0xFF0000,
+	EPDC_AUTOWV_LUT_DATA_OFFSET = 16,
+#if defined(CONFIG_MX7) || defined(CONFIG_MX6ULL) || defined(CONFIG_MX6SLL)
+	EPDC_AUTOWV_LUT_ADDR_MASK = 0x7,
+#else
+	EPDC_AUTOWV_LUT_ADDR_MASK = 0xFF,
+#endif
+	EPDC_AUTOWV_LUT_ADDR_OFFSET = 0,
+
+/* EPDC_TCE_CTRL field values */
+	EPDC_TCE_CTRL_VSCAN_HOLDOFF_MASK = 0x1FF0000,
+	EPDC_TCE_CTRL_VSCAN_HOLDOFF_OFFSET = 16,
+	EPDC_TCE_CTRL_VCOM_VAL_MASK = 0xC00,
+	EPDC_TCE_CTRL_VCOM_VAL_OFFSET = 10,
+	EPDC_TCE_CTRL_VCOM_MODE_AUTO = 0x200,
+	EPDC_TCE_CTRL_VCOM_MODE_MANUAL = 0x000,
+	EPDC_TCE_CTRL_DDR_MODE_ENABLE = 0x100,
+	EPDC_TCE_CTRL_LVDS_MODE_CE_ENABLE = 0x80,
+	EPDC_TCE_CTRL_LVDS_MODE_ENABLE = 0x40,
+	EPDC_TCE_CTRL_SCAN_DIR_1_UP = 0x20,
+	EPDC_TCE_CTRL_SCAN_DIR_0_UP = 0x10,
+	EPDC_TCE_CTRL_DUAL_SCAN_ENABLE = 0x8,
+	EPDC_TCE_CTRL_SDDO_WIDTH_16BIT = 0x4,
+	EPDC_TCE_CTRL_PIXELS_PER_SDCLK_2 = 1,
+	EPDC_TCE_CTRL_PIXELS_PER_SDCLK_4 = 2,
+	EPDC_TCE_CTRL_PIXELS_PER_SDCLK_8 = 3,
+
+/* EPDC_TCE_SDCFG field values */
+	EPDC_TCE_SDCFG_SDCLK_HOLD = 0x200000,
+	EPDC_TCE_SDCFG_SDSHR = 0x100000,
+	EPDC_TCE_SDCFG_NUM_CE_MASK = 0xF0000,
+	EPDC_TCE_SDCFG_NUM_CE_OFFSET = 16,
+	EPDC_TCE_SDCFG_SDDO_REFORMAT_STANDARD = 0,
+	EPDC_TCE_SDCFG_SDDO_REFORMAT_FLIP_PIXELS = 0x4000,
+	EPDC_TCE_SDCFG_SDDO_INVERT_ENABLE = 0x2000,
+	EPDC_TCE_SDCFG_PIXELS_PER_CE_MASK = 0x1FFF,
+	EPDC_TCE_SDCFG_PIXELS_PER_CE_OFFSET = 0,
+
+/* EPDC_TCE_GDCFG field values */
+	EPDC_TCE_SDCFG_GDRL = 0x10,
+	EPDC_TCE_SDCFG_GDOE_MODE_DELAYED_GDCLK = 0x2,
+	EPDC_TCE_SDCFG_GDSP_MODE_FRAME_SYNC = 0x1,
+	EPDC_TCE_SDCFG_GDSP_MODE_ONE_LINE = 0x0,
+
+/* EPDC_TCE_HSCAN1 field values */
+	EPDC_TCE_HSCAN1_LINE_SYNC_WIDTH_MASK = 0xFFF0000,
+	EPDC_TCE_HSCAN1_LINE_SYNC_WIDTH_OFFSET = 16,
+	EPDC_TCE_HSCAN1_LINE_SYNC_MASK = 0xFFF,
+	EPDC_TCE_HSCAN1_LINE_SYNC_OFFSET = 0,
+
+/* EPDC_TCE_HSCAN2 field values */
+	EPDC_TCE_HSCAN2_LINE_END_MASK = 0xFFF0000,
+	EPDC_TCE_HSCAN2_LINE_END_OFFSET = 16,
+	EPDC_TCE_HSCAN2_LINE_BEGIN_MASK = 0xFFF,
+	EPDC_TCE_HSCAN2_LINE_BEGIN_OFFSET = 0,
+
+/* EPDC_TCE_VSCAN field values */
+	EPDC_TCE_VSCAN_FRAME_END_MASK = 0xFF0000,
+	EPDC_TCE_VSCAN_FRAME_END_OFFSET = 16,
+	EPDC_TCE_VSCAN_FRAME_BEGIN_MASK = 0xFF00,
+	EPDC_TCE_VSCAN_FRAME_BEGIN_OFFSET = 8,
+	EPDC_TCE_VSCAN_FRAME_SYNC_MASK = 0xFF,
+	EPDC_TCE_VSCAN_FRAME_SYNC_OFFSET = 0,
+
+/* EPDC_TCE_OE field values */
+	EPDC_TCE_OE_SDOED_WIDTH_MASK = 0xFF000000,
+	EPDC_TCE_OE_SDOED_WIDTH_OFFSET = 24,
+	EPDC_TCE_OE_SDOED_DLY_MASK = 0xFF0000,
+	EPDC_TCE_OE_SDOED_DLY_OFFSET = 16,
+	EPDC_TCE_OE_SDOEZ_WIDTH_MASK = 0xFF00,
+	EPDC_TCE_OE_SDOEZ_WIDTH_OFFSET = 8,
+	EPDC_TCE_OE_SDOEZ_DLY_MASK = 0xFF,
+	EPDC_TCE_OE_SDOEZ_DLY_OFFSET = 0,
+
+/* EPDC_TCE_POLARITY field values */
+	EPDC_TCE_POLARITY_GDSP_POL_ACTIVE_HIGH = 0x10,
+	EPDC_TCE_POLARITY_GDOE_POL_ACTIVE_HIGH = 0x8,
+	EPDC_TCE_POLARITY_SDOE_POL_ACTIVE_HIGH = 0x4,
+	EPDC_TCE_POLARITY_SDLE_POL_ACTIVE_HIGH = 0x2,
+	EPDC_TCE_POLARITY_SDCE_POL_ACTIVE_HIGH = 0x1,
+
+/* EPDC_TCE_TIMING1 field values */
+	EPDC_TCE_TIMING1_SDLE_SHIFT_NONE = 0x00,
+	EPDC_TCE_TIMING1_SDLE_SHIFT_1 = 0x10,
+	EPDC_TCE_TIMING1_SDLE_SHIFT_2 = 0x20,
+	EPDC_TCE_TIMING1_SDLE_SHIFT_3 = 0x30,
+	EPDC_TCE_TIMING1_SDCLK_INVERT = 0x8,
+	EPDC_TCE_TIMING1_SDCLK_SHIFT_NONE = 0,
+	EPDC_TCE_TIMING1_SDCLK_SHIFT_1CYCLE = 1,
+	EPDC_TCE_TIMING1_SDCLK_SHIFT_2CYCLES = 2,
+	EPDC_TCE_TIMING1_SDCLK_SHIFT_3CYCLES = 3,
+
+/* EPDC_TCE_TIMING2 field values */
+	EPDC_TCE_TIMING2_GDCLK_HP_MASK = 0xFFFF0000,
+	EPDC_TCE_TIMING2_GDCLK_HP_OFFSET = 16,
+	EPDC_TCE_TIMING2_GDSP_OFFSET_MASK = 0xFFFF,
+	EPDC_TCE_TIMING2_GDSP_OFFSET_OFFSET = 0,
+
+/* EPDC_TCE_TIMING3 field values */
+	EPDC_TCE_TIMING3_GDOE_OFFSET_MASK = 0xFFFF0000,
+	EPDC_TCE_TIMING3_GDOE_OFFSET_OFFSET = 16,
+	EPDC_TCE_TIMING3_GDCLK_OFFSET_MASK = 0xFFFF,
+	EPDC_TCE_TIMING3_GDCLK_OFFSET_OFFSET = 0,
+
+/* EPDC EPDC_PIGEON_CTRL0 field values */
+	EPDC_PIGEON_CTRL0_LD_PERIOD_MASK = 0xFFF0000,
+	EPDC_PIGEON_CTRL0_LD_PERIOD_OFFSET = 16,
+	EPDC_PIGEON_CTRL0_FD_PERIOD_MASK = 0xFFF,
+	EPDC_PIGEON_CTRL0_FD_PERIOD_OFFSET = 0,
+
+/* EPDC EPDC_PIGEON_CTRL1 field values */
+	EPDC_PIGEON_CTRL1_LD_PERIOD_MASK = 0xFFF0000,
+	EPDC_PIGEON_CTRL1_LD_PERIOD_OFFSET = 16,
+	EPDC_PIGEON_CTRL1_FD_PERIOD_MASK = 0xFFF,
+	EPDC_PIGEON_CTRL1_FD_PERIOD_OFFSET = 0,
+
+/* EPDC_IRQ_MASK/EPDC_IRQ field values */
+	EPDC_IRQ_WB_CMPLT_IRQ = 0x10000,
+	EPDC_IRQ_LUT_COL_IRQ = 0x20000,
+	EPDC_IRQ_TCE_UNDERRUN_IRQ = 0x40000,
+	EPDC_IRQ_FRAME_END_IRQ = 0x80000,
+	EPDC_IRQ_BUS_ERROR_IRQ = 0x100000,
+	EPDC_IRQ_TCE_IDLE_IRQ = 0x200000,
+	EPDC_IRQ_UPD_DONE_IRQ = 0x400000,
+	EPDC_IRQ_PWR_IRQ = 0x800000,
+
+/* EPDC_STATUS_NEXTLUT field values */
+	EPDC_STATUS_NEXTLUT_NEXT_LUT_VALID = 0x100,
+	EPDC_STATUS_NEXTLUT_NEXT_LUT_MASK = 0x3F,
+	EPDC_STATUS_NEXTLUT_NEXT_LUT_OFFSET = 0,
+
+/* EPDC_STATUS field values */
+	EPDC_STATUS_HISTOGRAM_CP_MASK = 0x1F0000,
+	EPDC_STATUS_HISTOGRAM_CP_OFFSET = 16,
+	EPDC_STATUS_HISTOGRAM_NP_MASK = 0x1F00,
+	EPDC_STATUS_HISTOGRAM_NP_OFFSET = 8,
+	EPDC_STATUS_UPD_VOID = 0x8,
+	EPDC_STATUS_LUTS_UNDERRUN = 0x4,
+	EPDC_STATUS_LUTS_BUSY = 0x2,
+	EPDC_STATUS_WB_BUSY = 0x1,
+
+/* EPDC_UPD_COL_CORD field values */
+	EPDC_UPD_COL_CORD_YCORD_MASK = 0x1FFF0000,
+	EPDC_UPD_COL_CORD_YCORD_OFFSET = 16,
+	EPDC_UPD_COL_CORD_XCORD_MASK = 0x1FFF,
+	EPDC_UPD_COL_CORD_XCORD_OFFSET = 0,
+
+/* EPDC_UPD_COL_SIZE field values */
+	EPDC_UPD_COL_SIZE_HEIGHT_MASK = 0x1FFF0000,
+	EPDC_UPD_COL_SIZE_HEIGHT_OFFSET = 16,
+	EPDC_UPD_COL_SIZE_WIDTH_MASK = 0x1FFF,
+	EPDC_UPD_COL_SIZE_WIDTH_OFFSET = 0,
+
+/* EPDC_DEBUG field values */
+	EPDC_DEBUG_DEBUG_LUT_SEL_MASK = 0x3F00000,
+	EPDC_DEBUG_DEBUG_LUT_SEL_OFFSET = 24,
+	EPDC_DEBUG_UBW_BURST_LEN_MASK = 0xF000,
+	EPDC_DEBUG_UBW_BURST_LEN_OFFSET = 12,
+	EPDC_DEBUG_UBR_BURST_LEN_MASK = 0xF00,
+	EPDC_DEBUG_UBR_BURST_LEN = 8,
+	EPDC_DEBUG_UPD_BURST_LEN_MASK = 0xF0,
+	EPDC_DEBUG_UPD_BURST_LEN_OFFSET = 4,
+	EPDC_DEBUG_UPDATE_SAME = 0x4,
+	EPDC_DEBUG_UNDERRUN_RECOVER = 0x2,
+	EPDC_DEBUG_COLLISION_OFF = 0x1,
+
+/* EPDC_DEBUG_LUT field values */
+	EPDC_DEBUG_LUT_LUTADDR_MASK = 0x3FF0000,
+	EPDC_DEBUG_LUT_LUTADDR_OFFSET = 16,
+	EPDC_DEBUG_LUT_FRAME_MASK = 0x7FE0,
+	EPDC_DEBUG_LUT_FRAME_OFFSET = 5,
+	EPDC_DEBUG_LUT_STATEMACHINE_MASK = 0x1F,
+	EPDC_DEBUG_LUT_STATEMACHINE_OFFSET = 0,
+
+/* EPDC_HISTx_PARAM field values */
+	EPDC_HIST_PARAM_VALUE0_MASK = 0x1F,
+	EPDC_HIST_PARAM_VALUE0_OFFSET = 0,
+	EPDC_HIST_PARAM_VALUE1_MASK = 0x1F00,
+	EPDC_HIST_PARAM_VALUE1_OFFSET = 8,
+	EPDC_HIST_PARAM_VALUE2_MASK = 0x1F0000,
+	EPDC_HIST_PARAM_VALUE2_OFFSET = 16,
+	EPDC_HIST_PARAM_VALUE3_MASK = 0x1F000000,
+	EPDC_HIST_PARAM_VALUE3_OFFSET = 24,
+	EPDC_HIST_PARAM_VALUE4_MASK = 0x1F,
+	EPDC_HIST_PARAM_VALUE4_OFFSET = 0,
+	EPDC_HIST_PARAM_VALUE5_MASK = 0x1F00,
+	EPDC_HIST_PARAM_VALUE5_OFFSET = 8,
+	EPDC_HIST_PARAM_VALUE6_MASK = 0x1F0000,
+	EPDC_HIST_PARAM_VALUE6_OFFSET = 16,
+	EPDC_HIST_PARAM_VALUE7_MASK = 0x1F000000,
+	EPDC_HIST_PARAM_VALUE7_OFFSET = 24,
+	EPDC_HIST_PARAM_VALUE8_MASK = 0x1F,
+	EPDC_HIST_PARAM_VALUE8_OFFSET = 0,
+	EPDC_HIST_PARAM_VALUE9_MASK = 0x1F00,
+	EPDC_HIST_PARAM_VALUE9_OFFSET = 8,
+	EPDC_HIST_PARAM_VALUE10_MASK = 0x1F0000,
+	EPDC_HIST_PARAM_VALUE10_OFFSET = 16,
+	EPDC_HIST_PARAM_VALUE11_MASK = 0x1F000000,
+	EPDC_HIST_PARAM_VALUE11_OFFSET = 24,
+	EPDC_HIST_PARAM_VALUE12_MASK = 0x1F,
+	EPDC_HIST_PARAM_VALUE12_OFFSET = 0,
+	EPDC_HIST_PARAM_VALUE13_MASK = 0x1F00,
+	EPDC_HIST_PARAM_VALUE13_OFFSET = 8,
+	EPDC_HIST_PARAM_VALUE14_MASK = 0x1F0000,
+	EPDC_HIST_PARAM_VALUE14_OFFSET = 16,
+	EPDC_HIST_PARAM_VALUE15_MASK = 0x1F000000,
+	EPDC_HIST_PARAM_VALUE15_OFFSET = 24,
+
+/* EPDC_GPIO field values */
+	EPDC_GPIO_PWRSTAT = 0x100,
+	EPDC_GPIO_PWRWAKE = 0x80,
+	EPDC_GPIO_PWRCOM = 0x40,
+	EPDC_GPIO_PWRCTRL_MASK = 0x3C,
+	EPDC_GPIO_PWRCTRL_OFFSET = 2,
+	EPDC_GPIO_BDR_MASK = 0x3,
+	EPDC_GPIO_BDR_OFFSET = 0,
+
+/* EPDC_VERSION field values */
+	EPDC_VERSION_MAJOR_MASK = 0xFF000000,
+	EPDC_VERSION_MAJOR_OFFSET = 24,
+	EPDC_VERSION_MINOR_MASK = 0xFF0000,
+	EPDC_VERSION_MINOR_OFFSET = 16,
+	EPDC_VERSION_STEP_MASK = 0xFFFF,
+	EPDC_VERSION_STEP_OFFSET = 0,
+};
+
+int board_setup_waveform_file(ulong waveform_buf);
+int board_setup_logo_file(void *display_buf);
+void epdc_power_on(void);
+void epdc_power_off(void);
+
+extern void *lcd_base;
+
+#endif	/* __EPDC_REGS_INCLUDED__ */
diff -urN u-boot-2016.03/include/mxc_keyb.h ebf_6ull_uboot/include/mxc_keyb.h
--- u-boot-2016.03/include/mxc_keyb.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/mxc_keyb.h	2021-04-16 14:42:17.788596807 +0800
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2009-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*!
+ * @defgroup keypad Keypad Driver
+ */
+
+/*!
+ * @file mxc_keyb.h
+ *
+ * @brief MXC keypad header file.
+ *
+ * @ingroup keypad
+ */
+#ifndef __MXC_KEYB_H__
+#define __MXC_KEYB_H__
+
+/*!
+ * Keypad Module Name
+ */
+#define MOD_NAME  "mxckpd"
+
+/*!
+ * Keypad irq number
+ */
+#define KPP_IRQ  MXC_INT_KPP
+
+/*!
+ * XLATE mode selection
+ */
+#define KEYPAD_XLATE        0
+
+/*!
+ * RAW mode selection
+ */
+#define KEYPAD_RAW          1
+
+/*!
+ * Maximum number of keys.
+ */
+#define MAXROW			8
+#define MAXCOL			8
+#define MXC_MAXKEY		(MAXROW * MAXCOL)
+
+/*!
+ * This define indicates break scancode for every key release. A constant
+ * of 128 is added to the key press scancode.
+ */
+#define  MXC_KEYRELEASE   128
+
+/*
+ * _reg_KPP_KPCR   _reg_KPP_KPSR _reg_KPP_KDDR _reg_KPP_KPDR
+ * Keypad Control Register Address
+ */
+#define KPCR    (KPP_BASE_ADDR + 0x00)
+
+/*
+ * Keypad Status Register Address
+ */
+#define KPSR    (KPP_BASE_ADDR + 0x02)
+
+/*
+ * Keypad Data Direction Address
+ */
+#define KDDR    (KPP_BASE_ADDR + 0x04)
+
+/*
+ * Keypad Data Register
+ */
+#define KPDR    (KPP_BASE_ADDR + 0x06)
+
+/*
+ * Key Press Interrupt Status bit
+ */
+#define KBD_STAT_KPKD        0x01
+
+/*
+ * Key Release Interrupt Status bit
+ */
+#define KBD_STAT_KPKR        0x02
+
+/*
+ * Key Depress Synchronizer Chain Status bit
+ */
+#define KBD_STAT_KDSC        0x04
+
+/*
+ * Key Release Synchronizer Status bit
+ */
+#define KBD_STAT_KRSS        0x08
+
+/*
+ * Key Depress Interrupt Enable Status bit
+ */
+#define KBD_STAT_KDIE        0x100
+
+/*
+ * Key Release Interrupt Enable
+ */
+#define KBD_STAT_KRIE        0x200
+
+/*
+ * Keypad Clock Enable
+ */
+#define KBD_STAT_KPPEN       0x400
+
+/*!
+ * Buffer size of keypad queue. Should be a power of 2.
+ */
+#define KPP_BUF_SIZE    128
+
+/*!
+ * Test whether bit is set for integer c
+ */
+#define TEST_BIT(c, n) ((c) & (0x1 << (n)))
+
+/*!
+ * Set nth bit in the integer c
+ */
+#define BITSET(c, n)   ((c) | (1 << (n)))
+
+/*!
+ * Reset nth bit in the integer c
+ */
+#define BITRESET(c, n) ((c) & ~(1 << (n)))
+
+enum KeyEvent {
+	KDepress,
+	KRelease
+};
+
+/*!
+ * This enum represents the keypad state machine to maintain debounce logic
+ * for key press/release.
+ */
+enum KeyState {
+
+	/*!
+	 * Key press state.
+	 */
+	KStateUp,
+
+	/*!
+	 * Key press debounce state.
+	 */
+	KStateFirstDown,
+
+	/*!
+	 * Key release state.
+	 */
+	KStateDown,
+
+	/*!
+	 * Key release debounce state.
+	 */
+	KStateFirstUp
+};
+
+/*!
+ * Keypad Private Data Structure
+ */
+struct keypad_priv {
+
+	/*!
+	 * Keypad state machine.
+	 */
+	enum KeyState iKeyState;
+
+	/*!
+	 * Number of rows configured in the keypad matrix
+	 */
+	unsigned long kpp_rows;
+
+	/*!
+	 * Number of Columns configured in the keypad matrix
+	 */
+	unsigned long kpp_cols;
+};
+
+/*!
+ * Keypad Data Structure
+ * */
+struct kpp_key_info {
+	enum KeyEvent evt;
+	unsigned short val;
+};
+
+int mxc_kpp_init(void);
+int mxc_kpp_getc(struct kpp_key_info **);
+
+/*!
+ * These functions are used to configure and the GPIO pins for keypad to
+ * activate and deactivate it.
+ */
+void setup_mxc_kpd(void);
+
+
+#endif				/* __MXC_KEYB_H__ */
diff -urN u-boot-2016.03/include/mxsfb.h ebf_6ull_uboot/include/mxsfb.h
--- u-boot-2016.03/include/mxsfb.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/mxsfb.h	2021-04-16 14:42:17.788596807 +0800
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MXSFB_H__
+#define __MXSFB_H__
+
+#include <linux/fb.h>
+
+#ifdef CONFIG_VIDEO_MXS
+struct display_panel {
+	unsigned int reg_base;
+	unsigned int width;
+	unsigned int height;
+	unsigned int gdfindex;
+	unsigned int gdfbytespp;
+};
+
+void mxs_lcd_get_panel(struct display_panel *panel);
+void lcdif_power_down(void);
+int mxs_lcd_panel_setup(struct fb_videomode mode, int bpp,
+	uint32_t base_addr);
+#endif
+
+#endif				/* __MXSFB_H__ */
diff -urN u-boot-2016.03/include/power/pfuze3000_pmic.h ebf_6ull_uboot/include/power/pfuze3000_pmic.h
--- u-boot-2016.03/include/power/pfuze3000_pmic.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/include/power/pfuze3000_pmic.h	2021-04-16 14:42:17.820596973 +0800
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2015 Freescale Semiconductor, Inc
+ *  Copyright (C) 2015-2016 Freescale Semiconductor, Inc
  *  Peng Fan <Peng.Fan@freescale.com>
  *
  * SPDX-License-Identifier:     GPL-2.0+
@@ -73,6 +73,8 @@
 	PMIC_NUM_OF_REGS	= 0x7F,
 };
 
+#define PFUZE3000_SW1AB_SETP(x) (((x) - 700) / 25)
+
 int power_pfuze3000_init(unsigned char bus);
 
 #endif
diff -urN u-boot-2016.03/include/recovery.h ebf_6ull_uboot/include/recovery.h
--- u-boot-2016.03/include/recovery.h	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/include/recovery.h	2021-04-16 14:42:17.788596807 +0800
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __RECOVERY_H_
+#define __RECOVERY_H_
+
+struct reco_envs {
+	char *cmd;
+	char *args;
+};
+
+void check_recovery_mode(void);
+int recovery_check_and_clean_flag(void);
+int check_recovery_cmd_file(void);
+void board_recovery_setup(void);
+
+#endif
diff -urN u-boot-2016.03/.mailmap ebf_6ull_uboot/.mailmap
--- u-boot-2016.03/.mailmap	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/.mailmap	1970-01-01 08:00:00.000000000 +0800
@@ -1,34 +0,0 @@
-#
-# This list is used by git-shortlog to fix a few botched name translations
-# in the git archive, either because the author's full name was messed up
-# and/or not always written the same way, making contributions from the
-# same person appearing not to be so or badly displayed.
-#
-# This file can be modified by hand or updated by the following command:
-#  scripts/mailmapper > tmp; mv tmp .mailmap
-#
-
-Allen Martin <amartin@nvidia.com>
-Andreas Bießmann <andreas.devel@googlemail.com>
-Aneesh V <aneesh@ti.com>
-Dirk Behme <dirk.behme@googlemail.com>
-Fabio Estevam <fabio.estevam@nxp.com>
-Jagan Teki <402jagan@gmail.com>
-Jagan Teki <jaganna@gmail.com>
-Jagan Teki <jaganna@xilinx.com>
-Jagan Teki <jagannadh.teki@gmail.com>
-Jagan Teki <jagannadha.sutradharudu-teki@xilinx.com>
-Markus Klotzbuecher <mk@denx.de>
-Prabhakar Kushwaha <prabhakar@freescale.com>
-Rajeshwari Shinde <rajeshwari.s@samsung.com>
-Ricardo Ribalda <ricardo.ribalda@uam.es>
-Ricardo Ribalda <ricardo.ribalda@gmail.com>
-Sandeep Paulraj <s-paulraj@ti.com>
-Shaohui Xie <Shaohui.Xie@freescale.com>
-Stefan Roese <stroese>
-Stefano Babic <sbabic@denx.de>
-TsiChung Liew <Tsi-Chung.Liew@freescale.com>
-Wolfgang Denk <wdenk>
-York Sun <yorksun@freescale.com>
-York Sun <york.sun@nxp.com>
-Łukasz Majewski <l.majewski@samsung.com>
diff -urN u-boot-2016.03/OFFICIAL-README ebf_6ull_uboot/OFFICIAL-README
--- u-boot-2016.03/OFFICIAL-README	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/OFFICIAL-README	2021-04-16 14:42:13.932576852 +0800
@@ -0,0 +1,6624 @@
+#
+# (C) Copyright 2000 - 2013
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+Summary:
+========
+
+This directory contains the source code for U-Boot, a boot loader for
+Embedded boards based on PowerPC, ARM, MIPS and several other
+processors, which can be installed in a boot ROM and used to
+initialize and test the hardware or to download and run application
+code.
+
+The development of U-Boot is closely related to Linux: some parts of
+the source code originate in the Linux source tree, we have some
+header files in common, and special provision has been made to
+support booting of Linux images.
+
+Some attention has been paid to make this software easily
+configurable and extendable. For instance, all monitor commands are
+implemented with the same call interface, so that it's very easy to
+add new commands. Also, instead of permanently adding rarely used
+code (for instance hardware test utilities) to the monitor, you can
+load and run it dynamically.
+
+
+Status:
+=======
+
+In general, all boards for which a configuration option exists in the
+Makefile have been tested to some extent and can be considered
+"working". In fact, many of them are used in production systems.
+
+In case of problems see the CHANGELOG file to find out who contributed
+the specific port. In addition, there are various MAINTAINERS files
+scattered throughout the U-Boot source identifying the people or
+companies responsible for various boards and subsystems.
+
+Note: As of August, 2010, there is no longer a CHANGELOG file in the
+actual U-Boot source tree; however, it can be created dynamically
+from the Git log using:
+
+	make CHANGELOG
+
+
+Where to get help:
+==================
+
+In case you have questions about, problems with or contributions for
+U-Boot, you should send a message to the U-Boot mailing list at
+<u-boot@lists.denx.de>. There is also an archive of previous traffic
+on the mailing list - please search the archive before asking FAQ's.
+Please see http://lists.denx.de/pipermail/u-boot and
+http://dir.gmane.org/gmane.comp.boot-loaders.u-boot
+
+
+Where to get source code:
+=========================
+
+The U-Boot source code is maintained in the Git repository at
+git://www.denx.de/git/u-boot.git ; you can browse it online at
+http://www.denx.de/cgi-bin/gitweb.cgi?p=u-boot.git;a=summary
+
+The "snapshot" links on this page allow you to download tarballs of
+any version you might be interested in. Official releases are also
+available for FTP download from the ftp://ftp.denx.de/pub/u-boot/
+directory.
+
+Pre-built (and tested) images are available from
+ftp://ftp.denx.de/pub/u-boot/images/
+
+
+Where we come from:
+===================
+
+- start from 8xxrom sources
+- create PPCBoot project (http://sourceforge.net/projects/ppcboot)
+- clean up code
+- make it easier to add custom boards
+- make it possible to add other [PowerPC] CPUs
+- extend functions, especially:
+  * Provide extended interface to Linux boot loader
+  * S-Record download
+  * network boot
+  * PCMCIA / CompactFlash / ATA disk / SCSI ... boot
+- create ARMBoot project (http://sourceforge.net/projects/armboot)
+- add other CPU families (starting with ARM)
+- create U-Boot project (http://sourceforge.net/projects/u-boot)
+- current project page: see http://www.denx.de/wiki/U-Boot
+
+
+Names and Spelling:
+===================
+
+The "official" name of this project is "Das U-Boot". The spelling
+"U-Boot" shall be used in all written text (documentation, comments
+in source files etc.). Example:
+
+	This is the README file for the U-Boot project.
+
+File names etc. shall be based on the string "u-boot". Examples:
+
+	include/asm-ppc/u-boot.h
+
+	#include <asm/u-boot.h>
+
+Variable names, preprocessor constants etc. shall be either based on
+the string "u_boot" or on "U_BOOT". Example:
+
+	U_BOOT_VERSION		u_boot_logo
+	IH_OS_U_BOOT		u_boot_hush_start
+
+
+Versioning:
+===========
+
+Starting with the release in October 2008, the names of the releases
+were changed from numerical release numbers without deeper meaning
+into a time stamp based numbering. Regular releases are identified by
+names consisting of the calendar year and month of the release date.
+Additional fields (if present) indicate release candidates or bug fix
+releases in "stable" maintenance trees.
+
+Examples:
+	U-Boot v2009.11	    - Release November 2009
+	U-Boot v2009.11.1   - Release 1 in version November 2009 stable tree
+	U-Boot v2010.09-rc1 - Release candiate 1 for September 2010 release
+
+
+Directory Hierarchy:
+====================
+
+/arch			Architecture specific files
+  /arc			Files generic to ARC architecture
+  /arm			Files generic to ARM architecture
+  /avr32		Files generic to AVR32 architecture
+  /blackfin		Files generic to Analog Devices Blackfin architecture
+  /m68k			Files generic to m68k architecture
+  /microblaze		Files generic to microblaze architecture
+  /mips			Files generic to MIPS architecture
+  /nds32		Files generic to NDS32 architecture
+  /nios2		Files generic to Altera NIOS2 architecture
+  /openrisc		Files generic to OpenRISC architecture
+  /powerpc		Files generic to PowerPC architecture
+  /sandbox		Files generic to HW-independent "sandbox"
+  /sh			Files generic to SH architecture
+  /sparc		Files generic to SPARC architecture
+  /x86			Files generic to x86 architecture
+/api			Machine/arch independent API for external apps
+/board			Board dependent files
+/common			Misc architecture independent functions
+/configs		Board default configuration files
+/disk			Code for disk drive partition handling
+/doc			Documentation (don't expect too much)
+/drivers		Commonly used device drivers
+/dts			Contains Makefile for building internal U-Boot fdt.
+/examples		Example code for standalone applications, etc.
+/fs			Filesystem code (cramfs, ext2, jffs2, etc.)
+/include		Header Files
+/lib			Library routines generic to all architectures
+/Licenses		Various license files
+/net			Networking code
+/post			Power On Self Test
+/scripts		Various build scripts and Makefiles
+/test			Various unit test files
+/tools			Tools to build S-Record or U-Boot images, etc.
+
+Software Configuration:
+=======================
+
+Configuration is usually done using C preprocessor defines; the
+rationale behind that is to avoid dead code whenever possible.
+
+There are two classes of configuration variables:
+
+* Configuration _OPTIONS_:
+  These are selectable by the user and have names beginning with
+  "CONFIG_".
+
+* Configuration _SETTINGS_:
+  These depend on the hardware etc. and should not be meddled with if
+  you don't know what you're doing; they have names beginning with
+  "CONFIG_SYS_".
+
+Previously, all configuration was done by hand, which involved creating
+symbolic links and editing configuration files manually. More recently,
+U-Boot has added the Kbuild infrastructure used by the Linux kernel,
+allowing you to use the "make menuconfig" command to configure your
+build.
+
+
+Selection of Processor Architecture and Board Type:
+---------------------------------------------------
+
+For all supported boards there are ready-to-use default
+configurations available; just type "make <board_name>_defconfig".
+
+Example: For a TQM823L module type:
+
+	cd u-boot
+	make TQM823L_defconfig
+
+Note: If you're looking for the default configuration file for a board
+you're sure used to be there but is now missing, check the file
+doc/README.scrapyard for a list of no longer supported boards.
+
+Sandbox Environment:
+--------------------
+
+U-Boot can be built natively to run on a Linux host using the 'sandbox'
+board. This allows feature development which is not board- or architecture-
+specific to be undertaken on a native platform. The sandbox is also used to
+run some of U-Boot's tests.
+
+See board/sandbox/README.sandbox for more details.
+
+
+Board Initialisation Flow:
+--------------------------
+
+This is the intended start-up flow for boards. This should apply for both
+SPL and U-Boot proper (i.e. they both follow the same rules).
+
+Note: "SPL" stands for "Secondary Program Loader," which is explained in
+more detail later in this file.
+
+At present, SPL mostly uses a separate code path, but the function names
+and roles of each function are the same. Some boards or architectures
+may not conform to this.  At least most ARM boards which use
+CONFIG_SPL_FRAMEWORK conform to this.
+
+Execution typically starts with an architecture-specific (and possibly
+CPU-specific) start.S file, such as:
+
+	- arch/arm/cpu/armv7/start.S
+	- arch/powerpc/cpu/mpc83xx/start.S
+	- arch/mips/cpu/start.S
+
+and so on. From there, three functions are called; the purpose and
+limitations of each of these functions are described below.
+
+lowlevel_init():
+	- purpose: essential init to permit execution to reach board_init_f()
+	- no global_data or BSS
+	- there is no stack (ARMv7 may have one but it will soon be removed)
+	- must not set up SDRAM or use console
+	- must only do the bare minimum to allow execution to continue to
+		board_init_f()
+	- this is almost never needed
+	- return normally from this function
+
+board_init_f():
+	- purpose: set up the machine ready for running board_init_r():
+		i.e. SDRAM and serial UART
+	- global_data is available
+	- stack is in SRAM
+	- BSS is not available, so you cannot use global/static variables,
+		only stack variables and global_data
+
+	Non-SPL-specific notes:
+	- dram_init() is called to set up DRAM. If already done in SPL this
+		can do nothing
+
+	SPL-specific notes:
+	- you can override the entire board_init_f() function with your own
+		version as needed.
+	- preloader_console_init() can be called here in extremis
+	- should set up SDRAM, and anything needed to make the UART work
+	- these is no need to clear BSS, it will be done by crt0.S
+	- must return normally from this function (don't call board_init_r()
+		directly)
+
+Here the BSS is cleared. For SPL, if CONFIG_SPL_STACK_R is defined, then at
+this point the stack and global_data are relocated to below
+CONFIG_SPL_STACK_R_ADDR. For non-SPL, U-Boot is relocated to run at the top of
+memory.
+
+board_init_r():
+	- purpose: main execution, common code
+	- global_data is available
+	- SDRAM is available
+	- BSS is available, all static/global variables can be used
+	- execution eventually continues to main_loop()
+
+	Non-SPL-specific notes:
+	- U-Boot is relocated to the top of memory and is now running from
+		there.
+
+	SPL-specific notes:
+	- stack is optionally in SDRAM, if CONFIG_SPL_STACK_R is defined and
+		CONFIG_SPL_STACK_R_ADDR points into SDRAM
+	- preloader_console_init() can be called here - typically this is
+		done by defining CONFIG_SPL_BOARD_INIT and then supplying a
+		spl_board_init() function containing this call
+	- loads U-Boot or (in falcon mode) Linux
+
+
+
+Configuration Options:
+----------------------
+
+Configuration depends on the combination of board and CPU type; all
+such information is kept in a configuration file
+"include/configs/<board_name>.h".
+
+Example: For a TQM823L module, all configuration settings are in
+"include/configs/TQM823L.h".
+
+
+Many of the options are named exactly as the corresponding Linux
+kernel configuration options. The intention is to make it easier to
+build a config tool - later.
+
+
+The following options need to be configured:
+
+- CPU Type:	Define exactly one, e.g. CONFIG_MPC85XX.
+
+- Board Type:	Define exactly one, e.g. CONFIG_MPC8540ADS.
+
+- CPU Daughterboard Type: (if CONFIG_ATSTK1000 is defined)
+		Define exactly one, e.g. CONFIG_ATSTK1002
+
+- CPU Module Type: (if CONFIG_COGENT is defined)
+		Define exactly one of
+		CONFIG_CMA286_60_OLD
+--- FIXME --- not tested yet:
+		CONFIG_CMA286_60, CONFIG_CMA286_21, CONFIG_CMA286_60P,
+		CONFIG_CMA287_23, CONFIG_CMA287_50
+
+- Motherboard Type: (if CONFIG_COGENT is defined)
+		Define exactly one of
+		CONFIG_CMA101, CONFIG_CMA102
+
+- Motherboard I/O Modules: (if CONFIG_COGENT is defined)
+		Define one or more of
+		CONFIG_CMA302
+
+- Motherboard Options: (if CONFIG_CMA101 or CONFIG_CMA102 are defined)
+		Define one or more of
+		CONFIG_LCD_HEARTBEAT	- update a character position on
+					  the LCD display every second with
+					  a "rotator" |\-/|\-/
+
+- Marvell Family Member
+		CONFIG_SYS_MVFS		- define it if you want to enable
+					  multiple fs option at one time
+					  for marvell soc family
+
+- 8xx CPU Options: (if using an MPC8xx CPU)
+		CONFIG_8xx_GCLK_FREQ	- deprecated: CPU clock if
+					  get_gclk_freq() cannot work
+					  e.g. if there is no 32KHz
+					  reference PIT/RTC clock
+		CONFIG_8xx_OSCLK	- PLL input clock (either EXTCLK
+					  or XTAL/EXTAL)
+
+- 859/866/885 CPU options: (if using a MPC859 or MPC866 or MPC885 CPU):
+		CONFIG_SYS_8xx_CPUCLK_MIN
+		CONFIG_SYS_8xx_CPUCLK_MAX
+		CONFIG_8xx_CPUCLK_DEFAULT
+			See doc/README.MPC866
+
+		CONFIG_SYS_MEASURE_CPUCLK
+
+		Define this to measure the actual CPU clock instead
+		of relying on the correctness of the configured
+		values. Mostly useful for board bringup to make sure
+		the PLL is locked at the intended frequency. Note
+		that this requires a (stable) reference clock (32 kHz
+		RTC clock or CONFIG_SYS_8XX_XIN)
+
+		CONFIG_SYS_DELAYED_ICACHE
+
+		Define this option if you want to enable the
+		ICache only when Code runs from RAM.
+
+- 85xx CPU Options:
+		CONFIG_SYS_PPC64
+
+		Specifies that the core is a 64-bit PowerPC implementation (implements
+		the "64" category of the Power ISA). This is necessary for ePAPR
+		compliance, among other possible reasons.
+
+		CONFIG_SYS_FSL_TBCLK_DIV
+
+		Defines the core time base clock divider ratio compared to the
+		system clock.  On most PQ3 devices this is 8, on newer QorIQ
+		devices it can be 16 or 32.  The ratio varies from SoC to Soc.
+
+		CONFIG_SYS_FSL_PCIE_COMPAT
+
+		Defines the string to utilize when trying to match PCIe device
+		tree nodes for the given platform.
+
+		CONFIG_SYS_PPC_E500_DEBUG_TLB
+
+		Enables a temporary TLB entry to be used during boot to work
+		around limitations in e500v1 and e500v2 external debugger
+		support. This reduces the portions of the boot code where
+		breakpoints and single stepping do not work.  The value of this
+		symbol should be set to the TLB1 entry to be used for this
+		purpose.
+
+		CONFIG_SYS_FSL_ERRATUM_A004510
+
+		Enables a workaround for erratum A004510.  If set,
+		then CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV and
+		CONFIG_SYS_FSL_CORENET_SNOOPVEC_COREONLY must be set.
+
+		CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV
+		CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV2 (optional)
+
+		Defines one or two SoC revisions (low 8 bits of SVR)
+		for which the A004510 workaround should be applied.
+
+		The rest of SVR is either not relevant to the decision
+		of whether the erratum is present (e.g. p2040 versus
+		p2041) or is implied by the build target, which controls
+		whether CONFIG_SYS_FSL_ERRATUM_A004510 is set.
+
+		See Freescale App Note 4493 for more information about
+		this erratum.
+
+		CONFIG_A003399_NOR_WORKAROUND
+		Enables a workaround for IFC erratum A003399. It is only
+		required during NOR boot.
+
+		CONFIG_A008044_WORKAROUND
+		Enables a workaround for T1040/T1042 erratum A008044. It is only
+		required during NAND boot and valid for Rev 1.0 SoC revision
+
+		CONFIG_SYS_FSL_CORENET_SNOOPVEC_COREONLY
+
+		This is the value to write into CCSR offset 0x18600
+		according to the A004510 workaround.
+
+		CONFIG_SYS_FSL_DSP_DDR_ADDR
+		This value denotes start offset of DDR memory which is
+		connected exclusively to the DSP cores.
+
+		CONFIG_SYS_FSL_DSP_M2_RAM_ADDR
+		This value denotes start offset of M2 memory
+		which is directly connected to the DSP core.
+
+		CONFIG_SYS_FSL_DSP_M3_RAM_ADDR
+		This value denotes start offset of M3 memory which is directly
+		connected to the DSP core.
+
+		CONFIG_SYS_FSL_DSP_CCSRBAR_DEFAULT
+		This value denotes start offset of DSP CCSR space.
+
+		CONFIG_SYS_FSL_SINGLE_SOURCE_CLK
+		Single Source Clock is clocking mode present in some of FSL SoC's.
+		In this mode, a single differential clock is used to supply
+		clocks to the sysclock, ddrclock and usbclock.
+
+		CONFIG_SYS_CPC_REINIT_F
+		This CONFIG is defined when the CPC is configured as SRAM at the
+		time of U-Boot entry and is required to be re-initialized.
+
+		CONFIG_DEEP_SLEEP
+		Indicates this SoC supports deep sleep feature. If deep sleep is
+		supported, core will start to execute uboot when wakes up.
+
+- Generic CPU options:
+		CONFIG_SYS_GENERIC_GLOBAL_DATA
+		Defines global data is initialized in generic board board_init_f().
+		If this macro is defined, global data is created and cleared in
+		generic board board_init_f(). Without this macro, architecture/board
+		should initialize global data before calling board_init_f().
+
+		CONFIG_SYS_BIG_ENDIAN, CONFIG_SYS_LITTLE_ENDIAN
+
+		Defines the endianess of the CPU. Implementation of those
+		values is arch specific.
+
+		CONFIG_SYS_FSL_DDR
+		Freescale DDR driver in use. This type of DDR controller is
+		found in mpc83xx, mpc85xx, mpc86xx as well as some ARM core
+		SoCs.
+
+		CONFIG_SYS_FSL_DDR_ADDR
+		Freescale DDR memory-mapped register base.
+
+		CONFIG_SYS_FSL_DDR_EMU
+		Specify emulator support for DDR. Some DDR features such as
+		deskew training are not available.
+
+		CONFIG_SYS_FSL_DDRC_GEN1
+		Freescale DDR1 controller.
+
+		CONFIG_SYS_FSL_DDRC_GEN2
+		Freescale DDR2 controller.
+
+		CONFIG_SYS_FSL_DDRC_GEN3
+		Freescale DDR3 controller.
+
+		CONFIG_SYS_FSL_DDRC_GEN4
+		Freescale DDR4 controller.
+
+		CONFIG_SYS_FSL_DDRC_ARM_GEN3
+		Freescale DDR3 controller for ARM-based SoCs.
+
+		CONFIG_SYS_FSL_DDR1
+		Board config to use DDR1. It can be enabled for SoCs with
+		Freescale DDR1 or DDR2 controllers, depending on the board
+		implemetation.
+
+		CONFIG_SYS_FSL_DDR2
+		Board config to use DDR2. It can be eanbeld for SoCs with
+		Freescale DDR2 or DDR3 controllers, depending on the board
+		implementation.
+
+		CONFIG_SYS_FSL_DDR3
+		Board config to use DDR3. It can be enabled for SoCs with
+		Freescale DDR3 or DDR3L controllers.
+
+		CONFIG_SYS_FSL_DDR3L
+		Board config to use DDR3L. It can be enabled for SoCs with
+		DDR3L controllers.
+
+		CONFIG_SYS_FSL_DDR4
+		Board config to use DDR4. It can be enabled for SoCs with
+		DDR4 controllers.
+
+		CONFIG_SYS_FSL_IFC_BE
+		Defines the IFC controller register space as Big Endian
+
+		CONFIG_SYS_FSL_IFC_LE
+		Defines the IFC controller register space as Little Endian
+
+		CONFIG_SYS_FSL_PBL_PBI
+		It enables addition of RCW (Power on reset configuration) in built image.
+		Please refer doc/README.pblimage for more details
+
+		CONFIG_SYS_FSL_PBL_RCW
+		It adds PBI(pre-boot instructions) commands in u-boot build image.
+		PBI commands can be used to configure SoC before it starts the execution.
+		Please refer doc/README.pblimage for more details
+
+		CONFIG_SPL_FSL_PBL
+		It adds a target to create boot binary having SPL binary in PBI format
+		concatenated with u-boot binary.
+
+		CONFIG_SYS_FSL_DDR_BE
+		Defines the DDR controller register space as Big Endian
+
+		CONFIG_SYS_FSL_DDR_LE
+		Defines the DDR controller register space as Little Endian
+
+		CONFIG_SYS_FSL_DDR_SDRAM_BASE_PHY
+		Physical address from the view of DDR controllers. It is the
+		same as CONFIG_SYS_DDR_SDRAM_BASE for  all Power SoCs. But
+		it could be different for ARM SoCs.
+
+		CONFIG_SYS_FSL_DDR_INTLV_256B
+		DDR controller interleaving on 256-byte. This is a special
+		interleaving mode, handled by Dickens for Freescale layerscape
+		SoCs with ARM core.
+
+		CONFIG_SYS_FSL_DDR_MAIN_NUM_CTRLS
+		Number of controllers used as main memory.
+
+		CONFIG_SYS_FSL_OTHER_DDR_NUM_CTRLS
+		Number of controllers used for other than main memory.
+
+		CONFIG_SYS_FSL_HAS_DP_DDR
+		Defines the SoC has DP-DDR used for DPAA.
+
+		CONFIG_SYS_FSL_SEC_BE
+		Defines the SEC controller register space as Big Endian
+
+		CONFIG_SYS_FSL_SEC_LE
+		Defines the SEC controller register space as Little Endian
+
+- Intel Monahans options:
+		CONFIG_SYS_MONAHANS_RUN_MODE_OSC_RATIO
+
+		Defines the Monahans run mode to oscillator
+		ratio. Valid values are 8, 16, 24, 31. The core
+		frequency is this value multiplied by 13 MHz.
+
+		CONFIG_SYS_MONAHANS_TURBO_RUN_MODE_RATIO
+
+		Defines the Monahans turbo mode to oscillator
+		ratio. Valid values are 1 (default if undefined) and
+		2. The core frequency as calculated above is multiplied
+		by this value.
+
+- MIPS CPU options:
+		CONFIG_SYS_INIT_SP_OFFSET
+
+		Offset relative to CONFIG_SYS_SDRAM_BASE for initial stack
+		pointer. This is needed for the temporary stack before
+		relocation.
+
+		CONFIG_SYS_MIPS_CACHE_MODE
+
+		Cache operation mode for the MIPS CPU.
+		See also arch/mips/include/asm/mipsregs.h.
+		Possible values are:
+			CONF_CM_CACHABLE_NO_WA
+			CONF_CM_CACHABLE_WA
+			CONF_CM_UNCACHED
+			CONF_CM_CACHABLE_NONCOHERENT
+			CONF_CM_CACHABLE_CE
+			CONF_CM_CACHABLE_COW
+			CONF_CM_CACHABLE_CUW
+			CONF_CM_CACHABLE_ACCELERATED
+
+		CONFIG_SYS_XWAY_EBU_BOOTCFG
+
+		Special option for Lantiq XWAY SoCs for booting from NOR flash.
+		See also arch/mips/cpu/mips32/start.S.
+
+		CONFIG_XWAY_SWAP_BYTES
+
+		Enable compilation of tools/xway-swap-bytes needed for Lantiq
+		XWAY SoCs for booting from NOR flash. The U-Boot image needs to
+		be swapped if a flash programmer is used.
+
+- ARM options:
+		CONFIG_SYS_EXCEPTION_VECTORS_HIGH
+
+		Select high exception vectors of the ARM core, e.g., do not
+		clear the V bit of the c1 register of CP15.
+
+		CONFIG_SYS_THUMB_BUILD
+
+		Use this flag to build U-Boot using the Thumb instruction
+		set for ARM architectures. Thumb instruction set provides
+		better code density. For ARM architectures that support
+		Thumb2 this flag will result in Thumb2 code generated by
+		GCC.
+
+		CONFIG_ARM_ERRATA_716044
+		CONFIG_ARM_ERRATA_742230
+		CONFIG_ARM_ERRATA_743622
+		CONFIG_ARM_ERRATA_751472
+		CONFIG_ARM_ERRATA_761320
+		CONFIG_ARM_ERRATA_773022
+		CONFIG_ARM_ERRATA_774769
+		CONFIG_ARM_ERRATA_794072
+		CONFIG_ARM_ERRATA_845369
+
+		If set, the workarounds for these ARM errata are applied early
+		during U-Boot startup. Note that these options force the
+		workarounds to be applied; no CPU-type/version detection
+		exists, unlike the similar options in the Linux kernel. Do not
+		set these options unless they apply!
+
+		COUNTER_FREQUENCY
+		Generic timer clock source frequency.
+
+		COUNTER_FREQUENCY_REAL
+		Generic timer clock source frequency if the real clock is
+		different from COUNTER_FREQUENCY, and can only be determined
+		at run time.
+
+		NOTE: The following can be machine specific errata. These
+		do have ability to provide rudimentary version and machine
+		specific checks, but expect no product checks.
+		CONFIG_ARM_ERRATA_430973
+		CONFIG_ARM_ERRATA_454179
+		CONFIG_ARM_ERRATA_621766
+		CONFIG_ARM_ERRATA_798870
+		CONFIG_ARM_ERRATA_801819
+
+- Tegra SoC options:
+		CONFIG_TEGRA_SUPPORT_NON_SECURE
+
+		Support executing U-Boot in non-secure (NS) mode. Certain
+		impossible actions will be skipped if the CPU is in NS mode,
+		such as ARM architectural timer initialization.
+
+- Linux Kernel Interface:
+		CONFIG_CLOCKS_IN_MHZ
+
+		U-Boot stores all clock information in Hz
+		internally. For binary compatibility with older Linux
+		kernels (which expect the clocks passed in the
+		bd_info data to be in MHz) the environment variable
+		"clocks_in_mhz" can be defined so that U-Boot
+		converts clock data to MHZ before passing it to the
+		Linux kernel.
+		When CONFIG_CLOCKS_IN_MHZ is defined, a definition of
+		"clocks_in_mhz=1" is automatically included in the
+		default environment.
+
+		CONFIG_MEMSIZE_IN_BYTES		[relevant for MIPS only]
+
+		When transferring memsize parameter to Linux, some versions
+		expect it to be in bytes, others in MB.
+		Define CONFIG_MEMSIZE_IN_BYTES to make it in bytes.
+
+		CONFIG_OF_LIBFDT
+
+		New kernel versions are expecting firmware settings to be
+		passed using flattened device trees (based on open firmware
+		concepts).
+
+		CONFIG_OF_LIBFDT
+		 * New libfdt-based support
+		 * Adds the "fdt" command
+		 * The bootm command automatically updates the fdt
+
+		OF_CPU - The proper name of the cpus node (only required for
+			MPC512X and MPC5xxx based boards).
+		OF_SOC - The proper name of the soc node (only required for
+			MPC512X and MPC5xxx based boards).
+		OF_TBCLK - The timebase frequency.
+		OF_STDOUT_PATH - The path to the console device
+
+		boards with QUICC Engines require OF_QE to set UCC MAC
+		addresses
+
+		CONFIG_OF_BOARD_SETUP
+
+		Board code has addition modification that it wants to make
+		to the flat device tree before handing it off to the kernel
+
+		CONFIG_OF_SYSTEM_SETUP
+
+		Other code has addition modification that it wants to make
+		to the flat device tree before handing it off to the kernel.
+		This causes ft_system_setup() to be called before booting
+		the kernel.
+
+		CONFIG_OF_BOOT_CPU
+
+		This define fills in the correct boot CPU in the boot
+		param header, the default value is zero if undefined.
+
+		CONFIG_OF_IDE_FIXUP
+
+		U-Boot can detect if an IDE device is present or not.
+		If not, and this new config option is activated, U-Boot
+		removes the ATA node from the DTS before booting Linux,
+		so the Linux IDE driver does not probe the device and
+		crash. This is needed for buggy hardware (uc101) where
+		no pull down resistor is connected to the signal IDE5V_DD7.
+
+		CONFIG_MACH_TYPE	[relevant for ARM only][mandatory]
+
+		This setting is mandatory for all boards that have only one
+		machine type and must be used to specify the machine type
+		number as it appears in the ARM machine registry
+		(see http://www.arm.linux.org.uk/developer/machines/).
+		Only boards that have multiple machine types supported
+		in a single configuration file and the machine type is
+		runtime discoverable, do not have to use this setting.
+
+- vxWorks boot parameters:
+
+		bootvx constructs a valid bootline using the following
+		environments variables: bootdev, bootfile, ipaddr, netmask,
+		serverip, gatewayip, hostname, othbootargs.
+		It loads the vxWorks image pointed bootfile.
+
+		Note: If a "bootargs" environment is defined, it will overwride
+		the defaults discussed just above.
+
+- Cache Configuration:
+		CONFIG_SYS_ICACHE_OFF - Do not enable instruction cache in U-Boot
+		CONFIG_SYS_DCACHE_OFF - Do not enable data cache in U-Boot
+		CONFIG_SYS_L2CACHE_OFF- Do not enable L2 cache in U-Boot
+
+- Cache Configuration for ARM:
+		CONFIG_SYS_L2_PL310 - Enable support for ARM PL310 L2 cache
+				      controller
+		CONFIG_SYS_PL310_BASE - Physical base address of PL310
+					controller register space
+
+- Serial Ports:
+		CONFIG_PL010_SERIAL
+
+		Define this if you want support for Amba PrimeCell PL010 UARTs.
+
+		CONFIG_PL011_SERIAL
+
+		Define this if you want support for Amba PrimeCell PL011 UARTs.
+
+		CONFIG_PL011_CLOCK
+
+		If you have Amba PrimeCell PL011 UARTs, set this variable to
+		the clock speed of the UARTs.
+
+		CONFIG_PL01x_PORTS
+
+		If you have Amba PrimeCell PL010 or PL011 UARTs on your board,
+		define this to a list of base addresses for each (supported)
+		port. See e.g. include/configs/versatile.h
+
+		CONFIG_SERIAL_HW_FLOW_CONTROL
+
+		Define this variable to enable hw flow control in serial driver.
+		Current user of this option is drivers/serial/nsl16550.c driver
+
+- Console Interface:
+		Depending on board, define exactly one serial port
+		(like CONFIG_8xx_CONS_SMC1, CONFIG_8xx_CONS_SMC2,
+		CONFIG_8xx_CONS_SCC1, ...), or switch off the serial
+		console by defining CONFIG_8xx_CONS_NONE
+
+		Note: if CONFIG_8xx_CONS_NONE is defined, the serial
+		port routines must be defined elsewhere
+		(i.e. serial_init(), serial_getc(), ...)
+
+		CONFIG_CFB_CONSOLE
+		Enables console device for a color framebuffer. Needs following
+		defines (cf. smiLynxEM, i8042)
+			VIDEO_FB_LITTLE_ENDIAN	graphic memory organisation
+						(default big endian)
+			VIDEO_HW_RECTFILL	graphic chip supports
+						rectangle fill
+						(cf. smiLynxEM)
+			VIDEO_HW_BITBLT		graphic chip supports
+						bit-blit (cf. smiLynxEM)
+			VIDEO_VISIBLE_COLS	visible pixel columns
+						(cols=pitch)
+			VIDEO_VISIBLE_ROWS	visible pixel rows
+			VIDEO_PIXEL_SIZE	bytes per pixel
+			VIDEO_DATA_FORMAT	graphic data format
+						(0-5, cf. cfb_console.c)
+			VIDEO_FB_ADRS		framebuffer address
+			VIDEO_KBD_INIT_FCT	keyboard int fct
+						(i.e. rx51_kp_init())
+			VIDEO_TSTC_FCT		test char fct
+						(i.e. rx51_kp_tstc)
+			VIDEO_GETC_FCT		get char fct
+						(i.e. rx51_kp_getc)
+			CONFIG_VIDEO_LOGO	display Linux logo in
+						upper left corner
+			CONFIG_VIDEO_BMP_LOGO	use bmp_logo.h instead of
+						linux_logo.h for logo.
+						Requires CONFIG_VIDEO_LOGO
+			CONFIG_CONSOLE_EXTRA_INFO
+						additional board info beside
+						the logo
+
+		When CONFIG_CFB_CONSOLE_ANSI is defined, console will support
+		a limited number of ANSI escape sequences (cursor control,
+		erase functions and limited graphics rendition control).
+
+		When CONFIG_CFB_CONSOLE is defined, video console is
+		default i/o. Serial console can be forced with
+		environment 'console=serial'.
+
+		When CONFIG_SILENT_CONSOLE is defined, all console
+		messages (by U-Boot and Linux!) can be silenced with
+		the "silent" environment variable. See
+		doc/README.silent for more information.
+
+		CONFIG_SYS_CONSOLE_BG_COL: define the backgroundcolor, default
+			is 0x00.
+		CONFIG_SYS_CONSOLE_FG_COL: define the foregroundcolor, default
+			is 0xa0.
+
+- Console Baudrate:
+		CONFIG_BAUDRATE - in bps
+		Select one of the baudrates listed in
+		CONFIG_SYS_BAUDRATE_TABLE, see below.
+		CONFIG_SYS_BRGCLK_PRESCALE, baudrate prescale
+
+- Console Rx buffer length
+		With CONFIG_SYS_SMC_RXBUFLEN it is possible to define
+		the maximum receive buffer length for the SMC.
+		This option is actual only for 82xx and 8xx possible.
+		If using CONFIG_SYS_SMC_RXBUFLEN also CONFIG_SYS_MAXIDLE
+		must be defined, to setup the maximum idle timeout for
+		the SMC.
+
+- Pre-Console Buffer:
+		Prior to the console being initialised (i.e. serial UART
+		initialised etc) all console output is silently discarded.
+		Defining CONFIG_PRE_CONSOLE_BUFFER will cause U-Boot to
+		buffer any console messages prior to the console being
+		initialised to a buffer of size CONFIG_PRE_CON_BUF_SZ
+		bytes located at CONFIG_PRE_CON_BUF_ADDR. The buffer is
+		a circular buffer, so if more than CONFIG_PRE_CON_BUF_SZ
+		bytes are output before the console is initialised, the
+		earlier bytes are discarded.
+
+		Note that when printing the buffer a copy is made on the
+		stack so CONFIG_PRE_CON_BUF_SZ must fit on the stack.
+
+		'Sane' compilers will generate smaller code if
+		CONFIG_PRE_CON_BUF_SZ is a power of 2
+
+- Boot Delay:	CONFIG_BOOTDELAY - in seconds
+		Delay before automatically booting the default image;
+		set to -1 to disable autoboot.
+		set to -2 to autoboot with no delay and not check for abort
+		(even when CONFIG_ZERO_BOOTDELAY_CHECK is defined).
+
+		See doc/README.autoboot for these options that
+		work with CONFIG_BOOTDELAY. None are required.
+		CONFIG_BOOT_RETRY_TIME
+		CONFIG_BOOT_RETRY_MIN
+		CONFIG_AUTOBOOT_KEYED
+		CONFIG_AUTOBOOT_PROMPT
+		CONFIG_AUTOBOOT_DELAY_STR
+		CONFIG_AUTOBOOT_STOP_STR
+		CONFIG_ZERO_BOOTDELAY_CHECK
+		CONFIG_RESET_TO_RETRY
+
+- Autoboot Command:
+		CONFIG_BOOTCOMMAND
+		Only needed when CONFIG_BOOTDELAY is enabled;
+		define a command string that is automatically executed
+		when no character is read on the console interface
+		within "Boot Delay" after reset.
+
+		CONFIG_BOOTARGS
+		This can be used to pass arguments to the bootm
+		command. The value of CONFIG_BOOTARGS goes into the
+		environment value "bootargs".
+
+		CONFIG_RAMBOOT and CONFIG_NFSBOOT
+		The value of these goes into the environment as
+		"ramboot" and "nfsboot" respectively, and can be used
+		as a convenience, when switching between booting from
+		RAM and NFS.
+
+- Bootcount:
+		CONFIG_BOOTCOUNT_LIMIT
+		Implements a mechanism for detecting a repeating reboot
+		cycle, see:
+		http://www.denx.de/wiki/view/DULG/UBootBootCountLimit
+
+		CONFIG_BOOTCOUNT_ENV
+		If no softreset save registers are found on the hardware
+		"bootcount" is stored in the environment. To prevent a
+		saveenv on all reboots, the environment variable
+		"upgrade_available" is used. If "upgrade_available" is
+		0, "bootcount" is always 0, if "upgrade_available" is
+		1 "bootcount" is incremented in the environment.
+		So the Userspace Applikation must set the "upgrade_available"
+		and "bootcount" variable to 0, if a boot was successfully.
+
+- Pre-Boot Commands:
+		CONFIG_PREBOOT
+
+		When this option is #defined, the existence of the
+		environment variable "preboot" will be checked
+		immediately before starting the CONFIG_BOOTDELAY
+		countdown and/or running the auto-boot command resp.
+		entering interactive mode.
+
+		This feature is especially useful when "preboot" is
+		automatically generated or modified. For an example
+		see the LWMON board specific code: here "preboot" is
+		modified when the user holds down a certain
+		combination of keys on the (special) keyboard when
+		booting the systems
+
+- Serial Download Echo Mode:
+		CONFIG_LOADS_ECHO
+		If defined to 1, all characters received during a
+		serial download (using the "loads" command) are
+		echoed back. This might be needed by some terminal
+		emulations (like "cu"), but may as well just take
+		time on others. This setting #define's the initial
+		value of the "loads_echo" environment variable.
+
+- Kgdb Serial Baudrate: (if CONFIG_CMD_KGDB is defined)
+		CONFIG_KGDB_BAUDRATE
+		Select one of the baudrates listed in
+		CONFIG_SYS_BAUDRATE_TABLE, see below.
+
+- Monitor Functions:
+		Monitor commands can be included or excluded
+		from the build by using the #include files
+		<config_cmd_all.h> and #undef'ing unwanted
+		commands, or adding #define's for wanted commands.
+
+		The default command configuration includes all commands
+		except those marked below with a "*".
+
+		CONFIG_CMD_AES		  AES 128 CBC encrypt/decrypt
+		CONFIG_CMD_ASKENV	* ask for env variable
+		CONFIG_CMD_BDI		  bdinfo
+		CONFIG_CMD_BEDBUG	* Include BedBug Debugger
+		CONFIG_CMD_BMP		* BMP support
+		CONFIG_CMD_BSP		* Board specific commands
+		CONFIG_CMD_BOOTD	  bootd
+		CONFIG_CMD_BOOTI	* ARM64 Linux kernel Image support
+		CONFIG_CMD_CACHE	* icache, dcache
+		CONFIG_CMD_CLK   	* clock command support
+		CONFIG_CMD_CONSOLE	  coninfo
+		CONFIG_CMD_CRC32	* crc32
+		CONFIG_CMD_DATE		* support for RTC, date/time...
+		CONFIG_CMD_DHCP		* DHCP support
+		CONFIG_CMD_DIAG		* Diagnostics
+		CONFIG_CMD_DS4510	* ds4510 I2C gpio commands
+		CONFIG_CMD_DS4510_INFO	* ds4510 I2C info command
+		CONFIG_CMD_DS4510_MEM	* ds4510 I2C eeprom/sram commansd
+		CONFIG_CMD_DS4510_RST	* ds4510 I2C rst command
+		CONFIG_CMD_DTT		* Digital Therm and Thermostat
+		CONFIG_CMD_ECHO		  echo arguments
+		CONFIG_CMD_EDITENV	  edit env variable
+		CONFIG_CMD_EEPROM	* EEPROM read/write support
+		CONFIG_CMD_ELF		* bootelf, bootvx
+		CONFIG_CMD_ENV_CALLBACK	* display details about env callbacks
+		CONFIG_CMD_ENV_FLAGS	* display details about env flags
+		CONFIG_CMD_ENV_EXISTS	* check existence of env variable
+		CONFIG_CMD_EXPORTENV	* export the environment
+		CONFIG_CMD_EXT2		* ext2 command support
+		CONFIG_CMD_EXT4		* ext4 command support
+		CONFIG_CMD_FS_GENERIC	* filesystem commands (e.g. load, ls)
+					  that work for multiple fs types
+		CONFIG_CMD_FS_UUID	* Look up a filesystem UUID
+		CONFIG_CMD_SAVEENV	  saveenv
+		CONFIG_CMD_FDC		* Floppy Disk Support
+		CONFIG_CMD_FAT		* FAT command support
+		CONFIG_CMD_FLASH	  flinfo, erase, protect
+		CONFIG_CMD_FPGA		  FPGA device initialization support
+		CONFIG_CMD_FUSE		* Device fuse support
+		CONFIG_CMD_GETTIME	* Get time since boot
+		CONFIG_CMD_GO		* the 'go' command (exec code)
+		CONFIG_CMD_GREPENV	* search environment
+		CONFIG_CMD_HASH		* calculate hash / digest
+		CONFIG_CMD_I2C		* I2C serial bus support
+		CONFIG_CMD_IDE		* IDE harddisk support
+		CONFIG_CMD_IMI		  iminfo
+		CONFIG_CMD_IMLS		  List all images found in NOR flash
+		CONFIG_CMD_IMLS_NAND	* List all images found in NAND flash
+		CONFIG_CMD_IMMAP	* IMMR dump support
+		CONFIG_CMD_IOTRACE	* I/O tracing for debugging
+		CONFIG_CMD_IMPORTENV	* import an environment
+		CONFIG_CMD_INI		* import data from an ini file into the env
+		CONFIG_CMD_IRQ		* irqinfo
+		CONFIG_CMD_ITEST	  Integer/string test of 2 values
+		CONFIG_CMD_JFFS2	* JFFS2 Support
+		CONFIG_CMD_KGDB		* kgdb
+		CONFIG_CMD_LDRINFO	* ldrinfo (display Blackfin loader)
+		CONFIG_CMD_LINK_LOCAL	* link-local IP address auto-configuration
+					  (169.254.*.*)
+		CONFIG_CMD_LOADB	  loadb
+		CONFIG_CMD_LOADS	  loads
+		CONFIG_CMD_MD5SUM	* print md5 message digest
+					  (requires CONFIG_CMD_MEMORY and CONFIG_MD5)
+		CONFIG_CMD_MEMINFO	* Display detailed memory information
+		CONFIG_CMD_MEMORY	  md, mm, nm, mw, cp, cmp, crc, base,
+					  loop, loopw
+		CONFIG_CMD_MEMTEST	* mtest
+		CONFIG_CMD_MISC		  Misc functions like sleep etc
+		CONFIG_CMD_MMC		* MMC memory mapped support
+		CONFIG_CMD_MII		* MII utility commands
+		CONFIG_CMD_MTDPARTS	* MTD partition support
+		CONFIG_CMD_NAND		* NAND support
+		CONFIG_CMD_NET		  bootp, tftpboot, rarpboot
+		CONFIG_CMD_NFS		  NFS support
+		CONFIG_CMD_PCA953X	* PCA953x I2C gpio commands
+		CONFIG_CMD_PCA953X_INFO * PCA953x I2C gpio info command
+		CONFIG_CMD_PCI		* pciinfo
+		CONFIG_CMD_PCMCIA		* PCMCIA support
+		CONFIG_CMD_PING		* send ICMP ECHO_REQUEST to network
+					  host
+		CONFIG_CMD_PORTIO	* Port I/O
+		CONFIG_CMD_READ		* Read raw data from partition
+		CONFIG_CMD_REGINFO	* Register dump
+		CONFIG_CMD_RUN		  run command in env variable
+		CONFIG_CMD_SANDBOX	* sb command to access sandbox features
+		CONFIG_CMD_SAVES	* save S record dump
+		CONFIG_CMD_SCSI		* SCSI Support
+		CONFIG_CMD_SDRAM	* print SDRAM configuration information
+					  (requires CONFIG_CMD_I2C)
+		CONFIG_CMD_SETGETDCR	  Support for DCR Register access
+					  (4xx only)
+		CONFIG_CMD_SF		* Read/write/erase SPI NOR flash
+		CONFIG_CMD_SHA1SUM	* print sha1 memory digest
+					  (requires CONFIG_CMD_MEMORY)
+		CONFIG_CMD_SOFTSWITCH	* Soft switch setting command for BF60x
+		CONFIG_CMD_SOURCE	  "source" command Support
+		CONFIG_CMD_SPI		* SPI serial bus support
+		CONFIG_CMD_TFTPSRV	* TFTP transfer in server mode
+		CONFIG_CMD_TFTPPUT	* TFTP put command (upload)
+		CONFIG_CMD_TIME		* run command and report execution time (ARM specific)
+		CONFIG_CMD_TIMER	* access to the system tick timer
+		CONFIG_CMD_USB		* USB support
+		CONFIG_CMD_CDP		* Cisco Discover Protocol support
+		CONFIG_CMD_MFSL		* Microblaze FSL support
+		CONFIG_CMD_XIMG		  Load part of Multi Image
+		CONFIG_CMD_UUID		* Generate random UUID or GUID string
+
+		EXAMPLE: If you want all functions except of network
+		support you can write:
+
+		#include "config_cmd_all.h"
+		#undef CONFIG_CMD_NET
+
+	Other Commands:
+		fdt (flattened device tree) command: CONFIG_OF_LIBFDT
+
+	Note:	Don't enable the "icache" and "dcache" commands
+		(configuration option CONFIG_CMD_CACHE) unless you know
+		what you (and your U-Boot users) are doing. Data
+		cache cannot be enabled on systems like the 8xx or
+		8260 (where accesses to the IMMR region must be
+		uncached), and it cannot be disabled on all other
+		systems where we (mis-) use the data cache to hold an
+		initial stack and some data.
+
+
+		XXX - this list needs to get updated!
+
+- Regular expression support:
+		CONFIG_REGEX
+		If this variable is defined, U-Boot is linked against
+		the SLRE (Super Light Regular Expression) library,
+		which adds regex support to some commands, as for
+		example "env grep" and "setexpr".
+
+- Device tree:
+		CONFIG_OF_CONTROL
+		If this variable is defined, U-Boot will use a device tree
+		to configure its devices, instead of relying on statically
+		compiled #defines in the board file. This option is
+		experimental and only available on a few boards. The device
+		tree is available in the global data as gd->fdt_blob.
+
+		U-Boot needs to get its device tree from somewhere. This can
+		be done using one of the two options below:
+
+		CONFIG_OF_EMBED
+		If this variable is defined, U-Boot will embed a device tree
+		binary in its image. This device tree file should be in the
+		board directory and called <soc>-<board>.dts. The binary file
+		is then picked up in board_init_f() and made available through
+		the global data structure as gd->blob.
+
+		CONFIG_OF_SEPARATE
+		If this variable is defined, U-Boot will build a device tree
+		binary. It will be called u-boot.dtb. Architecture-specific
+		code will locate it at run-time. Generally this works by:
+
+			cat u-boot.bin u-boot.dtb >image.bin
+
+		and in fact, U-Boot does this for you, creating a file called
+		u-boot-dtb.bin which is useful in the common case. You can
+		still use the individual files if you need something more
+		exotic.
+
+- Watchdog:
+		CONFIG_WATCHDOG
+		If this variable is defined, it enables watchdog
+		support for the SoC. There must be support in the SoC
+		specific code for a watchdog. For the 8xx and 8260
+		CPUs, the SIU Watchdog feature is enabled in the SYPCR
+		register.  When supported for a specific SoC is
+		available, then no further board specific code should
+		be needed to use it.
+
+		CONFIG_HW_WATCHDOG
+		When using a watchdog circuitry external to the used
+		SoC, then define this variable and provide board
+		specific code for the "hw_watchdog_reset" function.
+
+		CONFIG_AT91_HW_WDT_TIMEOUT
+		specify the timeout in seconds. default 2 seconds.
+
+- U-Boot Version:
+		CONFIG_VERSION_VARIABLE
+		If this variable is defined, an environment variable
+		named "ver" is created by U-Boot showing the U-Boot
+		version as printed by the "version" command.
+		Any change to this variable will be reverted at the
+		next reset.
+
+- Real-Time Clock:
+
+		When CONFIG_CMD_DATE is selected, the type of the RTC
+		has to be selected, too. Define exactly one of the
+		following options:
+
+		CONFIG_RTC_MPC8xx	- use internal RTC of MPC8xx
+		CONFIG_RTC_PCF8563	- use Philips PCF8563 RTC
+		CONFIG_RTC_MC13XXX	- use MC13783 or MC13892 RTC
+		CONFIG_RTC_MC146818	- use MC146818 RTC
+		CONFIG_RTC_DS1307	- use Maxim, Inc. DS1307 RTC
+		CONFIG_RTC_DS1337	- use Maxim, Inc. DS1337 RTC
+		CONFIG_RTC_DS1338	- use Maxim, Inc. DS1338 RTC
+		CONFIG_RTC_DS1339	- use Maxim, Inc. DS1339 RTC
+		CONFIG_RTC_DS164x	- use Dallas DS164x RTC
+		CONFIG_RTC_ISL1208	- use Intersil ISL1208 RTC
+		CONFIG_RTC_MAX6900	- use Maxim, Inc. MAX6900 RTC
+		CONFIG_SYS_RTC_DS1337_NOOSC	- Turn off the OSC output for DS1337
+		CONFIG_SYS_RV3029_TCR	- enable trickle charger on
+					  RV3029 RTC.
+
+		Note that if the RTC uses I2C, then the I2C interface
+		must also be configured. See I2C Support, below.
+
+- GPIO Support:
+		CONFIG_PCA953X		- use NXP's PCA953X series I2C GPIO
+
+		The CONFIG_SYS_I2C_PCA953X_WIDTH option specifies a list of
+		chip-ngpio pairs that tell the PCA953X driver the number of
+		pins supported by a particular chip.
+
+		Note that if the GPIO device uses I2C, then the I2C interface
+		must also be configured. See I2C Support, below.
+
+- I/O tracing:
+		When CONFIG_IO_TRACE is selected, U-Boot intercepts all I/O
+		accesses and can checksum them or write a list of them out
+		to memory. See the 'iotrace' command for details. This is
+		useful for testing device drivers since it can confirm that
+		the driver behaves the same way before and after a code
+		change. Currently this is supported on sandbox and arm. To
+		add support for your architecture, add '#include <iotrace.h>'
+		to the bottom of arch/<arch>/include/asm/io.h and test.
+
+		Example output from the 'iotrace stats' command is below.
+		Note that if the trace buffer is exhausted, the checksum will
+		still continue to operate.
+
+			iotrace is enabled
+			Start:  10000000	(buffer start address)
+			Size:   00010000	(buffer size)
+			Offset: 00000120	(current buffer offset)
+			Output: 10000120	(start + offset)
+			Count:  00000018	(number of trace records)
+			CRC32:  9526fb66	(CRC32 of all trace records)
+
+- Timestamp Support:
+
+		When CONFIG_TIMESTAMP is selected, the timestamp
+		(date and time) of an image is printed by image
+		commands like bootm or iminfo. This option is
+		automatically enabled when you select CONFIG_CMD_DATE .
+
+- Partition Labels (disklabels) Supported:
+		Zero or more of the following:
+		CONFIG_MAC_PARTITION   Apple's MacOS partition table.
+		CONFIG_DOS_PARTITION   MS Dos partition table, traditional on the
+				       Intel architecture, USB sticks, etc.
+		CONFIG_ISO_PARTITION   ISO partition table, used on CDROM etc.
+		CONFIG_EFI_PARTITION   GPT partition table, common when EFI is the
+				       bootloader.  Note 2TB partition limit; see
+				       disk/part_efi.c
+		CONFIG_MTD_PARTITIONS  Memory Technology Device partition table.
+
+		If IDE or SCSI support is enabled (CONFIG_CMD_IDE or
+		CONFIG_CMD_SCSI) you must configure support for at
+		least one non-MTD partition type as well.
+
+- IDE Reset method:
+		CONFIG_IDE_RESET_ROUTINE - this is defined in several
+		board configurations files but used nowhere!
+
+		CONFIG_IDE_RESET - is this is defined, IDE Reset will
+		be performed by calling the function
+			ide_set_reset(int reset)
+		which has to be defined in a board specific file
+
+- ATAPI Support:
+		CONFIG_ATAPI
+
+		Set this to enable ATAPI support.
+
+- LBA48 Support
+		CONFIG_LBA48
+
+		Set this to enable support for disks larger than 137GB
+		Also look at CONFIG_SYS_64BIT_LBA.
+		Whithout these , LBA48 support uses 32bit variables and will 'only'
+		support disks up to 2.1TB.
+
+		CONFIG_SYS_64BIT_LBA:
+			When enabled, makes the IDE subsystem use 64bit sector addresses.
+			Default is 32bit.
+
+- SCSI Support:
+		At the moment only there is only support for the
+		SYM53C8XX SCSI controller; define
+		CONFIG_SCSI_SYM53C8XX to enable it.
+
+		CONFIG_SYS_SCSI_MAX_LUN [8], CONFIG_SYS_SCSI_MAX_SCSI_ID [7] and
+		CONFIG_SYS_SCSI_MAX_DEVICE [CONFIG_SYS_SCSI_MAX_SCSI_ID *
+		CONFIG_SYS_SCSI_MAX_LUN] can be adjusted to define the
+		maximum numbers of LUNs, SCSI ID's and target
+		devices.
+		CONFIG_SYS_SCSI_SYM53C8XX_CCF to fix clock timing (80Mhz)
+
+		The environment variable 'scsidevs' is set to the number of
+		SCSI devices found during the last scan.
+
+- NETWORK Support (PCI):
+		CONFIG_E1000
+		Support for Intel 8254x/8257x gigabit chips.
+
+		CONFIG_E1000_SPI
+		Utility code for direct access to the SPI bus on Intel 8257x.
+		This does not do anything useful unless you set at least one
+		of CONFIG_CMD_E1000 or CONFIG_E1000_SPI_GENERIC.
+
+		CONFIG_E1000_SPI_GENERIC
+		Allow generic access to the SPI bus on the Intel 8257x, for
+		example with the "sspi" command.
+
+		CONFIG_CMD_E1000
+		Management command for E1000 devices.  When used on devices
+		with SPI support you can reprogram the EEPROM from U-Boot.
+
+		CONFIG_EEPRO100
+		Support for Intel 82557/82559/82559ER chips.
+		Optional CONFIG_EEPRO100_SROM_WRITE enables EEPROM
+		write routine for first time initialisation.
+
+		CONFIG_TULIP
+		Support for Digital 2114x chips.
+		Optional CONFIG_TULIP_SELECT_MEDIA for board specific
+		modem chip initialisation (KS8761/QS6611).
+
+		CONFIG_NATSEMI
+		Support for National dp83815 chips.
+
+		CONFIG_NS8382X
+		Support for National dp8382[01] gigabit chips.
+
+- NETWORK Support (other):
+
+		CONFIG_DRIVER_AT91EMAC
+		Support for AT91RM9200 EMAC.
+
+			CONFIG_RMII
+			Define this to use reduced MII inteface
+
+			CONFIG_DRIVER_AT91EMAC_QUIET
+			If this defined, the driver is quiet.
+			The driver doen't show link status messages.
+
+		CONFIG_CALXEDA_XGMAC
+		Support for the Calxeda XGMAC device
+
+		CONFIG_LAN91C96
+		Support for SMSC's LAN91C96 chips.
+
+			CONFIG_LAN91C96_BASE
+			Define this to hold the physical address
+			of the LAN91C96's I/O space
+
+			CONFIG_LAN91C96_USE_32_BIT
+			Define this to enable 32 bit addressing
+
+		CONFIG_SMC91111
+		Support for SMSC's LAN91C111 chip
+
+			CONFIG_SMC91111_BASE
+			Define this to hold the physical address
+			of the device (I/O space)
+
+			CONFIG_SMC_USE_32_BIT
+			Define this if data bus is 32 bits
+
+			CONFIG_SMC_USE_IOFUNCS
+			Define this to use i/o functions instead of macros
+			(some hardware wont work with macros)
+
+		CONFIG_DRIVER_TI_EMAC
+		Support for davinci emac
+
+			CONFIG_SYS_DAVINCI_EMAC_PHY_COUNT
+			Define this if you have more then 3 PHYs.
+
+		CONFIG_FTGMAC100
+		Support for Faraday's FTGMAC100 Gigabit SoC Ethernet
+
+			CONFIG_FTGMAC100_EGIGA
+			Define this to use GE link update with gigabit PHY.
+			Define this if FTGMAC100 is connected to gigabit PHY.
+			If your system has 10/100 PHY only, it might not occur
+			wrong behavior. Because PHY usually return timeout or
+			useless data when polling gigabit status and gigabit
+			control registers. This behavior won't affect the
+			correctnessof 10/100 link speed update.
+
+		CONFIG_SMC911X
+		Support for SMSC's LAN911x and LAN921x chips
+
+			CONFIG_SMC911X_BASE
+			Define this to hold the physical address
+			of the device (I/O space)
+
+			CONFIG_SMC911X_32_BIT
+			Define this if data bus is 32 bits
+
+			CONFIG_SMC911X_16_BIT
+			Define this if data bus is 16 bits. If your processor
+			automatically converts one 32 bit word to two 16 bit
+			words you may also try CONFIG_SMC911X_32_BIT.
+
+		CONFIG_SH_ETHER
+		Support for Renesas on-chip Ethernet controller
+
+			CONFIG_SH_ETHER_USE_PORT
+			Define the number of ports to be used
+
+			CONFIG_SH_ETHER_PHY_ADDR
+			Define the ETH PHY's address
+
+			CONFIG_SH_ETHER_CACHE_WRITEBACK
+			If this option is set, the driver enables cache flush.
+
+- PWM Support:
+		CONFIG_PWM_IMX
+		Support for PWM modul on the imx6.
+
+- TPM Support:
+		CONFIG_TPM
+		Support TPM devices.
+
+		CONFIG_TPM_TIS_INFINEON
+		Support for Infineon i2c bus TPM devices. Only one device
+		per system is supported at this time.
+
+			CONFIG_TPM_TIS_I2C_BURST_LIMITATION
+			Define the burst count bytes upper limit
+
+		CONFIG_TPM_ST33ZP24
+		Support for STMicroelectronics TPM devices. Requires DM_TPM support.
+
+			CONFIG_TPM_ST33ZP24_I2C
+			Support for STMicroelectronics ST33ZP24 I2C devices.
+			Requires TPM_ST33ZP24 and I2C.
+
+			CONFIG_TPM_ST33ZP24_SPI
+			Support for STMicroelectronics ST33ZP24 SPI devices.
+			Requires TPM_ST33ZP24 and SPI.
+
+		CONFIG_TPM_ATMEL_TWI
+		Support for Atmel TWI TPM device. Requires I2C support.
+
+		CONFIG_TPM_TIS_LPC
+		Support for generic parallel port TPM devices. Only one device
+		per system is supported at this time.
+
+			CONFIG_TPM_TIS_BASE_ADDRESS
+			Base address where the generic TPM device is mapped
+			to. Contemporary x86 systems usually map it at
+			0xfed40000.
+
+		CONFIG_CMD_TPM
+		Add tpm monitor functions.
+		Requires CONFIG_TPM. If CONFIG_TPM_AUTH_SESSIONS is set, also
+		provides monitor access to authorized functions.
+
+		CONFIG_TPM
+		Define this to enable the TPM support library which provides
+		functional interfaces to some TPM commands.
+		Requires support for a TPM device.
+
+		CONFIG_TPM_AUTH_SESSIONS
+		Define this to enable authorized functions in the TPM library.
+		Requires CONFIG_TPM and CONFIG_SHA1.
+
+- USB Support:
+		At the moment only the UHCI host controller is
+		supported (PIP405, MIP405, MPC5200); define
+		CONFIG_USB_UHCI to enable it.
+		define CONFIG_USB_KEYBOARD to enable the USB Keyboard
+		and define CONFIG_USB_STORAGE to enable the USB
+		storage devices.
+		Note:
+		Supported are USB Keyboards and USB Floppy drives
+		(TEAC FD-05PUB).
+		MPC5200 USB requires additional defines:
+			CONFIG_USB_CLOCK
+				for 528 MHz Clock: 0x0001bbbb
+			CONFIG_PSC3_USB
+				for USB on PSC3
+			CONFIG_USB_CONFIG
+				for differential drivers: 0x00001000
+				for single ended drivers: 0x00005000
+				for differential drivers on PSC3: 0x00000100
+				for single ended drivers on PSC3: 0x00004100
+			CONFIG_SYS_USB_EVENT_POLL
+				May be defined to allow interrupt polling
+				instead of using asynchronous interrupts
+
+		CONFIG_USB_EHCI_TXFIFO_THRESH enables setting of the
+		txfilltuning field in the EHCI controller on reset.
+
+		CONFIG_USB_DWC2_REG_ADDR the physical CPU address of the DWC2
+		HW module registers.
+
+- USB Device:
+		Define the below if you wish to use the USB console.
+		Once firmware is rebuilt from a serial console issue the
+		command "setenv stdin usbtty; setenv stdout usbtty" and
+		attach your USB cable. The Unix command "dmesg" should print
+		it has found a new device. The environment variable usbtty
+		can be set to gserial or cdc_acm to enable your device to
+		appear to a USB host as a Linux gserial device or a
+		Common Device Class Abstract Control Model serial device.
+		If you select usbtty = gserial you should be able to enumerate
+		a Linux host by
+		# modprobe usbserial vendor=0xVendorID product=0xProductID
+		else if using cdc_acm, simply setting the environment
+		variable usbtty to be cdc_acm should suffice. The following
+		might be defined in YourBoardName.h
+
+			CONFIG_USB_DEVICE
+			Define this to build a UDC device
+
+			CONFIG_USB_TTY
+			Define this to have a tty type of device available to
+			talk to the UDC device
+
+			CONFIG_USBD_HS
+			Define this to enable the high speed support for usb
+			device and usbtty. If this feature is enabled, a routine
+			int is_usbd_high_speed(void)
+			also needs to be defined by the driver to dynamically poll
+			whether the enumeration has succeded at high speed or full
+			speed.
+
+			CONFIG_SYS_CONSOLE_IS_IN_ENV
+			Define this if you want stdin, stdout &/or stderr to
+			be set to usbtty.
+
+			mpc8xx:
+				CONFIG_SYS_USB_EXTC_CLK 0xBLAH
+				Derive USB clock from external clock "blah"
+				- CONFIG_SYS_USB_EXTC_CLK 0x02
+
+				CONFIG_SYS_USB_BRG_CLK 0xBLAH
+				Derive USB clock from brgclk
+				- CONFIG_SYS_USB_BRG_CLK 0x04
+
+		If you have a USB-IF assigned VendorID then you may wish to
+		define your own vendor specific values either in BoardName.h
+		or directly in usbd_vendor_info.h. If you don't define
+		CONFIG_USBD_MANUFACTURER, CONFIG_USBD_PRODUCT_NAME,
+		CONFIG_USBD_VENDORID and CONFIG_USBD_PRODUCTID, then U-Boot
+		should pretend to be a Linux device to it's target host.
+
+			CONFIG_USBD_MANUFACTURER
+			Define this string as the name of your company for
+			- CONFIG_USBD_MANUFACTURER "my company"
+
+			CONFIG_USBD_PRODUCT_NAME
+			Define this string as the name of your product
+			- CONFIG_USBD_PRODUCT_NAME "acme usb device"
+
+			CONFIG_USBD_VENDORID
+			Define this as your assigned Vendor ID from the USB
+			Implementors Forum. This *must* be a genuine Vendor ID
+			to avoid polluting the USB namespace.
+			- CONFIG_USBD_VENDORID 0xFFFF
+
+			CONFIG_USBD_PRODUCTID
+			Define this as the unique Product ID
+			for your device
+			- CONFIG_USBD_PRODUCTID 0xFFFF
+
+- ULPI Layer Support:
+		The ULPI (UTMI Low Pin (count) Interface) PHYs are supported via
+		the generic ULPI layer. The generic layer accesses the ULPI PHY
+		via the platform viewport, so you need both the genric layer and
+		the viewport enabled. Currently only Chipidea/ARC based
+		viewport is supported.
+		To enable the ULPI layer support, define CONFIG_USB_ULPI and
+		CONFIG_USB_ULPI_VIEWPORT in your board configuration file.
+		If your ULPI phy needs a different reference clock than the
+		standard 24 MHz then you have to define CONFIG_ULPI_REF_CLK to
+		the appropriate value in Hz.
+
+- MMC Support:
+		The MMC controller on the Intel PXA is supported. To
+		enable this define CONFIG_MMC. The MMC can be
+		accessed from the boot prompt by mapping the device
+		to physical memory similar to flash. Command line is
+		enabled with CONFIG_CMD_MMC. The MMC driver also works with
+		the FAT fs. This is enabled with CONFIG_CMD_FAT.
+
+		CONFIG_SH_MMCIF
+		Support for Renesas on-chip MMCIF controller
+
+			CONFIG_SH_MMCIF_ADDR
+			Define the base address of MMCIF registers
+
+			CONFIG_SH_MMCIF_CLK
+			Define the clock frequency for MMCIF
+
+		CONFIG_GENERIC_MMC
+		Enable the generic MMC driver
+
+		CONFIG_SUPPORT_EMMC_BOOT
+		Enable some additional features of the eMMC boot partitions.
+
+		CONFIG_SUPPORT_EMMC_RPMB
+		Enable the commands for reading, writing and programming the
+		key for the Replay Protection Memory Block partition in eMMC.
+
+- USB Device Firmware Update (DFU) class support:
+		CONFIG_USB_FUNCTION_DFU
+		This enables the USB portion of the DFU USB class
+
+		CONFIG_CMD_DFU
+		This enables the command "dfu" which is used to have
+		U-Boot create a DFU class device via USB.  This command
+		requires that the "dfu_alt_info" environment variable be
+		set and define the alt settings to expose to the host.
+
+		CONFIG_DFU_MMC
+		This enables support for exposing (e)MMC devices via DFU.
+
+		CONFIG_DFU_NAND
+		This enables support for exposing NAND devices via DFU.
+
+		CONFIG_DFU_RAM
+		This enables support for exposing RAM via DFU.
+		Note: DFU spec refer to non-volatile memory usage, but
+		allow usages beyond the scope of spec - here RAM usage,
+		one that would help mostly the developer.
+
+		CONFIG_SYS_DFU_DATA_BUF_SIZE
+		Dfu transfer uses a buffer before writing data to the
+		raw storage device. Make the size (in bytes) of this buffer
+		configurable. The size of this buffer is also configurable
+		through the "dfu_bufsiz" environment variable.
+
+		CONFIG_SYS_DFU_MAX_FILE_SIZE
+		When updating files rather than the raw storage device,
+		we use a static buffer to copy the file into and then write
+		the buffer once we've been given the whole file.  Define
+		this to the maximum filesize (in bytes) for the buffer.
+		Default is 4 MiB if undefined.
+
+		DFU_DEFAULT_POLL_TIMEOUT
+		Poll timeout [ms], is the timeout a device can send to the
+		host. The host must wait for this timeout before sending
+		a subsequent DFU_GET_STATUS request to the device.
+
+		DFU_MANIFEST_POLL_TIMEOUT
+		Poll timeout [ms], which the device sends to the host when
+		entering dfuMANIFEST state. Host waits this timeout, before
+		sending again an USB request to the device.
+
+- USB Device Android Fastboot support:
+		CONFIG_USB_FUNCTION_FASTBOOT
+		This enables the USB part of the fastboot gadget
+
+		CONFIG_CMD_FASTBOOT
+		This enables the command "fastboot" which enables the Android
+		fastboot mode for the platform's USB device. Fastboot is a USB
+		protocol for downloading images, flashing and device control
+		used on Android devices.
+		See doc/README.android-fastboot for more information.
+
+		CONFIG_ANDROID_BOOT_IMAGE
+		This enables support for booting images which use the Android
+		image format header.
+
+		CONFIG_FASTBOOT_BUF_ADDR
+		The fastboot protocol requires a large memory buffer for
+		downloads. Define this to the starting RAM address to use for
+		downloaded images.
+
+		CONFIG_FASTBOOT_BUF_SIZE
+		The fastboot protocol requires a large memory buffer for
+		downloads. This buffer should be as large as possible for a
+		platform. Define this to the size available RAM for fastboot.
+
+		CONFIG_FASTBOOT_FLASH
+		The fastboot protocol includes a "flash" command for writing
+		the downloaded image to a non-volatile storage device. Define
+		this to enable the "fastboot flash" command.
+
+		CONFIG_FASTBOOT_FLASH_MMC_DEV
+		The fastboot "flash" command requires additional information
+		regarding the non-volatile storage device. Define this to
+		the eMMC device that fastboot should use to store the image.
+
+		CONFIG_FASTBOOT_GPT_NAME
+		The fastboot "flash" command supports writing the downloaded
+		image to the Protective MBR and the Primary GUID Partition
+		Table. (Additionally, this downloaded image is post-processed
+		to generate and write the Backup GUID Partition Table.)
+		This occurs when the specified "partition name" on the
+		"fastboot flash" command line matches this value.
+		Default is GPT_ENTRY_NAME (currently "gpt") if undefined.
+
+- Journaling Flash filesystem support:
+		CONFIG_JFFS2_NAND, CONFIG_JFFS2_NAND_OFF, CONFIG_JFFS2_NAND_SIZE,
+		CONFIG_JFFS2_NAND_DEV
+		Define these for a default partition on a NAND device
+
+		CONFIG_SYS_JFFS2_FIRST_SECTOR,
+		CONFIG_SYS_JFFS2_FIRST_BANK, CONFIG_SYS_JFFS2_NUM_BANKS
+		Define these for a default partition on a NOR device
+
+		CONFIG_SYS_JFFS_CUSTOM_PART
+		Define this to create an own partition. You have to provide a
+		function struct part_info* jffs2_part_info(int part_num)
+
+		If you define only one JFFS2 partition you may also want to
+		#define CONFIG_SYS_JFFS_SINGLE_PART	1
+		to disable the command chpart. This is the default when you
+		have not defined a custom partition
+
+- FAT(File Allocation Table) filesystem write function support:
+		CONFIG_FAT_WRITE
+
+		Define this to enable support for saving memory data as a
+		file in FAT formatted partition.
+
+		This will also enable the command "fatwrite" enabling the
+		user to write files to FAT.
+
+CBFS (Coreboot Filesystem) support
+		CONFIG_CMD_CBFS
+
+		Define this to enable support for reading from a Coreboot
+		filesystem. Available commands are cbfsinit, cbfsinfo, cbfsls
+		and cbfsload.
+
+- FAT(File Allocation Table) filesystem cluster size:
+		CONFIG_FS_FAT_MAX_CLUSTSIZE
+
+		Define the max cluster size for fat operations else
+		a default value of 65536 will be defined.
+
+- Keyboard Support:
+		See Kconfig help for available keyboard drivers.
+
+		CONFIG_KEYBOARD
+
+		Define this to enable a custom keyboard support.
+		This simply calls drv_keyboard_init() which must be
+		defined in your board-specific files. This option is deprecated
+		and is only used by novena. For new boards, use driver model
+		instead.
+
+- Video support:
+		CONFIG_VIDEO
+
+		Define this to enable video support (for output to
+		video).
+
+		CONFIG_VIDEO_CT69000
+
+		Enable Chips & Technologies 69000 Video chip
+
+		CONFIG_VIDEO_SMI_LYNXEM
+		Enable Silicon Motion SMI 712/710/810 Video chip. The
+		video output is selected via environment 'videoout'
+		(1 = LCD and 2 = CRT). If videoout is undefined, CRT is
+		assumed.
+
+		For the CT69000 and SMI_LYNXEM drivers, videomode is
+		selected via environment 'videomode'. Two different ways
+		are possible:
+		- "videomode=num"   'num' is a standard LiLo mode numbers.
+		Following standard modes are supported	(* is default):
+
+		      Colors	640x480 800x600 1024x768 1152x864 1280x1024
+		-------------+---------------------------------------------
+		      8 bits |	0x301*	0x303	 0x305	  0x161	    0x307
+		     15 bits |	0x310	0x313	 0x316	  0x162	    0x319
+		     16 bits |	0x311	0x314	 0x317	  0x163	    0x31A
+		     24 bits |	0x312	0x315	 0x318	    ?	    0x31B
+		-------------+---------------------------------------------
+		(i.e. setenv videomode 317; saveenv; reset;)
+
+		- "videomode=bootargs" all the video parameters are parsed
+		from the bootargs. (See drivers/video/videomodes.c)
+
+
+		CONFIG_VIDEO_SED13806
+		Enable Epson SED13806 driver. This driver supports 8bpp
+		and 16bpp modes defined by CONFIG_VIDEO_SED13806_8BPP
+		or CONFIG_VIDEO_SED13806_16BPP
+
+		CONFIG_FSL_DIU_FB
+		Enable the Freescale DIU video driver.	Reference boards for
+		SOCs that have a DIU should define this macro to enable DIU
+		support, and should also define these other macros:
+
+			CONFIG_SYS_DIU_ADDR
+			CONFIG_VIDEO
+			CONFIG_CMD_BMP
+			CONFIG_CFB_CONSOLE
+			CONFIG_VIDEO_SW_CURSOR
+			CONFIG_VGA_AS_SINGLE_DEVICE
+			CONFIG_VIDEO_LOGO
+			CONFIG_VIDEO_BMP_LOGO
+
+		The DIU driver will look for the 'video-mode' environment
+		variable, and if defined, enable the DIU as a console during
+		boot.  See the documentation file README.video for a
+		description of this variable.
+
+- LCD Support:	CONFIG_LCD
+
+		Define this to enable LCD support (for output to LCD
+		display); also select one of the supported displays
+		by defining one of these:
+
+		CONFIG_ATMEL_LCD:
+
+			HITACHI TX09D70VM1CCA, 3.5", 240x320.
+
+		CONFIG_NEC_NL6448AC33:
+
+			NEC NL6448AC33-18. Active, color, single scan.
+
+		CONFIG_NEC_NL6448BC20
+
+			NEC NL6448BC20-08. 6.5", 640x480.
+			Active, color, single scan.
+
+		CONFIG_NEC_NL6448BC33_54
+
+			NEC NL6448BC33-54. 10.4", 640x480.
+			Active, color, single scan.
+
+		CONFIG_SHARP_16x9
+
+			Sharp 320x240. Active, color, single scan.
+			It isn't 16x9, and I am not sure what it is.
+
+		CONFIG_SHARP_LQ64D341
+
+			Sharp LQ64D341 display, 640x480.
+			Active, color, single scan.
+
+		CONFIG_HLD1045
+
+			HLD1045 display, 640x480.
+			Active, color, single scan.
+
+		CONFIG_OPTREX_BW
+
+			Optrex	 CBL50840-2 NF-FW 99 22 M5
+			or
+			Hitachi	 LMG6912RPFC-00T
+			or
+			Hitachi	 SP14Q002
+
+			320x240. Black & white.
+
+		Normally display is black on white background; define
+		CONFIG_SYS_WHITE_ON_BLACK to get it inverted.
+
+		CONFIG_LCD_ALIGNMENT
+
+		Normally the LCD is page-aligned (typically 4KB). If this is
+		defined then the LCD will be aligned to this value instead.
+		For ARM it is sometimes useful to use MMU_SECTION_SIZE
+		here, since it is cheaper to change data cache settings on
+		a per-section basis.
+
+		CONFIG_CONSOLE_SCROLL_LINES
+
+		When the console need to be scrolled, this is the number of
+		lines to scroll by. It defaults to 1. Increasing this makes
+		the console jump but can help speed up operation when scrolling
+		is slow.
+
+		CONFIG_LCD_ROTATION
+
+		Sometimes, for example if the display is mounted in portrait
+		mode or even if it's mounted landscape but rotated by 180degree,
+		we need to rotate our content of the display relative to the
+		framebuffer, so that user can read the messages which are
+		printed out.
+		Once CONFIG_LCD_ROTATION is defined, the lcd_console will be
+		initialized with a given rotation from "vl_rot" out of
+		"vidinfo_t" which is provided by the board specific code.
+		The value for vl_rot is coded as following (matching to
+		fbcon=rotate:<n> linux-kernel commandline):
+		0 = no rotation respectively 0 degree
+		1 = 90 degree rotation
+		2 = 180 degree rotation
+		3 = 270 degree rotation
+
+		If CONFIG_LCD_ROTATION is not defined, the console will be
+		initialized with 0degree rotation.
+
+		CONFIG_LCD_BMP_RLE8
+
+		Support drawing of RLE8-compressed bitmaps on the LCD.
+
+		CONFIG_I2C_EDID
+
+		Enables an 'i2c edid' command which can read EDID
+		information over I2C from an attached LCD display.
+
+- Splash Screen Support: CONFIG_SPLASH_SCREEN
+
+		If this option is set, the environment is checked for
+		a variable "splashimage". If found, the usual display
+		of logo, copyright and system information on the LCD
+		is suppressed and the BMP image at the address
+		specified in "splashimage" is loaded instead. The
+		console is redirected to the "nulldev", too. This
+		allows for a "silent" boot where a splash screen is
+		loaded very quickly after power-on.
+
+		CONFIG_SPLASHIMAGE_GUARD
+
+		If this option is set, then U-Boot will prevent the environment
+		variable "splashimage" from being set to a problematic address
+		(see README.displaying-bmps).
+		This option is useful for targets where, due to alignment
+		restrictions, an improperly aligned BMP image will cause a data
+		abort. If you think you will not have problems with unaligned
+		accesses (for example because your toolchain prevents them)
+		there is no need to set this option.
+
+		CONFIG_SPLASH_SCREEN_ALIGN
+
+		If this option is set the splash image can be freely positioned
+		on the screen. Environment variable "splashpos" specifies the
+		position as "x,y". If a positive number is given it is used as
+		number of pixel from left/top. If a negative number is given it
+		is used as number of pixel from right/bottom. You can also
+		specify 'm' for centering the image.
+
+		Example:
+		setenv splashpos m,m
+			=> image at center of screen
+
+		setenv splashpos 30,20
+			=> image at x = 30 and y = 20
+
+		setenv splashpos -10,m
+			=> vertically centered image
+			   at x = dspWidth - bmpWidth - 9
+
+- Gzip compressed BMP image support: CONFIG_VIDEO_BMP_GZIP
+
+		If this option is set, additionally to standard BMP
+		images, gzipped BMP images can be displayed via the
+		splashscreen support or the bmp command.
+
+- Run length encoded BMP image (RLE8) support: CONFIG_VIDEO_BMP_RLE8
+
+		If this option is set, 8-bit RLE compressed BMP images
+		can be displayed via the splashscreen support or the
+		bmp command.
+
+- Do compressing for memory range:
+		CONFIG_CMD_ZIP
+
+		If this option is set, it would use zlib deflate method
+		to compress the specified memory at its best effort.
+
+- Compression support:
+		CONFIG_GZIP
+
+		Enabled by default to support gzip compressed images.
+
+		CONFIG_BZIP2
+
+		If this option is set, support for bzip2 compressed
+		images is included. If not, only uncompressed and gzip
+		compressed images are supported.
+
+		NOTE: the bzip2 algorithm requires a lot of RAM, so
+		the malloc area (as defined by CONFIG_SYS_MALLOC_LEN) should
+		be at least 4MB.
+
+		CONFIG_LZMA
+
+		If this option is set, support for lzma compressed
+		images is included.
+
+		Note: The LZMA algorithm adds between 2 and 4KB of code and it
+		requires an amount of dynamic memory that is given by the
+		formula:
+
+			(1846 + 768 << (lc + lp)) * sizeof(uint16)
+
+		Where lc and lp stand for, respectively, Literal context bits
+		and Literal pos bits.
+
+		This value is upper-bounded by 14MB in the worst case. Anyway,
+		for a ~4MB large kernel image, we have lc=3 and lp=0 for a
+		total amount of (1846 + 768 << (3 + 0)) * 2 = ~41KB... that is
+		a very small buffer.
+
+		Use the lzmainfo tool to determinate the lc and lp values and
+		then calculate the amount of needed dynamic memory (ensuring
+		the appropriate CONFIG_SYS_MALLOC_LEN value).
+
+		CONFIG_LZO
+
+		If this option is set, support for LZO compressed images
+		is included.
+
+- MII/PHY support:
+		CONFIG_PHY_ADDR
+
+		The address of PHY on MII bus.
+
+		CONFIG_PHY_CLOCK_FREQ (ppc4xx)
+
+		The clock frequency of the MII bus
+
+		CONFIG_PHY_GIGE
+
+		If this option is set, support for speed/duplex
+		detection of gigabit PHY is included.
+
+		CONFIG_PHY_RESET_DELAY
+
+		Some PHY like Intel LXT971A need extra delay after
+		reset before any MII register access is possible.
+		For such PHY, set this option to the usec delay
+		required. (minimum 300usec for LXT971A)
+
+		CONFIG_PHY_CMD_DELAY (ppc4xx)
+
+		Some PHY like Intel LXT971A need extra delay after
+		command issued before MII status register can be read
+
+- IP address:
+		CONFIG_IPADDR
+
+		Define a default value for the IP address to use for
+		the default Ethernet interface, in case this is not
+		determined through e.g. bootp.
+		(Environment variable "ipaddr")
+
+- Server IP address:
+		CONFIG_SERVERIP
+
+		Defines a default value for the IP address of a TFTP
+		server to contact when using the "tftboot" command.
+		(Environment variable "serverip")
+
+		CONFIG_KEEP_SERVERADDR
+
+		Keeps the server's MAC address, in the env 'serveraddr'
+		for passing to bootargs (like Linux's netconsole option)
+
+- Gateway IP address:
+		CONFIG_GATEWAYIP
+
+		Defines a default value for the IP address of the
+		default router where packets to other networks are
+		sent to.
+		(Environment variable "gatewayip")
+
+- Subnet mask:
+		CONFIG_NETMASK
+
+		Defines a default value for the subnet mask (or
+		routing prefix) which is used to determine if an IP
+		address belongs to the local subnet or needs to be
+		forwarded through a router.
+		(Environment variable "netmask")
+
+- Multicast TFTP Mode:
+		CONFIG_MCAST_TFTP
+
+		Defines whether you want to support multicast TFTP as per
+		rfc-2090; for example to work with atftp.  Lets lots of targets
+		tftp down the same boot image concurrently.  Note: the Ethernet
+		driver in use must provide a function: mcast() to join/leave a
+		multicast group.
+
+- BOOTP Recovery Mode:
+		CONFIG_BOOTP_RANDOM_DELAY
+
+		If you have many targets in a network that try to
+		boot using BOOTP, you may want to avoid that all
+		systems send out BOOTP requests at precisely the same
+		moment (which would happen for instance at recovery
+		from a power failure, when all systems will try to
+		boot, thus flooding the BOOTP server. Defining
+		CONFIG_BOOTP_RANDOM_DELAY causes a random delay to be
+		inserted before sending out BOOTP requests. The
+		following delays are inserted then:
+
+		1st BOOTP request:	delay 0 ... 1 sec
+		2nd BOOTP request:	delay 0 ... 2 sec
+		3rd BOOTP request:	delay 0 ... 4 sec
+		4th and following
+		BOOTP requests:		delay 0 ... 8 sec
+
+		CONFIG_BOOTP_ID_CACHE_SIZE
+
+		BOOTP packets are uniquely identified using a 32-bit ID. The
+		server will copy the ID from client requests to responses and
+		U-Boot will use this to determine if it is the destination of
+		an incoming response. Some servers will check that addresses
+		aren't in use before handing them out (usually using an ARP
+		ping) and therefore take up to a few hundred milliseconds to
+		respond. Network congestion may also influence the time it
+		takes for a response to make it back to the client. If that
+		time is too long, U-Boot will retransmit requests. In order
+		to allow earlier responses to still be accepted after these
+		retransmissions, U-Boot's BOOTP client keeps a small cache of
+		IDs. The CONFIG_BOOTP_ID_CACHE_SIZE controls the size of this
+		cache. The default is to keep IDs for up to four outstanding
+		requests. Increasing this will allow U-Boot to accept offers
+		from a BOOTP client in networks with unusually high latency.
+
+- DHCP Advanced Options:
+		You can fine tune the DHCP functionality by defining
+		CONFIG_BOOTP_* symbols:
+
+		CONFIG_BOOTP_SUBNETMASK
+		CONFIG_BOOTP_GATEWAY
+		CONFIG_BOOTP_HOSTNAME
+		CONFIG_BOOTP_NISDOMAIN
+		CONFIG_BOOTP_BOOTPATH
+		CONFIG_BOOTP_BOOTFILESIZE
+		CONFIG_BOOTP_DNS
+		CONFIG_BOOTP_DNS2
+		CONFIG_BOOTP_SEND_HOSTNAME
+		CONFIG_BOOTP_NTPSERVER
+		CONFIG_BOOTP_TIMEOFFSET
+		CONFIG_BOOTP_VENDOREX
+		CONFIG_BOOTP_MAY_FAIL
+
+		CONFIG_BOOTP_SERVERIP - TFTP server will be the serverip
+		environment variable, not the BOOTP server.
+
+		CONFIG_BOOTP_MAY_FAIL - If the DHCP server is not found
+		after the configured retry count, the call will fail
+		instead of starting over.  This can be used to fail over
+		to Link-local IP address configuration if the DHCP server
+		is not available.
+
+		CONFIG_BOOTP_DNS2 - If a DHCP client requests the DNS
+		serverip from a DHCP server, it is possible that more
+		than one DNS serverip is offered to the client.
+		If CONFIG_BOOTP_DNS2 is enabled, the secondary DNS
+		serverip will be stored in the additional environment
+		variable "dnsip2". The first DNS serverip is always
+		stored in the variable "dnsip", when CONFIG_BOOTP_DNS
+		is defined.
+
+		CONFIG_BOOTP_SEND_HOSTNAME - Some DHCP servers are capable
+		to do a dynamic update of a DNS server. To do this, they
+		need the hostname of the DHCP requester.
+		If CONFIG_BOOTP_SEND_HOSTNAME is defined, the content
+		of the "hostname" environment variable is passed as
+		option 12 to the DHCP server.
+
+		CONFIG_BOOTP_DHCP_REQUEST_DELAY
+
+		A 32bit value in microseconds for a delay between
+		receiving a "DHCP Offer" and sending the "DHCP Request".
+		This fixes a problem with certain DHCP servers that don't
+		respond 100% of the time to a "DHCP request". E.g. On an
+		AT91RM9200 processor running at 180MHz, this delay needed
+		to be *at least* 15,000 usec before a Windows Server 2003
+		DHCP server would reply 100% of the time. I recommend at
+		least 50,000 usec to be safe. The alternative is to hope
+		that one of the retries will be successful but note that
+		the DHCP timeout and retry process takes a longer than
+		this delay.
+
+ - Link-local IP address negotiation:
+		Negotiate with other link-local clients on the local network
+		for an address that doesn't require explicit configuration.
+		This is especially useful if a DHCP server cannot be guaranteed
+		to exist in all environments that the device must operate.
+
+		See doc/README.link-local for more information.
+
+ - CDP Options:
+		CONFIG_CDP_DEVICE_ID
+
+		The device id used in CDP trigger frames.
+
+		CONFIG_CDP_DEVICE_ID_PREFIX
+
+		A two character string which is prefixed to the MAC address
+		of the device.
+
+		CONFIG_CDP_PORT_ID
+
+		A printf format string which contains the ascii name of
+		the port. Normally is set to "eth%d" which sets
+		eth0 for the first Ethernet, eth1 for the second etc.
+
+		CONFIG_CDP_CAPABILITIES
+
+		A 32bit integer which indicates the device capabilities;
+		0x00000010 for a normal host which does not forwards.
+
+		CONFIG_CDP_VERSION
+
+		An ascii string containing the version of the software.
+
+		CONFIG_CDP_PLATFORM
+
+		An ascii string containing the name of the platform.
+
+		CONFIG_CDP_TRIGGER
+
+		A 32bit integer sent on the trigger.
+
+		CONFIG_CDP_POWER_CONSUMPTION
+
+		A 16bit integer containing the power consumption of the
+		device in .1 of milliwatts.
+
+		CONFIG_CDP_APPLIANCE_VLAN_TYPE
+
+		A byte containing the id of the VLAN.
+
+- Status LED:	CONFIG_STATUS_LED
+
+		Several configurations allow to display the current
+		status using a LED. For instance, the LED will blink
+		fast while running U-Boot code, stop blinking as
+		soon as a reply to a BOOTP request was received, and
+		start blinking slow once the Linux kernel is running
+		(supported by a status LED driver in the Linux
+		kernel). Defining CONFIG_STATUS_LED enables this
+		feature in U-Boot.
+
+		Additional options:
+
+		CONFIG_GPIO_LED
+		The status LED can be connected to a GPIO pin.
+		In such cases, the gpio_led driver can be used as a
+		status LED backend implementation. Define CONFIG_GPIO_LED
+		to include the gpio_led driver in the U-Boot binary.
+
+		CONFIG_GPIO_LED_INVERTED_TABLE
+		Some GPIO connected LEDs may have inverted polarity in which
+		case the GPIO high value corresponds to LED off state and
+		GPIO low value corresponds to LED on state.
+		In such cases CONFIG_GPIO_LED_INVERTED_TABLE may be defined
+		with a list of GPIO LEDs that have inverted polarity.
+
+- CAN Support:	CONFIG_CAN_DRIVER
+
+		Defining CONFIG_CAN_DRIVER enables CAN driver support
+		on those systems that support this (optional)
+		feature, like the TQM8xxL modules.
+
+- I2C Support:	CONFIG_SYS_I2C
+
+		This enable the NEW i2c subsystem, and will allow you to use
+		i2c commands at the u-boot command line (as long as you set
+		CONFIG_CMD_I2C in CONFIG_COMMANDS) and communicate with i2c
+		based realtime clock chips or other i2c devices. See
+		common/cmd_i2c.c for a description of the command line
+		interface.
+
+		ported i2c driver to the new framework:
+		- drivers/i2c/soft_i2c.c:
+		  - activate first bus with CONFIG_SYS_I2C_SOFT define
+		    CONFIG_SYS_I2C_SOFT_SPEED and CONFIG_SYS_I2C_SOFT_SLAVE
+		    for defining speed and slave address
+		  - activate second bus with I2C_SOFT_DECLARATIONS2 define
+		    CONFIG_SYS_I2C_SOFT_SPEED_2 and CONFIG_SYS_I2C_SOFT_SLAVE_2
+		    for defining speed and slave address
+		  - activate third bus with I2C_SOFT_DECLARATIONS3 define
+		    CONFIG_SYS_I2C_SOFT_SPEED_3 and CONFIG_SYS_I2C_SOFT_SLAVE_3
+		    for defining speed and slave address
+		  - activate fourth bus with I2C_SOFT_DECLARATIONS4 define
+		    CONFIG_SYS_I2C_SOFT_SPEED_4 and CONFIG_SYS_I2C_SOFT_SLAVE_4
+		    for defining speed and slave address
+
+		- drivers/i2c/fsl_i2c.c:
+		  - activate i2c driver with CONFIG_SYS_I2C_FSL
+		    define CONFIG_SYS_FSL_I2C_OFFSET for setting the register
+		    offset CONFIG_SYS_FSL_I2C_SPEED for the i2c speed and
+		    CONFIG_SYS_FSL_I2C_SLAVE for the slave addr of the first
+		    bus.
+		  - If your board supports a second fsl i2c bus, define
+		    CONFIG_SYS_FSL_I2C2_OFFSET for the register offset
+		    CONFIG_SYS_FSL_I2C2_SPEED for the speed and
+		    CONFIG_SYS_FSL_I2C2_SLAVE for the slave address of the
+		    second bus.
+
+		- drivers/i2c/tegra_i2c.c:
+		  - activate this driver with CONFIG_SYS_I2C_TEGRA
+		  - This driver adds 4 i2c buses with a fix speed from
+		    100000 and the slave addr 0!
+
+		- drivers/i2c/ppc4xx_i2c.c
+		  - activate this driver with CONFIG_SYS_I2C_PPC4XX
+		  - CONFIG_SYS_I2C_PPC4XX_CH0 activate hardware channel 0
+		  - CONFIG_SYS_I2C_PPC4XX_CH1 activate hardware channel 1
+
+		- drivers/i2c/i2c_mxc.c
+		  - activate this driver with CONFIG_SYS_I2C_MXC
+		  - enable bus 1 with CONFIG_SYS_I2C_MXC_I2C1
+		  - enable bus 2 with CONFIG_SYS_I2C_MXC_I2C2
+		  - enable bus 3 with CONFIG_SYS_I2C_MXC_I2C3
+		  - enable bus 4 with CONFIG_SYS_I2C_MXC_I2C4
+		  - define speed for bus 1 with CONFIG_SYS_MXC_I2C1_SPEED
+		  - define slave for bus 1 with CONFIG_SYS_MXC_I2C1_SLAVE
+		  - define speed for bus 2 with CONFIG_SYS_MXC_I2C2_SPEED
+		  - define slave for bus 2 with CONFIG_SYS_MXC_I2C2_SLAVE
+		  - define speed for bus 3 with CONFIG_SYS_MXC_I2C3_SPEED
+		  - define slave for bus 3 with CONFIG_SYS_MXC_I2C3_SLAVE
+		  - define speed for bus 4 with CONFIG_SYS_MXC_I2C4_SPEED
+		  - define slave for bus 4 with CONFIG_SYS_MXC_I2C4_SLAVE
+		If those defines are not set, default value is 100000
+		for speed, and 0 for slave.
+
+		- drivers/i2c/rcar_i2c.c:
+		  - activate this driver with CONFIG_SYS_I2C_RCAR
+		  - This driver adds 4 i2c buses
+
+		  - CONFIG_SYS_RCAR_I2C0_BASE for setting the register channel 0
+		  - CONFIG_SYS_RCAR_I2C0_SPEED for for the speed channel 0
+		  - CONFIG_SYS_RCAR_I2C1_BASE for setting the register channel 1
+		  - CONFIG_SYS_RCAR_I2C1_SPEED for for the speed channel 1
+		  - CONFIG_SYS_RCAR_I2C2_BASE for setting the register channel 2
+		  - CONFIG_SYS_RCAR_I2C2_SPEED for for the speed channel 2
+		  - CONFIG_SYS_RCAR_I2C3_BASE for setting the register channel 3
+		  - CONFIG_SYS_RCAR_I2C3_SPEED for for the speed channel 3
+		  - CONFIF_SYS_RCAR_I2C_NUM_CONTROLLERS for number of i2c buses
+
+		- drivers/i2c/sh_i2c.c:
+		  - activate this driver with CONFIG_SYS_I2C_SH
+		  - This driver adds from 2 to 5 i2c buses
+
+		  - CONFIG_SYS_I2C_SH_BASE0 for setting the register channel 0
+		  - CONFIG_SYS_I2C_SH_SPEED0 for for the speed channel 0
+		  - CONFIG_SYS_I2C_SH_BASE1 for setting the register channel 1
+		  - CONFIG_SYS_I2C_SH_SPEED1 for for the speed channel 1
+		  - CONFIG_SYS_I2C_SH_BASE2 for setting the register channel 2
+		  - CONFIG_SYS_I2C_SH_SPEED2 for for the speed channel 2
+		  - CONFIG_SYS_I2C_SH_BASE3 for setting the register channel 3
+		  - CONFIG_SYS_I2C_SH_SPEED3 for for the speed channel 3
+		  - CONFIG_SYS_I2C_SH_BASE4 for setting the register channel 4
+		  - CONFIG_SYS_I2C_SH_SPEED4 for for the speed channel 4
+		  - CONFIG_SYS_I2C_SH_BASE5 for setting the register channel 5
+		  - CONFIG_SYS_I2C_SH_SPEED5 for for the speed channel 5
+		  - CONFIG_SYS_I2C_SH_NUM_CONTROLLERS for number of i2c buses
+
+		- drivers/i2c/omap24xx_i2c.c
+		  - activate this driver with CONFIG_SYS_I2C_OMAP24XX
+		  - CONFIG_SYS_OMAP24_I2C_SPEED speed channel 0
+		  - CONFIG_SYS_OMAP24_I2C_SLAVE slave addr channel 0
+		  - CONFIG_SYS_OMAP24_I2C_SPEED1 speed channel 1
+		  - CONFIG_SYS_OMAP24_I2C_SLAVE1 slave addr channel 1
+		  - CONFIG_SYS_OMAP24_I2C_SPEED2 speed channel 2
+		  - CONFIG_SYS_OMAP24_I2C_SLAVE2 slave addr channel 2
+		  - CONFIG_SYS_OMAP24_I2C_SPEED3 speed channel 3
+		  - CONFIG_SYS_OMAP24_I2C_SLAVE3 slave addr channel 3
+		  - CONFIG_SYS_OMAP24_I2C_SPEED4 speed channel 4
+		  - CONFIG_SYS_OMAP24_I2C_SLAVE4 slave addr channel 4
+
+		- drivers/i2c/zynq_i2c.c
+		  - activate this driver with CONFIG_SYS_I2C_ZYNQ
+		  - set CONFIG_SYS_I2C_ZYNQ_SPEED for speed setting
+		  - set CONFIG_SYS_I2C_ZYNQ_SLAVE for slave addr
+
+		- drivers/i2c/s3c24x0_i2c.c:
+		  - activate this driver with CONFIG_SYS_I2C_S3C24X0
+		  - This driver adds i2c buses (11 for Exynos5250, Exynos5420
+		    9 i2c buses for Exynos4 and 1 for S3C24X0 SoCs from Samsung)
+		    with a fix speed from 100000 and the slave addr 0!
+
+		- drivers/i2c/ihs_i2c.c
+		  - activate this driver with CONFIG_SYS_I2C_IHS
+		  - CONFIG_SYS_I2C_IHS_CH0 activate hardware channel 0
+		  - CONFIG_SYS_I2C_IHS_SPEED_0 speed channel 0
+		  - CONFIG_SYS_I2C_IHS_SLAVE_0 slave addr channel 0
+		  - CONFIG_SYS_I2C_IHS_CH1 activate hardware channel 1
+		  - CONFIG_SYS_I2C_IHS_SPEED_1 speed channel 1
+		  - CONFIG_SYS_I2C_IHS_SLAVE_1 slave addr channel 1
+		  - CONFIG_SYS_I2C_IHS_CH2 activate hardware channel 2
+		  - CONFIG_SYS_I2C_IHS_SPEED_2 speed channel 2
+		  - CONFIG_SYS_I2C_IHS_SLAVE_2 slave addr channel 2
+		  - CONFIG_SYS_I2C_IHS_CH3 activate hardware channel 3
+		  - CONFIG_SYS_I2C_IHS_SPEED_3 speed channel 3
+		  - CONFIG_SYS_I2C_IHS_SLAVE_3 slave addr channel 3
+		  - activate dual channel with CONFIG_SYS_I2C_IHS_DUAL
+		  - CONFIG_SYS_I2C_IHS_SPEED_0_1 speed channel 0_1
+		  - CONFIG_SYS_I2C_IHS_SLAVE_0_1 slave addr channel 0_1
+		  - CONFIG_SYS_I2C_IHS_SPEED_1_1 speed channel 1_1
+		  - CONFIG_SYS_I2C_IHS_SLAVE_1_1 slave addr channel 1_1
+		  - CONFIG_SYS_I2C_IHS_SPEED_2_1 speed channel 2_1
+		  - CONFIG_SYS_I2C_IHS_SLAVE_2_1 slave addr channel 2_1
+		  - CONFIG_SYS_I2C_IHS_SPEED_3_1 speed channel 3_1
+		  - CONFIG_SYS_I2C_IHS_SLAVE_3_1 slave addr channel 3_1
+
+		additional defines:
+
+		CONFIG_SYS_NUM_I2C_BUSES
+		Hold the number of i2c buses you want to use. If you
+		don't use/have i2c muxes on your i2c bus, this
+		is equal to CONFIG_SYS_NUM_I2C_ADAPTERS, and you can
+		omit this define.
+
+		CONFIG_SYS_I2C_DIRECT_BUS
+		define this, if you don't use i2c muxes on your hardware.
+		if CONFIG_SYS_I2C_MAX_HOPS is not defined or == 0 you can
+		omit this define.
+
+		CONFIG_SYS_I2C_MAX_HOPS
+		define how many muxes are maximal consecutively connected
+		on one i2c bus. If you not use i2c muxes, omit this
+		define.
+
+		CONFIG_SYS_I2C_BUSES
+		hold a list of buses you want to use, only used if
+		CONFIG_SYS_I2C_DIRECT_BUS is not defined, for example
+		a board with CONFIG_SYS_I2C_MAX_HOPS = 1 and
+		CONFIG_SYS_NUM_I2C_BUSES = 9:
+
+		 CONFIG_SYS_I2C_BUSES	{{0, {I2C_NULL_HOP}}, \
+					{0, {{I2C_MUX_PCA9547, 0x70, 1}}}, \
+					{0, {{I2C_MUX_PCA9547, 0x70, 2}}}, \
+					{0, {{I2C_MUX_PCA9547, 0x70, 3}}}, \
+					{0, {{I2C_MUX_PCA9547, 0x70, 4}}}, \
+					{0, {{I2C_MUX_PCA9547, 0x70, 5}}}, \
+					{1, {I2C_NULL_HOP}}, \
+					{1, {{I2C_MUX_PCA9544, 0x72, 1}}}, \
+					{1, {{I2C_MUX_PCA9544, 0x72, 2}}}, \
+					}
+
+		which defines
+			bus 0 on adapter 0 without a mux
+			bus 1 on adapter 0 with a PCA9547 on address 0x70 port 1
+			bus 2 on adapter 0 with a PCA9547 on address 0x70 port 2
+			bus 3 on adapter 0 with a PCA9547 on address 0x70 port 3
+			bus 4 on adapter 0 with a PCA9547 on address 0x70 port 4
+			bus 5 on adapter 0 with a PCA9547 on address 0x70 port 5
+			bus 6 on adapter 1 without a mux
+			bus 7 on adapter 1 with a PCA9544 on address 0x72 port 1
+			bus 8 on adapter 1 with a PCA9544 on address 0x72 port 2
+
+		If you do not have i2c muxes on your board, omit this define.
+
+- Legacy I2C Support:	CONFIG_HARD_I2C
+
+		NOTE: It is intended to move drivers to CONFIG_SYS_I2C which
+		provides the following compelling advantages:
+
+		- more than one i2c adapter is usable
+		- approved multibus support
+		- better i2c mux support
+
+		** Please consider updating your I2C driver now. **
+
+		These enable legacy I2C serial bus commands. Defining
+		CONFIG_HARD_I2C will include the appropriate I2C driver
+		for the selected CPU.
+
+		This will allow you to use i2c commands at the u-boot
+		command line (as long as you set CONFIG_CMD_I2C in
+		CONFIG_COMMANDS) and communicate with i2c based realtime
+		clock chips. See common/cmd_i2c.c for a description of the
+		command line interface.
+
+		CONFIG_HARD_I2C selects a hardware I2C controller.
+
+		There are several other quantities that must also be
+		defined when you define CONFIG_HARD_I2C.
+
+		In both cases you will need to define CONFIG_SYS_I2C_SPEED
+		to be the frequency (in Hz) at which you wish your i2c bus
+		to run and CONFIG_SYS_I2C_SLAVE to be the address of this node (ie
+		the CPU's i2c node address).
+
+		Now, the u-boot i2c code for the mpc8xx
+		(arch/powerpc/cpu/mpc8xx/i2c.c) sets the CPU up as a master node
+		and so its address should therefore be cleared to 0 (See,
+		eg, MPC823e User's Manual p.16-473). So, set
+		CONFIG_SYS_I2C_SLAVE to 0.
+
+		CONFIG_SYS_I2C_INIT_MPC5XXX
+
+		When a board is reset during an i2c bus transfer
+		chips might think that the current transfer is still
+		in progress.  Reset the slave devices by sending start
+		commands until the slave device responds.
+
+		That's all that's required for CONFIG_HARD_I2C.
+
+		If you use the software i2c interface (CONFIG_SYS_I2C_SOFT)
+		then the following macros need to be defined (examples are
+		from include/configs/lwmon.h):
+
+		I2C_INIT
+
+		(Optional). Any commands necessary to enable the I2C
+		controller or configure ports.
+
+		eg: #define I2C_INIT (immr->im_cpm.cp_pbdir |=	PB_SCL)
+
+		I2C_PORT
+
+		(Only for MPC8260 CPU). The I/O port to use (the code
+		assumes both bits are on the same port). Valid values
+		are 0..3 for ports A..D.
+
+		I2C_ACTIVE
+
+		The code necessary to make the I2C data line active
+		(driven).  If the data line is open collector, this
+		define can be null.
+
+		eg: #define I2C_ACTIVE (immr->im_cpm.cp_pbdir |=  PB_SDA)
+
+		I2C_TRISTATE
+
+		The code necessary to make the I2C data line tri-stated
+		(inactive).  If the data line is open collector, this
+		define can be null.
+
+		eg: #define I2C_TRISTATE (immr->im_cpm.cp_pbdir &= ~PB_SDA)
+
+		I2C_READ
+
+		Code that returns true if the I2C data line is high,
+		false if it is low.
+
+		eg: #define I2C_READ ((immr->im_cpm.cp_pbdat & PB_SDA) != 0)
+
+		I2C_SDA(bit)
+
+		If <bit> is true, sets the I2C data line high. If it
+		is false, it clears it (low).
+
+		eg: #define I2C_SDA(bit) \
+			if(bit) immr->im_cpm.cp_pbdat |=  PB_SDA; \
+			else	immr->im_cpm.cp_pbdat &= ~PB_SDA
+
+		I2C_SCL(bit)
+
+		If <bit> is true, sets the I2C clock line high. If it
+		is false, it clears it (low).
+
+		eg: #define I2C_SCL(bit) \
+			if(bit) immr->im_cpm.cp_pbdat |=  PB_SCL; \
+			else	immr->im_cpm.cp_pbdat &= ~PB_SCL
+
+		I2C_DELAY
+
+		This delay is invoked four times per clock cycle so this
+		controls the rate of data transfer.  The data rate thus
+		is 1 / (I2C_DELAY * 4). Often defined to be something
+		like:
+
+		#define I2C_DELAY  udelay(2)
+
+		CONFIG_SOFT_I2C_GPIO_SCL / CONFIG_SOFT_I2C_GPIO_SDA
+
+		If your arch supports the generic GPIO framework (asm/gpio.h),
+		then you may alternatively define the two GPIOs that are to be
+		used as SCL / SDA.  Any of the previous I2C_xxx macros will
+		have GPIO-based defaults assigned to them as appropriate.
+
+		You should define these to the GPIO value as given directly to
+		the generic GPIO functions.
+
+		CONFIG_SYS_I2C_INIT_BOARD
+
+		When a board is reset during an i2c bus transfer
+		chips might think that the current transfer is still
+		in progress. On some boards it is possible to access
+		the i2c SCLK line directly, either by using the
+		processor pin as a GPIO or by having a second pin
+		connected to the bus. If this option is defined a
+		custom i2c_init_board() routine in boards/xxx/board.c
+		is run early in the boot sequence.
+
+		CONFIG_SYS_I2C_BOARD_LATE_INIT
+
+		An alternative to CONFIG_SYS_I2C_INIT_BOARD. If this option is
+		defined a custom i2c_board_late_init() routine in
+		boards/xxx/board.c is run AFTER the operations in i2c_init()
+		is completed. This callpoint can be used to unreset i2c bus
+		using CPU i2c controller register accesses for CPUs whose i2c
+		controller provide such a method. It is called at the end of
+		i2c_init() to allow i2c_init operations to setup the i2c bus
+		controller on the CPU (e.g. setting bus speed & slave address).
+
+		CONFIG_I2CFAST (PPC405GP|PPC405EP only)
+
+		This option enables configuration of bi_iic_fast[] flags
+		in u-boot bd_info structure based on u-boot environment
+		variable "i2cfast". (see also i2cfast)
+
+		CONFIG_I2C_MULTI_BUS
+
+		This option allows the use of multiple I2C buses, each of which
+		must have a controller.	 At any point in time, only one bus is
+		active.	 To switch to a different bus, use the 'i2c dev' command.
+		Note that bus numbering is zero-based.
+
+		CONFIG_SYS_I2C_NOPROBES
+
+		This option specifies a list of I2C devices that will be skipped
+		when the 'i2c probe' command is issued.	 If CONFIG_I2C_MULTI_BUS
+		is set, specify a list of bus-device pairs.  Otherwise, specify
+		a 1D array of device addresses
+
+		e.g.
+			#undef	CONFIG_I2C_MULTI_BUS
+			#define CONFIG_SYS_I2C_NOPROBES {0x50,0x68}
+
+		will skip addresses 0x50 and 0x68 on a board with one I2C bus
+
+			#define CONFIG_I2C_MULTI_BUS
+			#define CONFIG_SYS_I2C_MULTI_NOPROBES	{{0,0x50},{0,0x68},{1,0x54}}
+
+		will skip addresses 0x50 and 0x68 on bus 0 and address 0x54 on bus 1
+
+		CONFIG_SYS_SPD_BUS_NUM
+
+		If defined, then this indicates the I2C bus number for DDR SPD.
+		If not defined, then U-Boot assumes that SPD is on I2C bus 0.
+
+		CONFIG_SYS_RTC_BUS_NUM
+
+		If defined, then this indicates the I2C bus number for the RTC.
+		If not defined, then U-Boot assumes that RTC is on I2C bus 0.
+
+		CONFIG_SYS_DTT_BUS_NUM
+
+		If defined, then this indicates the I2C bus number for the DTT.
+		If not defined, then U-Boot assumes that DTT is on I2C bus 0.
+
+		CONFIG_SYS_I2C_DTT_ADDR:
+
+		If defined, specifies the I2C address of the DTT device.
+		If not defined, then U-Boot uses predefined value for
+		specified DTT device.
+
+		CONFIG_SOFT_I2C_READ_REPEATED_START
+
+		defining this will force the i2c_read() function in
+		the soft_i2c driver to perform an I2C repeated start
+		between writing the address pointer and reading the
+		data.  If this define is omitted the default behaviour
+		of doing a stop-start sequence will be used.  Most I2C
+		devices can use either method, but some require one or
+		the other.
+
+- SPI Support:	CONFIG_SPI
+
+		Enables SPI driver (so far only tested with
+		SPI EEPROM, also an instance works with Crystal A/D and
+		D/As on the SACSng board)
+
+		CONFIG_SH_SPI
+
+		Enables the driver for SPI controller on SuperH. Currently
+		only SH7757 is supported.
+
+		CONFIG_SOFT_SPI
+
+		Enables a software (bit-bang) SPI driver rather than
+		using hardware support. This is a general purpose
+		driver that only requires three general I/O port pins
+		(two outputs, one input) to function. If this is
+		defined, the board configuration must define several
+		SPI configuration items (port pins to use, etc). For
+		an example, see include/configs/sacsng.h.
+
+		CONFIG_HARD_SPI
+
+		Enables a hardware SPI driver for general-purpose reads
+		and writes.  As with CONFIG_SOFT_SPI, the board configuration
+		must define a list of chip-select function pointers.
+		Currently supported on some MPC8xxx processors.	 For an
+		example, see include/configs/mpc8349emds.h.
+
+		CONFIG_MXC_SPI
+
+		Enables the driver for the SPI controllers on i.MX and MXC
+		SoCs. Currently i.MX31/35/51 are supported.
+
+		CONFIG_SYS_SPI_MXC_WAIT
+		Timeout for waiting until spi transfer completed.
+		default: (CONFIG_SYS_HZ/100)     /* 10 ms */
+
+- FPGA Support: CONFIG_FPGA
+
+		Enables FPGA subsystem.
+
+		CONFIG_FPGA_<vendor>
+
+		Enables support for specific chip vendors.
+		(ALTERA, XILINX)
+
+		CONFIG_FPGA_<family>
+
+		Enables support for FPGA family.
+		(SPARTAN2, SPARTAN3, VIRTEX2, CYCLONE2, ACEX1K, ACEX)
+
+		CONFIG_FPGA_COUNT
+
+		Specify the number of FPGA devices to support.
+
+		CONFIG_CMD_FPGA_LOADMK
+
+		Enable support for fpga loadmk command
+
+		CONFIG_CMD_FPGA_LOADP
+
+		Enable support for fpga loadp command - load partial bitstream
+
+		CONFIG_CMD_FPGA_LOADBP
+
+		Enable support for fpga loadbp command - load partial bitstream
+		(Xilinx only)
+
+		CONFIG_SYS_FPGA_PROG_FEEDBACK
+
+		Enable printing of hash marks during FPGA configuration.
+
+		CONFIG_SYS_FPGA_CHECK_BUSY
+
+		Enable checks on FPGA configuration interface busy
+		status by the configuration function. This option
+		will require a board or device specific function to
+		be written.
+
+		CONFIG_FPGA_DELAY
+
+		If defined, a function that provides delays in the FPGA
+		configuration driver.
+
+		CONFIG_SYS_FPGA_CHECK_CTRLC
+		Allow Control-C to interrupt FPGA configuration
+
+		CONFIG_SYS_FPGA_CHECK_ERROR
+
+		Check for configuration errors during FPGA bitfile
+		loading. For example, abort during Virtex II
+		configuration if the INIT_B line goes low (which
+		indicated a CRC error).
+
+		CONFIG_SYS_FPGA_WAIT_INIT
+
+		Maximum time to wait for the INIT_B line to de-assert
+		after PROB_B has been de-asserted during a Virtex II
+		FPGA configuration sequence. The default time is 500
+		ms.
+
+		CONFIG_SYS_FPGA_WAIT_BUSY
+
+		Maximum time to wait for BUSY to de-assert during
+		Virtex II FPGA configuration. The default is 5 ms.
+
+		CONFIG_SYS_FPGA_WAIT_CONFIG
+
+		Time to wait after FPGA configuration. The default is
+		200 ms.
+
+- Configuration Management:
+		CONFIG_BUILD_TARGET
+
+		Some SoCs need special image types (e.g. U-Boot binary
+		with a special header) as build targets. By defining
+		CONFIG_BUILD_TARGET in the SoC / board header, this
+		special image will be automatically built upon calling
+		make / MAKEALL.
+
+		CONFIG_IDENT_STRING
+
+		If defined, this string will be added to the U-Boot
+		version information (U_BOOT_VERSION)
+
+- Vendor Parameter Protection:
+
+		U-Boot considers the values of the environment
+		variables "serial#" (Board Serial Number) and
+		"ethaddr" (Ethernet Address) to be parameters that
+		are set once by the board vendor / manufacturer, and
+		protects these variables from casual modification by
+		the user. Once set, these variables are read-only,
+		and write or delete attempts are rejected. You can
+		change this behaviour:
+
+		If CONFIG_ENV_OVERWRITE is #defined in your config
+		file, the write protection for vendor parameters is
+		completely disabled. Anybody can change or delete
+		these parameters.
+
+		Alternatively, if you define _both_ an ethaddr in the
+		default env _and_ CONFIG_OVERWRITE_ETHADDR_ONCE, a default
+		Ethernet address is installed in the environment,
+		which can be changed exactly ONCE by the user. [The
+		serial# is unaffected by this, i. e. it remains
+		read-only.]
+
+		The same can be accomplished in a more flexible way
+		for any variable by configuring the type of access
+		to allow for those variables in the ".flags" variable
+		or define CONFIG_ENV_FLAGS_LIST_STATIC.
+
+- Protected RAM:
+		CONFIG_PRAM
+
+		Define this variable to enable the reservation of
+		"protected RAM", i. e. RAM which is not overwritten
+		by U-Boot. Define CONFIG_PRAM to hold the number of
+		kB you want to reserve for pRAM. You can overwrite
+		this default value by defining an environment
+		variable "pram" to the number of kB you want to
+		reserve. Note that the board info structure will
+		still show the full amount of RAM. If pRAM is
+		reserved, a new environment variable "mem" will
+		automatically be defined to hold the amount of
+		remaining RAM in a form that can be passed as boot
+		argument to Linux, for instance like that:
+
+			setenv bootargs ... mem=\${mem}
+			saveenv
+
+		This way you can tell Linux not to use this memory,
+		either, which results in a memory region that will
+		not be affected by reboots.
+
+		*WARNING* If your board configuration uses automatic
+		detection of the RAM size, you must make sure that
+		this memory test is non-destructive. So far, the
+		following board configurations are known to be
+		"pRAM-clean":
+
+			IVMS8, IVML24, SPD8xx, TQM8xxL,
+			HERMES, IP860, RPXlite, LWMON,
+			FLAGADM, TQM8260
+
+- Access to physical memory region (> 4GB)
+		Some basic support is provided for operations on memory not
+		normally accessible to U-Boot - e.g. some architectures
+		support access to more than 4GB of memory on 32-bit
+		machines using physical address extension or similar.
+		Define CONFIG_PHYSMEM to access this basic support, which
+		currently only supports clearing the memory.
+
+- Error Recovery:
+		CONFIG_PANIC_HANG
+
+		Define this variable to stop the system in case of a
+		fatal error, so that you have to reset it manually.
+		This is probably NOT a good idea for an embedded
+		system where you want the system to reboot
+		automatically as fast as possible, but it may be
+		useful during development since you can try to debug
+		the conditions that lead to the situation.
+
+		CONFIG_NET_RETRY_COUNT
+
+		This variable defines the number of retries for
+		network operations like ARP, RARP, TFTP, or BOOTP
+		before giving up the operation. If not defined, a
+		default value of 5 is used.
+
+		CONFIG_ARP_TIMEOUT
+
+		Timeout waiting for an ARP reply in milliseconds.
+
+		CONFIG_NFS_TIMEOUT
+
+		Timeout in milliseconds used in NFS protocol.
+		If you encounter "ERROR: Cannot umount" in nfs command,
+		try longer timeout such as
+		#define CONFIG_NFS_TIMEOUT 10000UL
+
+- Command Interpreter:
+		CONFIG_AUTO_COMPLETE
+
+		Enable auto completion of commands using TAB.
+
+		CONFIG_SYS_PROMPT_HUSH_PS2
+
+		This defines the secondary prompt string, which is
+		printed when the command interpreter needs more input
+		to complete a command. Usually "> ".
+
+	Note:
+
+		In the current implementation, the local variables
+		space and global environment variables space are
+		separated. Local variables are those you define by
+		simply typing `name=value'. To access a local
+		variable later on, you have write `$name' or
+		`${name}'; to execute the contents of a variable
+		directly type `$name' at the command prompt.
+
+		Global environment variables are those you use
+		setenv/printenv to work with. To run a command stored
+		in such a variable, you need to use the run command,
+		and you must not use the '$' sign to access them.
+
+		To store commands and special characters in a
+		variable, please use double quotation marks
+		surrounding the whole text of the variable, instead
+		of the backslashes before semicolons and special
+		symbols.
+
+- Command Line Editing and History:
+		CONFIG_CMDLINE_EDITING
+
+		Enable editing and History functions for interactive
+		command line input operations
+
+- Command Line PS1/PS2 support:
+		CONFIG_CMDLINE_PS_SUPPORT
+
+		Enable support for changing the command prompt string
+		at run-time. Only static string is supported so far.
+		The string is obtained from environment variables PS1
+		and PS2.
+
+- Default Environment:
+		CONFIG_EXTRA_ENV_SETTINGS
+
+		Define this to contain any number of null terminated
+		strings (variable = value pairs) that will be part of
+		the default environment compiled into the boot image.
+
+		For example, place something like this in your
+		board's config file:
+
+		#define CONFIG_EXTRA_ENV_SETTINGS \
+			"myvar1=value1\0" \
+			"myvar2=value2\0"
+
+		Warning: This method is based on knowledge about the
+		internal format how the environment is stored by the
+		U-Boot code. This is NOT an official, exported
+		interface! Although it is unlikely that this format
+		will change soon, there is no guarantee either.
+		You better know what you are doing here.
+
+		Note: overly (ab)use of the default environment is
+		discouraged. Make sure to check other ways to preset
+		the environment like the "source" command or the
+		boot command first.
+
+		CONFIG_ENV_VARS_UBOOT_CONFIG
+
+		Define this in order to add variables describing the
+		U-Boot build configuration to the default environment.
+		These will be named arch, cpu, board, vendor, and soc.
+
+		Enabling this option will cause the following to be defined:
+
+		- CONFIG_SYS_ARCH
+		- CONFIG_SYS_CPU
+		- CONFIG_SYS_BOARD
+		- CONFIG_SYS_VENDOR
+		- CONFIG_SYS_SOC
+
+		CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+
+		Define this in order to add variables describing certain
+		run-time determined information about the hardware to the
+		environment.  These will be named board_name, board_rev.
+
+		CONFIG_DELAY_ENVIRONMENT
+
+		Normally the environment is loaded when the board is
+		initialised so that it is available to U-Boot. This inhibits
+		that so that the environment is not available until
+		explicitly loaded later by U-Boot code. With CONFIG_OF_CONTROL
+		this is instead controlled by the value of
+		/config/load-environment.
+
+- Parallel Flash support:
+		CONFIG_SYS_NO_FLASH
+
+		Traditionally U-Boot was run on systems with parallel NOR
+		flash. This option is used to disable support for parallel NOR
+		flash. This option should be defined if the board does not have
+		parallel flash.
+
+		If this option is not defined one of the generic flash drivers
+		(e.g.  CONFIG_FLASH_CFI_DRIVER or CONFIG_ST_SMI) must be
+		selected or the board must provide an implementation of the
+		flash API (see include/flash.h).
+
+- DataFlash Support:
+		CONFIG_HAS_DATAFLASH
+
+		Defining this option enables DataFlash features and
+		allows to read/write in Dataflash via the standard
+		commands cp, md...
+
+- Serial Flash support
+		CONFIG_CMD_SF
+
+		Defining this option enables SPI flash commands
+		'sf probe/read/write/erase/update'.
+
+		Usage requires an initial 'probe' to define the serial
+		flash parameters, followed by read/write/erase/update
+		commands.
+
+		The following defaults may be provided by the platform
+		to handle the common case when only a single serial
+		flash is present on the system.
+
+		CONFIG_SF_DEFAULT_BUS		Bus identifier
+		CONFIG_SF_DEFAULT_CS		Chip-select
+		CONFIG_SF_DEFAULT_MODE 		(see include/spi.h)
+		CONFIG_SF_DEFAULT_SPEED		in Hz
+
+		CONFIG_CMD_SF_TEST
+
+		Define this option to include a destructive SPI flash
+		test ('sf test').
+
+		CONFIG_SF_DUAL_FLASH		Dual flash memories
+
+		Define this option to use dual flash support where two flash
+		memories can be connected with a given cs line.
+		Currently Xilinx Zynq qspi supports these type of connections.
+
+- SystemACE Support:
+		CONFIG_SYSTEMACE
+
+		Adding this option adds support for Xilinx SystemACE
+		chips attached via some sort of local bus. The address
+		of the chip must also be defined in the
+		CONFIG_SYS_SYSTEMACE_BASE macro. For example:
+
+		#define CONFIG_SYSTEMACE
+		#define CONFIG_SYS_SYSTEMACE_BASE 0xf0000000
+
+		When SystemACE support is added, the "ace" device type
+		becomes available to the fat commands, i.e. fatls.
+
+- TFTP Fixed UDP Port:
+		CONFIG_TFTP_PORT
+
+		If this is defined, the environment variable tftpsrcp
+		is used to supply the TFTP UDP source port value.
+		If tftpsrcp isn't defined, the normal pseudo-random port
+		number generator is used.
+
+		Also, the environment variable tftpdstp is used to supply
+		the TFTP UDP destination port value.  If tftpdstp isn't
+		defined, the normal port 69 is used.
+
+		The purpose for tftpsrcp is to allow a TFTP server to
+		blindly start the TFTP transfer using the pre-configured
+		target IP address and UDP port. This has the effect of
+		"punching through" the (Windows XP) firewall, allowing
+		the remainder of the TFTP transfer to proceed normally.
+		A better solution is to properly configure the firewall,
+		but sometimes that is not allowed.
+
+- Hashing support:
+		CONFIG_CMD_HASH
+
+		This enables a generic 'hash' command which can produce
+		hashes / digests from a few algorithms (e.g. SHA1, SHA256).
+
+		CONFIG_HASH_VERIFY
+
+		Enable the hash verify command (hash -v). This adds to code
+		size a little.
+
+		CONFIG_SHA1 - This option enables support of hashing using SHA1
+		algorithm. The hash is calculated in software.
+		CONFIG_SHA256 - This option enables support of hashing using
+		SHA256 algorithm. The hash is calculated in software.
+		CONFIG_SHA_HW_ACCEL - This option enables hardware acceleration
+		for SHA1/SHA256 hashing.
+		This affects the 'hash' command and also the
+		hash_lookup_algo() function.
+		CONFIG_SHA_PROG_HW_ACCEL - This option enables
+		hardware-acceleration for SHA1/SHA256 progressive hashing.
+		Data can be streamed in a block at a time and the hashing
+		is performed in hardware.
+
+		Note: There is also a sha1sum command, which should perhaps
+		be deprecated in favour of 'hash sha1'.
+
+- Freescale i.MX specific commands:
+		CONFIG_CMD_HDMIDETECT
+		This enables 'hdmidet' command which returns true if an
+		HDMI monitor is detected.  This command is i.MX 6 specific.
+
+		CONFIG_CMD_BMODE
+		This enables the 'bmode' (bootmode) command for forcing
+		a boot from specific media.
+
+		This is useful for forcing the ROM's usb downloader to
+		activate upon a watchdog reset which is nice when iterating
+		on U-Boot.  Using the reset button or running bmode normal
+		will set it back to normal.  This command currently
+		supports i.MX53 and i.MX6.
+
+- Signing support:
+		CONFIG_RSA
+
+		This enables the RSA algorithm used for FIT image verification
+		in U-Boot. See doc/uImage.FIT/signature.txt for more information.
+
+		The Modular Exponentiation algorithm in RSA is implemented using
+		driver model. So CONFIG_DM needs to be enabled by default for this
+		library to function.
+
+		The signing part is build into mkimage regardless of this
+		option. The software based modular exponentiation is built into
+		mkimage irrespective of this option.
+
+- bootcount support:
+		CONFIG_BOOTCOUNT_LIMIT
+
+		This enables the bootcounter support, see:
+		http://www.denx.de/wiki/DULG/UBootBootCountLimit
+
+		CONFIG_AT91SAM9XE
+		enable special bootcounter support on at91sam9xe based boards.
+		CONFIG_BLACKFIN
+		enable special bootcounter support on blackfin based boards.
+		CONFIG_SOC_DA8XX
+		enable special bootcounter support on da850 based boards.
+		CONFIG_BOOTCOUNT_RAM
+		enable support for the bootcounter in RAM
+		CONFIG_BOOTCOUNT_I2C
+		enable support for the bootcounter on an i2c (like RTC) device.
+			CONFIG_SYS_I2C_RTC_ADDR = i2c chip address
+			CONFIG_SYS_BOOTCOUNT_ADDR = i2c addr which is used for
+						    the bootcounter.
+			CONFIG_BOOTCOUNT_ALEN = address len
+
+- Show boot progress:
+		CONFIG_SHOW_BOOT_PROGRESS
+
+		Defining this option allows to add some board-
+		specific code (calling a user-provided function
+		"show_boot_progress(int)") that enables you to show
+		the system's boot progress on some display (for
+		example, some LED's) on your board. At the moment,
+		the following checkpoints are implemented:
+
+
+Legacy uImage format:
+
+  Arg	Where			When
+    1	common/cmd_bootm.c	before attempting to boot an image
+   -1	common/cmd_bootm.c	Image header has bad	 magic number
+    2	common/cmd_bootm.c	Image header has correct magic number
+   -2	common/cmd_bootm.c	Image header has bad	 checksum
+    3	common/cmd_bootm.c	Image header has correct checksum
+   -3	common/cmd_bootm.c	Image data   has bad	 checksum
+    4	common/cmd_bootm.c	Image data   has correct checksum
+   -4	common/cmd_bootm.c	Image is for unsupported architecture
+    5	common/cmd_bootm.c	Architecture check OK
+   -5	common/cmd_bootm.c	Wrong Image Type (not kernel, multi)
+    6	common/cmd_bootm.c	Image Type check OK
+   -6	common/cmd_bootm.c	gunzip uncompression error
+   -7	common/cmd_bootm.c	Unimplemented compression type
+    7	common/cmd_bootm.c	Uncompression OK
+    8	common/cmd_bootm.c	No uncompress/copy overwrite error
+   -9	common/cmd_bootm.c	Unsupported OS (not Linux, BSD, VxWorks, QNX)
+
+    9	common/image.c		Start initial ramdisk verification
+  -10	common/image.c		Ramdisk header has bad	   magic number
+  -11	common/image.c		Ramdisk header has bad	   checksum
+   10	common/image.c		Ramdisk header is OK
+  -12	common/image.c		Ramdisk data   has bad	   checksum
+   11	common/image.c		Ramdisk data   has correct checksum
+   12	common/image.c		Ramdisk verification complete, start loading
+  -13	common/image.c		Wrong Image Type (not PPC Linux ramdisk)
+   13	common/image.c		Start multifile image verification
+   14	common/image.c		No initial ramdisk, no multifile, continue.
+
+   15	arch/<arch>/lib/bootm.c All preparation done, transferring control to OS
+
+  -30	arch/powerpc/lib/board.c	Fatal error, hang the system
+  -31	post/post.c		POST test failed, detected by post_output_backlog()
+  -32	post/post.c		POST test failed, detected by post_run_single()
+
+   34	common/cmd_doc.c	before loading a Image from a DOC device
+  -35	common/cmd_doc.c	Bad usage of "doc" command
+   35	common/cmd_doc.c	correct usage of "doc" command
+  -36	common/cmd_doc.c	No boot device
+   36	common/cmd_doc.c	correct boot device
+  -37	common/cmd_doc.c	Unknown Chip ID on boot device
+   37	common/cmd_doc.c	correct chip ID found, device available
+  -38	common/cmd_doc.c	Read Error on boot device
+   38	common/cmd_doc.c	reading Image header from DOC device OK
+  -39	common/cmd_doc.c	Image header has bad magic number
+   39	common/cmd_doc.c	Image header has correct magic number
+  -40	common/cmd_doc.c	Error reading Image from DOC device
+   40	common/cmd_doc.c	Image header has correct magic number
+   41	common/cmd_ide.c	before loading a Image from a IDE device
+  -42	common/cmd_ide.c	Bad usage of "ide" command
+   42	common/cmd_ide.c	correct usage of "ide" command
+  -43	common/cmd_ide.c	No boot device
+   43	common/cmd_ide.c	boot device found
+  -44	common/cmd_ide.c	Device not available
+   44	common/cmd_ide.c	Device available
+  -45	common/cmd_ide.c	wrong partition selected
+   45	common/cmd_ide.c	partition selected
+  -46	common/cmd_ide.c	Unknown partition table
+   46	common/cmd_ide.c	valid partition table found
+  -47	common/cmd_ide.c	Invalid partition type
+   47	common/cmd_ide.c	correct partition type
+  -48	common/cmd_ide.c	Error reading Image Header on boot device
+   48	common/cmd_ide.c	reading Image Header from IDE device OK
+  -49	common/cmd_ide.c	Image header has bad magic number
+   49	common/cmd_ide.c	Image header has correct magic number
+  -50	common/cmd_ide.c	Image header has bad	 checksum
+   50	common/cmd_ide.c	Image header has correct checksum
+  -51	common/cmd_ide.c	Error reading Image from IDE device
+   51	common/cmd_ide.c	reading Image from IDE device OK
+   52	common/cmd_nand.c	before loading a Image from a NAND device
+  -53	common/cmd_nand.c	Bad usage of "nand" command
+   53	common/cmd_nand.c	correct usage of "nand" command
+  -54	common/cmd_nand.c	No boot device
+   54	common/cmd_nand.c	boot device found
+  -55	common/cmd_nand.c	Unknown Chip ID on boot device
+   55	common/cmd_nand.c	correct chip ID found, device available
+  -56	common/cmd_nand.c	Error reading Image Header on boot device
+   56	common/cmd_nand.c	reading Image Header from NAND device OK
+  -57	common/cmd_nand.c	Image header has bad magic number
+   57	common/cmd_nand.c	Image header has correct magic number
+  -58	common/cmd_nand.c	Error reading Image from NAND device
+   58	common/cmd_nand.c	reading Image from NAND device OK
+
+  -60	common/env_common.c	Environment has a bad CRC, using default
+
+   64	net/eth.c		starting with Ethernet configuration.
+  -64	net/eth.c		no Ethernet found.
+   65	net/eth.c		Ethernet found.
+
+  -80	common/cmd_net.c	usage wrong
+   80	common/cmd_net.c	before calling net_loop()
+  -81	common/cmd_net.c	some error in net_loop() occurred
+   81	common/cmd_net.c	net_loop() back without error
+  -82	common/cmd_net.c	size == 0 (File with size 0 loaded)
+   82	common/cmd_net.c	trying automatic boot
+   83	common/cmd_net.c	running "source" command
+  -83	common/cmd_net.c	some error in automatic boot or "source" command
+   84	common/cmd_net.c	end without errors
+
+FIT uImage format:
+
+  Arg	Where			When
+  100	common/cmd_bootm.c	Kernel FIT Image has correct format
+ -100	common/cmd_bootm.c	Kernel FIT Image has incorrect format
+  101	common/cmd_bootm.c	No Kernel subimage unit name, using configuration
+ -101	common/cmd_bootm.c	Can't get configuration for kernel subimage
+  102	common/cmd_bootm.c	Kernel unit name specified
+ -103	common/cmd_bootm.c	Can't get kernel subimage node offset
+  103	common/cmd_bootm.c	Found configuration node
+  104	common/cmd_bootm.c	Got kernel subimage node offset
+ -104	common/cmd_bootm.c	Kernel subimage hash verification failed
+  105	common/cmd_bootm.c	Kernel subimage hash verification OK
+ -105	common/cmd_bootm.c	Kernel subimage is for unsupported architecture
+  106	common/cmd_bootm.c	Architecture check OK
+ -106	common/cmd_bootm.c	Kernel subimage has wrong type
+  107	common/cmd_bootm.c	Kernel subimage type OK
+ -107	common/cmd_bootm.c	Can't get kernel subimage data/size
+  108	common/cmd_bootm.c	Got kernel subimage data/size
+ -108	common/cmd_bootm.c	Wrong image type (not legacy, FIT)
+ -109	common/cmd_bootm.c	Can't get kernel subimage type
+ -110	common/cmd_bootm.c	Can't get kernel subimage comp
+ -111	common/cmd_bootm.c	Can't get kernel subimage os
+ -112	common/cmd_bootm.c	Can't get kernel subimage load address
+ -113	common/cmd_bootm.c	Image uncompress/copy overwrite error
+
+  120	common/image.c		Start initial ramdisk verification
+ -120	common/image.c		Ramdisk FIT image has incorrect format
+  121	common/image.c		Ramdisk FIT image has correct format
+  122	common/image.c		No ramdisk subimage unit name, using configuration
+ -122	common/image.c		Can't get configuration for ramdisk subimage
+  123	common/image.c		Ramdisk unit name specified
+ -124	common/image.c		Can't get ramdisk subimage node offset
+  125	common/image.c		Got ramdisk subimage node offset
+ -125	common/image.c		Ramdisk subimage hash verification failed
+  126	common/image.c		Ramdisk subimage hash verification OK
+ -126	common/image.c		Ramdisk subimage for unsupported architecture
+  127	common/image.c		Architecture check OK
+ -127	common/image.c		Can't get ramdisk subimage data/size
+  128	common/image.c		Got ramdisk subimage data/size
+  129	common/image.c		Can't get ramdisk load address
+ -129	common/image.c		Got ramdisk load address
+
+ -130	common/cmd_doc.c	Incorrect FIT image format
+  131	common/cmd_doc.c	FIT image format OK
+
+ -140	common/cmd_ide.c	Incorrect FIT image format
+  141	common/cmd_ide.c	FIT image format OK
+
+ -150	common/cmd_nand.c	Incorrect FIT image format
+  151	common/cmd_nand.c	FIT image format OK
+
+- legacy image format:
+		CONFIG_IMAGE_FORMAT_LEGACY
+		enables the legacy image format support in U-Boot.
+
+		Default:
+		enabled if CONFIG_FIT_SIGNATURE is not defined.
+
+		CONFIG_DISABLE_IMAGE_LEGACY
+		disable the legacy image format
+
+		This define is introduced, as the legacy image format is
+		enabled per default for backward compatibility.
+
+- FIT image support:
+		CONFIG_FIT
+		Enable support for the FIT uImage format.
+
+		CONFIG_FIT_BEST_MATCH
+		When no configuration is explicitly selected, default to the
+		one whose fdt's compatibility field best matches that of
+		U-Boot itself. A match is considered "best" if it matches the
+		most specific compatibility entry of U-Boot's fdt's root node.
+		The order of entries in the configuration's fdt is ignored.
+
+		CONFIG_FIT_SIGNATURE
+		This option enables signature verification of FIT uImages,
+		using a hash signed and verified using RSA. If
+		CONFIG_SHA_PROG_HW_ACCEL is defined, i.e support for progressive
+		hashing is available using hardware, RSA library will use it.
+		See doc/uImage.FIT/signature.txt for more details.
+
+		WARNING: When relying on signed FIT images with required
+		signature check the legacy image format is default
+		disabled. If a board need legacy image format support
+		enable this through CONFIG_IMAGE_FORMAT_LEGACY
+
+		CONFIG_FIT_DISABLE_SHA256
+		Supporting SHA256 hashes has quite an impact on binary size.
+		For constrained systems sha256 hash support can be disabled
+		with this option.
+
+- Standalone program support:
+		CONFIG_STANDALONE_LOAD_ADDR
+
+		This option defines a board specific value for the
+		address where standalone program gets loaded, thus
+		overwriting the architecture dependent default
+		settings.
+
+- Frame Buffer Address:
+		CONFIG_FB_ADDR
+
+		Define CONFIG_FB_ADDR if you want to use specific
+		address for frame buffer.  This is typically the case
+		when using a graphics controller has separate video
+		memory.  U-Boot will then place the frame buffer at
+		the given address instead of dynamically reserving it
+		in system RAM by calling lcd_setmem(), which grabs
+		the memory for the frame buffer depending on the
+		configured panel size.
+
+		Please see board_init_f function.
+
+- Automatic software updates via TFTP server
+		CONFIG_UPDATE_TFTP
+		CONFIG_UPDATE_TFTP_CNT_MAX
+		CONFIG_UPDATE_TFTP_MSEC_MAX
+
+		These options enable and control the auto-update feature;
+		for a more detailed description refer to doc/README.update.
+
+- MTD Support (mtdparts command, UBI support)
+		CONFIG_MTD_DEVICE
+
+		Adds the MTD device infrastructure from the Linux kernel.
+		Needed for mtdparts command support.
+
+		CONFIG_MTD_PARTITIONS
+
+		Adds the MTD partitioning infrastructure from the Linux
+		kernel. Needed for UBI support.
+
+- UBI support
+		CONFIG_CMD_UBI
+
+		Adds commands for interacting with MTD partitions formatted
+		with the UBI flash translation layer
+
+		Requires also defining CONFIG_RBTREE
+
+		CONFIG_UBI_SILENCE_MSG
+
+		Make the verbose messages from UBI stop printing.  This leaves
+		warnings and errors enabled.
+
+
+		CONFIG_MTD_UBI_WL_THRESHOLD
+		This parameter defines the maximum difference between the highest
+		erase counter value and the lowest erase counter value of eraseblocks
+		of UBI devices. When this threshold is exceeded, UBI starts performing
+		wear leveling by means of moving data from eraseblock with low erase
+		counter to eraseblocks with high erase counter.
+
+		The default value should be OK for SLC NAND flashes, NOR flashes and
+		other flashes which have eraseblock life-cycle 100000 or more.
+		However, in case of MLC NAND flashes which typically have eraseblock
+		life-cycle less than 10000, the threshold should be lessened (e.g.,
+		to 128 or 256, although it does not have to be power of 2).
+
+		default: 4096
+
+		CONFIG_MTD_UBI_BEB_LIMIT
+		This option specifies the maximum bad physical eraseblocks UBI
+		expects on the MTD device (per 1024 eraseblocks). If the
+		underlying flash does not admit of bad eraseblocks (e.g. NOR
+		flash), this value is ignored.
+
+		NAND datasheets often specify the minimum and maximum NVM
+		(Number of Valid Blocks) for the flashes' endurance lifetime.
+		The maximum expected bad eraseblocks per 1024 eraseblocks
+		then can be calculated as "1024 * (1 - MinNVB / MaxNVB)",
+		which gives 20 for most NANDs (MaxNVB is basically the total
+		count of eraseblocks on the chip).
+
+		To put it differently, if this value is 20, UBI will try to
+		reserve about 1.9% of physical eraseblocks for bad blocks
+		handling. And that will be 1.9% of eraseblocks on the entire
+		NAND chip, not just the MTD partition UBI attaches. This means
+		that if you have, say, a NAND flash chip admits maximum 40 bad
+		eraseblocks, and it is split on two MTD partitions of the same
+		size, UBI will reserve 40 eraseblocks when attaching a
+		partition.
+
+		default: 20
+
+		CONFIG_MTD_UBI_FASTMAP
+		Fastmap is a mechanism which allows attaching an UBI device
+		in nearly constant time. Instead of scanning the whole MTD device it
+		only has to locate a checkpoint (called fastmap) on the device.
+		The on-flash fastmap contains all information needed to attach
+		the device. Using fastmap makes only sense on large devices where
+		attaching by scanning takes long. UBI will not automatically install
+		a fastmap on old images, but you can set the UBI parameter
+		CONFIG_MTD_UBI_FASTMAP_AUTOCONVERT to 1 if you want so. Please note
+		that fastmap-enabled images are still usable with UBI implementations
+		without	fastmap support. On typical flash devices the whole fastmap
+		fits into one PEB. UBI will reserve PEBs to hold two fastmaps.
+
+		CONFIG_MTD_UBI_FASTMAP_AUTOCONVERT
+		Set this parameter to enable fastmap automatically on images
+		without a fastmap.
+		default: 0
+
+		CONFIG_MTD_UBI_FM_DEBUG
+		Enable UBI fastmap debug
+		default: 0
+
+- UBIFS support
+		CONFIG_CMD_UBIFS
+
+		Adds commands for interacting with UBI volumes formatted as
+		UBIFS.  UBIFS is read-only in u-boot.
+
+		Requires UBI support as well as CONFIG_LZO
+
+		CONFIG_UBIFS_SILENCE_MSG
+
+		Make the verbose messages from UBIFS stop printing.  This leaves
+		warnings and errors enabled.
+
+- SPL framework
+		CONFIG_SPL
+		Enable building of SPL globally.
+
+		CONFIG_SPL_LDSCRIPT
+		LDSCRIPT for linking the SPL binary.
+
+		CONFIG_SPL_MAX_FOOTPRINT
+		Maximum size in memory allocated to the SPL, BSS included.
+		When defined, the linker checks that the actual memory
+		used by SPL from _start to __bss_end does not exceed it.
+		CONFIG_SPL_MAX_FOOTPRINT and CONFIG_SPL_BSS_MAX_SIZE
+		must not be both defined at the same time.
+
+		CONFIG_SPL_MAX_SIZE
+		Maximum size of the SPL image (text, data, rodata, and
+		linker lists sections), BSS excluded.
+		When defined, the linker checks that the actual size does
+		not exceed it.
+
+		CONFIG_SPL_TEXT_BASE
+		TEXT_BASE for linking the SPL binary.
+
+		CONFIG_SPL_RELOC_TEXT_BASE
+		Address to relocate to.  If unspecified, this is equal to
+		CONFIG_SPL_TEXT_BASE (i.e. no relocation is done).
+
+		CONFIG_SPL_BSS_START_ADDR
+		Link address for the BSS within the SPL binary.
+
+		CONFIG_SPL_BSS_MAX_SIZE
+		Maximum size in memory allocated to the SPL BSS.
+		When defined, the linker checks that the actual memory used
+		by SPL from __bss_start to __bss_end does not exceed it.
+		CONFIG_SPL_MAX_FOOTPRINT and CONFIG_SPL_BSS_MAX_SIZE
+		must not be both defined at the same time.
+
+		CONFIG_SPL_STACK
+		Adress of the start of the stack SPL will use
+
+		CONFIG_SPL_PANIC_ON_RAW_IMAGE
+		When defined, SPL will panic() if the image it has
+		loaded does not have a signature.
+		Defining this is useful when code which loads images
+		in SPL cannot guarantee that absolutely all read errors
+		will be caught.
+		An example is the LPC32XX MLC NAND driver, which will
+		consider that a completely unreadable NAND block is bad,
+		and thus should be skipped silently.
+
+		CONFIG_SPL_RELOC_STACK
+		Adress of the start of the stack SPL will use after
+		relocation.  If unspecified, this is equal to
+		CONFIG_SPL_STACK.
+
+		CONFIG_SYS_SPL_MALLOC_START
+		Starting address of the malloc pool used in SPL.
+		When this option is set the full malloc is used in SPL and
+		it is set up by spl_init() and before that, the simple malloc()
+		can be used if CONFIG_SYS_MALLOC_F is defined.
+
+		CONFIG_SYS_SPL_MALLOC_SIZE
+		The size of the malloc pool used in SPL.
+
+		CONFIG_SPL_FRAMEWORK
+		Enable the SPL framework under common/.  This framework
+		supports MMC, NAND and YMODEM loading of U-Boot and NAND
+		NAND loading of the Linux Kernel.
+
+		CONFIG_SPL_OS_BOOT
+		Enable booting directly to an OS from SPL.
+		See also: doc/README.falcon
+
+		CONFIG_SPL_DISPLAY_PRINT
+		For ARM, enable an optional function to print more information
+		about the running system.
+
+		CONFIG_SPL_INIT_MINIMAL
+		Arch init code should be built for a very small image
+
+		CONFIG_SPL_LIBCOMMON_SUPPORT
+		Support for common/libcommon.o in SPL binary
+
+		CONFIG_SPL_LIBDISK_SUPPORT
+		Support for disk/libdisk.o in SPL binary
+
+		CONFIG_SPL_I2C_SUPPORT
+		Support for drivers/i2c/libi2c.o in SPL binary
+
+		CONFIG_SPL_GPIO_SUPPORT
+		Support for drivers/gpio/libgpio.o in SPL binary
+
+		CONFIG_SPL_MMC_SUPPORT
+		Support for drivers/mmc/libmmc.o in SPL binary
+
+		CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR,
+		CONFIG_SYS_U_BOOT_MAX_SIZE_SECTORS,
+		Address and partition on the MMC to load U-Boot from
+		when the MMC is being used in raw mode.
+
+		CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION
+		Partition on the MMC to load U-Boot from when the MMC is being
+		used in raw mode
+
+		CONFIG_SYS_MMCSD_RAW_MODE_KERNEL_SECTOR
+		Sector to load kernel uImage from when MMC is being
+		used in raw mode (for Falcon mode)
+
+		CONFIG_SYS_MMCSD_RAW_MODE_ARGS_SECTOR,
+		CONFIG_SYS_MMCSD_RAW_MODE_ARGS_SECTORS
+		Sector and number of sectors to load kernel argument
+		parameters from when MMC is being used in raw mode
+		(for falcon mode)
+
+		CONFIG_SYS_MMCSD_FS_BOOT_PARTITION
+		Partition on the MMC to load U-Boot from when the MMC is being
+		used in fs mode
+
+		CONFIG_SPL_FAT_SUPPORT
+		Support for fs/fat/libfat.o in SPL binary
+
+		CONFIG_SPL_EXT_SUPPORT
+		Support for EXT filesystem in SPL binary
+
+		CONFIG_SPL_FS_LOAD_PAYLOAD_NAME
+		Filename to read to load U-Boot when reading from filesystem
+
+		CONFIG_SPL_FS_LOAD_KERNEL_NAME
+		Filename to read to load kernel uImage when reading
+		from filesystem (for Falcon mode)
+
+		CONFIG_SPL_FS_LOAD_ARGS_NAME
+		Filename to read to load kernel argument parameters
+		when reading from filesystem (for Falcon mode)
+
+		CONFIG_SPL_MPC83XX_WAIT_FOR_NAND
+		Set this for NAND SPL on PPC mpc83xx targets, so that
+		start.S waits for the rest of the SPL to load before
+		continuing (the hardware starts execution after just
+		loading the first page rather than the full 4K).
+
+		CONFIG_SPL_SKIP_RELOCATE
+		Avoid SPL relocation
+
+		CONFIG_SPL_NAND_BASE
+		Include nand_base.c in the SPL.  Requires
+		CONFIG_SPL_NAND_DRIVERS.
+
+		CONFIG_SPL_NAND_DRIVERS
+		SPL uses normal NAND drivers, not minimal drivers.
+
+		CONFIG_SPL_NAND_ECC
+		Include standard software ECC in the SPL
+
+		CONFIG_SPL_NAND_SIMPLE
+		Support for NAND boot using simple NAND drivers that
+		expose the cmd_ctrl() interface.
+
+		CONFIG_SPL_MTD_SUPPORT
+		Support for the MTD subsystem within SPL.  Useful for
+		environment on NAND support within SPL.
+
+		CONFIG_SPL_NAND_RAW_ONLY
+		Support to boot only raw u-boot.bin images. Use this only
+		if you need to save space.
+
+		CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+		Set for the SPL on PPC mpc8xxx targets, support for
+		drivers/ddr/fsl/libddr.o in SPL binary.
+
+		CONFIG_SPL_COMMON_INIT_DDR
+		Set for common ddr init with serial presence detect in
+		SPL binary.
+
+		CONFIG_SYS_NAND_5_ADDR_CYCLE, CONFIG_SYS_NAND_PAGE_COUNT,
+		CONFIG_SYS_NAND_PAGE_SIZE, CONFIG_SYS_NAND_OOBSIZE,
+		CONFIG_SYS_NAND_BLOCK_SIZE, CONFIG_SYS_NAND_BAD_BLOCK_POS,
+		CONFIG_SYS_NAND_ECCPOS, CONFIG_SYS_NAND_ECCSIZE,
+		CONFIG_SYS_NAND_ECCBYTES
+		Defines the size and behavior of the NAND that SPL uses
+		to read U-Boot
+
+		CONFIG_SPL_NAND_BOOT
+		Add support NAND boot
+
+		CONFIG_SYS_NAND_U_BOOT_OFFS
+		Location in NAND to read U-Boot from
+
+		CONFIG_SYS_NAND_U_BOOT_DST
+		Location in memory to load U-Boot to
+
+		CONFIG_SYS_NAND_U_BOOT_SIZE
+		Size of image to load
+
+		CONFIG_SYS_NAND_U_BOOT_START
+		Entry point in loaded image to jump to
+
+		CONFIG_SYS_NAND_HW_ECC_OOBFIRST
+		Define this if you need to first read the OOB and then the
+		data. This is used, for example, on davinci platforms.
+
+		CONFIG_SPL_OMAP3_ID_NAND
+		Support for an OMAP3-specific set of functions to return the
+		ID and MFR of the first attached NAND chip, if present.
+
+		CONFIG_SPL_SERIAL_SUPPORT
+		Support for drivers/serial/libserial.o in SPL binary
+
+		CONFIG_SPL_SPI_FLASH_SUPPORT
+		Support for drivers/mtd/spi/libspi_flash.o in SPL binary
+
+		CONFIG_SPL_SPI_SUPPORT
+		Support for drivers/spi/libspi.o in SPL binary
+
+		CONFIG_SPL_RAM_DEVICE
+		Support for running image already present in ram, in SPL binary
+
+		CONFIG_SPL_LIBGENERIC_SUPPORT
+		Support for lib/libgeneric.o in SPL binary
+
+		CONFIG_SPL_ENV_SUPPORT
+		Support for the environment operating in SPL binary
+
+		CONFIG_SPL_NET_SUPPORT
+		Support for the net/libnet.o in SPL binary.
+		It conflicts with SPL env from storage medium specified by
+		CONFIG_ENV_IS_xxx but CONFIG_ENV_IS_NOWHERE
+
+		CONFIG_SPL_PAD_TO
+		Image offset to which the SPL should be padded before appending
+		the SPL payload. By default, this is defined as
+		CONFIG_SPL_MAX_SIZE, or 0 if CONFIG_SPL_MAX_SIZE is undefined.
+		CONFIG_SPL_PAD_TO must be either 0, meaning to append the SPL
+		payload without any padding, or >= CONFIG_SPL_MAX_SIZE.
+
+		CONFIG_SPL_TARGET
+		Final target image containing SPL and payload.  Some SPLs
+		use an arch-specific makefile fragment instead, for
+		example if more than one image needs to be produced.
+
+		CONFIG_FIT_SPL_PRINT
+		Printing information about a FIT image adds quite a bit of
+		code to SPL. So this is normally disabled in SPL. Use this
+		option to re-enable it. This will affect the output of the
+		bootm command when booting a FIT image.
+
+- TPL framework
+		CONFIG_TPL
+		Enable building of TPL globally.
+
+		CONFIG_TPL_PAD_TO
+		Image offset to which the TPL should be padded before appending
+		the TPL payload. By default, this is defined as
+		CONFIG_SPL_MAX_SIZE, or 0 if CONFIG_SPL_MAX_SIZE is undefined.
+		CONFIG_SPL_PAD_TO must be either 0, meaning to append the SPL
+		payload without any padding, or >= CONFIG_SPL_MAX_SIZE.
+
+- Interrupt support (PPC):
+
+		There are common interrupt_init() and timer_interrupt()
+		for all PPC archs. interrupt_init() calls interrupt_init_cpu()
+		for CPU specific initialization. interrupt_init_cpu()
+		should set decrementer_count to appropriate value. If
+		CPU resets decrementer automatically after interrupt
+		(ppc4xx) it should set decrementer_count to zero.
+		timer_interrupt() calls timer_interrupt_cpu() for CPU
+		specific handling. If board has watchdog / status_led
+		/ other_activity_monitor it works automatically from
+		general timer_interrupt().
+
+
+Board initialization settings:
+------------------------------
+
+During Initialization u-boot calls a number of board specific functions
+to allow the preparation of board specific prerequisites, e.g. pin setup
+before drivers are initialized. To enable these callbacks the
+following configuration macros have to be defined. Currently this is
+architecture specific, so please check arch/your_architecture/lib/board.c
+typically in board_init_f() and board_init_r().
+
+- CONFIG_BOARD_EARLY_INIT_F: Call board_early_init_f()
+- CONFIG_BOARD_EARLY_INIT_R: Call board_early_init_r()
+- CONFIG_BOARD_LATE_INIT: Call board_late_init()
+- CONFIG_BOARD_POSTCLK_INIT: Call board_postclk_init()
+
+Configuration Settings:
+-----------------------
+
+- CONFIG_SYS_SUPPORT_64BIT_DATA: Defined automatically if compiled as 64-bit.
+		Optionally it can be defined to support 64-bit memory commands.
+
+- CONFIG_SYS_LONGHELP: Defined when you want long help messages included;
+		undefine this when you're short of memory.
+
+- CONFIG_SYS_HELP_CMD_WIDTH: Defined when you want to override the default
+		width of the commands listed in the 'help' command output.
+
+- CONFIG_SYS_PROMPT:	This is what U-Boot prints on the console to
+		prompt for user input.
+
+- CONFIG_SYS_CBSIZE:	Buffer size for input from the Console
+
+- CONFIG_SYS_PBSIZE:	Buffer size for Console output
+
+- CONFIG_SYS_MAXARGS:	max. Number of arguments accepted for monitor commands
+
+- CONFIG_SYS_BARGSIZE: Buffer size for Boot Arguments which are passed to
+		the application (usually a Linux kernel) when it is
+		booted
+
+- CONFIG_SYS_BAUDRATE_TABLE:
+		List of legal baudrate settings for this board.
+
+- CONFIG_SYS_CONSOLE_INFO_QUIET
+		Suppress display of console information at boot.
+
+- CONFIG_SYS_CONSOLE_IS_IN_ENV
+		If the board specific function
+			extern int overwrite_console (void);
+		returns 1, the stdin, stderr and stdout are switched to the
+		serial port, else the settings in the environment are used.
+
+- CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
+		Enable the call to overwrite_console().
+
+- CONFIG_SYS_CONSOLE_ENV_OVERWRITE
+		Enable overwrite of previous console environment settings.
+
+- CONFIG_SYS_MEMTEST_START, CONFIG_SYS_MEMTEST_END:
+		Begin and End addresses of the area used by the
+		simple memory test.
+
+- CONFIG_SYS_ALT_MEMTEST:
+		Enable an alternate, more extensive memory test.
+
+- CONFIG_SYS_MEMTEST_SCRATCH:
+		Scratch address used by the alternate memory test
+		You only need to set this if address zero isn't writeable
+
+- CONFIG_SYS_MEM_RESERVE_SECURE
+		If defined, the size of CONFIG_SYS_MEM_RESERVE_SECURE memory
+		is substracted from total RAM and won't be reported to OS.
+		This memory can be used as secure memory. A variable
+		gd->secure_ram is used to track the location. In systems
+		the RAM base is not zero, or RAM is divided into banks,
+		this variable needs to be recalcuated to get the address.
+
+- CONFIG_SYS_MEM_TOP_HIDE:
+		If CONFIG_SYS_MEM_TOP_HIDE is defined in the board config header,
+		this specified memory area will get subtracted from the top
+		(end) of RAM and won't get "touched" at all by U-Boot. By
+		fixing up gd->ram_size the Linux kernel should gets passed
+		the now "corrected" memory size and won't touch it either.
+		This should work for arch/ppc and arch/powerpc. Only Linux
+		board ports in arch/powerpc with bootwrapper support that
+		recalculate the memory size from the SDRAM controller setup
+		will have to get fixed in Linux additionally.
+
+		This option can be used as a workaround for the 440EPx/GRx
+		CHIP 11 errata where the last 256 bytes in SDRAM shouldn't
+		be touched.
+
+		WARNING: Please make sure that this value is a multiple of
+		the Linux page size (normally 4k). If this is not the case,
+		then the end address of the Linux memory will be located at a
+		non page size aligned address and this could cause major
+		problems.
+
+- CONFIG_SYS_LOADS_BAUD_CHANGE:
+		Enable temporary baudrate change while serial download
+
+- CONFIG_SYS_SDRAM_BASE:
+		Physical start address of SDRAM. _Must_ be 0 here.
+
+- CONFIG_SYS_MBIO_BASE:
+		Physical start address of Motherboard I/O (if using a
+		Cogent motherboard)
+
+- CONFIG_SYS_FLASH_BASE:
+		Physical start address of Flash memory.
+
+- CONFIG_SYS_MONITOR_BASE:
+		Physical start address of boot monitor code (set by
+		make config files to be same as the text base address
+		(CONFIG_SYS_TEXT_BASE) used when linking) - same as
+		CONFIG_SYS_FLASH_BASE when booting from flash.
+
+- CONFIG_SYS_MONITOR_LEN:
+		Size of memory reserved for monitor code, used to
+		determine _at_compile_time_ (!) if the environment is
+		embedded within the U-Boot image, or in a separate
+		flash sector.
+
+- CONFIG_SYS_MALLOC_LEN:
+		Size of DRAM reserved for malloc() use.
+
+- CONFIG_SYS_MALLOC_F_LEN
+		Size of the malloc() pool for use before relocation. If
+		this is defined, then a very simple malloc() implementation
+		will become available before relocation. The address is just
+		below the global data, and the stack is moved down to make
+		space.
+
+		This feature allocates regions with increasing addresses
+		within the region. calloc() is supported, but realloc()
+		is not available. free() is supported but does nothing.
+		The memory will be freed (or in fact just forgotten) when
+		U-Boot relocates itself.
+
+		Pre-relocation malloc() is only supported on ARM and sandbox
+		at present but is fairly easy to enable for other archs.
+
+- CONFIG_SYS_MALLOC_SIMPLE
+		Provides a simple and small malloc() and calloc() for those
+		boards which do not use the full malloc in SPL (which is
+		enabled with CONFIG_SYS_SPL_MALLOC_START).
+
+- CONFIG_SYS_NONCACHED_MEMORY:
+		Size of non-cached memory area. This area of memory will be
+		typically located right below the malloc() area and mapped
+		uncached in the MMU. This is useful for drivers that would
+		otherwise require a lot of explicit cache maintenance. For
+		some drivers it's also impossible to properly maintain the
+		cache. For example if the regions that need to be flushed
+		are not a multiple of the cache-line size, *and* padding
+		cannot be allocated between the regions to align them (i.e.
+		if the HW requires a contiguous array of regions, and the
+		size of each region is not cache-aligned), then a flush of
+		one region may result in overwriting data that hardware has
+		written to another region in the same cache-line. This can
+		happen for example in network drivers where descriptors for
+		buffers are typically smaller than the CPU cache-line (e.g.
+		16 bytes vs. 32 or 64 bytes).
+
+		Non-cached memory is only supported on 32-bit ARM at present.
+
+- CONFIG_SYS_BOOTM_LEN:
+		Normally compressed uImages are limited to an
+		uncompressed size of 8 MBytes. If this is not enough,
+		you can define CONFIG_SYS_BOOTM_LEN in your board config file
+		to adjust this setting to your needs.
+
+- CONFIG_SYS_BOOTMAPSZ:
+		Maximum size of memory mapped by the startup code of
+		the Linux kernel; all data that must be processed by
+		the Linux kernel (bd_info, boot arguments, FDT blob if
+		used) must be put below this limit, unless "bootm_low"
+		environment variable is defined and non-zero. In such case
+		all data for the Linux kernel must be between "bootm_low"
+		and "bootm_low" + CONFIG_SYS_BOOTMAPSZ.	 The environment
+		variable "bootm_mapsize" will override the value of
+		CONFIG_SYS_BOOTMAPSZ.  If CONFIG_SYS_BOOTMAPSZ is undefined,
+		then the value in "bootm_size" will be used instead.
+
+- CONFIG_SYS_BOOT_RAMDISK_HIGH:
+		Enable initrd_high functionality.  If defined then the
+		initrd_high feature is enabled and the bootm ramdisk subcommand
+		is enabled.
+
+- CONFIG_SYS_BOOT_GET_CMDLINE:
+		Enables allocating and saving kernel cmdline in space between
+		"bootm_low" and "bootm_low" + BOOTMAPSZ.
+
+- CONFIG_SYS_BOOT_GET_KBD:
+		Enables allocating and saving a kernel copy of the bd_info in
+		space between "bootm_low" and "bootm_low" + BOOTMAPSZ.
+
+- CONFIG_SYS_MAX_FLASH_BANKS:
+		Max number of Flash memory banks
+
+- CONFIG_SYS_MAX_FLASH_SECT:
+		Max number of sectors on a Flash chip
+
+- CONFIG_SYS_FLASH_ERASE_TOUT:
+		Timeout for Flash erase operations (in ms)
+
+- CONFIG_SYS_FLASH_WRITE_TOUT:
+		Timeout for Flash write operations (in ms)
+
+- CONFIG_SYS_FLASH_LOCK_TOUT
+		Timeout for Flash set sector lock bit operation (in ms)
+
+- CONFIG_SYS_FLASH_UNLOCK_TOUT
+		Timeout for Flash clear lock bits operation (in ms)
+
+- CONFIG_SYS_FLASH_PROTECTION
+		If defined, hardware flash sectors protection is used
+		instead of U-Boot software protection.
+
+- CONFIG_SYS_DIRECT_FLASH_TFTP:
+
+		Enable TFTP transfers directly to flash memory;
+		without this option such a download has to be
+		performed in two steps: (1) download to RAM, and (2)
+		copy from RAM to flash.
+
+		The two-step approach is usually more reliable, since
+		you can check if the download worked before you erase
+		the flash, but in some situations (when system RAM is
+		too limited to allow for a temporary copy of the
+		downloaded image) this option may be very useful.
+
+- CONFIG_SYS_FLASH_CFI:
+		Define if the flash driver uses extra elements in the
+		common flash structure for storing flash geometry.
+
+- CONFIG_FLASH_CFI_DRIVER
+		This option also enables the building of the cfi_flash driver
+		in the drivers directory
+
+- CONFIG_FLASH_CFI_MTD
+		This option enables the building of the cfi_mtd driver
+		in the drivers directory. The driver exports CFI flash
+		to the MTD layer.
+
+- CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+		Use buffered writes to flash.
+
+- CONFIG_FLASH_SPANSION_S29WS_N
+		s29ws-n MirrorBit flash has non-standard addresses for buffered
+		write commands.
+
+- CONFIG_SYS_FLASH_QUIET_TEST
+		If this option is defined, the common CFI flash doesn't
+		print it's warning upon not recognized FLASH banks. This
+		is useful, if some of the configured banks are only
+		optionally available.
+
+- CONFIG_FLASH_SHOW_PROGRESS
+		If defined (must be an integer), print out countdown
+		digits and dots.  Recommended value: 45 (9..1) for 80
+		column displays, 15 (3..1) for 40 column displays.
+
+- CONFIG_FLASH_VERIFY
+		If defined, the content of the flash (destination) is compared
+		against the source after the write operation. An error message
+		will be printed when the contents are not identical.
+		Please note that this option is useless in nearly all cases,
+		since such flash programming errors usually are detected earlier
+		while unprotecting/erasing/programming. Please only enable
+		this option if you really know what you are doing.
+
+- CONFIG_SYS_RX_ETH_BUFFER:
+		Defines the number of Ethernet receive buffers. On some
+		Ethernet controllers it is recommended to set this value
+		to 8 or even higher (EEPRO100 or 405 EMAC), since all
+		buffers can be full shortly after enabling the interface
+		on high Ethernet traffic.
+		Defaults to 4 if not defined.
+
+- CONFIG_ENV_MAX_ENTRIES
+
+	Maximum number of entries in the hash table that is used
+	internally to store the environment settings. The default
+	setting is supposed to be generous and should work in most
+	cases. This setting can be used to tune behaviour; see
+	lib/hashtable.c for details.
+
+- CONFIG_ENV_FLAGS_LIST_DEFAULT
+- CONFIG_ENV_FLAGS_LIST_STATIC
+	Enable validation of the values given to environment variables when
+	calling env set.  Variables can be restricted to only decimal,
+	hexadecimal, or boolean.  If CONFIG_CMD_NET is also defined,
+	the variables can also be restricted to IP address or MAC address.
+
+	The format of the list is:
+		type_attribute = [s|d|x|b|i|m]
+		access_attribute = [a|r|o|c]
+		attributes = type_attribute[access_attribute]
+		entry = variable_name[:attributes]
+		list = entry[,list]
+
+	The type attributes are:
+		s - String (default)
+		d - Decimal
+		x - Hexadecimal
+		b - Boolean ([1yYtT|0nNfF])
+		i - IP address
+		m - MAC address
+
+	The access attributes are:
+		a - Any (default)
+		r - Read-only
+		o - Write-once
+		c - Change-default
+
+	- CONFIG_ENV_FLAGS_LIST_DEFAULT
+		Define this to a list (string) to define the ".flags"
+		environment variable in the default or embedded environment.
+
+	- CONFIG_ENV_FLAGS_LIST_STATIC
+		Define this to a list (string) to define validation that
+		should be done if an entry is not found in the ".flags"
+		environment variable.  To override a setting in the static
+		list, simply add an entry for the same variable name to the
+		".flags" variable.
+
+	If CONFIG_REGEX is defined, the variable_name above is evaluated as a
+	regular expression. This allows multiple variables to define the same
+	flags without explicitly listing them for each variable.
+
+- CONFIG_ENV_ACCESS_IGNORE_FORCE
+	If defined, don't allow the -f switch to env set override variable
+	access flags.
+
+- CONFIG_SYS_GENERIC_BOARD
+	This selects the architecture-generic board system instead of the
+	architecture-specific board files. It is intended to move boards
+	to this new framework over time. Defining this will disable the
+	arch/foo/lib/board.c file and use common/board_f.c and
+	common/board_r.c instead. To use this option your architecture
+	must support it (i.e. must select HAVE_GENERIC_BOARD in arch/Kconfig).
+	If you find problems enabling this option on your board please report
+	the problem and send patches!
+
+- CONFIG_OMAP_PLATFORM_RESET_TIME_MAX_USEC (OMAP only)
+	This is set by OMAP boards for the max time that reset should
+	be asserted. See doc/README.omap-reset-time for details on how
+	the value can be calculated on a given board.
+
+- CONFIG_USE_STDINT
+	If stdint.h is available with your toolchain you can define this
+	option to enable it. You can provide option 'USE_STDINT=1' when
+	building U-Boot to enable this.
+
+The following definitions that deal with the placement and management
+of environment data (variable area); in general, we support the
+following configurations:
+
+- CONFIG_BUILD_ENVCRC:
+
+	Builds up envcrc with the target environment so that external utils
+	may easily extract it and embed it in final U-Boot images.
+
+- CONFIG_ENV_IS_IN_FLASH:
+
+	Define this if the environment is in flash memory.
+
+	a) The environment occupies one whole flash sector, which is
+	   "embedded" in the text segment with the U-Boot code. This
+	   happens usually with "bottom boot sector" or "top boot
+	   sector" type flash chips, which have several smaller
+	   sectors at the start or the end. For instance, such a
+	   layout can have sector sizes of 8, 2x4, 16, Nx32 kB. In
+	   such a case you would place the environment in one of the
+	   4 kB sectors - with U-Boot code before and after it. With
+	   "top boot sector" type flash chips, you would put the
+	   environment in one of the last sectors, leaving a gap
+	   between U-Boot and the environment.
+
+	- CONFIG_ENV_OFFSET:
+
+	   Offset of environment data (variable area) to the
+	   beginning of flash memory; for instance, with bottom boot
+	   type flash chips the second sector can be used: the offset
+	   for this sector is given here.
+
+	   CONFIG_ENV_OFFSET is used relative to CONFIG_SYS_FLASH_BASE.
+
+	- CONFIG_ENV_ADDR:
+
+	   This is just another way to specify the start address of
+	   the flash sector containing the environment (instead of
+	   CONFIG_ENV_OFFSET).
+
+	- CONFIG_ENV_SECT_SIZE:
+
+	   Size of the sector containing the environment.
+
+
+	b) Sometimes flash chips have few, equal sized, BIG sectors.
+	   In such a case you don't want to spend a whole sector for
+	   the environment.
+
+	- CONFIG_ENV_SIZE:
+
+	   If you use this in combination with CONFIG_ENV_IS_IN_FLASH
+	   and CONFIG_ENV_SECT_SIZE, you can specify to use only a part
+	   of this flash sector for the environment. This saves
+	   memory for the RAM copy of the environment.
+
+	   It may also save flash memory if you decide to use this
+	   when your environment is "embedded" within U-Boot code,
+	   since then the remainder of the flash sector could be used
+	   for U-Boot code. It should be pointed out that this is
+	   STRONGLY DISCOURAGED from a robustness point of view:
+	   updating the environment in flash makes it always
+	   necessary to erase the WHOLE sector. If something goes
+	   wrong before the contents has been restored from a copy in
+	   RAM, your target system will be dead.
+
+	- CONFIG_ENV_ADDR_REDUND
+	  CONFIG_ENV_SIZE_REDUND
+
+	   These settings describe a second storage area used to hold
+	   a redundant copy of the environment data, so that there is
+	   a valid backup copy in case there is a power failure during
+	   a "saveenv" operation.
+
+BE CAREFUL! Any changes to the flash layout, and some changes to the
+source code will make it necessary to adapt <board>/u-boot.lds*
+accordingly!
+
+
+- CONFIG_ENV_IS_IN_NVRAM:
+
+	Define this if you have some non-volatile memory device
+	(NVRAM, battery buffered SRAM) which you want to use for the
+	environment.
+
+	- CONFIG_ENV_ADDR:
+	- CONFIG_ENV_SIZE:
+
+	  These two #defines are used to determine the memory area you
+	  want to use for environment. It is assumed that this memory
+	  can just be read and written to, without any special
+	  provision.
+
+BE CAREFUL! The first access to the environment happens quite early
+in U-Boot initialization (when we try to get the setting of for the
+console baudrate). You *MUST* have mapped your NVRAM area then, or
+U-Boot will hang.
+
+Please note that even with NVRAM we still use a copy of the
+environment in RAM: we could work on NVRAM directly, but we want to
+keep settings there always unmodified except somebody uses "saveenv"
+to save the current settings.
+
+
+- CONFIG_ENV_IS_IN_EEPROM:
+
+	Use this if you have an EEPROM or similar serial access
+	device and a driver for it.
+
+	- CONFIG_ENV_OFFSET:
+	- CONFIG_ENV_SIZE:
+
+	  These two #defines specify the offset and size of the
+	  environment area within the total memory of your EEPROM.
+
+	- CONFIG_SYS_I2C_EEPROM_ADDR:
+	  If defined, specified the chip address of the EEPROM device.
+	  The default address is zero.
+
+	- CONFIG_SYS_I2C_EEPROM_BUS:
+	  If defined, specified the i2c bus of the EEPROM device.
+
+	- CONFIG_SYS_EEPROM_PAGE_WRITE_BITS:
+	  If defined, the number of bits used to address bytes in a
+	  single page in the EEPROM device.  A 64 byte page, for example
+	  would require six bits.
+
+	- CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS:
+	  If defined, the number of milliseconds to delay between
+	  page writes.	The default is zero milliseconds.
+
+	- CONFIG_SYS_I2C_EEPROM_ADDR_LEN:
+	  The length in bytes of the EEPROM memory array address.  Note
+	  that this is NOT the chip address length!
+
+	- CONFIG_SYS_I2C_EEPROM_ADDR_OVERFLOW:
+	  EEPROM chips that implement "address overflow" are ones
+	  like Catalyst 24WC04/08/16 which has 9/10/11 bits of
+	  address and the extra bits end up in the "chip address" bit
+	  slots. This makes a 24WC08 (1Kbyte) chip look like four 256
+	  byte chips.
+
+	  Note that we consider the length of the address field to
+	  still be one byte because the extra address bits are hidden
+	  in the chip address.
+
+	- CONFIG_SYS_EEPROM_SIZE:
+	  The size in bytes of the EEPROM device.
+
+	- CONFIG_ENV_EEPROM_IS_ON_I2C
+	  define this, if you have I2C and SPI activated, and your
+	  EEPROM, which holds the environment, is on the I2C bus.
+
+	- CONFIG_I2C_ENV_EEPROM_BUS
+	  if you have an Environment on an EEPROM reached over
+	  I2C muxes, you can define here, how to reach this
+	  EEPROM. For example:
+
+	  #define CONFIG_I2C_ENV_EEPROM_BUS	  1
+
+	  EEPROM which holds the environment, is reached over
+	  a pca9547 i2c mux with address 0x70, channel 3.
+
+- CONFIG_ENV_IS_IN_DATAFLASH:
+
+	Define this if you have a DataFlash memory device which you
+	want to use for the environment.
+
+	- CONFIG_ENV_OFFSET:
+	- CONFIG_ENV_ADDR:
+	- CONFIG_ENV_SIZE:
+
+	  These three #defines specify the offset and size of the
+	  environment area within the total memory of your DataFlash placed
+	  at the specified address.
+
+- CONFIG_ENV_IS_IN_SPI_FLASH:
+
+	Define this if you have a SPI Flash memory device which you
+	want to use for the environment.
+
+	- CONFIG_ENV_OFFSET:
+	- CONFIG_ENV_SIZE:
+
+	  These two #defines specify the offset and size of the
+	  environment area within the SPI Flash. CONFIG_ENV_OFFSET must be
+	  aligned to an erase sector boundary.
+
+	- CONFIG_ENV_SECT_SIZE:
+
+	  Define the SPI flash's sector size.
+
+	- CONFIG_ENV_OFFSET_REDUND (optional):
+
+	  This setting describes a second storage area of CONFIG_ENV_SIZE
+	  size used to hold a redundant copy of the environment data, so
+	  that there is a valid backup copy in case there is a power failure
+	  during a "saveenv" operation. CONFIG_ENV_OFFSET_RENDUND must be
+	  aligned to an erase sector boundary.
+
+	- CONFIG_ENV_SPI_BUS (optional):
+	- CONFIG_ENV_SPI_CS (optional):
+
+	  Define the SPI bus and chip select. If not defined they will be 0.
+
+	- CONFIG_ENV_SPI_MAX_HZ (optional):
+
+	  Define the SPI max work clock. If not defined then use 1MHz.
+
+	- CONFIG_ENV_SPI_MODE (optional):
+
+	  Define the SPI work mode. If not defined then use SPI_MODE_3.
+
+- CONFIG_ENV_IS_IN_REMOTE:
+
+	Define this if you have a remote memory space which you
+	want to use for the local device's environment.
+
+	- CONFIG_ENV_ADDR:
+	- CONFIG_ENV_SIZE:
+
+	  These two #defines specify the address and size of the
+	  environment area within the remote memory space. The
+	  local device can get the environment from remote memory
+	  space by SRIO or PCIE links.
+
+BE CAREFUL! For some special cases, the local device can not use
+"saveenv" command. For example, the local device will get the
+environment stored in a remote NOR flash by SRIO or PCIE link,
+but it can not erase, write this NOR flash by SRIO or PCIE interface.
+
+- CONFIG_ENV_IS_IN_NAND:
+
+	Define this if you have a NAND device which you want to use
+	for the environment.
+
+	- CONFIG_ENV_OFFSET:
+	- CONFIG_ENV_SIZE:
+
+	  These two #defines specify the offset and size of the environment
+	  area within the first NAND device.  CONFIG_ENV_OFFSET must be
+	  aligned to an erase block boundary.
+
+	- CONFIG_ENV_OFFSET_REDUND (optional):
+
+	  This setting describes a second storage area of CONFIG_ENV_SIZE
+	  size used to hold a redundant copy of the environment data, so
+	  that there is a valid backup copy in case there is a power failure
+	  during a "saveenv" operation.	 CONFIG_ENV_OFFSET_RENDUND must be
+	  aligned to an erase block boundary.
+
+	- CONFIG_ENV_RANGE (optional):
+
+	  Specifies the length of the region in which the environment
+	  can be written.  This should be a multiple of the NAND device's
+	  block size.  Specifying a range with more erase blocks than
+	  are needed to hold CONFIG_ENV_SIZE allows bad blocks within
+	  the range to be avoided.
+
+	- CONFIG_ENV_OFFSET_OOB (optional):
+
+	  Enables support for dynamically retrieving the offset of the
+	  environment from block zero's out-of-band data.  The
+	  "nand env.oob" command can be used to record this offset.
+	  Currently, CONFIG_ENV_OFFSET_REDUND is not supported when
+	  using CONFIG_ENV_OFFSET_OOB.
+
+- CONFIG_NAND_ENV_DST
+
+	Defines address in RAM to which the nand_spl code should copy the
+	environment. If redundant environment is used, it will be copied to
+	CONFIG_NAND_ENV_DST + CONFIG_ENV_SIZE.
+
+- CONFIG_ENV_IS_IN_UBI:
+
+	Define this if you have an UBI volume that you want to use for the
+	environment.  This has the benefit of wear-leveling the environment
+	accesses, which is important on NAND.
+
+	- CONFIG_ENV_UBI_PART:
+
+	  Define this to a string that is the mtd partition containing the UBI.
+
+	- CONFIG_ENV_UBI_VOLUME:
+
+	  Define this to the name of the volume that you want to store the
+	  environment in.
+
+	- CONFIG_ENV_UBI_VOLUME_REDUND:
+
+	  Define this to the name of another volume to store a second copy of
+	  the environment in.  This will enable redundant environments in UBI.
+	  It is assumed that both volumes are in the same MTD partition.
+
+	- CONFIG_UBI_SILENCE_MSG
+	- CONFIG_UBIFS_SILENCE_MSG
+
+	  You will probably want to define these to avoid a really noisy system
+	  when storing the env in UBI.
+
+- CONFIG_ENV_IS_IN_FAT:
+       Define this if you want to use the FAT file system for the environment.
+
+       - FAT_ENV_INTERFACE:
+
+         Define this to a string that is the name of the block device.
+
+       - FAT_ENV_DEV_AND_PART:
+
+         Define this to a string to specify the partition of the device. It can
+         be as following:
+
+           "D:P", "D:0", "D", "D:" or "D:auto" (D, P are integers. And P >= 1)
+               - "D:P": device D partition P. Error occurs if device D has no
+                        partition table.
+               - "D:0": device D.
+               - "D" or "D:": device D partition 1 if device D has partition
+                              table, or the whole device D if has no partition
+                              table.
+               - "D:auto": first partition in device D with bootable flag set.
+                           If none, first valid partition in device D. If no
+                           partition table then means device D.
+
+       - FAT_ENV_FILE:
+
+         It's a string of the FAT file name. This file use to store the
+         environment.
+
+       - CONFIG_FAT_WRITE:
+         This should be defined. Otherwise it cannot save the environment file.
+
+- CONFIG_ENV_IS_IN_MMC:
+
+	Define this if you have an MMC device which you want to use for the
+	environment.
+
+	- CONFIG_SYS_MMC_ENV_DEV:
+
+	  Specifies which MMC device the environment is stored in.
+
+	- CONFIG_SYS_MMC_ENV_PART (optional):
+
+	  Specifies which MMC partition the environment is stored in. If not
+	  set, defaults to partition 0, the user area. Common values might be
+	  1 (first MMC boot partition), 2 (second MMC boot partition).
+
+	- CONFIG_ENV_OFFSET:
+	- CONFIG_ENV_SIZE:
+
+	  These two #defines specify the offset and size of the environment
+	  area within the specified MMC device.
+
+	  If offset is positive (the usual case), it is treated as relative to
+	  the start of the MMC partition. If offset is negative, it is treated
+	  as relative to the end of the MMC partition. This can be useful if
+	  your board may be fitted with different MMC devices, which have
+	  different sizes for the MMC partitions, and you always want the
+	  environment placed at the very end of the partition, to leave the
+	  maximum possible space before it, to store other data.
+
+	  These two values are in units of bytes, but must be aligned to an
+	  MMC sector boundary.
+
+	- CONFIG_ENV_OFFSET_REDUND (optional):
+
+	  Specifies a second storage area, of CONFIG_ENV_SIZE size, used to
+	  hold a redundant copy of the environment data. This provides a
+	  valid backup copy in case the other copy is corrupted, e.g. due
+	  to a power failure during a "saveenv" operation.
+
+	  This value may also be positive or negative; this is handled in the
+	  same way as CONFIG_ENV_OFFSET.
+
+	  This value is also in units of bytes, but must also be aligned to
+	  an MMC sector boundary.
+
+	- CONFIG_ENV_SIZE_REDUND (optional):
+
+	  This value need not be set, even when CONFIG_ENV_OFFSET_REDUND is
+	  set. If this value is set, it must be set to the same value as
+	  CONFIG_ENV_SIZE.
+
+- CONFIG_SYS_SPI_INIT_OFFSET
+
+	Defines offset to the initial SPI buffer area in DPRAM. The
+	area is used at an early stage (ROM part) if the environment
+	is configured to reside in the SPI EEPROM: We need a 520 byte
+	scratch DPRAM area. It is used between the two initialization
+	calls (spi_init_f() and spi_init_r()). A value of 0xB00 seems
+	to be a good choice since it makes it far enough from the
+	start of the data area as well as from the stack pointer.
+
+Please note that the environment is read-only until the monitor
+has been relocated to RAM and a RAM copy of the environment has been
+created; also, when using EEPROM you will have to use getenv_f()
+until then to read environment variables.
+
+The environment is protected by a CRC32 checksum. Before the monitor
+is relocated into RAM, as a result of a bad CRC you will be working
+with the compiled-in default environment - *silently*!!! [This is
+necessary, because the first environment variable we need is the
+"baudrate" setting for the console - if we have a bad CRC, we don't
+have any device yet where we could complain.]
+
+Note: once the monitor has been relocated, then it will complain if
+the default environment is used; a new CRC is computed as soon as you
+use the "saveenv" command to store a valid environment.
+
+- CONFIG_SYS_FAULT_ECHO_LINK_DOWN:
+		Echo the inverted Ethernet link state to the fault LED.
+
+		Note: If this option is active, then CONFIG_SYS_FAULT_MII_ADDR
+		      also needs to be defined.
+
+- CONFIG_SYS_FAULT_MII_ADDR:
+		MII address of the PHY to check for the Ethernet link state.
+
+- CONFIG_NS16550_MIN_FUNCTIONS:
+		Define this if you desire to only have use of the NS16550_init
+		and NS16550_putc functions for the serial driver located at
+		drivers/serial/ns16550.c.  This option is useful for saving
+		space for already greatly restricted images, including but not
+		limited to NAND_SPL configurations.
+
+- CONFIG_DISPLAY_BOARDINFO
+		Display information about the board that U-Boot is running on
+		when U-Boot starts up. The board function checkboard() is called
+		to do this.
+
+- CONFIG_DISPLAY_BOARDINFO_LATE
+		Similar to the previous option, but display this information
+		later, once stdio is running and output goes to the LCD, if
+		present.
+
+- CONFIG_BOARD_SIZE_LIMIT:
+		Maximum size of the U-Boot image. When defined, the
+		build system checks that the actual size does not
+		exceed it.
+
+Low Level (hardware related) configuration options:
+---------------------------------------------------
+
+- CONFIG_SYS_CACHELINE_SIZE:
+		Cache Line Size of the CPU.
+
+- CONFIG_SYS_DEFAULT_IMMR:
+		Default address of the IMMR after system reset.
+
+		Needed on some 8260 systems (MPC8260ADS, PQ2FADS-ZU,
+		and RPXsuper) to be able to adjust the position of
+		the IMMR register after a reset.
+
+- CONFIG_SYS_CCSRBAR_DEFAULT:
+		Default (power-on reset) physical address of CCSR on Freescale
+		PowerPC SOCs.
+
+- CONFIG_SYS_CCSRBAR:
+		Virtual address of CCSR.  On a 32-bit build, this is typically
+		the same value as CONFIG_SYS_CCSRBAR_DEFAULT.
+
+		CONFIG_SYS_DEFAULT_IMMR must also be set to this value,
+		for cross-platform code that uses that macro instead.
+
+- CONFIG_SYS_CCSRBAR_PHYS:
+		Physical address of CCSR.  CCSR can be relocated to a new
+		physical address, if desired.  In this case, this macro should
+		be set to that address.	 Otherwise, it should be set to the
+		same value as CONFIG_SYS_CCSRBAR_DEFAULT.  For example, CCSR
+		is typically relocated on 36-bit builds.  It is recommended
+		that this macro be defined via the _HIGH and _LOW macros:
+
+		#define CONFIG_SYS_CCSRBAR_PHYS ((CONFIG_SYS_CCSRBAR_PHYS_HIGH
+			* 1ull) << 32 | CONFIG_SYS_CCSRBAR_PHYS_LOW)
+
+- CONFIG_SYS_CCSRBAR_PHYS_HIGH:
+		Bits 33-36 of CONFIG_SYS_CCSRBAR_PHYS.	This value is typically
+		either 0 (32-bit build) or 0xF (36-bit build).	This macro is
+		used in assembly code, so it must not contain typecasts or
+		integer size suffixes (e.g. "ULL").
+
+- CONFIG_SYS_CCSRBAR_PHYS_LOW:
+		Lower 32-bits of CONFIG_SYS_CCSRBAR_PHYS.  This macro is
+		used in assembly code, so it must not contain typecasts or
+		integer size suffixes (e.g. "ULL").
+
+- CONFIG_SYS_CCSR_DO_NOT_RELOCATE:
+		If this macro is defined, then CONFIG_SYS_CCSRBAR_PHYS will be
+		forced to a value that ensures that CCSR is not relocated.
+
+- Floppy Disk Support:
+		CONFIG_SYS_FDC_DRIVE_NUMBER
+
+		the default drive number (default value 0)
+
+		CONFIG_SYS_ISA_IO_STRIDE
+
+		defines the spacing between FDC chipset registers
+		(default value 1)
+
+		CONFIG_SYS_ISA_IO_OFFSET
+
+		defines the offset of register from address. It
+		depends on which part of the data bus is connected to
+		the FDC chipset. (default value 0)
+
+		If CONFIG_SYS_ISA_IO_STRIDE CONFIG_SYS_ISA_IO_OFFSET and
+		CONFIG_SYS_FDC_DRIVE_NUMBER are undefined, they take their
+		default value.
+
+		if CONFIG_SYS_FDC_HW_INIT is defined, then the function
+		fdc_hw_init() is called at the beginning of the FDC
+		setup. fdc_hw_init() must be provided by the board
+		source code. It is used to make hardware-dependent
+		initializations.
+
+- CONFIG_IDE_AHB:
+		Most IDE controllers were designed to be connected with PCI
+		interface. Only few of them were designed for AHB interface.
+		When software is doing ATA command and data transfer to
+		IDE devices through IDE-AHB controller, some additional
+		registers accessing to these kind of IDE-AHB controller
+		is required.
+
+- CONFIG_SYS_IMMR:	Physical address of the Internal Memory.
+		DO NOT CHANGE unless you know exactly what you're
+		doing! (11-4) [MPC8xx/82xx systems only]
+
+- CONFIG_SYS_INIT_RAM_ADDR:
+
+		Start address of memory area that can be used for
+		initial data and stack; please note that this must be
+		writable memory that is working WITHOUT special
+		initialization, i. e. you CANNOT use normal RAM which
+		will become available only after programming the
+		memory controller and running certain initialization
+		sequences.
+
+		U-Boot uses the following memory types:
+		- MPC8xx and MPC8260: IMMR (internal memory of the CPU)
+		- MPC824X: data cache
+		- PPC4xx:  data cache
+
+- CONFIG_SYS_GBL_DATA_OFFSET:
+
+		Offset of the initial data structure in the memory
+		area defined by CONFIG_SYS_INIT_RAM_ADDR. Usually
+		CONFIG_SYS_GBL_DATA_OFFSET is chosen such that the initial
+		data is located at the end of the available space
+		(sometimes written as (CONFIG_SYS_INIT_RAM_SIZE -
+		CONFIG_SYS_INIT_DATA_SIZE), and the initial stack is just
+		below that area (growing from (CONFIG_SYS_INIT_RAM_ADDR +
+		CONFIG_SYS_GBL_DATA_OFFSET) downward.
+
+	Note:
+		On the MPC824X (or other systems that use the data
+		cache for initial memory) the address chosen for
+		CONFIG_SYS_INIT_RAM_ADDR is basically arbitrary - it must
+		point to an otherwise UNUSED address space between
+		the top of RAM and the start of the PCI space.
+
+- CONFIG_SYS_SIUMCR:	SIU Module Configuration (11-6)
+
+- CONFIG_SYS_SYPCR:	System Protection Control (11-9)
+
+- CONFIG_SYS_TBSCR:	Time Base Status and Control (11-26)
+
+- CONFIG_SYS_PISCR:	Periodic Interrupt Status and Control (11-31)
+
+- CONFIG_SYS_PLPRCR:	PLL, Low-Power, and Reset Control Register (15-30)
+
+- CONFIG_SYS_SCCR:	System Clock and reset Control Register (15-27)
+
+- CONFIG_SYS_OR_TIMING_SDRAM:
+		SDRAM timing
+
+- CONFIG_SYS_MAMR_PTA:
+		periodic timer for refresh
+
+- CONFIG_SYS_DER:	Debug Event Register (37-47)
+
+- FLASH_BASE0_PRELIM, FLASH_BASE1_PRELIM, CONFIG_SYS_REMAP_OR_AM,
+  CONFIG_SYS_PRELIM_OR_AM, CONFIG_SYS_OR_TIMING_FLASH, CONFIG_SYS_OR0_REMAP,
+  CONFIG_SYS_OR0_PRELIM, CONFIG_SYS_BR0_PRELIM, CONFIG_SYS_OR1_REMAP, CONFIG_SYS_OR1_PRELIM,
+  CONFIG_SYS_BR1_PRELIM:
+		Memory Controller Definitions: BR0/1 and OR0/1 (FLASH)
+
+- SDRAM_BASE2_PRELIM, SDRAM_BASE3_PRELIM, SDRAM_MAX_SIZE,
+  CONFIG_SYS_OR_TIMING_SDRAM, CONFIG_SYS_OR2_PRELIM, CONFIG_SYS_BR2_PRELIM,
+  CONFIG_SYS_OR3_PRELIM, CONFIG_SYS_BR3_PRELIM:
+		Memory Controller Definitions: BR2/3 and OR2/3 (SDRAM)
+
+- CONFIG_SYS_MAMR_PTA, CONFIG_SYS_MPTPR_2BK_4K, CONFIG_SYS_MPTPR_1BK_4K, CONFIG_SYS_MPTPR_2BK_8K,
+  CONFIG_SYS_MPTPR_1BK_8K, CONFIG_SYS_MAMR_8COL, CONFIG_SYS_MAMR_9COL:
+		Machine Mode Register and Memory Periodic Timer
+		Prescaler definitions (SDRAM timing)
+
+- CONFIG_SYS_I2C_UCODE_PATCH, CONFIG_SYS_I2C_DPMEM_OFFSET [0x1FC0]:
+		enable I2C microcode relocation patch (MPC8xx);
+		define relocation offset in DPRAM [DSP2]
+
+- CONFIG_SYS_SMC_UCODE_PATCH, CONFIG_SYS_SMC_DPMEM_OFFSET [0x1FC0]:
+		enable SMC microcode relocation patch (MPC8xx);
+		define relocation offset in DPRAM [SMC1]
+
+- CONFIG_SYS_SPI_UCODE_PATCH, CONFIG_SYS_SPI_DPMEM_OFFSET [0x1FC0]:
+		enable SPI microcode relocation patch (MPC8xx);
+		define relocation offset in DPRAM [SCC4]
+
+- CONFIG_SYS_USE_OSCCLK:
+		Use OSCM clock mode on MBX8xx board. Be careful,
+		wrong setting might damage your board. Read
+		doc/README.MBX before setting this variable!
+
+- CONFIG_SYS_CPM_POST_WORD_ADDR: (MPC8xx, MPC8260 only)
+		Offset of the bootmode word in DPRAM used by post
+		(Power On Self Tests). This definition overrides
+		#define'd default value in commproc.h resp.
+		cpm_8260.h.
+
+- CONFIG_SYS_PCI_SLV_MEM_LOCAL, CONFIG_SYS_PCI_SLV_MEM_BUS, CONFIG_SYS_PICMR0_MASK_ATTRIB,
+  CONFIG_SYS_PCI_MSTR0_LOCAL, CONFIG_SYS_PCIMSK0_MASK, CONFIG_SYS_PCI_MSTR1_LOCAL,
+  CONFIG_SYS_PCIMSK1_MASK, CONFIG_SYS_PCI_MSTR_MEM_LOCAL, CONFIG_SYS_PCI_MSTR_MEM_BUS,
+  CONFIG_SYS_CPU_PCI_MEM_START, CONFIG_SYS_PCI_MSTR_MEM_SIZE, CONFIG_SYS_POCMR0_MASK_ATTRIB,
+  CONFIG_SYS_PCI_MSTR_MEMIO_LOCAL, CONFIG_SYS_PCI_MSTR_MEMIO_BUS, CPU_PCI_MEMIO_START,
+  CONFIG_SYS_PCI_MSTR_MEMIO_SIZE, CONFIG_SYS_POCMR1_MASK_ATTRIB, CONFIG_SYS_PCI_MSTR_IO_LOCAL,
+  CONFIG_SYS_PCI_MSTR_IO_BUS, CONFIG_SYS_CPU_PCI_IO_START, CONFIG_SYS_PCI_MSTR_IO_SIZE,
+  CONFIG_SYS_POCMR2_MASK_ATTRIB: (MPC826x only)
+		Overrides the default PCI memory map in arch/powerpc/cpu/mpc8260/pci.c if set.
+
+- CONFIG_PCI_DISABLE_PCIE:
+		Disable PCI-Express on systems where it is supported but not
+		required.
+
+- CONFIG_PCI_ENUM_ONLY
+		Only scan through and get the devices on the buses.
+		Don't do any setup work, presumably because someone or
+		something has already done it, and we don't need to do it
+		a second time.	Useful for platforms that are pre-booted
+		by coreboot or similar.
+
+- CONFIG_PCI_INDIRECT_BRIDGE:
+		Enable support for indirect PCI bridges.
+
+- CONFIG_SYS_SRIO:
+		Chip has SRIO or not
+
+- CONFIG_SRIO1:
+		Board has SRIO 1 port available
+
+- CONFIG_SRIO2:
+		Board has SRIO 2 port available
+
+- CONFIG_SRIO_PCIE_BOOT_MASTER
+		Board can support master function for Boot from SRIO and PCIE
+
+- CONFIG_SYS_SRIOn_MEM_VIRT:
+		Virtual Address of SRIO port 'n' memory region
+
+- CONFIG_SYS_SRIOn_MEM_PHYS:
+		Physical Address of SRIO port 'n' memory region
+
+- CONFIG_SYS_SRIOn_MEM_SIZE:
+		Size of SRIO port 'n' memory region
+
+- CONFIG_SYS_NAND_BUSWIDTH_16BIT
+		Defined to tell the NAND controller that the NAND chip is using
+		a 16 bit bus.
+		Not all NAND drivers use this symbol.
+		Example of drivers that use it:
+		- drivers/mtd/nand/ndfc.c
+		- drivers/mtd/nand/mxc_nand.c
+
+- CONFIG_SYS_NDFC_EBC0_CFG
+		Sets the EBC0_CFG register for the NDFC. If not defined
+		a default value will be used.
+
+- CONFIG_SPD_EEPROM
+		Get DDR timing information from an I2C EEPROM. Common
+		with pluggable memory modules such as SODIMMs
+
+  SPD_EEPROM_ADDRESS
+		I2C address of the SPD EEPROM
+
+- CONFIG_SYS_SPD_BUS_NUM
+		If SPD EEPROM is on an I2C bus other than the first
+		one, specify here. Note that the value must resolve
+		to something your driver can deal with.
+
+- CONFIG_SYS_DDR_RAW_TIMING
+		Get DDR timing information from other than SPD. Common with
+		soldered DDR chips onboard without SPD. DDR raw timing
+		parameters are extracted from datasheet and hard-coded into
+		header files or board specific files.
+
+- CONFIG_FSL_DDR_INTERACTIVE
+		Enable interactive DDR debugging. See doc/README.fsl-ddr.
+
+- CONFIG_FSL_DDR_SYNC_REFRESH
+		Enable sync of refresh for multiple controllers.
+
+- CONFIG_FSL_DDR_BIST
+		Enable built-in memory test for Freescale DDR controllers.
+
+- CONFIG_SYS_83XX_DDR_USES_CS0
+		Only for 83xx systems. If specified, then DDR should
+		be configured using CS0 and CS1 instead of CS2 and CS3.
+
+- CONFIG_ETHER_ON_FEC[12]
+		Define to enable FEC[12] on a 8xx series processor.
+
+- CONFIG_FEC[12]_PHY
+		Define to the hardcoded PHY address which corresponds
+		to the given FEC; i. e.
+			#define CONFIG_FEC1_PHY 4
+		means that the PHY with address 4 is connected to FEC1
+
+		When set to -1, means to probe for first available.
+
+- CONFIG_FEC[12]_PHY_NORXERR
+		The PHY does not have a RXERR line (RMII only).
+		(so program the FEC to ignore it).
+
+- CONFIG_RMII
+		Enable RMII mode for all FECs.
+		Note that this is a global option, we can't
+		have one FEC in standard MII mode and another in RMII mode.
+
+- CONFIG_CRC32_VERIFY
+		Add a verify option to the crc32 command.
+		The syntax is:
+
+		=> crc32 -v <address> <count> <crc32>
+
+		Where address/count indicate a memory area
+		and crc32 is the correct crc32 which the
+		area should have.
+
+- CONFIG_LOOPW
+		Add the "loopw" memory command. This only takes effect if
+		the memory commands are activated globally (CONFIG_CMD_MEM).
+
+- CONFIG_MX_CYCLIC
+		Add the "mdc" and "mwc" memory commands. These are cyclic
+		"md/mw" commands.
+		Examples:
+
+		=> mdc.b 10 4 500
+		This command will print 4 bytes (10,11,12,13) each 500 ms.
+
+		=> mwc.l 100 12345678 10
+		This command will write 12345678 to address 100 all 10 ms.
+
+		This only takes effect if the memory commands are activated
+		globally (CONFIG_CMD_MEM).
+
+- CONFIG_SKIP_LOWLEVEL_INIT
+		[ARM, NDS32, MIPS only] If this variable is defined, then certain
+		low level initializations (like setting up the memory
+		controller) are omitted and/or U-Boot does not
+		relocate itself into RAM.
+
+		Normally this variable MUST NOT be defined. The only
+		exception is when U-Boot is loaded (to RAM) by some
+		other boot loader or by a debugger which performs
+		these initializations itself.
+
+- CONFIG_SPL_BUILD
+		Modifies the behaviour of start.S when compiling a loader
+		that is executed before the actual U-Boot. E.g. when
+		compiling a NAND SPL.
+
+- CONFIG_TPL_BUILD
+		Modifies the behaviour of start.S  when compiling a loader
+		that is executed after the SPL and before the actual U-Boot.
+		It is loaded by the SPL.
+
+- CONFIG_SYS_MPC85XX_NO_RESETVEC
+		Only for 85xx systems. If this variable is specified, the section
+		.resetvec is not kept and the section .bootpg is placed in the
+		previous 4k of the .text section.
+
+- CONFIG_ARCH_MAP_SYSMEM
+		Generally U-Boot (and in particular the md command) uses
+		effective address. It is therefore not necessary to regard
+		U-Boot address as virtual addresses that need to be translated
+		to physical addresses. However, sandbox requires this, since
+		it maintains its own little RAM buffer which contains all
+		addressable memory. This option causes some memory accesses
+		to be mapped through map_sysmem() / unmap_sysmem().
+
+- CONFIG_USE_ARCH_MEMCPY
+  CONFIG_USE_ARCH_MEMSET
+		If these options are used a optimized version of memcpy/memset will
+		be used if available. These functions may be faster under some
+		conditions but may increase the binary size.
+
+- CONFIG_X86_RESET_VECTOR
+		If defined, the x86 reset vector code is included. This is not
+		needed when U-Boot is running from Coreboot.
+
+- CONFIG_SYS_MPUCLK
+		Defines the MPU clock speed (in MHz).
+
+		NOTE : currently only supported on AM335x platforms.
+
+- CONFIG_SPL_AM33XX_ENABLE_RTC32K_OSC:
+		Enables the RTC32K OSC on AM33xx based plattforms
+
+- CONFIG_SYS_NAND_NO_SUBPAGE_WRITE
+		Option to disable subpage write in NAND driver
+		driver that uses this:
+		drivers/mtd/nand/davinci_nand.c
+
+Freescale QE/FMAN Firmware Support:
+-----------------------------------
+
+The Freescale QUICCEngine (QE) and Frame Manager (FMAN) both support the
+loading of "firmware", which is encoded in the QE firmware binary format.
+This firmware often needs to be loaded during U-Boot booting, so macros
+are used to identify the storage device (NOR flash, SPI, etc) and the address
+within that device.
+
+- CONFIG_SYS_FMAN_FW_ADDR
+	The address in the storage device where the FMAN microcode is located.  The
+	meaning of this address depends on which CONFIG_SYS_QE_FW_IN_xxx macro
+	is also specified.
+
+- CONFIG_SYS_QE_FW_ADDR
+	The address in the storage device where the QE microcode is located.  The
+	meaning of this address depends on which CONFIG_SYS_QE_FW_IN_xxx macro
+	is also specified.
+
+- CONFIG_SYS_QE_FMAN_FW_LENGTH
+	The maximum possible size of the firmware.  The firmware binary format
+	has a field that specifies the actual size of the firmware, but it
+	might not be possible to read any part of the firmware unless some
+	local storage is allocated to hold the entire firmware first.
+
+- CONFIG_SYS_QE_FMAN_FW_IN_NOR
+	Specifies that QE/FMAN firmware is located in NOR flash, mapped as
+	normal addressable memory via the LBC.  CONFIG_SYS_FMAN_FW_ADDR is the
+	virtual address in NOR flash.
+
+- CONFIG_SYS_QE_FMAN_FW_IN_NAND
+	Specifies that QE/FMAN firmware is located in NAND flash.
+	CONFIG_SYS_FMAN_FW_ADDR is the offset within NAND flash.
+
+- CONFIG_SYS_QE_FMAN_FW_IN_MMC
+	Specifies that QE/FMAN firmware is located on the primary SD/MMC
+	device.  CONFIG_SYS_FMAN_FW_ADDR is the byte offset on that device.
+
+- CONFIG_SYS_QE_FMAN_FW_IN_SPIFLASH
+	Specifies that QE/FMAN firmware is located on the primary SPI
+	device.  CONFIG_SYS_FMAN_FW_ADDR is the byte offset on that device.
+
+- CONFIG_SYS_QE_FMAN_FW_IN_REMOTE
+	Specifies that QE/FMAN firmware is located in the remote (master)
+	memory space.	CONFIG_SYS_FMAN_FW_ADDR is a virtual address which
+	can be mapped from slave TLB->slave LAW->slave SRIO or PCIE outbound
+	window->master inbound window->master LAW->the ucode address in
+	master's memory space.
+
+Freescale Layerscape Management Complex Firmware Support:
+---------------------------------------------------------
+The Freescale Layerscape Management Complex (MC) supports the loading of
+"firmware".
+This firmware often needs to be loaded during U-Boot booting, so macros
+are used to identify the storage device (NOR flash, SPI, etc) and the address
+within that device.
+
+- CONFIG_FSL_MC_ENET
+	Enable the MC driver for Layerscape SoCs.
+
+- CONFIG_SYS_LS_MC_FW_ADDR
+	The address in the storage device where the firmware is located.  The
+	meaning of this address depends on which CONFIG_SYS_LS_MC_FW_IN_xxx macro
+	is also specified.
+
+- CONFIG_SYS_LS_MC_FW_LENGTH
+	The maximum possible size of the firmware.  The firmware binary format
+	has a field that specifies the actual size of the firmware, but it
+	might not be possible to read any part of the firmware unless some
+	local storage is allocated to hold the entire firmware first.
+
+- CONFIG_SYS_LS_MC_FW_IN_NOR
+	Specifies that MC firmware is located in NOR flash, mapped as
+	normal addressable memory via the LBC. CONFIG_SYS_LS_MC_FW_ADDR is the
+	virtual address in NOR flash.
+
+Freescale Layerscape Debug Server Support:
+-------------------------------------------
+The Freescale Layerscape Debug Server Support supports the loading of
+"Debug Server firmware" and triggering SP boot-rom.
+This firmware often needs to be loaded during U-Boot booting.
+
+- CONFIG_FSL_DEBUG_SERVER
+	Enable the Debug Server for Layerscape SoCs.
+
+- CONFIG_SYS_DEBUG_SERVER_DRAM_BLOCK_MIN_SIZE
+	Define minimum DDR size required for debug server image
+
+- CONFIG_SYS_MC_RSV_MEM_ALIGN
+	Define alignment of reserved memory MC requires
+
+Reproducible builds
+-------------------
+
+In order to achieve reproducible builds, timestamps used in the U-Boot build
+process have to be set to a fixed value.
+
+This is done using the SOURCE_DATE_EPOCH environment variable.
+SOURCE_DATE_EPOCH is to be set on the build host's shell, not as a configuration
+option for U-Boot or an environment variable in U-Boot.
+
+SOURCE_DATE_EPOCH should be set to a number of seconds since the epoch, in UTC.
+
+Building the Software:
+======================
+
+Building U-Boot has been tested in several native build environments
+and in many different cross environments. Of course we cannot support
+all possibly existing versions of cross development tools in all
+(potentially obsolete) versions. In case of tool chain problems we
+recommend to use the ELDK (see http://www.denx.de/wiki/DULG/ELDK)
+which is extensively used to build and test U-Boot.
+
+If you are not using a native environment, it is assumed that you
+have GNU cross compiling tools available in your path. In this case,
+you must set the environment variable CROSS_COMPILE in your shell.
+Note that no changes to the Makefile or any other source files are
+necessary. For example using the ELDK on a 4xx CPU, please enter:
+
+	$ CROSS_COMPILE=ppc_4xx-
+	$ export CROSS_COMPILE
+
+Note: If you wish to generate Windows versions of the utilities in
+      the tools directory you can use the MinGW toolchain
+      (http://www.mingw.org).  Set your HOST tools to the MinGW
+      toolchain and execute 'make tools'.  For example:
+
+       $ make HOSTCC=i586-mingw32msvc-gcc HOSTSTRIP=i586-mingw32msvc-strip tools
+
+      Binaries such as tools/mkimage.exe will be created which can
+      be executed on computers running Windows.
+
+U-Boot is intended to be simple to build. After installing the
+sources you must configure U-Boot for one specific board type. This
+is done by typing:
+
+	make NAME_defconfig
+
+where "NAME_defconfig" is the name of one of the existing configu-
+rations; see boards.cfg for supported names.
+
+Note: for some board special configuration names may exist; check if
+      additional information is available from the board vendor; for
+      instance, the TQM823L systems are available without (standard)
+      or with LCD support. You can select such additional "features"
+      when choosing the configuration, i. e.
+
+      make TQM823L_defconfig
+	- will configure for a plain TQM823L, i. e. no LCD support
+
+      make TQM823L_LCD_defconfig
+	- will configure for a TQM823L with U-Boot console on LCD
+
+      etc.
+
+
+Finally, type "make all", and you should get some working U-Boot
+images ready for download to / installation on your system:
+
+- "u-boot.bin" is a raw binary image
+- "u-boot" is an image in ELF binary format
+- "u-boot.srec" is in Motorola S-Record format
+
+By default the build is performed locally and the objects are saved
+in the source directory. One of the two methods can be used to change
+this behavior and build U-Boot to some external directory:
+
+1. Add O= to the make command line invocations:
+
+	make O=/tmp/build distclean
+	make O=/tmp/build NAME_defconfig
+	make O=/tmp/build all
+
+2. Set environment variable KBUILD_OUTPUT to point to the desired location:
+
+	export KBUILD_OUTPUT=/tmp/build
+	make distclean
+	make NAME_defconfig
+	make all
+
+Note that the command line "O=" setting overrides the KBUILD_OUTPUT environment
+variable.
+
+
+Please be aware that the Makefiles assume you are using GNU make, so
+for instance on NetBSD you might need to use "gmake" instead of
+native "make".
+
+
+If the system board that you have is not listed, then you will need
+to port U-Boot to your hardware platform. To do this, follow these
+steps:
+
+1.  Create a new directory to hold your board specific code. Add any
+    files you need. In your board directory, you will need at least
+    the "Makefile" and a "<board>.c".
+2.  Create a new configuration file "include/configs/<board>.h" for
+    your board.
+3.  If you're porting U-Boot to a new CPU, then also create a new
+    directory to hold your CPU specific code. Add any files you need.
+4.  Run "make <board>_defconfig" with your new name.
+5.  Type "make", and you should get a working "u-boot.srec" file
+    to be installed on your target system.
+6.  Debug and solve any problems that might arise.
+    [Of course, this last step is much harder than it sounds.]
+
+
+Testing of U-Boot Modifications, Ports to New Hardware, etc.:
+==============================================================
+
+If you have modified U-Boot sources (for instance added a new board
+or support for new devices, a new CPU, etc.) you are expected to
+provide feedback to the other developers. The feedback normally takes
+the form of a "patch", i. e. a context diff against a certain (latest
+official or latest in the git repository) version of U-Boot sources.
+
+But before you submit such a patch, please verify that your modifi-
+cation did not break existing code. At least make sure that *ALL* of
+the supported boards compile WITHOUT ANY compiler warnings. To do so,
+just run the "MAKEALL" script, which will configure and build U-Boot
+for ALL supported system. Be warned, this will take a while. You can
+select which (cross) compiler to use by passing a `CROSS_COMPILE'
+environment variable to the script, i. e. to use the ELDK cross tools
+you can type
+
+	CROSS_COMPILE=ppc_8xx- MAKEALL
+
+or to build on a native PowerPC system you can type
+
+	CROSS_COMPILE=' ' MAKEALL
+
+When using the MAKEALL script, the default behaviour is to build
+U-Boot in the source directory. This location can be changed by
+setting the BUILD_DIR environment variable. Also, for each target
+built, the MAKEALL script saves two log files (<target>.ERR and
+<target>.MAKEALL) in the <source dir>/LOG directory. This default
+location can be changed by setting the MAKEALL_LOGDIR environment
+variable. For example:
+
+	export BUILD_DIR=/tmp/build
+	export MAKEALL_LOGDIR=/tmp/log
+	CROSS_COMPILE=ppc_8xx- MAKEALL
+
+With the above settings build objects are saved in the /tmp/build,
+log files are saved in the /tmp/log and the source tree remains clean
+during the whole build process.
+
+
+See also "U-Boot Porting Guide" below.
+
+
+Monitor Commands - Overview:
+============================
+
+go	- start application at address 'addr'
+run	- run commands in an environment variable
+bootm	- boot application image from memory
+bootp	- boot image via network using BootP/TFTP protocol
+bootz   - boot zImage from memory
+tftpboot- boot image via network using TFTP protocol
+	       and env variables "ipaddr" and "serverip"
+	       (and eventually "gatewayip")
+tftpput - upload a file via network using TFTP protocol
+rarpboot- boot image via network using RARP/TFTP protocol
+diskboot- boot from IDE devicebootd   - boot default, i.e., run 'bootcmd'
+loads	- load S-Record file over serial line
+loadb	- load binary file over serial line (kermit mode)
+md	- memory display
+mm	- memory modify (auto-incrementing)
+nm	- memory modify (constant address)
+mw	- memory write (fill)
+cp	- memory copy
+cmp	- memory compare
+crc32	- checksum calculation
+i2c	- I2C sub-system
+sspi	- SPI utility commands
+base	- print or set address offset
+printenv- print environment variables
+setenv	- set environment variables
+saveenv - save environment variables to persistent storage
+protect - enable or disable FLASH write protection
+erase	- erase FLASH memory
+flinfo	- print FLASH memory information
+nand	- NAND memory operations (see doc/README.nand)
+bdinfo	- print Board Info structure
+iminfo	- print header information for application image
+coninfo - print console devices and informations
+ide	- IDE sub-system
+loop	- infinite loop on address range
+loopw	- infinite write loop on address range
+mtest	- simple RAM test
+icache	- enable or disable instruction cache
+dcache	- enable or disable data cache
+reset	- Perform RESET of the CPU
+echo	- echo args to console
+version - print monitor version
+help	- print online help
+?	- alias for 'help'
+
+
+Monitor Commands - Detailed Description:
+========================================
+
+TODO.
+
+For now: just type "help <command>".
+
+
+Environment Variables:
+======================
+
+U-Boot supports user configuration using Environment Variables which
+can be made persistent by saving to Flash memory.
+
+Environment Variables are set using "setenv", printed using
+"printenv", and saved to Flash using "saveenv". Using "setenv"
+without a value can be used to delete a variable from the
+environment. As long as you don't save the environment you are
+working with an in-memory copy. In case the Flash area containing the
+environment is erased by accident, a default environment is provided.
+
+Some configuration options can be set using Environment Variables.
+
+List of environment variables (most likely not complete):
+
+  baudrate	- see CONFIG_BAUDRATE
+
+  bootdelay	- see CONFIG_BOOTDELAY
+
+  bootcmd	- see CONFIG_BOOTCOMMAND
+
+  bootargs	- Boot arguments when booting an RTOS image
+
+  bootfile	- Name of the image to load with TFTP
+
+  bootm_low	- Memory range available for image processing in the bootm
+		  command can be restricted. This variable is given as
+		  a hexadecimal number and defines lowest address allowed
+		  for use by the bootm command. See also "bootm_size"
+		  environment variable. Address defined by "bootm_low" is
+		  also the base of the initial memory mapping for the Linux
+		  kernel -- see the description of CONFIG_SYS_BOOTMAPSZ and
+		  bootm_mapsize.
+
+  bootm_mapsize - Size of the initial memory mapping for the Linux kernel.
+		  This variable is given as a hexadecimal number and it
+		  defines the size of the memory region starting at base
+		  address bootm_low that is accessible by the Linux kernel
+		  during early boot.  If unset, CONFIG_SYS_BOOTMAPSZ is used
+		  as the default value if it is defined, and bootm_size is
+		  used otherwise.
+
+  bootm_size	- Memory range available for image processing in the bootm
+		  command can be restricted. This variable is given as
+		  a hexadecimal number and defines the size of the region
+		  allowed for use by the bootm command. See also "bootm_low"
+		  environment variable.
+
+  updatefile	- Location of the software update file on a TFTP server, used
+		  by the automatic software update feature. Please refer to
+		  documentation in doc/README.update for more details.
+
+  autoload	- if set to "no" (any string beginning with 'n'),
+		  "bootp" will just load perform a lookup of the
+		  configuration from the BOOTP server, but not try to
+		  load any image using TFTP
+
+  autostart	- if set to "yes", an image loaded using the "bootp",
+		  "rarpboot", "tftpboot" or "diskboot" commands will
+		  be automatically started (by internally calling
+		  "bootm")
+
+		  If set to "no", a standalone image passed to the
+		  "bootm" command will be copied to the load address
+		  (and eventually uncompressed), but NOT be started.
+		  This can be used to load and uncompress arbitrary
+		  data.
+
+  fdt_high	- if set this restricts the maximum address that the
+		  flattened device tree will be copied into upon boot.
+		  For example, if you have a system with 1 GB memory
+		  at physical address 0x10000000, while Linux kernel
+		  only recognizes the first 704 MB as low memory, you
+		  may need to set fdt_high as 0x3C000000 to have the
+		  device tree blob be copied to the maximum address
+		  of the 704 MB low memory, so that Linux kernel can
+		  access it during the boot procedure.
+
+		  If this is set to the special value 0xFFFFFFFF then
+		  the fdt will not be copied at all on boot.  For this
+		  to work it must reside in writable memory, have
+		  sufficient padding on the end of it for u-boot to
+		  add the information it needs into it, and the memory
+		  must be accessible by the kernel.
+
+  fdtcontroladdr- if set this is the address of the control flattened
+		  device tree used by U-Boot when CONFIG_OF_CONTROL is
+		  defined.
+
+  i2cfast	- (PPC405GP|PPC405EP only)
+		  if set to 'y' configures Linux I2C driver for fast
+		  mode (400kHZ). This environment variable is used in
+		  initialization code. So, for changes to be effective
+		  it must be saved and board must be reset.
+
+  initrd_high	- restrict positioning of initrd images:
+		  If this variable is not set, initrd images will be
+		  copied to the highest possible address in RAM; this
+		  is usually what you want since it allows for
+		  maximum initrd size. If for some reason you want to
+		  make sure that the initrd image is loaded below the
+		  CONFIG_SYS_BOOTMAPSZ limit, you can set this environment
+		  variable to a value of "no" or "off" or "0".
+		  Alternatively, you can set it to a maximum upper
+		  address to use (U-Boot will still check that it
+		  does not overwrite the U-Boot stack and data).
+
+		  For instance, when you have a system with 16 MB
+		  RAM, and want to reserve 4 MB from use by Linux,
+		  you can do this by adding "mem=12M" to the value of
+		  the "bootargs" variable. However, now you must make
+		  sure that the initrd image is placed in the first
+		  12 MB as well - this can be done with
+
+		  setenv initrd_high 00c00000
+
+		  If you set initrd_high to 0xFFFFFFFF, this is an
+		  indication to U-Boot that all addresses are legal
+		  for the Linux kernel, including addresses in flash
+		  memory. In this case U-Boot will NOT COPY the
+		  ramdisk at all. This may be useful to reduce the
+		  boot time on your system, but requires that this
+		  feature is supported by your Linux kernel.
+
+  ipaddr	- IP address; needed for tftpboot command
+
+  loadaddr	- Default load address for commands like "bootp",
+		  "rarpboot", "tftpboot", "loadb" or "diskboot"
+
+  loads_echo	- see CONFIG_LOADS_ECHO
+
+  serverip	- TFTP server IP address; needed for tftpboot command
+
+  bootretry	- see CONFIG_BOOT_RETRY_TIME
+
+  bootdelaykey	- see CONFIG_AUTOBOOT_DELAY_STR
+
+  bootstopkey	- see CONFIG_AUTOBOOT_STOP_STR
+
+  ethprime	- controls which interface is used first.
+
+  ethact	- controls which interface is currently active.
+		  For example you can do the following
+
+		  => setenv ethact FEC
+		  => ping 192.168.0.1 # traffic sent on FEC
+		  => setenv ethact SCC
+		  => ping 10.0.0.1 # traffic sent on SCC
+
+  ethrotate	- When set to "no" U-Boot does not go through all
+		  available network interfaces.
+		  It just stays at the currently selected interface.
+
+  netretry	- When set to "no" each network operation will
+		  either succeed or fail without retrying.
+		  When set to "once" the network operation will
+		  fail when all the available network interfaces
+		  are tried once without success.
+		  Useful on scripts which control the retry operation
+		  themselves.
+
+  npe_ucode	- set load address for the NPE microcode
+
+  silent_linux  - If set then Linux will be told to boot silently, by
+		  changing the console to be empty. If "yes" it will be
+		  made silent. If "no" it will not be made silent. If
+		  unset, then it will be made silent if the U-Boot console
+		  is silent.
+
+  tftpsrcp	- If this is set, the value is used for TFTP's
+		  UDP source port.
+
+  tftpdstp	- If this is set, the value is used for TFTP's UDP
+		  destination port instead of the Well Know Port 69.
+
+  tftpblocksize - Block size to use for TFTP transfers; if not set,
+		  we use the TFTP server's default block size
+
+  tftptimeout	- Retransmission timeout for TFTP packets (in milli-
+		  seconds, minimum value is 1000 = 1 second). Defines
+		  when a packet is considered to be lost so it has to
+		  be retransmitted. The default is 5000 = 5 seconds.
+		  Lowering this value may make downloads succeed
+		  faster in networks with high packet loss rates or
+		  with unreliable TFTP servers.
+
+  tftptimeoutcountmax	- maximum count of TFTP timeouts (no
+		  unit, minimum value = 0). Defines how many timeouts
+		  can happen during a single file transfer before that
+		  transfer is aborted. The default is 10, and 0 means
+		  'no timeouts allowed'. Increasing this value may help
+		  downloads succeed with high packet loss rates, or with
+		  unreliable TFTP servers or client hardware.
+
+  vlan		- When set to a value < 4095 the traffic over
+		  Ethernet is encapsulated/received over 802.1q
+		  VLAN tagged frames.
+
+  bootpretryperiod	- Period during which BOOTP/DHCP sends retries.
+		  Unsigned value, in milliseconds. If not set, the period will
+		  be either the default (28000), or a value based on
+		  CONFIG_NET_RETRY_COUNT, if defined. This value has
+		  precedence over the valu based on CONFIG_NET_RETRY_COUNT.
+
+The following image location variables contain the location of images
+used in booting. The "Image" column gives the role of the image and is
+not an environment variable name. The other columns are environment
+variable names. "File Name" gives the name of the file on a TFTP
+server, "RAM Address" gives the location in RAM the image will be
+loaded to, and "Flash Location" gives the image's address in NOR
+flash or offset in NAND flash.
+
+*Note* - these variables don't have to be defined for all boards, some
+boards currently use other variables for these purposes, and some
+boards use these variables for other purposes.
+
+Image		    File Name	     RAM Address       Flash Location
+-----		    ---------	     -----------       --------------
+u-boot		    u-boot	     u-boot_addr_r     u-boot_addr
+Linux kernel	    bootfile	     kernel_addr_r     kernel_addr
+device tree blob    fdtfile	     fdt_addr_r	       fdt_addr
+ramdisk		    ramdiskfile	     ramdisk_addr_r    ramdisk_addr
+
+The following environment variables may be used and automatically
+updated by the network boot commands ("bootp" and "rarpboot"),
+depending the information provided by your boot server:
+
+  bootfile	- see above
+  dnsip		- IP address of your Domain Name Server
+  dnsip2	- IP address of your secondary Domain Name Server
+  gatewayip	- IP address of the Gateway (Router) to use
+  hostname	- Target hostname
+  ipaddr	- see above
+  netmask	- Subnet Mask
+  rootpath	- Pathname of the root filesystem on the NFS server
+  serverip	- see above
+
+
+There are two special Environment Variables:
+
+  serial#	- contains hardware identification information such
+		  as type string and/or serial number
+  ethaddr	- Ethernet address
+
+These variables can be set only once (usually during manufacturing of
+the board). U-Boot refuses to delete or overwrite these variables
+once they have been set once.
+
+
+Further special Environment Variables:
+
+  ver		- Contains the U-Boot version string as printed
+		  with the "version" command. This variable is
+		  readonly (see CONFIG_VERSION_VARIABLE).
+
+
+Please note that changes to some configuration parameters may take
+only effect after the next boot (yes, that's just like Windoze :-).
+
+
+Callback functions for environment variables:
+---------------------------------------------
+
+For some environment variables, the behavior of u-boot needs to change
+when their values are changed.  This functionality allows functions to
+be associated with arbitrary variables.  On creation, overwrite, or
+deletion, the callback will provide the opportunity for some side
+effect to happen or for the change to be rejected.
+
+The callbacks are named and associated with a function using the
+U_BOOT_ENV_CALLBACK macro in your board or driver code.
+
+These callbacks are associated with variables in one of two ways.  The
+static list can be added to by defining CONFIG_ENV_CALLBACK_LIST_STATIC
+in the board configuration to a string that defines a list of
+associations.  The list must be in the following format:
+
+	entry = variable_name[:callback_name]
+	list = entry[,list]
+
+If the callback name is not specified, then the callback is deleted.
+Spaces are also allowed anywhere in the list.
+
+Callbacks can also be associated by defining the ".callbacks" variable
+with the same list format above.  Any association in ".callbacks" will
+override any association in the static list. You can define
+CONFIG_ENV_CALLBACK_LIST_DEFAULT to a list (string) to define the
+".callbacks" environment variable in the default or embedded environment.
+
+If CONFIG_REGEX is defined, the variable_name above is evaluated as a
+regular expression. This allows multiple variables to be connected to
+the same callback without explicitly listing them all out.
+
+
+Command Line Parsing:
+=====================
+
+There are two different command line parsers available with U-Boot:
+the old "simple" one, and the much more powerful "hush" shell:
+
+Old, simple command line parser:
+--------------------------------
+
+- supports environment variables (through setenv / saveenv commands)
+- several commands on one line, separated by ';'
+- variable substitution using "... ${name} ..." syntax
+- special characters ('$', ';') can be escaped by prefixing with '\',
+  for example:
+	setenv bootcmd bootm \${address}
+- You can also escape text by enclosing in single apostrophes, for example:
+	setenv addip 'setenv bootargs $bootargs ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname::off'
+
+Hush shell:
+-----------
+
+- similar to Bourne shell, with control structures like
+  if...then...else...fi, for...do...done; while...do...done,
+  until...do...done, ...
+- supports environment ("global") variables (through setenv / saveenv
+  commands) and local shell variables (through standard shell syntax
+  "name=value"); only environment variables can be used with "run"
+  command
+
+General rules:
+--------------
+
+(1) If a command line (or an environment variable executed by a "run"
+    command) contains several commands separated by semicolon, and
+    one of these commands fails, then the remaining commands will be
+    executed anyway.
+
+(2) If you execute several variables with one call to run (i. e.
+    calling run with a list of variables as arguments), any failing
+    command will cause "run" to terminate, i. e. the remaining
+    variables are not executed.
+
+Note for Redundant Ethernet Interfaces:
+=======================================
+
+Some boards come with redundant Ethernet interfaces; U-Boot supports
+such configurations and is capable of automatic selection of a
+"working" interface when needed. MAC assignment works as follows:
+
+Network interfaces are numbered eth0, eth1, eth2, ... Corresponding
+MAC addresses can be stored in the environment as "ethaddr" (=>eth0),
+"eth1addr" (=>eth1), "eth2addr", ...
+
+If the network interface stores some valid MAC address (for instance
+in SROM), this is used as default address if there is NO correspon-
+ding setting in the environment; if the corresponding environment
+variable is set, this overrides the settings in the card; that means:
+
+o If the SROM has a valid MAC address, and there is no address in the
+  environment, the SROM's address is used.
+
+o If there is no valid address in the SROM, and a definition in the
+  environment exists, then the value from the environment variable is
+  used.
+
+o If both the SROM and the environment contain a MAC address, and
+  both addresses are the same, this MAC address is used.
+
+o If both the SROM and the environment contain a MAC address, and the
+  addresses differ, the value from the environment is used and a
+  warning is printed.
+
+o If neither SROM nor the environment contain a MAC address, an error
+  is raised. If CONFIG_NET_RANDOM_ETHADDR is defined, then in this case
+  a random, locally-assigned MAC is used.
+
+If Ethernet drivers implement the 'write_hwaddr' function, valid MAC addresses
+will be programmed into hardware as part of the initialization process.	 This
+may be skipped by setting the appropriate 'ethmacskip' environment variable.
+The naming convention is as follows:
+"ethmacskip" (=>eth0), "eth1macskip" (=>eth1) etc.
+
+Image Formats:
+==============
+
+U-Boot is capable of booting (and performing other auxiliary operations on)
+images in two formats:
+
+New uImage format (FIT)
+-----------------------
+
+Flexible and powerful format based on Flattened Image Tree -- FIT (similar
+to Flattened Device Tree). It allows the use of images with multiple
+components (several kernels, ramdisks, etc.), with contents protected by
+SHA1, MD5 or CRC32. More details are found in the doc/uImage.FIT directory.
+
+
+Old uImage format
+-----------------
+
+Old image format is based on binary files which can be basically anything,
+preceded by a special header; see the definitions in include/image.h for
+details; basically, the header defines the following image properties:
+
+* Target Operating System (Provisions for OpenBSD, NetBSD, FreeBSD,
+  4.4BSD, Linux, SVR4, Esix, Solaris, Irix, SCO, Dell, NCR, VxWorks,
+  LynxOS, pSOS, QNX, RTEMS, INTEGRITY;
+  Currently supported: Linux, NetBSD, VxWorks, QNX, RTEMS, LynxOS,
+  INTEGRITY).
+* Target CPU Architecture (Provisions for Alpha, ARM, AVR32, Intel x86,
+  IA64, MIPS, NDS32, Nios II, PowerPC, IBM S390, SuperH, Sparc, Sparc 64 Bit;
+  Currently supported: ARM, AVR32, Intel x86, MIPS, NDS32, Nios II, PowerPC).
+* Compression Type (uncompressed, gzip, bzip2)
+* Load Address
+* Entry Point
+* Image Name
+* Image Timestamp
+
+The header is marked by a special Magic Number, and both the header
+and the data portions of the image are secured against corruption by
+CRC32 checksums.
+
+
+Linux Support:
+==============
+
+Although U-Boot should support any OS or standalone application
+easily, the main focus has always been on Linux during the design of
+U-Boot.
+
+U-Boot includes many features that so far have been part of some
+special "boot loader" code within the Linux kernel. Also, any
+"initrd" images to be used are no longer part of one big Linux image;
+instead, kernel and "initrd" are separate images. This implementation
+serves several purposes:
+
+- the same features can be used for other OS or standalone
+  applications (for instance: using compressed images to reduce the
+  Flash memory footprint)
+
+- it becomes much easier to port new Linux kernel versions because
+  lots of low-level, hardware dependent stuff are done by U-Boot
+
+- the same Linux kernel image can now be used with different "initrd"
+  images; of course this also means that different kernel images can
+  be run with the same "initrd". This makes testing easier (you don't
+  have to build a new "zImage.initrd" Linux image when you just
+  change a file in your "initrd"). Also, a field-upgrade of the
+  software is easier now.
+
+
+Linux HOWTO:
+============
+
+Porting Linux to U-Boot based systems:
+---------------------------------------
+
+U-Boot cannot save you from doing all the necessary modifications to
+configure the Linux device drivers for use with your target hardware
+(no, we don't intend to provide a full virtual machine interface to
+Linux :-).
+
+But now you can ignore ALL boot loader code (in arch/powerpc/mbxboot).
+
+Just make sure your machine specific header file (for instance
+include/asm-ppc/tqm8xx.h) includes the same definition of the Board
+Information structure as we define in include/asm-<arch>/u-boot.h,
+and make sure that your definition of IMAP_ADDR uses the same value
+as your U-Boot configuration in CONFIG_SYS_IMMR.
+
+Note that U-Boot now has a driver model, a unified model for drivers.
+If you are adding a new driver, plumb it into driver model. If there
+is no uclass available, you are encouraged to create one. See
+doc/driver-model.
+
+
+Configuring the Linux kernel:
+-----------------------------
+
+No specific requirements for U-Boot. Make sure you have some root
+device (initial ramdisk, NFS) for your target system.
+
+
+Building a Linux Image:
+-----------------------
+
+With U-Boot, "normal" build targets like "zImage" or "bzImage" are
+not used. If you use recent kernel source, a new build target
+"uImage" will exist which automatically builds an image usable by
+U-Boot. Most older kernels also have support for a "pImage" target,
+which was introduced for our predecessor project PPCBoot and uses a
+100% compatible format.
+
+Example:
+
+	make TQM850L_defconfig
+	make oldconfig
+	make dep
+	make uImage
+
+The "uImage" build target uses a special tool (in 'tools/mkimage') to
+encapsulate a compressed Linux kernel image with header	 information,
+CRC32 checksum etc. for use with U-Boot. This is what we are doing:
+
+* build a standard "vmlinux" kernel image (in ELF binary format):
+
+* convert the kernel into a raw binary image:
+
+	${CROSS_COMPILE}-objcopy -O binary \
+				 -R .note -R .comment \
+				 -S vmlinux linux.bin
+
+* compress the binary image:
+
+	gzip -9 linux.bin
+
+* package compressed binary image for U-Boot:
+
+	mkimage -A ppc -O linux -T kernel -C gzip \
+		-a 0 -e 0 -n "Linux Kernel Image" \
+		-d linux.bin.gz uImage
+
+
+The "mkimage" tool can also be used to create ramdisk images for use
+with U-Boot, either separated from the Linux kernel image, or
+combined into one file. "mkimage" encapsulates the images with a 64
+byte header containing information about target architecture,
+operating system, image type, compression method, entry points, time
+stamp, CRC32 checksums, etc.
+
+"mkimage" can be called in two ways: to verify existing images and
+print the header information, or to build new images.
+
+In the first form (with "-l" option) mkimage lists the information
+contained in the header of an existing U-Boot image; this includes
+checksum verification:
+
+	tools/mkimage -l image
+	  -l ==> list image header information
+
+The second form (with "-d" option) is used to build a U-Boot image
+from a "data file" which is used as image payload:
+
+	tools/mkimage -A arch -O os -T type -C comp -a addr -e ep \
+		      -n name -d data_file image
+	  -A ==> set architecture to 'arch'
+	  -O ==> set operating system to 'os'
+	  -T ==> set image type to 'type'
+	  -C ==> set compression type 'comp'
+	  -a ==> set load address to 'addr' (hex)
+	  -e ==> set entry point to 'ep' (hex)
+	  -n ==> set image name to 'name'
+	  -d ==> use image data from 'datafile'
+
+Right now, all Linux kernels for PowerPC systems use the same load
+address (0x00000000), but the entry point address depends on the
+kernel version:
+
+- 2.2.x kernels have the entry point at 0x0000000C,
+- 2.3.x and later kernels have the entry point at 0x00000000.
+
+So a typical call to build a U-Boot image would read:
+
+	-> tools/mkimage -n '2.4.4 kernel for TQM850L' \
+	> -A ppc -O linux -T kernel -C gzip -a 0 -e 0 \
+	> -d /opt/elsk/ppc_8xx/usr/src/linux-2.4.4/arch/powerpc/coffboot/vmlinux.gz \
+	> examples/uImage.TQM850L
+	Image Name:   2.4.4 kernel for TQM850L
+	Created:      Wed Jul 19 02:34:59 2000
+	Image Type:   PowerPC Linux Kernel Image (gzip compressed)
+	Data Size:    335725 Bytes = 327.86 kB = 0.32 MB
+	Load Address: 0x00000000
+	Entry Point:  0x00000000
+
+To verify the contents of the image (or check for corruption):
+
+	-> tools/mkimage -l examples/uImage.TQM850L
+	Image Name:   2.4.4 kernel for TQM850L
+	Created:      Wed Jul 19 02:34:59 2000
+	Image Type:   PowerPC Linux Kernel Image (gzip compressed)
+	Data Size:    335725 Bytes = 327.86 kB = 0.32 MB
+	Load Address: 0x00000000
+	Entry Point:  0x00000000
+
+NOTE: for embedded systems where boot time is critical you can trade
+speed for memory and install an UNCOMPRESSED image instead: this
+needs more space in Flash, but boots much faster since it does not
+need to be uncompressed:
+
+	-> gunzip /opt/elsk/ppc_8xx/usr/src/linux-2.4.4/arch/powerpc/coffboot/vmlinux.gz
+	-> tools/mkimage -n '2.4.4 kernel for TQM850L' \
+	> -A ppc -O linux -T kernel -C none -a 0 -e 0 \
+	> -d /opt/elsk/ppc_8xx/usr/src/linux-2.4.4/arch/powerpc/coffboot/vmlinux \
+	> examples/uImage.TQM850L-uncompressed
+	Image Name:   2.4.4 kernel for TQM850L
+	Created:      Wed Jul 19 02:34:59 2000
+	Image Type:   PowerPC Linux Kernel Image (uncompressed)
+	Data Size:    792160 Bytes = 773.59 kB = 0.76 MB
+	Load Address: 0x00000000
+	Entry Point:  0x00000000
+
+
+Similar you can build U-Boot images from a 'ramdisk.image.gz' file
+when your kernel is intended to use an initial ramdisk:
+
+	-> tools/mkimage -n 'Simple Ramdisk Image' \
+	> -A ppc -O linux -T ramdisk -C gzip \
+	> -d /LinuxPPC/images/SIMPLE-ramdisk.image.gz examples/simple-initrd
+	Image Name:   Simple Ramdisk Image
+	Created:      Wed Jan 12 14:01:50 2000
+	Image Type:   PowerPC Linux RAMDisk Image (gzip compressed)
+	Data Size:    566530 Bytes = 553.25 kB = 0.54 MB
+	Load Address: 0x00000000
+	Entry Point:  0x00000000
+
+The "dumpimage" is a tool to disassemble images built by mkimage. Its "-i"
+option performs the converse operation of the mkimage's second form (the "-d"
+option). Given an image built by mkimage, the dumpimage extracts a "data file"
+from the image:
+
+	tools/dumpimage -i image -T type -p position data_file
+	  -i ==> extract from the 'image' a specific 'data_file'
+	  -T ==> set image type to 'type'
+	  -p ==> 'position' (starting at 0) of the 'data_file' inside the 'image'
+
+
+Installing a Linux Image:
+-------------------------
+
+To downloading a U-Boot image over the serial (console) interface,
+you must convert the image to S-Record format:
+
+	objcopy -I binary -O srec examples/image examples/image.srec
+
+The 'objcopy' does not understand the information in the U-Boot
+image header, so the resulting S-Record file will be relative to
+address 0x00000000. To load it to a given address, you need to
+specify the target address as 'offset' parameter with the 'loads'
+command.
+
+Example: install the image to address 0x40100000 (which on the
+TQM8xxL is in the first Flash bank):
+
+	=> erase 40100000 401FFFFF
+
+	.......... done
+	Erased 8 sectors
+
+	=> loads 40100000
+	## Ready for S-Record download ...
+	~>examples/image.srec
+	1 2 3 4 5 6 7 8 9 10 11 12 13 ...
+	...
+	15989 15990 15991 15992
+	[file transfer complete]
+	[connected]
+	## Start Addr = 0x00000000
+
+
+You can check the success of the download using the 'iminfo' command;
+this includes a checksum verification so you can be sure no data
+corruption happened:
+
+	=> imi 40100000
+
+	## Checking Image at 40100000 ...
+	   Image Name:	 2.2.13 for initrd on TQM850L
+	   Image Type:	 PowerPC Linux Kernel Image (gzip compressed)
+	   Data Size:	 335725 Bytes = 327 kB = 0 MB
+	   Load Address: 00000000
+	   Entry Point:	 0000000c
+	   Verifying Checksum ... OK
+
+
+Boot Linux:
+-----------
+
+The "bootm" command is used to boot an application that is stored in
+memory (RAM or Flash). In case of a Linux kernel image, the contents
+of the "bootargs" environment variable is passed to the kernel as
+parameters. You can check and modify this variable using the
+"printenv" and "setenv" commands:
+
+
+	=> printenv bootargs
+	bootargs=root=/dev/ram
+
+	=> setenv bootargs root=/dev/nfs rw nfsroot=10.0.0.2:/LinuxPPC nfsaddrs=10.0.0.99:10.0.0.2
+
+	=> printenv bootargs
+	bootargs=root=/dev/nfs rw nfsroot=10.0.0.2:/LinuxPPC nfsaddrs=10.0.0.99:10.0.0.2
+
+	=> bootm 40020000
+	## Booting Linux kernel at 40020000 ...
+	   Image Name:	 2.2.13 for NFS on TQM850L
+	   Image Type:	 PowerPC Linux Kernel Image (gzip compressed)
+	   Data Size:	 381681 Bytes = 372 kB = 0 MB
+	   Load Address: 00000000
+	   Entry Point:	 0000000c
+	   Verifying Checksum ... OK
+	   Uncompressing Kernel Image ... OK
+	Linux version 2.2.13 (wd@denx.local.net) (gcc version 2.95.2 19991024 (release)) #1 Wed Jul 19 02:35:17 MEST 2000
+	Boot arguments: root=/dev/nfs rw nfsroot=10.0.0.2:/LinuxPPC nfsaddrs=10.0.0.99:10.0.0.2
+	time_init: decrementer frequency = 187500000/60
+	Calibrating delay loop... 49.77 BogoMIPS
+	Memory: 15208k available (700k kernel code, 444k data, 32k init) [c0000000,c1000000]
+	...
+
+If you want to boot a Linux kernel with initial RAM disk, you pass
+the memory addresses of both the kernel and the initrd image (PPBCOOT
+format!) to the "bootm" command:
+
+	=> imi 40100000 40200000
+
+	## Checking Image at 40100000 ...
+	   Image Name:	 2.2.13 for initrd on TQM850L
+	   Image Type:	 PowerPC Linux Kernel Image (gzip compressed)
+	   Data Size:	 335725 Bytes = 327 kB = 0 MB
+	   Load Address: 00000000
+	   Entry Point:	 0000000c
+	   Verifying Checksum ... OK
+
+	## Checking Image at 40200000 ...
+	   Image Name:	 Simple Ramdisk Image
+	   Image Type:	 PowerPC Linux RAMDisk Image (gzip compressed)
+	   Data Size:	 566530 Bytes = 553 kB = 0 MB
+	   Load Address: 00000000
+	   Entry Point:	 00000000
+	   Verifying Checksum ... OK
+
+	=> bootm 40100000 40200000
+	## Booting Linux kernel at 40100000 ...
+	   Image Name:	 2.2.13 for initrd on TQM850L
+	   Image Type:	 PowerPC Linux Kernel Image (gzip compressed)
+	   Data Size:	 335725 Bytes = 327 kB = 0 MB
+	   Load Address: 00000000
+	   Entry Point:	 0000000c
+	   Verifying Checksum ... OK
+	   Uncompressing Kernel Image ... OK
+	## Loading RAMDisk Image at 40200000 ...
+	   Image Name:	 Simple Ramdisk Image
+	   Image Type:	 PowerPC Linux RAMDisk Image (gzip compressed)
+	   Data Size:	 566530 Bytes = 553 kB = 0 MB
+	   Load Address: 00000000
+	   Entry Point:	 00000000
+	   Verifying Checksum ... OK
+	   Loading Ramdisk ... OK
+	Linux version 2.2.13 (wd@denx.local.net) (gcc version 2.95.2 19991024 (release)) #1 Wed Jul 19 02:32:08 MEST 2000
+	Boot arguments: root=/dev/ram
+	time_init: decrementer frequency = 187500000/60
+	Calibrating delay loop... 49.77 BogoMIPS
+	...
+	RAMDISK: Compressed image found at block 0
+	VFS: Mounted root (ext2 filesystem).
+
+	bash#
+
+Boot Linux and pass a flat device tree:
+-----------
+
+First, U-Boot must be compiled with the appropriate defines. See the section
+titled "Linux Kernel Interface" above for a more in depth explanation. The
+following is an example of how to start a kernel and pass an updated
+flat device tree:
+
+=> print oftaddr
+oftaddr=0x300000
+=> print oft
+oft=oftrees/mpc8540ads.dtb
+=> tftp $oftaddr $oft
+Speed: 1000, full duplex
+Using TSEC0 device
+TFTP from server 192.168.1.1; our IP address is 192.168.1.101
+Filename 'oftrees/mpc8540ads.dtb'.
+Load address: 0x300000
+Loading: #
+done
+Bytes transferred = 4106 (100a hex)
+=> tftp $loadaddr $bootfile
+Speed: 1000, full duplex
+Using TSEC0 device
+TFTP from server 192.168.1.1; our IP address is 192.168.1.2
+Filename 'uImage'.
+Load address: 0x200000
+Loading:############
+done
+Bytes transferred = 1029407 (fb51f hex)
+=> print loadaddr
+loadaddr=200000
+=> print oftaddr
+oftaddr=0x300000
+=> bootm $loadaddr - $oftaddr
+## Booting image at 00200000 ...
+   Image Name:	 Linux-2.6.17-dirty
+   Image Type:	 PowerPC Linux Kernel Image (gzip compressed)
+   Data Size:	 1029343 Bytes = 1005.2 kB
+   Load Address: 00000000
+   Entry Point:	 00000000
+   Verifying Checksum ... OK
+   Uncompressing Kernel Image ... OK
+Booting using flat device tree at 0x300000
+Using MPC85xx ADS machine description
+Memory CAM mapping: CAM0=256Mb, CAM1=256Mb, CAM2=0Mb residual: 0Mb
+[snip]
+
+
+More About U-Boot Image Types:
+------------------------------
+
+U-Boot supports the following image types:
+
+   "Standalone Programs" are directly runnable in the environment
+	provided by U-Boot; it is expected that (if they behave
+	well) you can continue to work in U-Boot after return from
+	the Standalone Program.
+   "OS Kernel Images" are usually images of some Embedded OS which
+	will take over control completely. Usually these programs
+	will install their own set of exception handlers, device
+	drivers, set up the MMU, etc. - this means, that you cannot
+	expect to re-enter U-Boot except by resetting the CPU.
+   "RAMDisk Images" are more or less just data blocks, and their
+	parameters (address, size) are passed to an OS kernel that is
+	being started.
+   "Multi-File Images" contain several images, typically an OS
+	(Linux) kernel image and one or more data images like
+	RAMDisks. This construct is useful for instance when you want
+	to boot over the network using BOOTP etc., where the boot
+	server provides just a single image file, but you want to get
+	for instance an OS kernel and a RAMDisk image.
+
+	"Multi-File Images" start with a list of image sizes, each
+	image size (in bytes) specified by an "uint32_t" in network
+	byte order. This list is terminated by an "(uint32_t)0".
+	Immediately after the terminating 0 follow the images, one by
+	one, all aligned on "uint32_t" boundaries (size rounded up to
+	a multiple of 4 bytes).
+
+   "Firmware Images" are binary images containing firmware (like
+	U-Boot or FPGA images) which usually will be programmed to
+	flash memory.
+
+   "Script files" are command sequences that will be executed by
+	U-Boot's command interpreter; this feature is especially
+	useful when you configure U-Boot to use a real shell (hush)
+	as command interpreter.
+
+Booting the Linux zImage:
+-------------------------
+
+On some platforms, it's possible to boot Linux zImage. This is done
+using the "bootz" command. The syntax of "bootz" command is the same
+as the syntax of "bootm" command.
+
+Note, defining the CONFIG_SUPPORT_RAW_INITRD allows user to supply
+kernel with raw initrd images. The syntax is slightly different, the
+address of the initrd must be augmented by it's size, in the following
+format: "<initrd addres>:<initrd size>".
+
+
+Standalone HOWTO:
+=================
+
+One of the features of U-Boot is that you can dynamically load and
+run "standalone" applications, which can use some resources of
+U-Boot like console I/O functions or interrupt services.
+
+Two simple examples are included with the sources:
+
+"Hello World" Demo:
+-------------------
+
+'examples/hello_world.c' contains a small "Hello World" Demo
+application; it is automatically compiled when you build U-Boot.
+It's configured to run at address 0x00040004, so you can play with it
+like that:
+
+	=> loads
+	## Ready for S-Record download ...
+	~>examples/hello_world.srec
+	1 2 3 4 5 6 7 8 9 10 11 ...
+	[file transfer complete]
+	[connected]
+	## Start Addr = 0x00040004
+
+	=> go 40004 Hello World! This is a test.
+	## Starting application at 0x00040004 ...
+	Hello World
+	argc = 7
+	argv[0] = "40004"
+	argv[1] = "Hello"
+	argv[2] = "World!"
+	argv[3] = "This"
+	argv[4] = "is"
+	argv[5] = "a"
+	argv[6] = "test."
+	argv[7] = "<NULL>"
+	Hit any key to exit ...
+
+	## Application terminated, rc = 0x0
+
+Another example, which demonstrates how to register a CPM interrupt
+handler with the U-Boot code, can be found in 'examples/timer.c'.
+Here, a CPM timer is set up to generate an interrupt every second.
+The interrupt service routine is trivial, just printing a '.'
+character, but this is just a demo program. The application can be
+controlled by the following keys:
+
+	? - print current values og the CPM Timer registers
+	b - enable interrupts and start timer
+	e - stop timer and disable interrupts
+	q - quit application
+
+	=> loads
+	## Ready for S-Record download ...
+	~>examples/timer.srec
+	1 2 3 4 5 6 7 8 9 10 11 ...
+	[file transfer complete]
+	[connected]
+	## Start Addr = 0x00040004
+
+	=> go 40004
+	## Starting application at 0x00040004 ...
+	TIMERS=0xfff00980
+	Using timer 1
+	  tgcr @ 0xfff00980, tmr @ 0xfff00990, trr @ 0xfff00994, tcr @ 0xfff00998, tcn @ 0xfff0099c, ter @ 0xfff009b0
+
+Hit 'b':
+	[q, b, e, ?] Set interval 1000000 us
+	Enabling timer
+Hit '?':
+	[q, b, e, ?] ........
+	tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0xef6, ter=0x0
+Hit '?':
+	[q, b, e, ?] .
+	tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0x2ad4, ter=0x0
+Hit '?':
+	[q, b, e, ?] .
+	tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0x1efc, ter=0x0
+Hit '?':
+	[q, b, e, ?] .
+	tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0x169d, ter=0x0
+Hit 'e':
+	[q, b, e, ?] ...Stopping timer
+Hit 'q':
+	[q, b, e, ?] ## Application terminated, rc = 0x0
+
+
+Minicom warning:
+================
+
+Over time, many people have reported problems when trying to use the
+"minicom" terminal emulation program for serial download. I (wd)
+consider minicom to be broken, and recommend not to use it. Under
+Unix, I recommend to use C-Kermit for general purpose use (and
+especially for kermit binary protocol download ("loadb" command), and
+use "cu" for S-Record download ("loads" command).  See
+http://www.denx.de/wiki/view/DULG/SystemSetup#Section_4.3.
+for help with kermit.
+
+
+Nevertheless, if you absolutely want to use it try adding this
+configuration to your "File transfer protocols" section:
+
+	   Name	   Program			Name U/D FullScr IO-Red. Multi
+	X  kermit  /usr/bin/kermit -i -l %l -s	 Y    U	   Y	   N	  N
+	Y  kermit  /usr/bin/kermit -i -l %l -r	 N    D	   Y	   N	  N
+
+
+NetBSD Notes:
+=============
+
+Starting at version 0.9.2, U-Boot supports NetBSD both as host
+(build U-Boot) and target system (boots NetBSD/mpc8xx).
+
+Building requires a cross environment; it is known to work on
+NetBSD/i386 with the cross-powerpc-netbsd-1.3 package (you will also
+need gmake since the Makefiles are not compatible with BSD make).
+Note that the cross-powerpc package does not install include files;
+attempting to build U-Boot will fail because <machine/ansi.h> is
+missing.  This file has to be installed and patched manually:
+
+	# cd /usr/pkg/cross/powerpc-netbsd/include
+	# mkdir powerpc
+	# ln -s powerpc machine
+	# cp /usr/src/sys/arch/powerpc/include/ansi.h powerpc/ansi.h
+	# ${EDIT} powerpc/ansi.h	## must remove __va_list, _BSD_VA_LIST
+
+Native builds *don't* work due to incompatibilities between native
+and U-Boot include files.
+
+Booting assumes that (the first part of) the image booted is a
+stage-2 loader which in turn loads and then invokes the kernel
+proper. Loader sources will eventually appear in the NetBSD source
+tree (probably in sys/arc/mpc8xx/stand/u-boot_stage2/); in the
+meantime, see ftp://ftp.denx.de/pub/u-boot/ppcboot_stage2.tar.gz
+
+
+Implementation Internals:
+=========================
+
+The following is not intended to be a complete description of every
+implementation detail. However, it should help to understand the
+inner workings of U-Boot and make it easier to port it to custom
+hardware.
+
+
+Initial Stack, Global Data:
+---------------------------
+
+The implementation of U-Boot is complicated by the fact that U-Boot
+starts running out of ROM (flash memory), usually without access to
+system RAM (because the memory controller is not initialized yet).
+This means that we don't have writable Data or BSS segments, and BSS
+is not initialized as zero. To be able to get a C environment working
+at all, we have to allocate at least a minimal stack. Implementation
+options for this are defined and restricted by the CPU used: Some CPU
+models provide on-chip memory (like the IMMR area on MPC8xx and
+MPC826x processors), on others (parts of) the data cache can be
+locked as (mis-) used as memory, etc.
+
+	Chris Hallinan posted a good summary of these issues to the
+	U-Boot mailing list:
+
+	Subject: RE: [U-Boot-Users] RE: More On Memory Bank x (nothingness)?
+	From: "Chris Hallinan" <clh@net1plus.com>
+	Date: Mon, 10 Feb 2003 16:43:46 -0500 (22:43 MET)
+	...
+
+	Correct me if I'm wrong, folks, but the way I understand it
+	is this: Using DCACHE as initial RAM for Stack, etc, does not
+	require any physical RAM backing up the cache. The cleverness
+	is that the cache is being used as a temporary supply of
+	necessary storage before the SDRAM controller is setup. It's
+	beyond the scope of this list to explain the details, but you
+	can see how this works by studying the cache architecture and
+	operation in the architecture and processor-specific manuals.
+
+	OCM is On Chip Memory, which I believe the 405GP has 4K. It
+	is another option for the system designer to use as an
+	initial stack/RAM area prior to SDRAM being available. Either
+	option should work for you. Using CS 4 should be fine if your
+	board designers haven't used it for something that would
+	cause you grief during the initial boot! It is frequently not
+	used.
+
+	CONFIG_SYS_INIT_RAM_ADDR should be somewhere that won't interfere
+	with your processor/board/system design. The default value
+	you will find in any recent u-boot distribution in
+	walnut.h should work for you. I'd set it to a value larger
+	than your SDRAM module. If you have a 64MB SDRAM module, set
+	it above 400_0000. Just make sure your board has no resources
+	that are supposed to respond to that address! That code in
+	start.S has been around a while and should work as is when
+	you get the config right.
+
+	-Chris Hallinan
+	DS4.COM, Inc.
+
+It is essential to remember this, since it has some impact on the C
+code for the initialization procedures:
+
+* Initialized global data (data segment) is read-only. Do not attempt
+  to write it.
+
+* Do not use any uninitialized global data (or implicitly initialized
+  as zero data - BSS segment) at all - this is undefined, initiali-
+  zation is performed later (when relocating to RAM).
+
+* Stack space is very limited. Avoid big data buffers or things like
+  that.
+
+Having only the stack as writable memory limits means we cannot use
+normal global data to share information between the code. But it
+turned out that the implementation of U-Boot can be greatly
+simplified by making a global data structure (gd_t) available to all
+functions. We could pass a pointer to this data as argument to _all_
+functions, but this would bloat the code. Instead we use a feature of
+the GCC compiler (Global Register Variables) to share the data: we
+place a pointer (gd) to the global data into a register which we
+reserve for this purpose.
+
+When choosing a register for such a purpose we are restricted by the
+relevant  (E)ABI  specifications for the current architecture, and by
+GCC's implementation.
+
+For PowerPC, the following registers have specific use:
+	R1:	stack pointer
+	R2:	reserved for system use
+	R3-R4:	parameter passing and return values
+	R5-R10: parameter passing
+	R13:	small data area pointer
+	R30:	GOT pointer
+	R31:	frame pointer
+
+	(U-Boot also uses R12 as internal GOT pointer. r12
+	is a volatile register so r12 needs to be reset when
+	going back and forth between asm and C)
+
+    ==> U-Boot will use R2 to hold a pointer to the global data
+
+    Note: on PPC, we could use a static initializer (since the
+    address of the global data structure is known at compile time),
+    but it turned out that reserving a register results in somewhat
+    smaller code - although the code savings are not that big (on
+    average for all boards 752 bytes for the whole U-Boot image,
+    624 text + 127 data).
+
+On Blackfin, the normal C ABI (except for P3) is followed as documented here:
+	http://docs.blackfin.uclinux.org/doku.php?id=application_binary_interface
+
+    ==> U-Boot will use P3 to hold a pointer to the global data
+
+On ARM, the following registers are used:
+
+	R0:	function argument word/integer result
+	R1-R3:	function argument word
+	R9:	platform specific
+	R10:	stack limit (used only if stack checking is enabled)
+	R11:	argument (frame) pointer
+	R12:	temporary workspace
+	R13:	stack pointer
+	R14:	link register
+	R15:	program counter
+
+    ==> U-Boot will use R9 to hold a pointer to the global data
+
+    Note: on ARM, only R_ARM_RELATIVE relocations are supported.
+
+On Nios II, the ABI is documented here:
+	http://www.altera.com/literature/hb/nios2/n2cpu_nii51016.pdf
+
+    ==> U-Boot will use gp to hold a pointer to the global data
+
+    Note: on Nios II, we give "-G0" option to gcc and don't use gp
+    to access small data sections, so gp is free.
+
+On NDS32, the following registers are used:
+
+	R0-R1:	argument/return
+	R2-R5:	argument
+	R15:	temporary register for assembler
+	R16:	trampoline register
+	R28:	frame pointer (FP)
+	R29:	global pointer (GP)
+	R30:	link register (LP)
+	R31:	stack pointer (SP)
+	PC:	program counter (PC)
+
+    ==> U-Boot will use R10 to hold a pointer to the global data
+
+NOTE: DECLARE_GLOBAL_DATA_PTR must be used with file-global scope,
+or current versions of GCC may "optimize" the code too much.
+
+Memory Management:
+------------------
+
+U-Boot runs in system state and uses physical addresses, i.e. the
+MMU is not used either for address mapping nor for memory protection.
+
+The available memory is mapped to fixed addresses using the memory
+controller. In this process, a contiguous block is formed for each
+memory type (Flash, SDRAM, SRAM), even when it consists of several
+physical memory banks.
+
+U-Boot is installed in the first 128 kB of the first Flash bank (on
+TQM8xxL modules this is the range 0x40000000 ... 0x4001FFFF). After
+booting and sizing and initializing DRAM, the code relocates itself
+to the upper end of DRAM. Immediately below the U-Boot code some
+memory is reserved for use by malloc() [see CONFIG_SYS_MALLOC_LEN
+configuration setting]. Below that, a structure with global Board
+Info data is placed, followed by the stack (growing downward).
+
+Additionally, some exception handler code is copied to the low 8 kB
+of DRAM (0x00000000 ... 0x00001FFF).
+
+So a typical memory configuration with 16 MB of DRAM could look like
+this:
+
+	0x0000 0000	Exception Vector code
+	      :
+	0x0000 1FFF
+	0x0000 2000	Free for Application Use
+	      :
+	      :
+
+	      :
+	      :
+	0x00FB FF20	Monitor Stack (Growing downward)
+	0x00FB FFAC	Board Info Data and permanent copy of global data
+	0x00FC 0000	Malloc Arena
+	      :
+	0x00FD FFFF
+	0x00FE 0000	RAM Copy of Monitor Code
+	...		eventually: LCD or video framebuffer
+	...		eventually: pRAM (Protected RAM - unchanged by reset)
+	0x00FF FFFF	[End of RAM]
+
+
+System Initialization:
+----------------------
+
+In the reset configuration, U-Boot starts at the reset entry point
+(on most PowerPC systems at address 0x00000100). Because of the reset
+configuration for CS0# this is a mirror of the on board Flash memory.
+To be able to re-map memory U-Boot then jumps to its link address.
+To be able to implement the initialization code in C, a (small!)
+initial stack is set up in the internal Dual Ported RAM (in case CPUs
+which provide such a feature like MPC8xx or MPC8260), or in a locked
+part of the data cache. After that, U-Boot initializes the CPU core,
+the caches and the SIU.
+
+Next, all (potentially) available memory banks are mapped using a
+preliminary mapping. For example, we put them on 512 MB boundaries
+(multiples of 0x20000000: SDRAM on 0x00000000 and 0x20000000, Flash
+on 0x40000000 and 0x60000000, SRAM on 0x80000000). Then UPM A is
+programmed for SDRAM access. Using the temporary configuration, a
+simple memory test is run that determines the size of the SDRAM
+banks.
+
+When there is more than one SDRAM bank, and the banks are of
+different size, the largest is mapped first. For equal size, the first
+bank (CS2#) is mapped first. The first mapping is always for address
+0x00000000, with any additional banks following immediately to create
+contiguous memory starting from 0.
+
+Then, the monitor installs itself at the upper end of the SDRAM area
+and allocates memory for use by malloc() and for the global Board
+Info data; also, the exception vector code is copied to the low RAM
+pages, and the final stack is set up.
+
+Only after this relocation will you have a "normal" C environment;
+until that you are restricted in several ways, mostly because you are
+running from ROM, and because the code will have to be relocated to a
+new address in RAM.
+
+
+U-Boot Porting Guide:
+----------------------
+
+[Based on messages by Jerry Van Baren in the U-Boot-Users mailing
+list, October 2002]
+
+
+int main(int argc, char *argv[])
+{
+	sighandler_t no_more_time;
+
+	signal(SIGALRM, no_more_time);
+	alarm(PROJECT_DEADLINE - toSec (3 * WEEK));
+
+	if (available_money > available_manpower) {
+		Pay consultant to port U-Boot;
+		return 0;
+	}
+
+	Download latest U-Boot source;
+
+	Subscribe to u-boot mailing list;
+
+	if (clueless)
+		email("Hi, I am new to U-Boot, how do I get started?");
+
+	while (learning) {
+		Read the README file in the top level directory;
+		Read http://www.denx.de/twiki/bin/view/DULG/Manual;
+		Read applicable doc/*.README;
+		Read the source, Luke;
+		/* find . -name "*.[chS]" | xargs grep -i <keyword> */
+	}
+
+	if (available_money > toLocalCurrency ($2500))
+		Buy a BDI3000;
+	else
+		Add a lot of aggravation and time;
+
+	if (a similar board exists) {	/* hopefully... */
+		cp -a board/<similar> board/<myboard>
+		cp include/configs/<similar>.h include/configs/<myboard>.h
+	} else {
+		Create your own board support subdirectory;
+		Create your own board include/configs/<myboard>.h file;
+	}
+	Edit new board/<myboard> files
+	Edit new include/configs/<myboard>.h
+
+	while (!accepted) {
+		while (!running) {
+			do {
+				Add / modify source code;
+			} until (compiles);
+			Debug;
+			if (clueless)
+				email("Hi, I am having problems...");
+		}
+		Send patch file to the U-Boot email list;
+		if (reasonable critiques)
+			Incorporate improvements from email list code review;
+		else
+			Defend code as written;
+	}
+
+	return 0;
+}
+
+void no_more_time (int sig)
+{
+      hire_a_guru();
+}
+
+
+Coding Standards:
+-----------------
+
+All contributions to U-Boot should conform to the Linux kernel
+coding style; see the file "Documentation/CodingStyle" and the script
+"scripts/Lindent" in your Linux kernel source directory.
+
+Source files originating from a different project (for example the
+MTD subsystem) are generally exempt from these guidelines and are not
+reformatted to ease subsequent migration to newer versions of those
+sources.
+
+Please note that U-Boot is implemented in C (and to some small parts in
+Assembler); no C++ is used, so please do not use C++ style comments (//)
+in your code.
+
+Please also stick to the following formatting rules:
+- remove any trailing white space
+- use TAB characters for indentation and vertical alignment, not spaces
+- make sure NOT to use DOS '\r\n' line feeds
+- do not add more than 2 consecutive empty lines to source files
+- do not add trailing empty lines to source files
+
+Submissions which do not conform to the standards may be returned
+with a request to reformat the changes.
+
+
+Submitting Patches:
+-------------------
+
+Since the number of patches for U-Boot is growing, we need to
+establish some rules. Submissions which do not conform to these rules
+may be rejected, even when they contain important and valuable stuff.
+
+Please see http://www.denx.de/wiki/U-Boot/Patches for details.
+
+Patches shall be sent to the u-boot mailing list <u-boot@lists.denx.de>;
+see http://lists.denx.de/mailman/listinfo/u-boot
+
+When you send a patch, please include the following information with
+it:
+
+* For bug fixes: a description of the bug and how your patch fixes
+  this bug. Please try to include a way of demonstrating that the
+  patch actually fixes something.
+
+* For new features: a description of the feature and your
+  implementation.
+
+* A CHANGELOG entry as plaintext (separate from the patch)
+
+* For major contributions, add a MAINTAINERS file with your
+  information and associated file and directory references.
+
+* When you add support for a new board, don't forget to add a
+  maintainer e-mail address to the boards.cfg file, too.
+
+* If your patch adds new configuration options, don't forget to
+  document these in the README file.
+
+* The patch itself. If you are using git (which is *strongly*
+  recommended) you can easily generate the patch using the
+  "git format-patch". If you then use "git send-email" to send it to
+  the U-Boot mailing list, you will avoid most of the common problems
+  with some other mail clients.
+
+  If you cannot use git, use "diff -purN OLD NEW". If your version of
+  diff does not support these options, then get the latest version of
+  GNU diff.
+
+  The current directory when running this command shall be the parent
+  directory of the U-Boot source tree (i. e. please make sure that
+  your patch includes sufficient directory information for the
+  affected files).
+
+  We prefer patches as plain text. MIME attachments are discouraged,
+  and compressed attachments must not be used.
+
+* If one logical set of modifications affects or creates several
+  files, all these changes shall be submitted in a SINGLE patch file.
+
+* Changesets that contain different, unrelated modifications shall be
+  submitted as SEPARATE patches, one patch per changeset.
+
+
+Notes:
+
+* Before sending the patch, run the MAKEALL script on your patched
+  source tree and make sure that no errors or warnings are reported
+  for any of the boards.
+
+* Keep your modifications to the necessary minimum: A patch
+  containing several unrelated changes or arbitrary reformats will be
+  returned with a request to re-formatting / split it.
+
+* If you modify existing code, make sure that your new code does not
+  add to the memory footprint of the code ;-) Small is beautiful!
+  When adding new features, these should compile conditionally only
+  (using #ifdef), and the resulting code with the new feature
+  disabled must not need more memory than the old code without your
+  modification.
+
+* Remember that there is a size limit of 100 kB per message on the
+  u-boot mailing list. Bigger patches will be moderated. If they are
+  reasonable and not too big, they will be acknowledged. But patches
+  bigger than the size limit should be avoided.
diff -urN u-boot-2016.03/README ebf_6ull_uboot/README
--- u-boot-2016.03/README	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/README	1970-01-01 08:00:00.000000000 +0800
@@ -1,6623 +0,0 @@
-#
-# (C) Copyright 2000 - 2013
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-Summary:
-========
-
-This directory contains the source code for U-Boot, a boot loader for
-Embedded boards based on PowerPC, ARM, MIPS and several other
-processors, which can be installed in a boot ROM and used to
-initialize and test the hardware or to download and run application
-code.
-
-The development of U-Boot is closely related to Linux: some parts of
-the source code originate in the Linux source tree, we have some
-header files in common, and special provision has been made to
-support booting of Linux images.
-
-Some attention has been paid to make this software easily
-configurable and extendable. For instance, all monitor commands are
-implemented with the same call interface, so that it's very easy to
-add new commands. Also, instead of permanently adding rarely used
-code (for instance hardware test utilities) to the monitor, you can
-load and run it dynamically.
-
-
-Status:
-=======
-
-In general, all boards for which a configuration option exists in the
-Makefile have been tested to some extent and can be considered
-"working". In fact, many of them are used in production systems.
-
-In case of problems see the CHANGELOG file to find out who contributed
-the specific port. In addition, there are various MAINTAINERS files
-scattered throughout the U-Boot source identifying the people or
-companies responsible for various boards and subsystems.
-
-Note: As of August, 2010, there is no longer a CHANGELOG file in the
-actual U-Boot source tree; however, it can be created dynamically
-from the Git log using:
-
-	make CHANGELOG
-
-
-Where to get help:
-==================
-
-In case you have questions about, problems with or contributions for
-U-Boot, you should send a message to the U-Boot mailing list at
-<u-boot@lists.denx.de>. There is also an archive of previous traffic
-on the mailing list - please search the archive before asking FAQ's.
-Please see http://lists.denx.de/pipermail/u-boot and
-http://dir.gmane.org/gmane.comp.boot-loaders.u-boot
-
-
-Where to get source code:
-=========================
-
-The U-Boot source code is maintained in the Git repository at
-git://www.denx.de/git/u-boot.git ; you can browse it online at
-http://www.denx.de/cgi-bin/gitweb.cgi?p=u-boot.git;a=summary
-
-The "snapshot" links on this page allow you to download tarballs of
-any version you might be interested in. Official releases are also
-available for FTP download from the ftp://ftp.denx.de/pub/u-boot/
-directory.
-
-Pre-built (and tested) images are available from
-ftp://ftp.denx.de/pub/u-boot/images/
-
-
-Where we come from:
-===================
-
-- start from 8xxrom sources
-- create PPCBoot project (http://sourceforge.net/projects/ppcboot)
-- clean up code
-- make it easier to add custom boards
-- make it possible to add other [PowerPC] CPUs
-- extend functions, especially:
-  * Provide extended interface to Linux boot loader
-  * S-Record download
-  * network boot
-  * PCMCIA / CompactFlash / ATA disk / SCSI ... boot
-- create ARMBoot project (http://sourceforge.net/projects/armboot)
-- add other CPU families (starting with ARM)
-- create U-Boot project (http://sourceforge.net/projects/u-boot)
-- current project page: see http://www.denx.de/wiki/U-Boot
-
-
-Names and Spelling:
-===================
-
-The "official" name of this project is "Das U-Boot". The spelling
-"U-Boot" shall be used in all written text (documentation, comments
-in source files etc.). Example:
-
-	This is the README file for the U-Boot project.
-
-File names etc. shall be based on the string "u-boot". Examples:
-
-	include/asm-ppc/u-boot.h
-
-	#include <asm/u-boot.h>
-
-Variable names, preprocessor constants etc. shall be either based on
-the string "u_boot" or on "U_BOOT". Example:
-
-	U_BOOT_VERSION		u_boot_logo
-	IH_OS_U_BOOT		u_boot_hush_start
-
-
-Versioning:
-===========
-
-Starting with the release in October 2008, the names of the releases
-were changed from numerical release numbers without deeper meaning
-into a time stamp based numbering. Regular releases are identified by
-names consisting of the calendar year and month of the release date.
-Additional fields (if present) indicate release candidates or bug fix
-releases in "stable" maintenance trees.
-
-Examples:
-	U-Boot v2009.11	    - Release November 2009
-	U-Boot v2009.11.1   - Release 1 in version November 2009 stable tree
-	U-Boot v2010.09-rc1 - Release candiate 1 for September 2010 release
-
-
-Directory Hierarchy:
-====================
-
-/arch			Architecture specific files
-  /arc			Files generic to ARC architecture
-  /arm			Files generic to ARM architecture
-  /avr32		Files generic to AVR32 architecture
-  /blackfin		Files generic to Analog Devices Blackfin architecture
-  /m68k			Files generic to m68k architecture
-  /microblaze		Files generic to microblaze architecture
-  /mips			Files generic to MIPS architecture
-  /nds32		Files generic to NDS32 architecture
-  /nios2		Files generic to Altera NIOS2 architecture
-  /openrisc		Files generic to OpenRISC architecture
-  /powerpc		Files generic to PowerPC architecture
-  /sandbox		Files generic to HW-independent "sandbox"
-  /sh			Files generic to SH architecture
-  /sparc		Files generic to SPARC architecture
-  /x86			Files generic to x86 architecture
-/api			Machine/arch independent API for external apps
-/board			Board dependent files
-/common			Misc architecture independent functions
-/configs		Board default configuration files
-/disk			Code for disk drive partition handling
-/doc			Documentation (don't expect too much)
-/drivers		Commonly used device drivers
-/dts			Contains Makefile for building internal U-Boot fdt.
-/examples		Example code for standalone applications, etc.
-/fs			Filesystem code (cramfs, ext2, jffs2, etc.)
-/include		Header Files
-/lib			Library routines generic to all architectures
-/Licenses		Various license files
-/net			Networking code
-/post			Power On Self Test
-/scripts		Various build scripts and Makefiles
-/test			Various unit test files
-/tools			Tools to build S-Record or U-Boot images, etc.
-
-Software Configuration:
-=======================
-
-Configuration is usually done using C preprocessor defines; the
-rationale behind that is to avoid dead code whenever possible.
-
-There are two classes of configuration variables:
-
-* Configuration _OPTIONS_:
-  These are selectable by the user and have names beginning with
-  "CONFIG_".
-
-* Configuration _SETTINGS_:
-  These depend on the hardware etc. and should not be meddled with if
-  you don't know what you're doing; they have names beginning with
-  "CONFIG_SYS_".
-
-Previously, all configuration was done by hand, which involved creating
-symbolic links and editing configuration files manually. More recently,
-U-Boot has added the Kbuild infrastructure used by the Linux kernel,
-allowing you to use the "make menuconfig" command to configure your
-build.
-
-
-Selection of Processor Architecture and Board Type:
----------------------------------------------------
-
-For all supported boards there are ready-to-use default
-configurations available; just type "make <board_name>_defconfig".
-
-Example: For a TQM823L module type:
-
-	cd u-boot
-	make TQM823L_defconfig
-
-Note: If you're looking for the default configuration file for a board
-you're sure used to be there but is now missing, check the file
-doc/README.scrapyard for a list of no longer supported boards.
-
-Sandbox Environment:
---------------------
-
-U-Boot can be built natively to run on a Linux host using the 'sandbox'
-board. This allows feature development which is not board- or architecture-
-specific to be undertaken on a native platform. The sandbox is also used to
-run some of U-Boot's tests.
-
-See board/sandbox/README.sandbox for more details.
-
-
-Board Initialisation Flow:
---------------------------
-
-This is the intended start-up flow for boards. This should apply for both
-SPL and U-Boot proper (i.e. they both follow the same rules).
-
-Note: "SPL" stands for "Secondary Program Loader," which is explained in
-more detail later in this file.
-
-At present, SPL mostly uses a separate code path, but the function names
-and roles of each function are the same. Some boards or architectures
-may not conform to this.  At least most ARM boards which use
-CONFIG_SPL_FRAMEWORK conform to this.
-
-Execution typically starts with an architecture-specific (and possibly
-CPU-specific) start.S file, such as:
-
-	- arch/arm/cpu/armv7/start.S
-	- arch/powerpc/cpu/mpc83xx/start.S
-	- arch/mips/cpu/start.S
-
-and so on. From there, three functions are called; the purpose and
-limitations of each of these functions are described below.
-
-lowlevel_init():
-	- purpose: essential init to permit execution to reach board_init_f()
-	- no global_data or BSS
-	- there is no stack (ARMv7 may have one but it will soon be removed)
-	- must not set up SDRAM or use console
-	- must only do the bare minimum to allow execution to continue to
-		board_init_f()
-	- this is almost never needed
-	- return normally from this function
-
-board_init_f():
-	- purpose: set up the machine ready for running board_init_r():
-		i.e. SDRAM and serial UART
-	- global_data is available
-	- stack is in SRAM
-	- BSS is not available, so you cannot use global/static variables,
-		only stack variables and global_data
-
-	Non-SPL-specific notes:
-	- dram_init() is called to set up DRAM. If already done in SPL this
-		can do nothing
-
-	SPL-specific notes:
-	- you can override the entire board_init_f() function with your own
-		version as needed.
-	- preloader_console_init() can be called here in extremis
-	- should set up SDRAM, and anything needed to make the UART work
-	- these is no need to clear BSS, it will be done by crt0.S
-	- must return normally from this function (don't call board_init_r()
-		directly)
-
-Here the BSS is cleared. For SPL, if CONFIG_SPL_STACK_R is defined, then at
-this point the stack and global_data are relocated to below
-CONFIG_SPL_STACK_R_ADDR. For non-SPL, U-Boot is relocated to run at the top of
-memory.
-
-board_init_r():
-	- purpose: main execution, common code
-	- global_data is available
-	- SDRAM is available
-	- BSS is available, all static/global variables can be used
-	- execution eventually continues to main_loop()
-
-	Non-SPL-specific notes:
-	- U-Boot is relocated to the top of memory and is now running from
-		there.
-
-	SPL-specific notes:
-	- stack is optionally in SDRAM, if CONFIG_SPL_STACK_R is defined and
-		CONFIG_SPL_STACK_R_ADDR points into SDRAM
-	- preloader_console_init() can be called here - typically this is
-		done by defining CONFIG_SPL_BOARD_INIT and then supplying a
-		spl_board_init() function containing this call
-	- loads U-Boot or (in falcon mode) Linux
-
-
-
-Configuration Options:
-----------------------
-
-Configuration depends on the combination of board and CPU type; all
-such information is kept in a configuration file
-"include/configs/<board_name>.h".
-
-Example: For a TQM823L module, all configuration settings are in
-"include/configs/TQM823L.h".
-
-
-Many of the options are named exactly as the corresponding Linux
-kernel configuration options. The intention is to make it easier to
-build a config tool - later.
-
-
-The following options need to be configured:
-
-- CPU Type:	Define exactly one, e.g. CONFIG_MPC85XX.
-
-- Board Type:	Define exactly one, e.g. CONFIG_MPC8540ADS.
-
-- CPU Daughterboard Type: (if CONFIG_ATSTK1000 is defined)
-		Define exactly one, e.g. CONFIG_ATSTK1002
-
-- CPU Module Type: (if CONFIG_COGENT is defined)
-		Define exactly one of
-		CONFIG_CMA286_60_OLD
---- FIXME --- not tested yet:
-		CONFIG_CMA286_60, CONFIG_CMA286_21, CONFIG_CMA286_60P,
-		CONFIG_CMA287_23, CONFIG_CMA287_50
-
-- Motherboard Type: (if CONFIG_COGENT is defined)
-		Define exactly one of
-		CONFIG_CMA101, CONFIG_CMA102
-
-- Motherboard I/O Modules: (if CONFIG_COGENT is defined)
-		Define one or more of
-		CONFIG_CMA302
-
-- Motherboard Options: (if CONFIG_CMA101 or CONFIG_CMA102 are defined)
-		Define one or more of
-		CONFIG_LCD_HEARTBEAT	- update a character position on
-					  the LCD display every second with
-					  a "rotator" |\-/|\-/
-
-- Marvell Family Member
-		CONFIG_SYS_MVFS		- define it if you want to enable
-					  multiple fs option at one time
-					  for marvell soc family
-
-- 8xx CPU Options: (if using an MPC8xx CPU)
-		CONFIG_8xx_GCLK_FREQ	- deprecated: CPU clock if
-					  get_gclk_freq() cannot work
-					  e.g. if there is no 32KHz
-					  reference PIT/RTC clock
-		CONFIG_8xx_OSCLK	- PLL input clock (either EXTCLK
-					  or XTAL/EXTAL)
-
-- 859/866/885 CPU options: (if using a MPC859 or MPC866 or MPC885 CPU):
-		CONFIG_SYS_8xx_CPUCLK_MIN
-		CONFIG_SYS_8xx_CPUCLK_MAX
-		CONFIG_8xx_CPUCLK_DEFAULT
-			See doc/README.MPC866
-
-		CONFIG_SYS_MEASURE_CPUCLK
-
-		Define this to measure the actual CPU clock instead
-		of relying on the correctness of the configured
-		values. Mostly useful for board bringup to make sure
-		the PLL is locked at the intended frequency. Note
-		that this requires a (stable) reference clock (32 kHz
-		RTC clock or CONFIG_SYS_8XX_XIN)
-
-		CONFIG_SYS_DELAYED_ICACHE
-
-		Define this option if you want to enable the
-		ICache only when Code runs from RAM.
-
-- 85xx CPU Options:
-		CONFIG_SYS_PPC64
-
-		Specifies that the core is a 64-bit PowerPC implementation (implements
-		the "64" category of the Power ISA). This is necessary for ePAPR
-		compliance, among other possible reasons.
-
-		CONFIG_SYS_FSL_TBCLK_DIV
-
-		Defines the core time base clock divider ratio compared to the
-		system clock.  On most PQ3 devices this is 8, on newer QorIQ
-		devices it can be 16 or 32.  The ratio varies from SoC to Soc.
-
-		CONFIG_SYS_FSL_PCIE_COMPAT
-
-		Defines the string to utilize when trying to match PCIe device
-		tree nodes for the given platform.
-
-		CONFIG_SYS_PPC_E500_DEBUG_TLB
-
-		Enables a temporary TLB entry to be used during boot to work
-		around limitations in e500v1 and e500v2 external debugger
-		support. This reduces the portions of the boot code where
-		breakpoints and single stepping do not work.  The value of this
-		symbol should be set to the TLB1 entry to be used for this
-		purpose.
-
-		CONFIG_SYS_FSL_ERRATUM_A004510
-
-		Enables a workaround for erratum A004510.  If set,
-		then CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV and
-		CONFIG_SYS_FSL_CORENET_SNOOPVEC_COREONLY must be set.
-
-		CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV
-		CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV2 (optional)
-
-		Defines one or two SoC revisions (low 8 bits of SVR)
-		for which the A004510 workaround should be applied.
-
-		The rest of SVR is either not relevant to the decision
-		of whether the erratum is present (e.g. p2040 versus
-		p2041) or is implied by the build target, which controls
-		whether CONFIG_SYS_FSL_ERRATUM_A004510 is set.
-
-		See Freescale App Note 4493 for more information about
-		this erratum.
-
-		CONFIG_A003399_NOR_WORKAROUND
-		Enables a workaround for IFC erratum A003399. It is only
-		required during NOR boot.
-
-		CONFIG_A008044_WORKAROUND
-		Enables a workaround for T1040/T1042 erratum A008044. It is only
-		required during NAND boot and valid for Rev 1.0 SoC revision
-
-		CONFIG_SYS_FSL_CORENET_SNOOPVEC_COREONLY
-
-		This is the value to write into CCSR offset 0x18600
-		according to the A004510 workaround.
-
-		CONFIG_SYS_FSL_DSP_DDR_ADDR
-		This value denotes start offset of DDR memory which is
-		connected exclusively to the DSP cores.
-
-		CONFIG_SYS_FSL_DSP_M2_RAM_ADDR
-		This value denotes start offset of M2 memory
-		which is directly connected to the DSP core.
-
-		CONFIG_SYS_FSL_DSP_M3_RAM_ADDR
-		This value denotes start offset of M3 memory which is directly
-		connected to the DSP core.
-
-		CONFIG_SYS_FSL_DSP_CCSRBAR_DEFAULT
-		This value denotes start offset of DSP CCSR space.
-
-		CONFIG_SYS_FSL_SINGLE_SOURCE_CLK
-		Single Source Clock is clocking mode present in some of FSL SoC's.
-		In this mode, a single differential clock is used to supply
-		clocks to the sysclock, ddrclock and usbclock.
-
-		CONFIG_SYS_CPC_REINIT_F
-		This CONFIG is defined when the CPC is configured as SRAM at the
-		time of U-Boot entry and is required to be re-initialized.
-
-		CONFIG_DEEP_SLEEP
-		Indicates this SoC supports deep sleep feature. If deep sleep is
-		supported, core will start to execute uboot when wakes up.
-
-- Generic CPU options:
-		CONFIG_SYS_GENERIC_GLOBAL_DATA
-		Defines global data is initialized in generic board board_init_f().
-		If this macro is defined, global data is created and cleared in
-		generic board board_init_f(). Without this macro, architecture/board
-		should initialize global data before calling board_init_f().
-
-		CONFIG_SYS_BIG_ENDIAN, CONFIG_SYS_LITTLE_ENDIAN
-
-		Defines the endianess of the CPU. Implementation of those
-		values is arch specific.
-
-		CONFIG_SYS_FSL_DDR
-		Freescale DDR driver in use. This type of DDR controller is
-		found in mpc83xx, mpc85xx, mpc86xx as well as some ARM core
-		SoCs.
-
-		CONFIG_SYS_FSL_DDR_ADDR
-		Freescale DDR memory-mapped register base.
-
-		CONFIG_SYS_FSL_DDR_EMU
-		Specify emulator support for DDR. Some DDR features such as
-		deskew training are not available.
-
-		CONFIG_SYS_FSL_DDRC_GEN1
-		Freescale DDR1 controller.
-
-		CONFIG_SYS_FSL_DDRC_GEN2
-		Freescale DDR2 controller.
-
-		CONFIG_SYS_FSL_DDRC_GEN3
-		Freescale DDR3 controller.
-
-		CONFIG_SYS_FSL_DDRC_GEN4
-		Freescale DDR4 controller.
-
-		CONFIG_SYS_FSL_DDRC_ARM_GEN3
-		Freescale DDR3 controller for ARM-based SoCs.
-
-		CONFIG_SYS_FSL_DDR1
-		Board config to use DDR1. It can be enabled for SoCs with
-		Freescale DDR1 or DDR2 controllers, depending on the board
-		implemetation.
-
-		CONFIG_SYS_FSL_DDR2
-		Board config to use DDR2. It can be eanbeld for SoCs with
-		Freescale DDR2 or DDR3 controllers, depending on the board
-		implementation.
-
-		CONFIG_SYS_FSL_DDR3
-		Board config to use DDR3. It can be enabled for SoCs with
-		Freescale DDR3 or DDR3L controllers.
-
-		CONFIG_SYS_FSL_DDR3L
-		Board config to use DDR3L. It can be enabled for SoCs with
-		DDR3L controllers.
-
-		CONFIG_SYS_FSL_DDR4
-		Board config to use DDR4. It can be enabled for SoCs with
-		DDR4 controllers.
-
-		CONFIG_SYS_FSL_IFC_BE
-		Defines the IFC controller register space as Big Endian
-
-		CONFIG_SYS_FSL_IFC_LE
-		Defines the IFC controller register space as Little Endian
-
-		CONFIG_SYS_FSL_PBL_PBI
-		It enables addition of RCW (Power on reset configuration) in built image.
-		Please refer doc/README.pblimage for more details
-
-		CONFIG_SYS_FSL_PBL_RCW
-		It adds PBI(pre-boot instructions) commands in u-boot build image.
-		PBI commands can be used to configure SoC before it starts the execution.
-		Please refer doc/README.pblimage for more details
-
-		CONFIG_SPL_FSL_PBL
-		It adds a target to create boot binary having SPL binary in PBI format
-		concatenated with u-boot binary.
-
-		CONFIG_SYS_FSL_DDR_BE
-		Defines the DDR controller register space as Big Endian
-
-		CONFIG_SYS_FSL_DDR_LE
-		Defines the DDR controller register space as Little Endian
-
-		CONFIG_SYS_FSL_DDR_SDRAM_BASE_PHY
-		Physical address from the view of DDR controllers. It is the
-		same as CONFIG_SYS_DDR_SDRAM_BASE for  all Power SoCs. But
-		it could be different for ARM SoCs.
-
-		CONFIG_SYS_FSL_DDR_INTLV_256B
-		DDR controller interleaving on 256-byte. This is a special
-		interleaving mode, handled by Dickens for Freescale layerscape
-		SoCs with ARM core.
-
-		CONFIG_SYS_FSL_DDR_MAIN_NUM_CTRLS
-		Number of controllers used as main memory.
-
-		CONFIG_SYS_FSL_OTHER_DDR_NUM_CTRLS
-		Number of controllers used for other than main memory.
-
-		CONFIG_SYS_FSL_HAS_DP_DDR
-		Defines the SoC has DP-DDR used for DPAA.
-
-		CONFIG_SYS_FSL_SEC_BE
-		Defines the SEC controller register space as Big Endian
-
-		CONFIG_SYS_FSL_SEC_LE
-		Defines the SEC controller register space as Little Endian
-
-- Intel Monahans options:
-		CONFIG_SYS_MONAHANS_RUN_MODE_OSC_RATIO
-
-		Defines the Monahans run mode to oscillator
-		ratio. Valid values are 8, 16, 24, 31. The core
-		frequency is this value multiplied by 13 MHz.
-
-		CONFIG_SYS_MONAHANS_TURBO_RUN_MODE_RATIO
-
-		Defines the Monahans turbo mode to oscillator
-		ratio. Valid values are 1 (default if undefined) and
-		2. The core frequency as calculated above is multiplied
-		by this value.
-
-- MIPS CPU options:
-		CONFIG_SYS_INIT_SP_OFFSET
-
-		Offset relative to CONFIG_SYS_SDRAM_BASE for initial stack
-		pointer. This is needed for the temporary stack before
-		relocation.
-
-		CONFIG_SYS_MIPS_CACHE_MODE
-
-		Cache operation mode for the MIPS CPU.
-		See also arch/mips/include/asm/mipsregs.h.
-		Possible values are:
-			CONF_CM_CACHABLE_NO_WA
-			CONF_CM_CACHABLE_WA
-			CONF_CM_UNCACHED
-			CONF_CM_CACHABLE_NONCOHERENT
-			CONF_CM_CACHABLE_CE
-			CONF_CM_CACHABLE_COW
-			CONF_CM_CACHABLE_CUW
-			CONF_CM_CACHABLE_ACCELERATED
-
-		CONFIG_SYS_XWAY_EBU_BOOTCFG
-
-		Special option for Lantiq XWAY SoCs for booting from NOR flash.
-		See also arch/mips/cpu/mips32/start.S.
-
-		CONFIG_XWAY_SWAP_BYTES
-
-		Enable compilation of tools/xway-swap-bytes needed for Lantiq
-		XWAY SoCs for booting from NOR flash. The U-Boot image needs to
-		be swapped if a flash programmer is used.
-
-- ARM options:
-		CONFIG_SYS_EXCEPTION_VECTORS_HIGH
-
-		Select high exception vectors of the ARM core, e.g., do not
-		clear the V bit of the c1 register of CP15.
-
-		CONFIG_SYS_THUMB_BUILD
-
-		Use this flag to build U-Boot using the Thumb instruction
-		set for ARM architectures. Thumb instruction set provides
-		better code density. For ARM architectures that support
-		Thumb2 this flag will result in Thumb2 code generated by
-		GCC.
-
-		CONFIG_ARM_ERRATA_716044
-		CONFIG_ARM_ERRATA_742230
-		CONFIG_ARM_ERRATA_743622
-		CONFIG_ARM_ERRATA_751472
-		CONFIG_ARM_ERRATA_761320
-		CONFIG_ARM_ERRATA_773022
-		CONFIG_ARM_ERRATA_774769
-		CONFIG_ARM_ERRATA_794072
-
-		If set, the workarounds for these ARM errata are applied early
-		during U-Boot startup. Note that these options force the
-		workarounds to be applied; no CPU-type/version detection
-		exists, unlike the similar options in the Linux kernel. Do not
-		set these options unless they apply!
-
-		COUNTER_FREQUENCY
-		Generic timer clock source frequency.
-
-		COUNTER_FREQUENCY_REAL
-		Generic timer clock source frequency if the real clock is
-		different from COUNTER_FREQUENCY, and can only be determined
-		at run time.
-
-		NOTE: The following can be machine specific errata. These
-		do have ability to provide rudimentary version and machine
-		specific checks, but expect no product checks.
-		CONFIG_ARM_ERRATA_430973
-		CONFIG_ARM_ERRATA_454179
-		CONFIG_ARM_ERRATA_621766
-		CONFIG_ARM_ERRATA_798870
-		CONFIG_ARM_ERRATA_801819
-
-- Tegra SoC options:
-		CONFIG_TEGRA_SUPPORT_NON_SECURE
-
-		Support executing U-Boot in non-secure (NS) mode. Certain
-		impossible actions will be skipped if the CPU is in NS mode,
-		such as ARM architectural timer initialization.
-
-- Linux Kernel Interface:
-		CONFIG_CLOCKS_IN_MHZ
-
-		U-Boot stores all clock information in Hz
-		internally. For binary compatibility with older Linux
-		kernels (which expect the clocks passed in the
-		bd_info data to be in MHz) the environment variable
-		"clocks_in_mhz" can be defined so that U-Boot
-		converts clock data to MHZ before passing it to the
-		Linux kernel.
-		When CONFIG_CLOCKS_IN_MHZ is defined, a definition of
-		"clocks_in_mhz=1" is automatically included in the
-		default environment.
-
-		CONFIG_MEMSIZE_IN_BYTES		[relevant for MIPS only]
-
-		When transferring memsize parameter to Linux, some versions
-		expect it to be in bytes, others in MB.
-		Define CONFIG_MEMSIZE_IN_BYTES to make it in bytes.
-
-		CONFIG_OF_LIBFDT
-
-		New kernel versions are expecting firmware settings to be
-		passed using flattened device trees (based on open firmware
-		concepts).
-
-		CONFIG_OF_LIBFDT
-		 * New libfdt-based support
-		 * Adds the "fdt" command
-		 * The bootm command automatically updates the fdt
-
-		OF_CPU - The proper name of the cpus node (only required for
-			MPC512X and MPC5xxx based boards).
-		OF_SOC - The proper name of the soc node (only required for
-			MPC512X and MPC5xxx based boards).
-		OF_TBCLK - The timebase frequency.
-		OF_STDOUT_PATH - The path to the console device
-
-		boards with QUICC Engines require OF_QE to set UCC MAC
-		addresses
-
-		CONFIG_OF_BOARD_SETUP
-
-		Board code has addition modification that it wants to make
-		to the flat device tree before handing it off to the kernel
-
-		CONFIG_OF_SYSTEM_SETUP
-
-		Other code has addition modification that it wants to make
-		to the flat device tree before handing it off to the kernel.
-		This causes ft_system_setup() to be called before booting
-		the kernel.
-
-		CONFIG_OF_BOOT_CPU
-
-		This define fills in the correct boot CPU in the boot
-		param header, the default value is zero if undefined.
-
-		CONFIG_OF_IDE_FIXUP
-
-		U-Boot can detect if an IDE device is present or not.
-		If not, and this new config option is activated, U-Boot
-		removes the ATA node from the DTS before booting Linux,
-		so the Linux IDE driver does not probe the device and
-		crash. This is needed for buggy hardware (uc101) where
-		no pull down resistor is connected to the signal IDE5V_DD7.
-
-		CONFIG_MACH_TYPE	[relevant for ARM only][mandatory]
-
-		This setting is mandatory for all boards that have only one
-		machine type and must be used to specify the machine type
-		number as it appears in the ARM machine registry
-		(see http://www.arm.linux.org.uk/developer/machines/).
-		Only boards that have multiple machine types supported
-		in a single configuration file and the machine type is
-		runtime discoverable, do not have to use this setting.
-
-- vxWorks boot parameters:
-
-		bootvx constructs a valid bootline using the following
-		environments variables: bootdev, bootfile, ipaddr, netmask,
-		serverip, gatewayip, hostname, othbootargs.
-		It loads the vxWorks image pointed bootfile.
-
-		Note: If a "bootargs" environment is defined, it will overwride
-		the defaults discussed just above.
-
-- Cache Configuration:
-		CONFIG_SYS_ICACHE_OFF - Do not enable instruction cache in U-Boot
-		CONFIG_SYS_DCACHE_OFF - Do not enable data cache in U-Boot
-		CONFIG_SYS_L2CACHE_OFF- Do not enable L2 cache in U-Boot
-
-- Cache Configuration for ARM:
-		CONFIG_SYS_L2_PL310 - Enable support for ARM PL310 L2 cache
-				      controller
-		CONFIG_SYS_PL310_BASE - Physical base address of PL310
-					controller register space
-
-- Serial Ports:
-		CONFIG_PL010_SERIAL
-
-		Define this if you want support for Amba PrimeCell PL010 UARTs.
-
-		CONFIG_PL011_SERIAL
-
-		Define this if you want support for Amba PrimeCell PL011 UARTs.
-
-		CONFIG_PL011_CLOCK
-
-		If you have Amba PrimeCell PL011 UARTs, set this variable to
-		the clock speed of the UARTs.
-
-		CONFIG_PL01x_PORTS
-
-		If you have Amba PrimeCell PL010 or PL011 UARTs on your board,
-		define this to a list of base addresses for each (supported)
-		port. See e.g. include/configs/versatile.h
-
-		CONFIG_SERIAL_HW_FLOW_CONTROL
-
-		Define this variable to enable hw flow control in serial driver.
-		Current user of this option is drivers/serial/nsl16550.c driver
-
-- Console Interface:
-		Depending on board, define exactly one serial port
-		(like CONFIG_8xx_CONS_SMC1, CONFIG_8xx_CONS_SMC2,
-		CONFIG_8xx_CONS_SCC1, ...), or switch off the serial
-		console by defining CONFIG_8xx_CONS_NONE
-
-		Note: if CONFIG_8xx_CONS_NONE is defined, the serial
-		port routines must be defined elsewhere
-		(i.e. serial_init(), serial_getc(), ...)
-
-		CONFIG_CFB_CONSOLE
-		Enables console device for a color framebuffer. Needs following
-		defines (cf. smiLynxEM, i8042)
-			VIDEO_FB_LITTLE_ENDIAN	graphic memory organisation
-						(default big endian)
-			VIDEO_HW_RECTFILL	graphic chip supports
-						rectangle fill
-						(cf. smiLynxEM)
-			VIDEO_HW_BITBLT		graphic chip supports
-						bit-blit (cf. smiLynxEM)
-			VIDEO_VISIBLE_COLS	visible pixel columns
-						(cols=pitch)
-			VIDEO_VISIBLE_ROWS	visible pixel rows
-			VIDEO_PIXEL_SIZE	bytes per pixel
-			VIDEO_DATA_FORMAT	graphic data format
-						(0-5, cf. cfb_console.c)
-			VIDEO_FB_ADRS		framebuffer address
-			VIDEO_KBD_INIT_FCT	keyboard int fct
-						(i.e. rx51_kp_init())
-			VIDEO_TSTC_FCT		test char fct
-						(i.e. rx51_kp_tstc)
-			VIDEO_GETC_FCT		get char fct
-						(i.e. rx51_kp_getc)
-			CONFIG_VIDEO_LOGO	display Linux logo in
-						upper left corner
-			CONFIG_VIDEO_BMP_LOGO	use bmp_logo.h instead of
-						linux_logo.h for logo.
-						Requires CONFIG_VIDEO_LOGO
-			CONFIG_CONSOLE_EXTRA_INFO
-						additional board info beside
-						the logo
-
-		When CONFIG_CFB_CONSOLE_ANSI is defined, console will support
-		a limited number of ANSI escape sequences (cursor control,
-		erase functions and limited graphics rendition control).
-
-		When CONFIG_CFB_CONSOLE is defined, video console is
-		default i/o. Serial console can be forced with
-		environment 'console=serial'.
-
-		When CONFIG_SILENT_CONSOLE is defined, all console
-		messages (by U-Boot and Linux!) can be silenced with
-		the "silent" environment variable. See
-		doc/README.silent for more information.
-
-		CONFIG_SYS_CONSOLE_BG_COL: define the backgroundcolor, default
-			is 0x00.
-		CONFIG_SYS_CONSOLE_FG_COL: define the foregroundcolor, default
-			is 0xa0.
-
-- Console Baudrate:
-		CONFIG_BAUDRATE - in bps
-		Select one of the baudrates listed in
-		CONFIG_SYS_BAUDRATE_TABLE, see below.
-		CONFIG_SYS_BRGCLK_PRESCALE, baudrate prescale
-
-- Console Rx buffer length
-		With CONFIG_SYS_SMC_RXBUFLEN it is possible to define
-		the maximum receive buffer length for the SMC.
-		This option is actual only for 82xx and 8xx possible.
-		If using CONFIG_SYS_SMC_RXBUFLEN also CONFIG_SYS_MAXIDLE
-		must be defined, to setup the maximum idle timeout for
-		the SMC.
-
-- Pre-Console Buffer:
-		Prior to the console being initialised (i.e. serial UART
-		initialised etc) all console output is silently discarded.
-		Defining CONFIG_PRE_CONSOLE_BUFFER will cause U-Boot to
-		buffer any console messages prior to the console being
-		initialised to a buffer of size CONFIG_PRE_CON_BUF_SZ
-		bytes located at CONFIG_PRE_CON_BUF_ADDR. The buffer is
-		a circular buffer, so if more than CONFIG_PRE_CON_BUF_SZ
-		bytes are output before the console is initialised, the
-		earlier bytes are discarded.
-
-		Note that when printing the buffer a copy is made on the
-		stack so CONFIG_PRE_CON_BUF_SZ must fit on the stack.
-
-		'Sane' compilers will generate smaller code if
-		CONFIG_PRE_CON_BUF_SZ is a power of 2
-
-- Boot Delay:	CONFIG_BOOTDELAY - in seconds
-		Delay before automatically booting the default image;
-		set to -1 to disable autoboot.
-		set to -2 to autoboot with no delay and not check for abort
-		(even when CONFIG_ZERO_BOOTDELAY_CHECK is defined).
-
-		See doc/README.autoboot for these options that
-		work with CONFIG_BOOTDELAY. None are required.
-		CONFIG_BOOT_RETRY_TIME
-		CONFIG_BOOT_RETRY_MIN
-		CONFIG_AUTOBOOT_KEYED
-		CONFIG_AUTOBOOT_PROMPT
-		CONFIG_AUTOBOOT_DELAY_STR
-		CONFIG_AUTOBOOT_STOP_STR
-		CONFIG_ZERO_BOOTDELAY_CHECK
-		CONFIG_RESET_TO_RETRY
-
-- Autoboot Command:
-		CONFIG_BOOTCOMMAND
-		Only needed when CONFIG_BOOTDELAY is enabled;
-		define a command string that is automatically executed
-		when no character is read on the console interface
-		within "Boot Delay" after reset.
-
-		CONFIG_BOOTARGS
-		This can be used to pass arguments to the bootm
-		command. The value of CONFIG_BOOTARGS goes into the
-		environment value "bootargs".
-
-		CONFIG_RAMBOOT and CONFIG_NFSBOOT
-		The value of these goes into the environment as
-		"ramboot" and "nfsboot" respectively, and can be used
-		as a convenience, when switching between booting from
-		RAM and NFS.
-
-- Bootcount:
-		CONFIG_BOOTCOUNT_LIMIT
-		Implements a mechanism for detecting a repeating reboot
-		cycle, see:
-		http://www.denx.de/wiki/view/DULG/UBootBootCountLimit
-
-		CONFIG_BOOTCOUNT_ENV
-		If no softreset save registers are found on the hardware
-		"bootcount" is stored in the environment. To prevent a
-		saveenv on all reboots, the environment variable
-		"upgrade_available" is used. If "upgrade_available" is
-		0, "bootcount" is always 0, if "upgrade_available" is
-		1 "bootcount" is incremented in the environment.
-		So the Userspace Applikation must set the "upgrade_available"
-		and "bootcount" variable to 0, if a boot was successfully.
-
-- Pre-Boot Commands:
-		CONFIG_PREBOOT
-
-		When this option is #defined, the existence of the
-		environment variable "preboot" will be checked
-		immediately before starting the CONFIG_BOOTDELAY
-		countdown and/or running the auto-boot command resp.
-		entering interactive mode.
-
-		This feature is especially useful when "preboot" is
-		automatically generated or modified. For an example
-		see the LWMON board specific code: here "preboot" is
-		modified when the user holds down a certain
-		combination of keys on the (special) keyboard when
-		booting the systems
-
-- Serial Download Echo Mode:
-		CONFIG_LOADS_ECHO
-		If defined to 1, all characters received during a
-		serial download (using the "loads" command) are
-		echoed back. This might be needed by some terminal
-		emulations (like "cu"), but may as well just take
-		time on others. This setting #define's the initial
-		value of the "loads_echo" environment variable.
-
-- Kgdb Serial Baudrate: (if CONFIG_CMD_KGDB is defined)
-		CONFIG_KGDB_BAUDRATE
-		Select one of the baudrates listed in
-		CONFIG_SYS_BAUDRATE_TABLE, see below.
-
-- Monitor Functions:
-		Monitor commands can be included or excluded
-		from the build by using the #include files
-		<config_cmd_all.h> and #undef'ing unwanted
-		commands, or adding #define's for wanted commands.
-
-		The default command configuration includes all commands
-		except those marked below with a "*".
-
-		CONFIG_CMD_AES		  AES 128 CBC encrypt/decrypt
-		CONFIG_CMD_ASKENV	* ask for env variable
-		CONFIG_CMD_BDI		  bdinfo
-		CONFIG_CMD_BEDBUG	* Include BedBug Debugger
-		CONFIG_CMD_BMP		* BMP support
-		CONFIG_CMD_BSP		* Board specific commands
-		CONFIG_CMD_BOOTD	  bootd
-		CONFIG_CMD_BOOTI	* ARM64 Linux kernel Image support
-		CONFIG_CMD_CACHE	* icache, dcache
-		CONFIG_CMD_CLK   	* clock command support
-		CONFIG_CMD_CONSOLE	  coninfo
-		CONFIG_CMD_CRC32	* crc32
-		CONFIG_CMD_DATE		* support for RTC, date/time...
-		CONFIG_CMD_DHCP		* DHCP support
-		CONFIG_CMD_DIAG		* Diagnostics
-		CONFIG_CMD_DS4510	* ds4510 I2C gpio commands
-		CONFIG_CMD_DS4510_INFO	* ds4510 I2C info command
-		CONFIG_CMD_DS4510_MEM	* ds4510 I2C eeprom/sram commansd
-		CONFIG_CMD_DS4510_RST	* ds4510 I2C rst command
-		CONFIG_CMD_DTT		* Digital Therm and Thermostat
-		CONFIG_CMD_ECHO		  echo arguments
-		CONFIG_CMD_EDITENV	  edit env variable
-		CONFIG_CMD_EEPROM	* EEPROM read/write support
-		CONFIG_CMD_ELF		* bootelf, bootvx
-		CONFIG_CMD_ENV_CALLBACK	* display details about env callbacks
-		CONFIG_CMD_ENV_FLAGS	* display details about env flags
-		CONFIG_CMD_ENV_EXISTS	* check existence of env variable
-		CONFIG_CMD_EXPORTENV	* export the environment
-		CONFIG_CMD_EXT2		* ext2 command support
-		CONFIG_CMD_EXT4		* ext4 command support
-		CONFIG_CMD_FS_GENERIC	* filesystem commands (e.g. load, ls)
-					  that work for multiple fs types
-		CONFIG_CMD_FS_UUID	* Look up a filesystem UUID
-		CONFIG_CMD_SAVEENV	  saveenv
-		CONFIG_CMD_FDC		* Floppy Disk Support
-		CONFIG_CMD_FAT		* FAT command support
-		CONFIG_CMD_FLASH	  flinfo, erase, protect
-		CONFIG_CMD_FPGA		  FPGA device initialization support
-		CONFIG_CMD_FUSE		* Device fuse support
-		CONFIG_CMD_GETTIME	* Get time since boot
-		CONFIG_CMD_GO		* the 'go' command (exec code)
-		CONFIG_CMD_GREPENV	* search environment
-		CONFIG_CMD_HASH		* calculate hash / digest
-		CONFIG_CMD_I2C		* I2C serial bus support
-		CONFIG_CMD_IDE		* IDE harddisk support
-		CONFIG_CMD_IMI		  iminfo
-		CONFIG_CMD_IMLS		  List all images found in NOR flash
-		CONFIG_CMD_IMLS_NAND	* List all images found in NAND flash
-		CONFIG_CMD_IMMAP	* IMMR dump support
-		CONFIG_CMD_IOTRACE	* I/O tracing for debugging
-		CONFIG_CMD_IMPORTENV	* import an environment
-		CONFIG_CMD_INI		* import data from an ini file into the env
-		CONFIG_CMD_IRQ		* irqinfo
-		CONFIG_CMD_ITEST	  Integer/string test of 2 values
-		CONFIG_CMD_JFFS2	* JFFS2 Support
-		CONFIG_CMD_KGDB		* kgdb
-		CONFIG_CMD_LDRINFO	* ldrinfo (display Blackfin loader)
-		CONFIG_CMD_LINK_LOCAL	* link-local IP address auto-configuration
-					  (169.254.*.*)
-		CONFIG_CMD_LOADB	  loadb
-		CONFIG_CMD_LOADS	  loads
-		CONFIG_CMD_MD5SUM	* print md5 message digest
-					  (requires CONFIG_CMD_MEMORY and CONFIG_MD5)
-		CONFIG_CMD_MEMINFO	* Display detailed memory information
-		CONFIG_CMD_MEMORY	  md, mm, nm, mw, cp, cmp, crc, base,
-					  loop, loopw
-		CONFIG_CMD_MEMTEST	* mtest
-		CONFIG_CMD_MISC		  Misc functions like sleep etc
-		CONFIG_CMD_MMC		* MMC memory mapped support
-		CONFIG_CMD_MII		* MII utility commands
-		CONFIG_CMD_MTDPARTS	* MTD partition support
-		CONFIG_CMD_NAND		* NAND support
-		CONFIG_CMD_NET		  bootp, tftpboot, rarpboot
-		CONFIG_CMD_NFS		  NFS support
-		CONFIG_CMD_PCA953X	* PCA953x I2C gpio commands
-		CONFIG_CMD_PCA953X_INFO * PCA953x I2C gpio info command
-		CONFIG_CMD_PCI		* pciinfo
-		CONFIG_CMD_PCMCIA		* PCMCIA support
-		CONFIG_CMD_PING		* send ICMP ECHO_REQUEST to network
-					  host
-		CONFIG_CMD_PORTIO	* Port I/O
-		CONFIG_CMD_READ		* Read raw data from partition
-		CONFIG_CMD_REGINFO	* Register dump
-		CONFIG_CMD_RUN		  run command in env variable
-		CONFIG_CMD_SANDBOX	* sb command to access sandbox features
-		CONFIG_CMD_SAVES	* save S record dump
-		CONFIG_CMD_SCSI		* SCSI Support
-		CONFIG_CMD_SDRAM	* print SDRAM configuration information
-					  (requires CONFIG_CMD_I2C)
-		CONFIG_CMD_SETGETDCR	  Support for DCR Register access
-					  (4xx only)
-		CONFIG_CMD_SF		* Read/write/erase SPI NOR flash
-		CONFIG_CMD_SHA1SUM	* print sha1 memory digest
-					  (requires CONFIG_CMD_MEMORY)
-		CONFIG_CMD_SOFTSWITCH	* Soft switch setting command for BF60x
-		CONFIG_CMD_SOURCE	  "source" command Support
-		CONFIG_CMD_SPI		* SPI serial bus support
-		CONFIG_CMD_TFTPSRV	* TFTP transfer in server mode
-		CONFIG_CMD_TFTPPUT	* TFTP put command (upload)
-		CONFIG_CMD_TIME		* run command and report execution time (ARM specific)
-		CONFIG_CMD_TIMER	* access to the system tick timer
-		CONFIG_CMD_USB		* USB support
-		CONFIG_CMD_CDP		* Cisco Discover Protocol support
-		CONFIG_CMD_MFSL		* Microblaze FSL support
-		CONFIG_CMD_XIMG		  Load part of Multi Image
-		CONFIG_CMD_UUID		* Generate random UUID or GUID string
-
-		EXAMPLE: If you want all functions except of network
-		support you can write:
-
-		#include "config_cmd_all.h"
-		#undef CONFIG_CMD_NET
-
-	Other Commands:
-		fdt (flattened device tree) command: CONFIG_OF_LIBFDT
-
-	Note:	Don't enable the "icache" and "dcache" commands
-		(configuration option CONFIG_CMD_CACHE) unless you know
-		what you (and your U-Boot users) are doing. Data
-		cache cannot be enabled on systems like the 8xx or
-		8260 (where accesses to the IMMR region must be
-		uncached), and it cannot be disabled on all other
-		systems where we (mis-) use the data cache to hold an
-		initial stack and some data.
-
-
-		XXX - this list needs to get updated!
-
-- Regular expression support:
-		CONFIG_REGEX
-		If this variable is defined, U-Boot is linked against
-		the SLRE (Super Light Regular Expression) library,
-		which adds regex support to some commands, as for
-		example "env grep" and "setexpr".
-
-- Device tree:
-		CONFIG_OF_CONTROL
-		If this variable is defined, U-Boot will use a device tree
-		to configure its devices, instead of relying on statically
-		compiled #defines in the board file. This option is
-		experimental and only available on a few boards. The device
-		tree is available in the global data as gd->fdt_blob.
-
-		U-Boot needs to get its device tree from somewhere. This can
-		be done using one of the two options below:
-
-		CONFIG_OF_EMBED
-		If this variable is defined, U-Boot will embed a device tree
-		binary in its image. This device tree file should be in the
-		board directory and called <soc>-<board>.dts. The binary file
-		is then picked up in board_init_f() and made available through
-		the global data structure as gd->blob.
-
-		CONFIG_OF_SEPARATE
-		If this variable is defined, U-Boot will build a device tree
-		binary. It will be called u-boot.dtb. Architecture-specific
-		code will locate it at run-time. Generally this works by:
-
-			cat u-boot.bin u-boot.dtb >image.bin
-
-		and in fact, U-Boot does this for you, creating a file called
-		u-boot-dtb.bin which is useful in the common case. You can
-		still use the individual files if you need something more
-		exotic.
-
-- Watchdog:
-		CONFIG_WATCHDOG
-		If this variable is defined, it enables watchdog
-		support for the SoC. There must be support in the SoC
-		specific code for a watchdog. For the 8xx and 8260
-		CPUs, the SIU Watchdog feature is enabled in the SYPCR
-		register.  When supported for a specific SoC is
-		available, then no further board specific code should
-		be needed to use it.
-
-		CONFIG_HW_WATCHDOG
-		When using a watchdog circuitry external to the used
-		SoC, then define this variable and provide board
-		specific code for the "hw_watchdog_reset" function.
-
-		CONFIG_AT91_HW_WDT_TIMEOUT
-		specify the timeout in seconds. default 2 seconds.
-
-- U-Boot Version:
-		CONFIG_VERSION_VARIABLE
-		If this variable is defined, an environment variable
-		named "ver" is created by U-Boot showing the U-Boot
-		version as printed by the "version" command.
-		Any change to this variable will be reverted at the
-		next reset.
-
-- Real-Time Clock:
-
-		When CONFIG_CMD_DATE is selected, the type of the RTC
-		has to be selected, too. Define exactly one of the
-		following options:
-
-		CONFIG_RTC_MPC8xx	- use internal RTC of MPC8xx
-		CONFIG_RTC_PCF8563	- use Philips PCF8563 RTC
-		CONFIG_RTC_MC13XXX	- use MC13783 or MC13892 RTC
-		CONFIG_RTC_MC146818	- use MC146818 RTC
-		CONFIG_RTC_DS1307	- use Maxim, Inc. DS1307 RTC
-		CONFIG_RTC_DS1337	- use Maxim, Inc. DS1337 RTC
-		CONFIG_RTC_DS1338	- use Maxim, Inc. DS1338 RTC
-		CONFIG_RTC_DS1339	- use Maxim, Inc. DS1339 RTC
-		CONFIG_RTC_DS164x	- use Dallas DS164x RTC
-		CONFIG_RTC_ISL1208	- use Intersil ISL1208 RTC
-		CONFIG_RTC_MAX6900	- use Maxim, Inc. MAX6900 RTC
-		CONFIG_SYS_RTC_DS1337_NOOSC	- Turn off the OSC output for DS1337
-		CONFIG_SYS_RV3029_TCR	- enable trickle charger on
-					  RV3029 RTC.
-
-		Note that if the RTC uses I2C, then the I2C interface
-		must also be configured. See I2C Support, below.
-
-- GPIO Support:
-		CONFIG_PCA953X		- use NXP's PCA953X series I2C GPIO
-
-		The CONFIG_SYS_I2C_PCA953X_WIDTH option specifies a list of
-		chip-ngpio pairs that tell the PCA953X driver the number of
-		pins supported by a particular chip.
-
-		Note that if the GPIO device uses I2C, then the I2C interface
-		must also be configured. See I2C Support, below.
-
-- I/O tracing:
-		When CONFIG_IO_TRACE is selected, U-Boot intercepts all I/O
-		accesses and can checksum them or write a list of them out
-		to memory. See the 'iotrace' command for details. This is
-		useful for testing device drivers since it can confirm that
-		the driver behaves the same way before and after a code
-		change. Currently this is supported on sandbox and arm. To
-		add support for your architecture, add '#include <iotrace.h>'
-		to the bottom of arch/<arch>/include/asm/io.h and test.
-
-		Example output from the 'iotrace stats' command is below.
-		Note that if the trace buffer is exhausted, the checksum will
-		still continue to operate.
-
-			iotrace is enabled
-			Start:  10000000	(buffer start address)
-			Size:   00010000	(buffer size)
-			Offset: 00000120	(current buffer offset)
-			Output: 10000120	(start + offset)
-			Count:  00000018	(number of trace records)
-			CRC32:  9526fb66	(CRC32 of all trace records)
-
-- Timestamp Support:
-
-		When CONFIG_TIMESTAMP is selected, the timestamp
-		(date and time) of an image is printed by image
-		commands like bootm or iminfo. This option is
-		automatically enabled when you select CONFIG_CMD_DATE .
-
-- Partition Labels (disklabels) Supported:
-		Zero or more of the following:
-		CONFIG_MAC_PARTITION   Apple's MacOS partition table.
-		CONFIG_DOS_PARTITION   MS Dos partition table, traditional on the
-				       Intel architecture, USB sticks, etc.
-		CONFIG_ISO_PARTITION   ISO partition table, used on CDROM etc.
-		CONFIG_EFI_PARTITION   GPT partition table, common when EFI is the
-				       bootloader.  Note 2TB partition limit; see
-				       disk/part_efi.c
-		CONFIG_MTD_PARTITIONS  Memory Technology Device partition table.
-
-		If IDE or SCSI support is enabled (CONFIG_CMD_IDE or
-		CONFIG_CMD_SCSI) you must configure support for at
-		least one non-MTD partition type as well.
-
-- IDE Reset method:
-		CONFIG_IDE_RESET_ROUTINE - this is defined in several
-		board configurations files but used nowhere!
-
-		CONFIG_IDE_RESET - is this is defined, IDE Reset will
-		be performed by calling the function
-			ide_set_reset(int reset)
-		which has to be defined in a board specific file
-
-- ATAPI Support:
-		CONFIG_ATAPI
-
-		Set this to enable ATAPI support.
-
-- LBA48 Support
-		CONFIG_LBA48
-
-		Set this to enable support for disks larger than 137GB
-		Also look at CONFIG_SYS_64BIT_LBA.
-		Whithout these , LBA48 support uses 32bit variables and will 'only'
-		support disks up to 2.1TB.
-
-		CONFIG_SYS_64BIT_LBA:
-			When enabled, makes the IDE subsystem use 64bit sector addresses.
-			Default is 32bit.
-
-- SCSI Support:
-		At the moment only there is only support for the
-		SYM53C8XX SCSI controller; define
-		CONFIG_SCSI_SYM53C8XX to enable it.
-
-		CONFIG_SYS_SCSI_MAX_LUN [8], CONFIG_SYS_SCSI_MAX_SCSI_ID [7] and
-		CONFIG_SYS_SCSI_MAX_DEVICE [CONFIG_SYS_SCSI_MAX_SCSI_ID *
-		CONFIG_SYS_SCSI_MAX_LUN] can be adjusted to define the
-		maximum numbers of LUNs, SCSI ID's and target
-		devices.
-		CONFIG_SYS_SCSI_SYM53C8XX_CCF to fix clock timing (80Mhz)
-
-		The environment variable 'scsidevs' is set to the number of
-		SCSI devices found during the last scan.
-
-- NETWORK Support (PCI):
-		CONFIG_E1000
-		Support for Intel 8254x/8257x gigabit chips.
-
-		CONFIG_E1000_SPI
-		Utility code for direct access to the SPI bus on Intel 8257x.
-		This does not do anything useful unless you set at least one
-		of CONFIG_CMD_E1000 or CONFIG_E1000_SPI_GENERIC.
-
-		CONFIG_E1000_SPI_GENERIC
-		Allow generic access to the SPI bus on the Intel 8257x, for
-		example with the "sspi" command.
-
-		CONFIG_CMD_E1000
-		Management command for E1000 devices.  When used on devices
-		with SPI support you can reprogram the EEPROM from U-Boot.
-
-		CONFIG_EEPRO100
-		Support for Intel 82557/82559/82559ER chips.
-		Optional CONFIG_EEPRO100_SROM_WRITE enables EEPROM
-		write routine for first time initialisation.
-
-		CONFIG_TULIP
-		Support for Digital 2114x chips.
-		Optional CONFIG_TULIP_SELECT_MEDIA for board specific
-		modem chip initialisation (KS8761/QS6611).
-
-		CONFIG_NATSEMI
-		Support for National dp83815 chips.
-
-		CONFIG_NS8382X
-		Support for National dp8382[01] gigabit chips.
-
-- NETWORK Support (other):
-
-		CONFIG_DRIVER_AT91EMAC
-		Support for AT91RM9200 EMAC.
-
-			CONFIG_RMII
-			Define this to use reduced MII inteface
-
-			CONFIG_DRIVER_AT91EMAC_QUIET
-			If this defined, the driver is quiet.
-			The driver doen't show link status messages.
-
-		CONFIG_CALXEDA_XGMAC
-		Support for the Calxeda XGMAC device
-
-		CONFIG_LAN91C96
-		Support for SMSC's LAN91C96 chips.
-
-			CONFIG_LAN91C96_BASE
-			Define this to hold the physical address
-			of the LAN91C96's I/O space
-
-			CONFIG_LAN91C96_USE_32_BIT
-			Define this to enable 32 bit addressing
-
-		CONFIG_SMC91111
-		Support for SMSC's LAN91C111 chip
-
-			CONFIG_SMC91111_BASE
-			Define this to hold the physical address
-			of the device (I/O space)
-
-			CONFIG_SMC_USE_32_BIT
-			Define this if data bus is 32 bits
-
-			CONFIG_SMC_USE_IOFUNCS
-			Define this to use i/o functions instead of macros
-			(some hardware wont work with macros)
-
-		CONFIG_DRIVER_TI_EMAC
-		Support for davinci emac
-
-			CONFIG_SYS_DAVINCI_EMAC_PHY_COUNT
-			Define this if you have more then 3 PHYs.
-
-		CONFIG_FTGMAC100
-		Support for Faraday's FTGMAC100 Gigabit SoC Ethernet
-
-			CONFIG_FTGMAC100_EGIGA
-			Define this to use GE link update with gigabit PHY.
-			Define this if FTGMAC100 is connected to gigabit PHY.
-			If your system has 10/100 PHY only, it might not occur
-			wrong behavior. Because PHY usually return timeout or
-			useless data when polling gigabit status and gigabit
-			control registers. This behavior won't affect the
-			correctnessof 10/100 link speed update.
-
-		CONFIG_SMC911X
-		Support for SMSC's LAN911x and LAN921x chips
-
-			CONFIG_SMC911X_BASE
-			Define this to hold the physical address
-			of the device (I/O space)
-
-			CONFIG_SMC911X_32_BIT
-			Define this if data bus is 32 bits
-
-			CONFIG_SMC911X_16_BIT
-			Define this if data bus is 16 bits. If your processor
-			automatically converts one 32 bit word to two 16 bit
-			words you may also try CONFIG_SMC911X_32_BIT.
-
-		CONFIG_SH_ETHER
-		Support for Renesas on-chip Ethernet controller
-
-			CONFIG_SH_ETHER_USE_PORT
-			Define the number of ports to be used
-
-			CONFIG_SH_ETHER_PHY_ADDR
-			Define the ETH PHY's address
-
-			CONFIG_SH_ETHER_CACHE_WRITEBACK
-			If this option is set, the driver enables cache flush.
-
-- PWM Support:
-		CONFIG_PWM_IMX
-		Support for PWM modul on the imx6.
-
-- TPM Support:
-		CONFIG_TPM
-		Support TPM devices.
-
-		CONFIG_TPM_TIS_INFINEON
-		Support for Infineon i2c bus TPM devices. Only one device
-		per system is supported at this time.
-
-			CONFIG_TPM_TIS_I2C_BURST_LIMITATION
-			Define the burst count bytes upper limit
-
-		CONFIG_TPM_ST33ZP24
-		Support for STMicroelectronics TPM devices. Requires DM_TPM support.
-
-			CONFIG_TPM_ST33ZP24_I2C
-			Support for STMicroelectronics ST33ZP24 I2C devices.
-			Requires TPM_ST33ZP24 and I2C.
-
-			CONFIG_TPM_ST33ZP24_SPI
-			Support for STMicroelectronics ST33ZP24 SPI devices.
-			Requires TPM_ST33ZP24 and SPI.
-
-		CONFIG_TPM_ATMEL_TWI
-		Support for Atmel TWI TPM device. Requires I2C support.
-
-		CONFIG_TPM_TIS_LPC
-		Support for generic parallel port TPM devices. Only one device
-		per system is supported at this time.
-
-			CONFIG_TPM_TIS_BASE_ADDRESS
-			Base address where the generic TPM device is mapped
-			to. Contemporary x86 systems usually map it at
-			0xfed40000.
-
-		CONFIG_CMD_TPM
-		Add tpm monitor functions.
-		Requires CONFIG_TPM. If CONFIG_TPM_AUTH_SESSIONS is set, also
-		provides monitor access to authorized functions.
-
-		CONFIG_TPM
-		Define this to enable the TPM support library which provides
-		functional interfaces to some TPM commands.
-		Requires support for a TPM device.
-
-		CONFIG_TPM_AUTH_SESSIONS
-		Define this to enable authorized functions in the TPM library.
-		Requires CONFIG_TPM and CONFIG_SHA1.
-
-- USB Support:
-		At the moment only the UHCI host controller is
-		supported (PIP405, MIP405, MPC5200); define
-		CONFIG_USB_UHCI to enable it.
-		define CONFIG_USB_KEYBOARD to enable the USB Keyboard
-		and define CONFIG_USB_STORAGE to enable the USB
-		storage devices.
-		Note:
-		Supported are USB Keyboards and USB Floppy drives
-		(TEAC FD-05PUB).
-		MPC5200 USB requires additional defines:
-			CONFIG_USB_CLOCK
-				for 528 MHz Clock: 0x0001bbbb
-			CONFIG_PSC3_USB
-				for USB on PSC3
-			CONFIG_USB_CONFIG
-				for differential drivers: 0x00001000
-				for single ended drivers: 0x00005000
-				for differential drivers on PSC3: 0x00000100
-				for single ended drivers on PSC3: 0x00004100
-			CONFIG_SYS_USB_EVENT_POLL
-				May be defined to allow interrupt polling
-				instead of using asynchronous interrupts
-
-		CONFIG_USB_EHCI_TXFIFO_THRESH enables setting of the
-		txfilltuning field in the EHCI controller on reset.
-
-		CONFIG_USB_DWC2_REG_ADDR the physical CPU address of the DWC2
-		HW module registers.
-
-- USB Device:
-		Define the below if you wish to use the USB console.
-		Once firmware is rebuilt from a serial console issue the
-		command "setenv stdin usbtty; setenv stdout usbtty" and
-		attach your USB cable. The Unix command "dmesg" should print
-		it has found a new device. The environment variable usbtty
-		can be set to gserial or cdc_acm to enable your device to
-		appear to a USB host as a Linux gserial device or a
-		Common Device Class Abstract Control Model serial device.
-		If you select usbtty = gserial you should be able to enumerate
-		a Linux host by
-		# modprobe usbserial vendor=0xVendorID product=0xProductID
-		else if using cdc_acm, simply setting the environment
-		variable usbtty to be cdc_acm should suffice. The following
-		might be defined in YourBoardName.h
-
-			CONFIG_USB_DEVICE
-			Define this to build a UDC device
-
-			CONFIG_USB_TTY
-			Define this to have a tty type of device available to
-			talk to the UDC device
-
-			CONFIG_USBD_HS
-			Define this to enable the high speed support for usb
-			device and usbtty. If this feature is enabled, a routine
-			int is_usbd_high_speed(void)
-			also needs to be defined by the driver to dynamically poll
-			whether the enumeration has succeded at high speed or full
-			speed.
-
-			CONFIG_SYS_CONSOLE_IS_IN_ENV
-			Define this if you want stdin, stdout &/or stderr to
-			be set to usbtty.
-
-			mpc8xx:
-				CONFIG_SYS_USB_EXTC_CLK 0xBLAH
-				Derive USB clock from external clock "blah"
-				- CONFIG_SYS_USB_EXTC_CLK 0x02
-
-				CONFIG_SYS_USB_BRG_CLK 0xBLAH
-				Derive USB clock from brgclk
-				- CONFIG_SYS_USB_BRG_CLK 0x04
-
-		If you have a USB-IF assigned VendorID then you may wish to
-		define your own vendor specific values either in BoardName.h
-		or directly in usbd_vendor_info.h. If you don't define
-		CONFIG_USBD_MANUFACTURER, CONFIG_USBD_PRODUCT_NAME,
-		CONFIG_USBD_VENDORID and CONFIG_USBD_PRODUCTID, then U-Boot
-		should pretend to be a Linux device to it's target host.
-
-			CONFIG_USBD_MANUFACTURER
-			Define this string as the name of your company for
-			- CONFIG_USBD_MANUFACTURER "my company"
-
-			CONFIG_USBD_PRODUCT_NAME
-			Define this string as the name of your product
-			- CONFIG_USBD_PRODUCT_NAME "acme usb device"
-
-			CONFIG_USBD_VENDORID
-			Define this as your assigned Vendor ID from the USB
-			Implementors Forum. This *must* be a genuine Vendor ID
-			to avoid polluting the USB namespace.
-			- CONFIG_USBD_VENDORID 0xFFFF
-
-			CONFIG_USBD_PRODUCTID
-			Define this as the unique Product ID
-			for your device
-			- CONFIG_USBD_PRODUCTID 0xFFFF
-
-- ULPI Layer Support:
-		The ULPI (UTMI Low Pin (count) Interface) PHYs are supported via
-		the generic ULPI layer. The generic layer accesses the ULPI PHY
-		via the platform viewport, so you need both the genric layer and
-		the viewport enabled. Currently only Chipidea/ARC based
-		viewport is supported.
-		To enable the ULPI layer support, define CONFIG_USB_ULPI and
-		CONFIG_USB_ULPI_VIEWPORT in your board configuration file.
-		If your ULPI phy needs a different reference clock than the
-		standard 24 MHz then you have to define CONFIG_ULPI_REF_CLK to
-		the appropriate value in Hz.
-
-- MMC Support:
-		The MMC controller on the Intel PXA is supported. To
-		enable this define CONFIG_MMC. The MMC can be
-		accessed from the boot prompt by mapping the device
-		to physical memory similar to flash. Command line is
-		enabled with CONFIG_CMD_MMC. The MMC driver also works with
-		the FAT fs. This is enabled with CONFIG_CMD_FAT.
-
-		CONFIG_SH_MMCIF
-		Support for Renesas on-chip MMCIF controller
-
-			CONFIG_SH_MMCIF_ADDR
-			Define the base address of MMCIF registers
-
-			CONFIG_SH_MMCIF_CLK
-			Define the clock frequency for MMCIF
-
-		CONFIG_GENERIC_MMC
-		Enable the generic MMC driver
-
-		CONFIG_SUPPORT_EMMC_BOOT
-		Enable some additional features of the eMMC boot partitions.
-
-		CONFIG_SUPPORT_EMMC_RPMB
-		Enable the commands for reading, writing and programming the
-		key for the Replay Protection Memory Block partition in eMMC.
-
-- USB Device Firmware Update (DFU) class support:
-		CONFIG_USB_FUNCTION_DFU
-		This enables the USB portion of the DFU USB class
-
-		CONFIG_CMD_DFU
-		This enables the command "dfu" which is used to have
-		U-Boot create a DFU class device via USB.  This command
-		requires that the "dfu_alt_info" environment variable be
-		set and define the alt settings to expose to the host.
-
-		CONFIG_DFU_MMC
-		This enables support for exposing (e)MMC devices via DFU.
-
-		CONFIG_DFU_NAND
-		This enables support for exposing NAND devices via DFU.
-
-		CONFIG_DFU_RAM
-		This enables support for exposing RAM via DFU.
-		Note: DFU spec refer to non-volatile memory usage, but
-		allow usages beyond the scope of spec - here RAM usage,
-		one that would help mostly the developer.
-
-		CONFIG_SYS_DFU_DATA_BUF_SIZE
-		Dfu transfer uses a buffer before writing data to the
-		raw storage device. Make the size (in bytes) of this buffer
-		configurable. The size of this buffer is also configurable
-		through the "dfu_bufsiz" environment variable.
-
-		CONFIG_SYS_DFU_MAX_FILE_SIZE
-		When updating files rather than the raw storage device,
-		we use a static buffer to copy the file into and then write
-		the buffer once we've been given the whole file.  Define
-		this to the maximum filesize (in bytes) for the buffer.
-		Default is 4 MiB if undefined.
-
-		DFU_DEFAULT_POLL_TIMEOUT
-		Poll timeout [ms], is the timeout a device can send to the
-		host. The host must wait for this timeout before sending
-		a subsequent DFU_GET_STATUS request to the device.
-
-		DFU_MANIFEST_POLL_TIMEOUT
-		Poll timeout [ms], which the device sends to the host when
-		entering dfuMANIFEST state. Host waits this timeout, before
-		sending again an USB request to the device.
-
-- USB Device Android Fastboot support:
-		CONFIG_USB_FUNCTION_FASTBOOT
-		This enables the USB part of the fastboot gadget
-
-		CONFIG_CMD_FASTBOOT
-		This enables the command "fastboot" which enables the Android
-		fastboot mode for the platform's USB device. Fastboot is a USB
-		protocol for downloading images, flashing and device control
-		used on Android devices.
-		See doc/README.android-fastboot for more information.
-
-		CONFIG_ANDROID_BOOT_IMAGE
-		This enables support for booting images which use the Android
-		image format header.
-
-		CONFIG_FASTBOOT_BUF_ADDR
-		The fastboot protocol requires a large memory buffer for
-		downloads. Define this to the starting RAM address to use for
-		downloaded images.
-
-		CONFIG_FASTBOOT_BUF_SIZE
-		The fastboot protocol requires a large memory buffer for
-		downloads. This buffer should be as large as possible for a
-		platform. Define this to the size available RAM for fastboot.
-
-		CONFIG_FASTBOOT_FLASH
-		The fastboot protocol includes a "flash" command for writing
-		the downloaded image to a non-volatile storage device. Define
-		this to enable the "fastboot flash" command.
-
-		CONFIG_FASTBOOT_FLASH_MMC_DEV
-		The fastboot "flash" command requires additional information
-		regarding the non-volatile storage device. Define this to
-		the eMMC device that fastboot should use to store the image.
-
-		CONFIG_FASTBOOT_GPT_NAME
-		The fastboot "flash" command supports writing the downloaded
-		image to the Protective MBR and the Primary GUID Partition
-		Table. (Additionally, this downloaded image is post-processed
-		to generate and write the Backup GUID Partition Table.)
-		This occurs when the specified "partition name" on the
-		"fastboot flash" command line matches this value.
-		Default is GPT_ENTRY_NAME (currently "gpt") if undefined.
-
-- Journaling Flash filesystem support:
-		CONFIG_JFFS2_NAND, CONFIG_JFFS2_NAND_OFF, CONFIG_JFFS2_NAND_SIZE,
-		CONFIG_JFFS2_NAND_DEV
-		Define these for a default partition on a NAND device
-
-		CONFIG_SYS_JFFS2_FIRST_SECTOR,
-		CONFIG_SYS_JFFS2_FIRST_BANK, CONFIG_SYS_JFFS2_NUM_BANKS
-		Define these for a default partition on a NOR device
-
-		CONFIG_SYS_JFFS_CUSTOM_PART
-		Define this to create an own partition. You have to provide a
-		function struct part_info* jffs2_part_info(int part_num)
-
-		If you define only one JFFS2 partition you may also want to
-		#define CONFIG_SYS_JFFS_SINGLE_PART	1
-		to disable the command chpart. This is the default when you
-		have not defined a custom partition
-
-- FAT(File Allocation Table) filesystem write function support:
-		CONFIG_FAT_WRITE
-
-		Define this to enable support for saving memory data as a
-		file in FAT formatted partition.
-
-		This will also enable the command "fatwrite" enabling the
-		user to write files to FAT.
-
-CBFS (Coreboot Filesystem) support
-		CONFIG_CMD_CBFS
-
-		Define this to enable support for reading from a Coreboot
-		filesystem. Available commands are cbfsinit, cbfsinfo, cbfsls
-		and cbfsload.
-
-- FAT(File Allocation Table) filesystem cluster size:
-		CONFIG_FS_FAT_MAX_CLUSTSIZE
-
-		Define the max cluster size for fat operations else
-		a default value of 65536 will be defined.
-
-- Keyboard Support:
-		See Kconfig help for available keyboard drivers.
-
-		CONFIG_KEYBOARD
-
-		Define this to enable a custom keyboard support.
-		This simply calls drv_keyboard_init() which must be
-		defined in your board-specific files. This option is deprecated
-		and is only used by novena. For new boards, use driver model
-		instead.
-
-- Video support:
-		CONFIG_VIDEO
-
-		Define this to enable video support (for output to
-		video).
-
-		CONFIG_VIDEO_CT69000
-
-		Enable Chips & Technologies 69000 Video chip
-
-		CONFIG_VIDEO_SMI_LYNXEM
-		Enable Silicon Motion SMI 712/710/810 Video chip. The
-		video output is selected via environment 'videoout'
-		(1 = LCD and 2 = CRT). If videoout is undefined, CRT is
-		assumed.
-
-		For the CT69000 and SMI_LYNXEM drivers, videomode is
-		selected via environment 'videomode'. Two different ways
-		are possible:
-		- "videomode=num"   'num' is a standard LiLo mode numbers.
-		Following standard modes are supported	(* is default):
-
-		      Colors	640x480 800x600 1024x768 1152x864 1280x1024
-		-------------+---------------------------------------------
-		      8 bits |	0x301*	0x303	 0x305	  0x161	    0x307
-		     15 bits |	0x310	0x313	 0x316	  0x162	    0x319
-		     16 bits |	0x311	0x314	 0x317	  0x163	    0x31A
-		     24 bits |	0x312	0x315	 0x318	    ?	    0x31B
-		-------------+---------------------------------------------
-		(i.e. setenv videomode 317; saveenv; reset;)
-
-		- "videomode=bootargs" all the video parameters are parsed
-		from the bootargs. (See drivers/video/videomodes.c)
-
-
-		CONFIG_VIDEO_SED13806
-		Enable Epson SED13806 driver. This driver supports 8bpp
-		and 16bpp modes defined by CONFIG_VIDEO_SED13806_8BPP
-		or CONFIG_VIDEO_SED13806_16BPP
-
-		CONFIG_FSL_DIU_FB
-		Enable the Freescale DIU video driver.	Reference boards for
-		SOCs that have a DIU should define this macro to enable DIU
-		support, and should also define these other macros:
-
-			CONFIG_SYS_DIU_ADDR
-			CONFIG_VIDEO
-			CONFIG_CMD_BMP
-			CONFIG_CFB_CONSOLE
-			CONFIG_VIDEO_SW_CURSOR
-			CONFIG_VGA_AS_SINGLE_DEVICE
-			CONFIG_VIDEO_LOGO
-			CONFIG_VIDEO_BMP_LOGO
-
-		The DIU driver will look for the 'video-mode' environment
-		variable, and if defined, enable the DIU as a console during
-		boot.  See the documentation file README.video for a
-		description of this variable.
-
-- LCD Support:	CONFIG_LCD
-
-		Define this to enable LCD support (for output to LCD
-		display); also select one of the supported displays
-		by defining one of these:
-
-		CONFIG_ATMEL_LCD:
-
-			HITACHI TX09D70VM1CCA, 3.5", 240x320.
-
-		CONFIG_NEC_NL6448AC33:
-
-			NEC NL6448AC33-18. Active, color, single scan.
-
-		CONFIG_NEC_NL6448BC20
-
-			NEC NL6448BC20-08. 6.5", 640x480.
-			Active, color, single scan.
-
-		CONFIG_NEC_NL6448BC33_54
-
-			NEC NL6448BC33-54. 10.4", 640x480.
-			Active, color, single scan.
-
-		CONFIG_SHARP_16x9
-
-			Sharp 320x240. Active, color, single scan.
-			It isn't 16x9, and I am not sure what it is.
-
-		CONFIG_SHARP_LQ64D341
-
-			Sharp LQ64D341 display, 640x480.
-			Active, color, single scan.
-
-		CONFIG_HLD1045
-
-			HLD1045 display, 640x480.
-			Active, color, single scan.
-
-		CONFIG_OPTREX_BW
-
-			Optrex	 CBL50840-2 NF-FW 99 22 M5
-			or
-			Hitachi	 LMG6912RPFC-00T
-			or
-			Hitachi	 SP14Q002
-
-			320x240. Black & white.
-
-		Normally display is black on white background; define
-		CONFIG_SYS_WHITE_ON_BLACK to get it inverted.
-
-		CONFIG_LCD_ALIGNMENT
-
-		Normally the LCD is page-aligned (typically 4KB). If this is
-		defined then the LCD will be aligned to this value instead.
-		For ARM it is sometimes useful to use MMU_SECTION_SIZE
-		here, since it is cheaper to change data cache settings on
-		a per-section basis.
-
-		CONFIG_CONSOLE_SCROLL_LINES
-
-		When the console need to be scrolled, this is the number of
-		lines to scroll by. It defaults to 1. Increasing this makes
-		the console jump but can help speed up operation when scrolling
-		is slow.
-
-		CONFIG_LCD_ROTATION
-
-		Sometimes, for example if the display is mounted in portrait
-		mode or even if it's mounted landscape but rotated by 180degree,
-		we need to rotate our content of the display relative to the
-		framebuffer, so that user can read the messages which are
-		printed out.
-		Once CONFIG_LCD_ROTATION is defined, the lcd_console will be
-		initialized with a given rotation from "vl_rot" out of
-		"vidinfo_t" which is provided by the board specific code.
-		The value for vl_rot is coded as following (matching to
-		fbcon=rotate:<n> linux-kernel commandline):
-		0 = no rotation respectively 0 degree
-		1 = 90 degree rotation
-		2 = 180 degree rotation
-		3 = 270 degree rotation
-
-		If CONFIG_LCD_ROTATION is not defined, the console will be
-		initialized with 0degree rotation.
-
-		CONFIG_LCD_BMP_RLE8
-
-		Support drawing of RLE8-compressed bitmaps on the LCD.
-
-		CONFIG_I2C_EDID
-
-		Enables an 'i2c edid' command which can read EDID
-		information over I2C from an attached LCD display.
-
-- Splash Screen Support: CONFIG_SPLASH_SCREEN
-
-		If this option is set, the environment is checked for
-		a variable "splashimage". If found, the usual display
-		of logo, copyright and system information on the LCD
-		is suppressed and the BMP image at the address
-		specified in "splashimage" is loaded instead. The
-		console is redirected to the "nulldev", too. This
-		allows for a "silent" boot where a splash screen is
-		loaded very quickly after power-on.
-
-		CONFIG_SPLASHIMAGE_GUARD
-
-		If this option is set, then U-Boot will prevent the environment
-		variable "splashimage" from being set to a problematic address
-		(see README.displaying-bmps).
-		This option is useful for targets where, due to alignment
-		restrictions, an improperly aligned BMP image will cause a data
-		abort. If you think you will not have problems with unaligned
-		accesses (for example because your toolchain prevents them)
-		there is no need to set this option.
-
-		CONFIG_SPLASH_SCREEN_ALIGN
-
-		If this option is set the splash image can be freely positioned
-		on the screen. Environment variable "splashpos" specifies the
-		position as "x,y". If a positive number is given it is used as
-		number of pixel from left/top. If a negative number is given it
-		is used as number of pixel from right/bottom. You can also
-		specify 'm' for centering the image.
-
-		Example:
-		setenv splashpos m,m
-			=> image at center of screen
-
-		setenv splashpos 30,20
-			=> image at x = 30 and y = 20
-
-		setenv splashpos -10,m
-			=> vertically centered image
-			   at x = dspWidth - bmpWidth - 9
-
-- Gzip compressed BMP image support: CONFIG_VIDEO_BMP_GZIP
-
-		If this option is set, additionally to standard BMP
-		images, gzipped BMP images can be displayed via the
-		splashscreen support or the bmp command.
-
-- Run length encoded BMP image (RLE8) support: CONFIG_VIDEO_BMP_RLE8
-
-		If this option is set, 8-bit RLE compressed BMP images
-		can be displayed via the splashscreen support or the
-		bmp command.
-
-- Do compressing for memory range:
-		CONFIG_CMD_ZIP
-
-		If this option is set, it would use zlib deflate method
-		to compress the specified memory at its best effort.
-
-- Compression support:
-		CONFIG_GZIP
-
-		Enabled by default to support gzip compressed images.
-
-		CONFIG_BZIP2
-
-		If this option is set, support for bzip2 compressed
-		images is included. If not, only uncompressed and gzip
-		compressed images are supported.
-
-		NOTE: the bzip2 algorithm requires a lot of RAM, so
-		the malloc area (as defined by CONFIG_SYS_MALLOC_LEN) should
-		be at least 4MB.
-
-		CONFIG_LZMA
-
-		If this option is set, support for lzma compressed
-		images is included.
-
-		Note: The LZMA algorithm adds between 2 and 4KB of code and it
-		requires an amount of dynamic memory that is given by the
-		formula:
-
-			(1846 + 768 << (lc + lp)) * sizeof(uint16)
-
-		Where lc and lp stand for, respectively, Literal context bits
-		and Literal pos bits.
-
-		This value is upper-bounded by 14MB in the worst case. Anyway,
-		for a ~4MB large kernel image, we have lc=3 and lp=0 for a
-		total amount of (1846 + 768 << (3 + 0)) * 2 = ~41KB... that is
-		a very small buffer.
-
-		Use the lzmainfo tool to determinate the lc and lp values and
-		then calculate the amount of needed dynamic memory (ensuring
-		the appropriate CONFIG_SYS_MALLOC_LEN value).
-
-		CONFIG_LZO
-
-		If this option is set, support for LZO compressed images
-		is included.
-
-- MII/PHY support:
-		CONFIG_PHY_ADDR
-
-		The address of PHY on MII bus.
-
-		CONFIG_PHY_CLOCK_FREQ (ppc4xx)
-
-		The clock frequency of the MII bus
-
-		CONFIG_PHY_GIGE
-
-		If this option is set, support for speed/duplex
-		detection of gigabit PHY is included.
-
-		CONFIG_PHY_RESET_DELAY
-
-		Some PHY like Intel LXT971A need extra delay after
-		reset before any MII register access is possible.
-		For such PHY, set this option to the usec delay
-		required. (minimum 300usec for LXT971A)
-
-		CONFIG_PHY_CMD_DELAY (ppc4xx)
-
-		Some PHY like Intel LXT971A need extra delay after
-		command issued before MII status register can be read
-
-- IP address:
-		CONFIG_IPADDR
-
-		Define a default value for the IP address to use for
-		the default Ethernet interface, in case this is not
-		determined through e.g. bootp.
-		(Environment variable "ipaddr")
-
-- Server IP address:
-		CONFIG_SERVERIP
-
-		Defines a default value for the IP address of a TFTP
-		server to contact when using the "tftboot" command.
-		(Environment variable "serverip")
-
-		CONFIG_KEEP_SERVERADDR
-
-		Keeps the server's MAC address, in the env 'serveraddr'
-		for passing to bootargs (like Linux's netconsole option)
-
-- Gateway IP address:
-		CONFIG_GATEWAYIP
-
-		Defines a default value for the IP address of the
-		default router where packets to other networks are
-		sent to.
-		(Environment variable "gatewayip")
-
-- Subnet mask:
-		CONFIG_NETMASK
-
-		Defines a default value for the subnet mask (or
-		routing prefix) which is used to determine if an IP
-		address belongs to the local subnet or needs to be
-		forwarded through a router.
-		(Environment variable "netmask")
-
-- Multicast TFTP Mode:
-		CONFIG_MCAST_TFTP
-
-		Defines whether you want to support multicast TFTP as per
-		rfc-2090; for example to work with atftp.  Lets lots of targets
-		tftp down the same boot image concurrently.  Note: the Ethernet
-		driver in use must provide a function: mcast() to join/leave a
-		multicast group.
-
-- BOOTP Recovery Mode:
-		CONFIG_BOOTP_RANDOM_DELAY
-
-		If you have many targets in a network that try to
-		boot using BOOTP, you may want to avoid that all
-		systems send out BOOTP requests at precisely the same
-		moment (which would happen for instance at recovery
-		from a power failure, when all systems will try to
-		boot, thus flooding the BOOTP server. Defining
-		CONFIG_BOOTP_RANDOM_DELAY causes a random delay to be
-		inserted before sending out BOOTP requests. The
-		following delays are inserted then:
-
-		1st BOOTP request:	delay 0 ... 1 sec
-		2nd BOOTP request:	delay 0 ... 2 sec
-		3rd BOOTP request:	delay 0 ... 4 sec
-		4th and following
-		BOOTP requests:		delay 0 ... 8 sec
-
-		CONFIG_BOOTP_ID_CACHE_SIZE
-
-		BOOTP packets are uniquely identified using a 32-bit ID. The
-		server will copy the ID from client requests to responses and
-		U-Boot will use this to determine if it is the destination of
-		an incoming response. Some servers will check that addresses
-		aren't in use before handing them out (usually using an ARP
-		ping) and therefore take up to a few hundred milliseconds to
-		respond. Network congestion may also influence the time it
-		takes for a response to make it back to the client. If that
-		time is too long, U-Boot will retransmit requests. In order
-		to allow earlier responses to still be accepted after these
-		retransmissions, U-Boot's BOOTP client keeps a small cache of
-		IDs. The CONFIG_BOOTP_ID_CACHE_SIZE controls the size of this
-		cache. The default is to keep IDs for up to four outstanding
-		requests. Increasing this will allow U-Boot to accept offers
-		from a BOOTP client in networks with unusually high latency.
-
-- DHCP Advanced Options:
-		You can fine tune the DHCP functionality by defining
-		CONFIG_BOOTP_* symbols:
-
-		CONFIG_BOOTP_SUBNETMASK
-		CONFIG_BOOTP_GATEWAY
-		CONFIG_BOOTP_HOSTNAME
-		CONFIG_BOOTP_NISDOMAIN
-		CONFIG_BOOTP_BOOTPATH
-		CONFIG_BOOTP_BOOTFILESIZE
-		CONFIG_BOOTP_DNS
-		CONFIG_BOOTP_DNS2
-		CONFIG_BOOTP_SEND_HOSTNAME
-		CONFIG_BOOTP_NTPSERVER
-		CONFIG_BOOTP_TIMEOFFSET
-		CONFIG_BOOTP_VENDOREX
-		CONFIG_BOOTP_MAY_FAIL
-
-		CONFIG_BOOTP_SERVERIP - TFTP server will be the serverip
-		environment variable, not the BOOTP server.
-
-		CONFIG_BOOTP_MAY_FAIL - If the DHCP server is not found
-		after the configured retry count, the call will fail
-		instead of starting over.  This can be used to fail over
-		to Link-local IP address configuration if the DHCP server
-		is not available.
-
-		CONFIG_BOOTP_DNS2 - If a DHCP client requests the DNS
-		serverip from a DHCP server, it is possible that more
-		than one DNS serverip is offered to the client.
-		If CONFIG_BOOTP_DNS2 is enabled, the secondary DNS
-		serverip will be stored in the additional environment
-		variable "dnsip2". The first DNS serverip is always
-		stored in the variable "dnsip", when CONFIG_BOOTP_DNS
-		is defined.
-
-		CONFIG_BOOTP_SEND_HOSTNAME - Some DHCP servers are capable
-		to do a dynamic update of a DNS server. To do this, they
-		need the hostname of the DHCP requester.
-		If CONFIG_BOOTP_SEND_HOSTNAME is defined, the content
-		of the "hostname" environment variable is passed as
-		option 12 to the DHCP server.
-
-		CONFIG_BOOTP_DHCP_REQUEST_DELAY
-
-		A 32bit value in microseconds for a delay between
-		receiving a "DHCP Offer" and sending the "DHCP Request".
-		This fixes a problem with certain DHCP servers that don't
-		respond 100% of the time to a "DHCP request". E.g. On an
-		AT91RM9200 processor running at 180MHz, this delay needed
-		to be *at least* 15,000 usec before a Windows Server 2003
-		DHCP server would reply 100% of the time. I recommend at
-		least 50,000 usec to be safe. The alternative is to hope
-		that one of the retries will be successful but note that
-		the DHCP timeout and retry process takes a longer than
-		this delay.
-
- - Link-local IP address negotiation:
-		Negotiate with other link-local clients on the local network
-		for an address that doesn't require explicit configuration.
-		This is especially useful if a DHCP server cannot be guaranteed
-		to exist in all environments that the device must operate.
-
-		See doc/README.link-local for more information.
-
- - CDP Options:
-		CONFIG_CDP_DEVICE_ID
-
-		The device id used in CDP trigger frames.
-
-		CONFIG_CDP_DEVICE_ID_PREFIX
-
-		A two character string which is prefixed to the MAC address
-		of the device.
-
-		CONFIG_CDP_PORT_ID
-
-		A printf format string which contains the ascii name of
-		the port. Normally is set to "eth%d" which sets
-		eth0 for the first Ethernet, eth1 for the second etc.
-
-		CONFIG_CDP_CAPABILITIES
-
-		A 32bit integer which indicates the device capabilities;
-		0x00000010 for a normal host which does not forwards.
-
-		CONFIG_CDP_VERSION
-
-		An ascii string containing the version of the software.
-
-		CONFIG_CDP_PLATFORM
-
-		An ascii string containing the name of the platform.
-
-		CONFIG_CDP_TRIGGER
-
-		A 32bit integer sent on the trigger.
-
-		CONFIG_CDP_POWER_CONSUMPTION
-
-		A 16bit integer containing the power consumption of the
-		device in .1 of milliwatts.
-
-		CONFIG_CDP_APPLIANCE_VLAN_TYPE
-
-		A byte containing the id of the VLAN.
-
-- Status LED:	CONFIG_STATUS_LED
-
-		Several configurations allow to display the current
-		status using a LED. For instance, the LED will blink
-		fast while running U-Boot code, stop blinking as
-		soon as a reply to a BOOTP request was received, and
-		start blinking slow once the Linux kernel is running
-		(supported by a status LED driver in the Linux
-		kernel). Defining CONFIG_STATUS_LED enables this
-		feature in U-Boot.
-
-		Additional options:
-
-		CONFIG_GPIO_LED
-		The status LED can be connected to a GPIO pin.
-		In such cases, the gpio_led driver can be used as a
-		status LED backend implementation. Define CONFIG_GPIO_LED
-		to include the gpio_led driver in the U-Boot binary.
-
-		CONFIG_GPIO_LED_INVERTED_TABLE
-		Some GPIO connected LEDs may have inverted polarity in which
-		case the GPIO high value corresponds to LED off state and
-		GPIO low value corresponds to LED on state.
-		In such cases CONFIG_GPIO_LED_INVERTED_TABLE may be defined
-		with a list of GPIO LEDs that have inverted polarity.
-
-- CAN Support:	CONFIG_CAN_DRIVER
-
-		Defining CONFIG_CAN_DRIVER enables CAN driver support
-		on those systems that support this (optional)
-		feature, like the TQM8xxL modules.
-
-- I2C Support:	CONFIG_SYS_I2C
-
-		This enable the NEW i2c subsystem, and will allow you to use
-		i2c commands at the u-boot command line (as long as you set
-		CONFIG_CMD_I2C in CONFIG_COMMANDS) and communicate with i2c
-		based realtime clock chips or other i2c devices. See
-		common/cmd_i2c.c for a description of the command line
-		interface.
-
-		ported i2c driver to the new framework:
-		- drivers/i2c/soft_i2c.c:
-		  - activate first bus with CONFIG_SYS_I2C_SOFT define
-		    CONFIG_SYS_I2C_SOFT_SPEED and CONFIG_SYS_I2C_SOFT_SLAVE
-		    for defining speed and slave address
-		  - activate second bus with I2C_SOFT_DECLARATIONS2 define
-		    CONFIG_SYS_I2C_SOFT_SPEED_2 and CONFIG_SYS_I2C_SOFT_SLAVE_2
-		    for defining speed and slave address
-		  - activate third bus with I2C_SOFT_DECLARATIONS3 define
-		    CONFIG_SYS_I2C_SOFT_SPEED_3 and CONFIG_SYS_I2C_SOFT_SLAVE_3
-		    for defining speed and slave address
-		  - activate fourth bus with I2C_SOFT_DECLARATIONS4 define
-		    CONFIG_SYS_I2C_SOFT_SPEED_4 and CONFIG_SYS_I2C_SOFT_SLAVE_4
-		    for defining speed and slave address
-
-		- drivers/i2c/fsl_i2c.c:
-		  - activate i2c driver with CONFIG_SYS_I2C_FSL
-		    define CONFIG_SYS_FSL_I2C_OFFSET for setting the register
-		    offset CONFIG_SYS_FSL_I2C_SPEED for the i2c speed and
-		    CONFIG_SYS_FSL_I2C_SLAVE for the slave addr of the first
-		    bus.
-		  - If your board supports a second fsl i2c bus, define
-		    CONFIG_SYS_FSL_I2C2_OFFSET for the register offset
-		    CONFIG_SYS_FSL_I2C2_SPEED for the speed and
-		    CONFIG_SYS_FSL_I2C2_SLAVE for the slave address of the
-		    second bus.
-
-		- drivers/i2c/tegra_i2c.c:
-		  - activate this driver with CONFIG_SYS_I2C_TEGRA
-		  - This driver adds 4 i2c buses with a fix speed from
-		    100000 and the slave addr 0!
-
-		- drivers/i2c/ppc4xx_i2c.c
-		  - activate this driver with CONFIG_SYS_I2C_PPC4XX
-		  - CONFIG_SYS_I2C_PPC4XX_CH0 activate hardware channel 0
-		  - CONFIG_SYS_I2C_PPC4XX_CH1 activate hardware channel 1
-
-		- drivers/i2c/i2c_mxc.c
-		  - activate this driver with CONFIG_SYS_I2C_MXC
-		  - enable bus 1 with CONFIG_SYS_I2C_MXC_I2C1
-		  - enable bus 2 with CONFIG_SYS_I2C_MXC_I2C2
-		  - enable bus 3 with CONFIG_SYS_I2C_MXC_I2C3
-		  - enable bus 4 with CONFIG_SYS_I2C_MXC_I2C4
-		  - define speed for bus 1 with CONFIG_SYS_MXC_I2C1_SPEED
-		  - define slave for bus 1 with CONFIG_SYS_MXC_I2C1_SLAVE
-		  - define speed for bus 2 with CONFIG_SYS_MXC_I2C2_SPEED
-		  - define slave for bus 2 with CONFIG_SYS_MXC_I2C2_SLAVE
-		  - define speed for bus 3 with CONFIG_SYS_MXC_I2C3_SPEED
-		  - define slave for bus 3 with CONFIG_SYS_MXC_I2C3_SLAVE
-		  - define speed for bus 4 with CONFIG_SYS_MXC_I2C4_SPEED
-		  - define slave for bus 4 with CONFIG_SYS_MXC_I2C4_SLAVE
-		If those defines are not set, default value is 100000
-		for speed, and 0 for slave.
-
-		- drivers/i2c/rcar_i2c.c:
-		  - activate this driver with CONFIG_SYS_I2C_RCAR
-		  - This driver adds 4 i2c buses
-
-		  - CONFIG_SYS_RCAR_I2C0_BASE for setting the register channel 0
-		  - CONFIG_SYS_RCAR_I2C0_SPEED for for the speed channel 0
-		  - CONFIG_SYS_RCAR_I2C1_BASE for setting the register channel 1
-		  - CONFIG_SYS_RCAR_I2C1_SPEED for for the speed channel 1
-		  - CONFIG_SYS_RCAR_I2C2_BASE for setting the register channel 2
-		  - CONFIG_SYS_RCAR_I2C2_SPEED for for the speed channel 2
-		  - CONFIG_SYS_RCAR_I2C3_BASE for setting the register channel 3
-		  - CONFIG_SYS_RCAR_I2C3_SPEED for for the speed channel 3
-		  - CONFIF_SYS_RCAR_I2C_NUM_CONTROLLERS for number of i2c buses
-
-		- drivers/i2c/sh_i2c.c:
-		  - activate this driver with CONFIG_SYS_I2C_SH
-		  - This driver adds from 2 to 5 i2c buses
-
-		  - CONFIG_SYS_I2C_SH_BASE0 for setting the register channel 0
-		  - CONFIG_SYS_I2C_SH_SPEED0 for for the speed channel 0
-		  - CONFIG_SYS_I2C_SH_BASE1 for setting the register channel 1
-		  - CONFIG_SYS_I2C_SH_SPEED1 for for the speed channel 1
-		  - CONFIG_SYS_I2C_SH_BASE2 for setting the register channel 2
-		  - CONFIG_SYS_I2C_SH_SPEED2 for for the speed channel 2
-		  - CONFIG_SYS_I2C_SH_BASE3 for setting the register channel 3
-		  - CONFIG_SYS_I2C_SH_SPEED3 for for the speed channel 3
-		  - CONFIG_SYS_I2C_SH_BASE4 for setting the register channel 4
-		  - CONFIG_SYS_I2C_SH_SPEED4 for for the speed channel 4
-		  - CONFIG_SYS_I2C_SH_BASE5 for setting the register channel 5
-		  - CONFIG_SYS_I2C_SH_SPEED5 for for the speed channel 5
-		  - CONFIG_SYS_I2C_SH_NUM_CONTROLLERS for number of i2c buses
-
-		- drivers/i2c/omap24xx_i2c.c
-		  - activate this driver with CONFIG_SYS_I2C_OMAP24XX
-		  - CONFIG_SYS_OMAP24_I2C_SPEED speed channel 0
-		  - CONFIG_SYS_OMAP24_I2C_SLAVE slave addr channel 0
-		  - CONFIG_SYS_OMAP24_I2C_SPEED1 speed channel 1
-		  - CONFIG_SYS_OMAP24_I2C_SLAVE1 slave addr channel 1
-		  - CONFIG_SYS_OMAP24_I2C_SPEED2 speed channel 2
-		  - CONFIG_SYS_OMAP24_I2C_SLAVE2 slave addr channel 2
-		  - CONFIG_SYS_OMAP24_I2C_SPEED3 speed channel 3
-		  - CONFIG_SYS_OMAP24_I2C_SLAVE3 slave addr channel 3
-		  - CONFIG_SYS_OMAP24_I2C_SPEED4 speed channel 4
-		  - CONFIG_SYS_OMAP24_I2C_SLAVE4 slave addr channel 4
-
-		- drivers/i2c/zynq_i2c.c
-		  - activate this driver with CONFIG_SYS_I2C_ZYNQ
-		  - set CONFIG_SYS_I2C_ZYNQ_SPEED for speed setting
-		  - set CONFIG_SYS_I2C_ZYNQ_SLAVE for slave addr
-
-		- drivers/i2c/s3c24x0_i2c.c:
-		  - activate this driver with CONFIG_SYS_I2C_S3C24X0
-		  - This driver adds i2c buses (11 for Exynos5250, Exynos5420
-		    9 i2c buses for Exynos4 and 1 for S3C24X0 SoCs from Samsung)
-		    with a fix speed from 100000 and the slave addr 0!
-
-		- drivers/i2c/ihs_i2c.c
-		  - activate this driver with CONFIG_SYS_I2C_IHS
-		  - CONFIG_SYS_I2C_IHS_CH0 activate hardware channel 0
-		  - CONFIG_SYS_I2C_IHS_SPEED_0 speed channel 0
-		  - CONFIG_SYS_I2C_IHS_SLAVE_0 slave addr channel 0
-		  - CONFIG_SYS_I2C_IHS_CH1 activate hardware channel 1
-		  - CONFIG_SYS_I2C_IHS_SPEED_1 speed channel 1
-		  - CONFIG_SYS_I2C_IHS_SLAVE_1 slave addr channel 1
-		  - CONFIG_SYS_I2C_IHS_CH2 activate hardware channel 2
-		  - CONFIG_SYS_I2C_IHS_SPEED_2 speed channel 2
-		  - CONFIG_SYS_I2C_IHS_SLAVE_2 slave addr channel 2
-		  - CONFIG_SYS_I2C_IHS_CH3 activate hardware channel 3
-		  - CONFIG_SYS_I2C_IHS_SPEED_3 speed channel 3
-		  - CONFIG_SYS_I2C_IHS_SLAVE_3 slave addr channel 3
-		  - activate dual channel with CONFIG_SYS_I2C_IHS_DUAL
-		  - CONFIG_SYS_I2C_IHS_SPEED_0_1 speed channel 0_1
-		  - CONFIG_SYS_I2C_IHS_SLAVE_0_1 slave addr channel 0_1
-		  - CONFIG_SYS_I2C_IHS_SPEED_1_1 speed channel 1_1
-		  - CONFIG_SYS_I2C_IHS_SLAVE_1_1 slave addr channel 1_1
-		  - CONFIG_SYS_I2C_IHS_SPEED_2_1 speed channel 2_1
-		  - CONFIG_SYS_I2C_IHS_SLAVE_2_1 slave addr channel 2_1
-		  - CONFIG_SYS_I2C_IHS_SPEED_3_1 speed channel 3_1
-		  - CONFIG_SYS_I2C_IHS_SLAVE_3_1 slave addr channel 3_1
-
-		additional defines:
-
-		CONFIG_SYS_NUM_I2C_BUSES
-		Hold the number of i2c buses you want to use. If you
-		don't use/have i2c muxes on your i2c bus, this
-		is equal to CONFIG_SYS_NUM_I2C_ADAPTERS, and you can
-		omit this define.
-
-		CONFIG_SYS_I2C_DIRECT_BUS
-		define this, if you don't use i2c muxes on your hardware.
-		if CONFIG_SYS_I2C_MAX_HOPS is not defined or == 0 you can
-		omit this define.
-
-		CONFIG_SYS_I2C_MAX_HOPS
-		define how many muxes are maximal consecutively connected
-		on one i2c bus. If you not use i2c muxes, omit this
-		define.
-
-		CONFIG_SYS_I2C_BUSES
-		hold a list of buses you want to use, only used if
-		CONFIG_SYS_I2C_DIRECT_BUS is not defined, for example
-		a board with CONFIG_SYS_I2C_MAX_HOPS = 1 and
-		CONFIG_SYS_NUM_I2C_BUSES = 9:
-
-		 CONFIG_SYS_I2C_BUSES	{{0, {I2C_NULL_HOP}}, \
-					{0, {{I2C_MUX_PCA9547, 0x70, 1}}}, \
-					{0, {{I2C_MUX_PCA9547, 0x70, 2}}}, \
-					{0, {{I2C_MUX_PCA9547, 0x70, 3}}}, \
-					{0, {{I2C_MUX_PCA9547, 0x70, 4}}}, \
-					{0, {{I2C_MUX_PCA9547, 0x70, 5}}}, \
-					{1, {I2C_NULL_HOP}}, \
-					{1, {{I2C_MUX_PCA9544, 0x72, 1}}}, \
-					{1, {{I2C_MUX_PCA9544, 0x72, 2}}}, \
-					}
-
-		which defines
-			bus 0 on adapter 0 without a mux
-			bus 1 on adapter 0 with a PCA9547 on address 0x70 port 1
-			bus 2 on adapter 0 with a PCA9547 on address 0x70 port 2
-			bus 3 on adapter 0 with a PCA9547 on address 0x70 port 3
-			bus 4 on adapter 0 with a PCA9547 on address 0x70 port 4
-			bus 5 on adapter 0 with a PCA9547 on address 0x70 port 5
-			bus 6 on adapter 1 without a mux
-			bus 7 on adapter 1 with a PCA9544 on address 0x72 port 1
-			bus 8 on adapter 1 with a PCA9544 on address 0x72 port 2
-
-		If you do not have i2c muxes on your board, omit this define.
-
-- Legacy I2C Support:	CONFIG_HARD_I2C
-
-		NOTE: It is intended to move drivers to CONFIG_SYS_I2C which
-		provides the following compelling advantages:
-
-		- more than one i2c adapter is usable
-		- approved multibus support
-		- better i2c mux support
-
-		** Please consider updating your I2C driver now. **
-
-		These enable legacy I2C serial bus commands. Defining
-		CONFIG_HARD_I2C will include the appropriate I2C driver
-		for the selected CPU.
-
-		This will allow you to use i2c commands at the u-boot
-		command line (as long as you set CONFIG_CMD_I2C in
-		CONFIG_COMMANDS) and communicate with i2c based realtime
-		clock chips. See common/cmd_i2c.c for a description of the
-		command line interface.
-
-		CONFIG_HARD_I2C selects a hardware I2C controller.
-
-		There are several other quantities that must also be
-		defined when you define CONFIG_HARD_I2C.
-
-		In both cases you will need to define CONFIG_SYS_I2C_SPEED
-		to be the frequency (in Hz) at which you wish your i2c bus
-		to run and CONFIG_SYS_I2C_SLAVE to be the address of this node (ie
-		the CPU's i2c node address).
-
-		Now, the u-boot i2c code for the mpc8xx
-		(arch/powerpc/cpu/mpc8xx/i2c.c) sets the CPU up as a master node
-		and so its address should therefore be cleared to 0 (See,
-		eg, MPC823e User's Manual p.16-473). So, set
-		CONFIG_SYS_I2C_SLAVE to 0.
-
-		CONFIG_SYS_I2C_INIT_MPC5XXX
-
-		When a board is reset during an i2c bus transfer
-		chips might think that the current transfer is still
-		in progress.  Reset the slave devices by sending start
-		commands until the slave device responds.
-
-		That's all that's required for CONFIG_HARD_I2C.
-
-		If you use the software i2c interface (CONFIG_SYS_I2C_SOFT)
-		then the following macros need to be defined (examples are
-		from include/configs/lwmon.h):
-
-		I2C_INIT
-
-		(Optional). Any commands necessary to enable the I2C
-		controller or configure ports.
-
-		eg: #define I2C_INIT (immr->im_cpm.cp_pbdir |=	PB_SCL)
-
-		I2C_PORT
-
-		(Only for MPC8260 CPU). The I/O port to use (the code
-		assumes both bits are on the same port). Valid values
-		are 0..3 for ports A..D.
-
-		I2C_ACTIVE
-
-		The code necessary to make the I2C data line active
-		(driven).  If the data line is open collector, this
-		define can be null.
-
-		eg: #define I2C_ACTIVE (immr->im_cpm.cp_pbdir |=  PB_SDA)
-
-		I2C_TRISTATE
-
-		The code necessary to make the I2C data line tri-stated
-		(inactive).  If the data line is open collector, this
-		define can be null.
-
-		eg: #define I2C_TRISTATE (immr->im_cpm.cp_pbdir &= ~PB_SDA)
-
-		I2C_READ
-
-		Code that returns true if the I2C data line is high,
-		false if it is low.
-
-		eg: #define I2C_READ ((immr->im_cpm.cp_pbdat & PB_SDA) != 0)
-
-		I2C_SDA(bit)
-
-		If <bit> is true, sets the I2C data line high. If it
-		is false, it clears it (low).
-
-		eg: #define I2C_SDA(bit) \
-			if(bit) immr->im_cpm.cp_pbdat |=  PB_SDA; \
-			else	immr->im_cpm.cp_pbdat &= ~PB_SDA
-
-		I2C_SCL(bit)
-
-		If <bit> is true, sets the I2C clock line high. If it
-		is false, it clears it (low).
-
-		eg: #define I2C_SCL(bit) \
-			if(bit) immr->im_cpm.cp_pbdat |=  PB_SCL; \
-			else	immr->im_cpm.cp_pbdat &= ~PB_SCL
-
-		I2C_DELAY
-
-		This delay is invoked four times per clock cycle so this
-		controls the rate of data transfer.  The data rate thus
-		is 1 / (I2C_DELAY * 4). Often defined to be something
-		like:
-
-		#define I2C_DELAY  udelay(2)
-
-		CONFIG_SOFT_I2C_GPIO_SCL / CONFIG_SOFT_I2C_GPIO_SDA
-
-		If your arch supports the generic GPIO framework (asm/gpio.h),
-		then you may alternatively define the two GPIOs that are to be
-		used as SCL / SDA.  Any of the previous I2C_xxx macros will
-		have GPIO-based defaults assigned to them as appropriate.
-
-		You should define these to the GPIO value as given directly to
-		the generic GPIO functions.
-
-		CONFIG_SYS_I2C_INIT_BOARD
-
-		When a board is reset during an i2c bus transfer
-		chips might think that the current transfer is still
-		in progress. On some boards it is possible to access
-		the i2c SCLK line directly, either by using the
-		processor pin as a GPIO or by having a second pin
-		connected to the bus. If this option is defined a
-		custom i2c_init_board() routine in boards/xxx/board.c
-		is run early in the boot sequence.
-
-		CONFIG_SYS_I2C_BOARD_LATE_INIT
-
-		An alternative to CONFIG_SYS_I2C_INIT_BOARD. If this option is
-		defined a custom i2c_board_late_init() routine in
-		boards/xxx/board.c is run AFTER the operations in i2c_init()
-		is completed. This callpoint can be used to unreset i2c bus
-		using CPU i2c controller register accesses for CPUs whose i2c
-		controller provide such a method. It is called at the end of
-		i2c_init() to allow i2c_init operations to setup the i2c bus
-		controller on the CPU (e.g. setting bus speed & slave address).
-
-		CONFIG_I2CFAST (PPC405GP|PPC405EP only)
-
-		This option enables configuration of bi_iic_fast[] flags
-		in u-boot bd_info structure based on u-boot environment
-		variable "i2cfast". (see also i2cfast)
-
-		CONFIG_I2C_MULTI_BUS
-
-		This option allows the use of multiple I2C buses, each of which
-		must have a controller.	 At any point in time, only one bus is
-		active.	 To switch to a different bus, use the 'i2c dev' command.
-		Note that bus numbering is zero-based.
-
-		CONFIG_SYS_I2C_NOPROBES
-
-		This option specifies a list of I2C devices that will be skipped
-		when the 'i2c probe' command is issued.	 If CONFIG_I2C_MULTI_BUS
-		is set, specify a list of bus-device pairs.  Otherwise, specify
-		a 1D array of device addresses
-
-		e.g.
-			#undef	CONFIG_I2C_MULTI_BUS
-			#define CONFIG_SYS_I2C_NOPROBES {0x50,0x68}
-
-		will skip addresses 0x50 and 0x68 on a board with one I2C bus
-
-			#define CONFIG_I2C_MULTI_BUS
-			#define CONFIG_SYS_I2C_MULTI_NOPROBES	{{0,0x50},{0,0x68},{1,0x54}}
-
-		will skip addresses 0x50 and 0x68 on bus 0 and address 0x54 on bus 1
-
-		CONFIG_SYS_SPD_BUS_NUM
-
-		If defined, then this indicates the I2C bus number for DDR SPD.
-		If not defined, then U-Boot assumes that SPD is on I2C bus 0.
-
-		CONFIG_SYS_RTC_BUS_NUM
-
-		If defined, then this indicates the I2C bus number for the RTC.
-		If not defined, then U-Boot assumes that RTC is on I2C bus 0.
-
-		CONFIG_SYS_DTT_BUS_NUM
-
-		If defined, then this indicates the I2C bus number for the DTT.
-		If not defined, then U-Boot assumes that DTT is on I2C bus 0.
-
-		CONFIG_SYS_I2C_DTT_ADDR:
-
-		If defined, specifies the I2C address of the DTT device.
-		If not defined, then U-Boot uses predefined value for
-		specified DTT device.
-
-		CONFIG_SOFT_I2C_READ_REPEATED_START
-
-		defining this will force the i2c_read() function in
-		the soft_i2c driver to perform an I2C repeated start
-		between writing the address pointer and reading the
-		data.  If this define is omitted the default behaviour
-		of doing a stop-start sequence will be used.  Most I2C
-		devices can use either method, but some require one or
-		the other.
-
-- SPI Support:	CONFIG_SPI
-
-		Enables SPI driver (so far only tested with
-		SPI EEPROM, also an instance works with Crystal A/D and
-		D/As on the SACSng board)
-
-		CONFIG_SH_SPI
-
-		Enables the driver for SPI controller on SuperH. Currently
-		only SH7757 is supported.
-
-		CONFIG_SOFT_SPI
-
-		Enables a software (bit-bang) SPI driver rather than
-		using hardware support. This is a general purpose
-		driver that only requires three general I/O port pins
-		(two outputs, one input) to function. If this is
-		defined, the board configuration must define several
-		SPI configuration items (port pins to use, etc). For
-		an example, see include/configs/sacsng.h.
-
-		CONFIG_HARD_SPI
-
-		Enables a hardware SPI driver for general-purpose reads
-		and writes.  As with CONFIG_SOFT_SPI, the board configuration
-		must define a list of chip-select function pointers.
-		Currently supported on some MPC8xxx processors.	 For an
-		example, see include/configs/mpc8349emds.h.
-
-		CONFIG_MXC_SPI
-
-		Enables the driver for the SPI controllers on i.MX and MXC
-		SoCs. Currently i.MX31/35/51 are supported.
-
-		CONFIG_SYS_SPI_MXC_WAIT
-		Timeout for waiting until spi transfer completed.
-		default: (CONFIG_SYS_HZ/100)     /* 10 ms */
-
-- FPGA Support: CONFIG_FPGA
-
-		Enables FPGA subsystem.
-
-		CONFIG_FPGA_<vendor>
-
-		Enables support for specific chip vendors.
-		(ALTERA, XILINX)
-
-		CONFIG_FPGA_<family>
-
-		Enables support for FPGA family.
-		(SPARTAN2, SPARTAN3, VIRTEX2, CYCLONE2, ACEX1K, ACEX)
-
-		CONFIG_FPGA_COUNT
-
-		Specify the number of FPGA devices to support.
-
-		CONFIG_CMD_FPGA_LOADMK
-
-		Enable support for fpga loadmk command
-
-		CONFIG_CMD_FPGA_LOADP
-
-		Enable support for fpga loadp command - load partial bitstream
-
-		CONFIG_CMD_FPGA_LOADBP
-
-		Enable support for fpga loadbp command - load partial bitstream
-		(Xilinx only)
-
-		CONFIG_SYS_FPGA_PROG_FEEDBACK
-
-		Enable printing of hash marks during FPGA configuration.
-
-		CONFIG_SYS_FPGA_CHECK_BUSY
-
-		Enable checks on FPGA configuration interface busy
-		status by the configuration function. This option
-		will require a board or device specific function to
-		be written.
-
-		CONFIG_FPGA_DELAY
-
-		If defined, a function that provides delays in the FPGA
-		configuration driver.
-
-		CONFIG_SYS_FPGA_CHECK_CTRLC
-		Allow Control-C to interrupt FPGA configuration
-
-		CONFIG_SYS_FPGA_CHECK_ERROR
-
-		Check for configuration errors during FPGA bitfile
-		loading. For example, abort during Virtex II
-		configuration if the INIT_B line goes low (which
-		indicated a CRC error).
-
-		CONFIG_SYS_FPGA_WAIT_INIT
-
-		Maximum time to wait for the INIT_B line to de-assert
-		after PROB_B has been de-asserted during a Virtex II
-		FPGA configuration sequence. The default time is 500
-		ms.
-
-		CONFIG_SYS_FPGA_WAIT_BUSY
-
-		Maximum time to wait for BUSY to de-assert during
-		Virtex II FPGA configuration. The default is 5 ms.
-
-		CONFIG_SYS_FPGA_WAIT_CONFIG
-
-		Time to wait after FPGA configuration. The default is
-		200 ms.
-
-- Configuration Management:
-		CONFIG_BUILD_TARGET
-
-		Some SoCs need special image types (e.g. U-Boot binary
-		with a special header) as build targets. By defining
-		CONFIG_BUILD_TARGET in the SoC / board header, this
-		special image will be automatically built upon calling
-		make / MAKEALL.
-
-		CONFIG_IDENT_STRING
-
-		If defined, this string will be added to the U-Boot
-		version information (U_BOOT_VERSION)
-
-- Vendor Parameter Protection:
-
-		U-Boot considers the values of the environment
-		variables "serial#" (Board Serial Number) and
-		"ethaddr" (Ethernet Address) to be parameters that
-		are set once by the board vendor / manufacturer, and
-		protects these variables from casual modification by
-		the user. Once set, these variables are read-only,
-		and write or delete attempts are rejected. You can
-		change this behaviour:
-
-		If CONFIG_ENV_OVERWRITE is #defined in your config
-		file, the write protection for vendor parameters is
-		completely disabled. Anybody can change or delete
-		these parameters.
-
-		Alternatively, if you define _both_ an ethaddr in the
-		default env _and_ CONFIG_OVERWRITE_ETHADDR_ONCE, a default
-		Ethernet address is installed in the environment,
-		which can be changed exactly ONCE by the user. [The
-		serial# is unaffected by this, i. e. it remains
-		read-only.]
-
-		The same can be accomplished in a more flexible way
-		for any variable by configuring the type of access
-		to allow for those variables in the ".flags" variable
-		or define CONFIG_ENV_FLAGS_LIST_STATIC.
-
-- Protected RAM:
-		CONFIG_PRAM
-
-		Define this variable to enable the reservation of
-		"protected RAM", i. e. RAM which is not overwritten
-		by U-Boot. Define CONFIG_PRAM to hold the number of
-		kB you want to reserve for pRAM. You can overwrite
-		this default value by defining an environment
-		variable "pram" to the number of kB you want to
-		reserve. Note that the board info structure will
-		still show the full amount of RAM. If pRAM is
-		reserved, a new environment variable "mem" will
-		automatically be defined to hold the amount of
-		remaining RAM in a form that can be passed as boot
-		argument to Linux, for instance like that:
-
-			setenv bootargs ... mem=\${mem}
-			saveenv
-
-		This way you can tell Linux not to use this memory,
-		either, which results in a memory region that will
-		not be affected by reboots.
-
-		*WARNING* If your board configuration uses automatic
-		detection of the RAM size, you must make sure that
-		this memory test is non-destructive. So far, the
-		following board configurations are known to be
-		"pRAM-clean":
-
-			IVMS8, IVML24, SPD8xx, TQM8xxL,
-			HERMES, IP860, RPXlite, LWMON,
-			FLAGADM, TQM8260
-
-- Access to physical memory region (> 4GB)
-		Some basic support is provided for operations on memory not
-		normally accessible to U-Boot - e.g. some architectures
-		support access to more than 4GB of memory on 32-bit
-		machines using physical address extension or similar.
-		Define CONFIG_PHYSMEM to access this basic support, which
-		currently only supports clearing the memory.
-
-- Error Recovery:
-		CONFIG_PANIC_HANG
-
-		Define this variable to stop the system in case of a
-		fatal error, so that you have to reset it manually.
-		This is probably NOT a good idea for an embedded
-		system where you want the system to reboot
-		automatically as fast as possible, but it may be
-		useful during development since you can try to debug
-		the conditions that lead to the situation.
-
-		CONFIG_NET_RETRY_COUNT
-
-		This variable defines the number of retries for
-		network operations like ARP, RARP, TFTP, or BOOTP
-		before giving up the operation. If not defined, a
-		default value of 5 is used.
-
-		CONFIG_ARP_TIMEOUT
-
-		Timeout waiting for an ARP reply in milliseconds.
-
-		CONFIG_NFS_TIMEOUT
-
-		Timeout in milliseconds used in NFS protocol.
-		If you encounter "ERROR: Cannot umount" in nfs command,
-		try longer timeout such as
-		#define CONFIG_NFS_TIMEOUT 10000UL
-
-- Command Interpreter:
-		CONFIG_AUTO_COMPLETE
-
-		Enable auto completion of commands using TAB.
-
-		CONFIG_SYS_PROMPT_HUSH_PS2
-
-		This defines the secondary prompt string, which is
-		printed when the command interpreter needs more input
-		to complete a command. Usually "> ".
-
-	Note:
-
-		In the current implementation, the local variables
-		space and global environment variables space are
-		separated. Local variables are those you define by
-		simply typing `name=value'. To access a local
-		variable later on, you have write `$name' or
-		`${name}'; to execute the contents of a variable
-		directly type `$name' at the command prompt.
-
-		Global environment variables are those you use
-		setenv/printenv to work with. To run a command stored
-		in such a variable, you need to use the run command,
-		and you must not use the '$' sign to access them.
-
-		To store commands and special characters in a
-		variable, please use double quotation marks
-		surrounding the whole text of the variable, instead
-		of the backslashes before semicolons and special
-		symbols.
-
-- Command Line Editing and History:
-		CONFIG_CMDLINE_EDITING
-
-		Enable editing and History functions for interactive
-		command line input operations
-
-- Command Line PS1/PS2 support:
-		CONFIG_CMDLINE_PS_SUPPORT
-
-		Enable support for changing the command prompt string
-		at run-time. Only static string is supported so far.
-		The string is obtained from environment variables PS1
-		and PS2.
-
-- Default Environment:
-		CONFIG_EXTRA_ENV_SETTINGS
-
-		Define this to contain any number of null terminated
-		strings (variable = value pairs) that will be part of
-		the default environment compiled into the boot image.
-
-		For example, place something like this in your
-		board's config file:
-
-		#define CONFIG_EXTRA_ENV_SETTINGS \
-			"myvar1=value1\0" \
-			"myvar2=value2\0"
-
-		Warning: This method is based on knowledge about the
-		internal format how the environment is stored by the
-		U-Boot code. This is NOT an official, exported
-		interface! Although it is unlikely that this format
-		will change soon, there is no guarantee either.
-		You better know what you are doing here.
-
-		Note: overly (ab)use of the default environment is
-		discouraged. Make sure to check other ways to preset
-		the environment like the "source" command or the
-		boot command first.
-
-		CONFIG_ENV_VARS_UBOOT_CONFIG
-
-		Define this in order to add variables describing the
-		U-Boot build configuration to the default environment.
-		These will be named arch, cpu, board, vendor, and soc.
-
-		Enabling this option will cause the following to be defined:
-
-		- CONFIG_SYS_ARCH
-		- CONFIG_SYS_CPU
-		- CONFIG_SYS_BOARD
-		- CONFIG_SYS_VENDOR
-		- CONFIG_SYS_SOC
-
-		CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
-
-		Define this in order to add variables describing certain
-		run-time determined information about the hardware to the
-		environment.  These will be named board_name, board_rev.
-
-		CONFIG_DELAY_ENVIRONMENT
-
-		Normally the environment is loaded when the board is
-		initialised so that it is available to U-Boot. This inhibits
-		that so that the environment is not available until
-		explicitly loaded later by U-Boot code. With CONFIG_OF_CONTROL
-		this is instead controlled by the value of
-		/config/load-environment.
-
-- Parallel Flash support:
-		CONFIG_SYS_NO_FLASH
-
-		Traditionally U-Boot was run on systems with parallel NOR
-		flash. This option is used to disable support for parallel NOR
-		flash. This option should be defined if the board does not have
-		parallel flash.
-
-		If this option is not defined one of the generic flash drivers
-		(e.g.  CONFIG_FLASH_CFI_DRIVER or CONFIG_ST_SMI) must be
-		selected or the board must provide an implementation of the
-		flash API (see include/flash.h).
-
-- DataFlash Support:
-		CONFIG_HAS_DATAFLASH
-
-		Defining this option enables DataFlash features and
-		allows to read/write in Dataflash via the standard
-		commands cp, md...
-
-- Serial Flash support
-		CONFIG_CMD_SF
-
-		Defining this option enables SPI flash commands
-		'sf probe/read/write/erase/update'.
-
-		Usage requires an initial 'probe' to define the serial
-		flash parameters, followed by read/write/erase/update
-		commands.
-
-		The following defaults may be provided by the platform
-		to handle the common case when only a single serial
-		flash is present on the system.
-
-		CONFIG_SF_DEFAULT_BUS		Bus identifier
-		CONFIG_SF_DEFAULT_CS		Chip-select
-		CONFIG_SF_DEFAULT_MODE 		(see include/spi.h)
-		CONFIG_SF_DEFAULT_SPEED		in Hz
-
-		CONFIG_CMD_SF_TEST
-
-		Define this option to include a destructive SPI flash
-		test ('sf test').
-
-		CONFIG_SF_DUAL_FLASH		Dual flash memories
-
-		Define this option to use dual flash support where two flash
-		memories can be connected with a given cs line.
-		Currently Xilinx Zynq qspi supports these type of connections.
-
-- SystemACE Support:
-		CONFIG_SYSTEMACE
-
-		Adding this option adds support for Xilinx SystemACE
-		chips attached via some sort of local bus. The address
-		of the chip must also be defined in the
-		CONFIG_SYS_SYSTEMACE_BASE macro. For example:
-
-		#define CONFIG_SYSTEMACE
-		#define CONFIG_SYS_SYSTEMACE_BASE 0xf0000000
-
-		When SystemACE support is added, the "ace" device type
-		becomes available to the fat commands, i.e. fatls.
-
-- TFTP Fixed UDP Port:
-		CONFIG_TFTP_PORT
-
-		If this is defined, the environment variable tftpsrcp
-		is used to supply the TFTP UDP source port value.
-		If tftpsrcp isn't defined, the normal pseudo-random port
-		number generator is used.
-
-		Also, the environment variable tftpdstp is used to supply
-		the TFTP UDP destination port value.  If tftpdstp isn't
-		defined, the normal port 69 is used.
-
-		The purpose for tftpsrcp is to allow a TFTP server to
-		blindly start the TFTP transfer using the pre-configured
-		target IP address and UDP port. This has the effect of
-		"punching through" the (Windows XP) firewall, allowing
-		the remainder of the TFTP transfer to proceed normally.
-		A better solution is to properly configure the firewall,
-		but sometimes that is not allowed.
-
-- Hashing support:
-		CONFIG_CMD_HASH
-
-		This enables a generic 'hash' command which can produce
-		hashes / digests from a few algorithms (e.g. SHA1, SHA256).
-
-		CONFIG_HASH_VERIFY
-
-		Enable the hash verify command (hash -v). This adds to code
-		size a little.
-
-		CONFIG_SHA1 - This option enables support of hashing using SHA1
-		algorithm. The hash is calculated in software.
-		CONFIG_SHA256 - This option enables support of hashing using
-		SHA256 algorithm. The hash is calculated in software.
-		CONFIG_SHA_HW_ACCEL - This option enables hardware acceleration
-		for SHA1/SHA256 hashing.
-		This affects the 'hash' command and also the
-		hash_lookup_algo() function.
-		CONFIG_SHA_PROG_HW_ACCEL - This option enables
-		hardware-acceleration for SHA1/SHA256 progressive hashing.
-		Data can be streamed in a block at a time and the hashing
-		is performed in hardware.
-
-		Note: There is also a sha1sum command, which should perhaps
-		be deprecated in favour of 'hash sha1'.
-
-- Freescale i.MX specific commands:
-		CONFIG_CMD_HDMIDETECT
-		This enables 'hdmidet' command which returns true if an
-		HDMI monitor is detected.  This command is i.MX 6 specific.
-
-		CONFIG_CMD_BMODE
-		This enables the 'bmode' (bootmode) command for forcing
-		a boot from specific media.
-
-		This is useful for forcing the ROM's usb downloader to
-		activate upon a watchdog reset which is nice when iterating
-		on U-Boot.  Using the reset button or running bmode normal
-		will set it back to normal.  This command currently
-		supports i.MX53 and i.MX6.
-
-- Signing support:
-		CONFIG_RSA
-
-		This enables the RSA algorithm used for FIT image verification
-		in U-Boot. See doc/uImage.FIT/signature.txt for more information.
-
-		The Modular Exponentiation algorithm in RSA is implemented using
-		driver model. So CONFIG_DM needs to be enabled by default for this
-		library to function.
-
-		The signing part is build into mkimage regardless of this
-		option. The software based modular exponentiation is built into
-		mkimage irrespective of this option.
-
-- bootcount support:
-		CONFIG_BOOTCOUNT_LIMIT
-
-		This enables the bootcounter support, see:
-		http://www.denx.de/wiki/DULG/UBootBootCountLimit
-
-		CONFIG_AT91SAM9XE
-		enable special bootcounter support on at91sam9xe based boards.
-		CONFIG_BLACKFIN
-		enable special bootcounter support on blackfin based boards.
-		CONFIG_SOC_DA8XX
-		enable special bootcounter support on da850 based boards.
-		CONFIG_BOOTCOUNT_RAM
-		enable support for the bootcounter in RAM
-		CONFIG_BOOTCOUNT_I2C
-		enable support for the bootcounter on an i2c (like RTC) device.
-			CONFIG_SYS_I2C_RTC_ADDR = i2c chip address
-			CONFIG_SYS_BOOTCOUNT_ADDR = i2c addr which is used for
-						    the bootcounter.
-			CONFIG_BOOTCOUNT_ALEN = address len
-
-- Show boot progress:
-		CONFIG_SHOW_BOOT_PROGRESS
-
-		Defining this option allows to add some board-
-		specific code (calling a user-provided function
-		"show_boot_progress(int)") that enables you to show
-		the system's boot progress on some display (for
-		example, some LED's) on your board. At the moment,
-		the following checkpoints are implemented:
-
-
-Legacy uImage format:
-
-  Arg	Where			When
-    1	common/cmd_bootm.c	before attempting to boot an image
-   -1	common/cmd_bootm.c	Image header has bad	 magic number
-    2	common/cmd_bootm.c	Image header has correct magic number
-   -2	common/cmd_bootm.c	Image header has bad	 checksum
-    3	common/cmd_bootm.c	Image header has correct checksum
-   -3	common/cmd_bootm.c	Image data   has bad	 checksum
-    4	common/cmd_bootm.c	Image data   has correct checksum
-   -4	common/cmd_bootm.c	Image is for unsupported architecture
-    5	common/cmd_bootm.c	Architecture check OK
-   -5	common/cmd_bootm.c	Wrong Image Type (not kernel, multi)
-    6	common/cmd_bootm.c	Image Type check OK
-   -6	common/cmd_bootm.c	gunzip uncompression error
-   -7	common/cmd_bootm.c	Unimplemented compression type
-    7	common/cmd_bootm.c	Uncompression OK
-    8	common/cmd_bootm.c	No uncompress/copy overwrite error
-   -9	common/cmd_bootm.c	Unsupported OS (not Linux, BSD, VxWorks, QNX)
-
-    9	common/image.c		Start initial ramdisk verification
-  -10	common/image.c		Ramdisk header has bad	   magic number
-  -11	common/image.c		Ramdisk header has bad	   checksum
-   10	common/image.c		Ramdisk header is OK
-  -12	common/image.c		Ramdisk data   has bad	   checksum
-   11	common/image.c		Ramdisk data   has correct checksum
-   12	common/image.c		Ramdisk verification complete, start loading
-  -13	common/image.c		Wrong Image Type (not PPC Linux ramdisk)
-   13	common/image.c		Start multifile image verification
-   14	common/image.c		No initial ramdisk, no multifile, continue.
-
-   15	arch/<arch>/lib/bootm.c All preparation done, transferring control to OS
-
-  -30	arch/powerpc/lib/board.c	Fatal error, hang the system
-  -31	post/post.c		POST test failed, detected by post_output_backlog()
-  -32	post/post.c		POST test failed, detected by post_run_single()
-
-   34	common/cmd_doc.c	before loading a Image from a DOC device
-  -35	common/cmd_doc.c	Bad usage of "doc" command
-   35	common/cmd_doc.c	correct usage of "doc" command
-  -36	common/cmd_doc.c	No boot device
-   36	common/cmd_doc.c	correct boot device
-  -37	common/cmd_doc.c	Unknown Chip ID on boot device
-   37	common/cmd_doc.c	correct chip ID found, device available
-  -38	common/cmd_doc.c	Read Error on boot device
-   38	common/cmd_doc.c	reading Image header from DOC device OK
-  -39	common/cmd_doc.c	Image header has bad magic number
-   39	common/cmd_doc.c	Image header has correct magic number
-  -40	common/cmd_doc.c	Error reading Image from DOC device
-   40	common/cmd_doc.c	Image header has correct magic number
-   41	common/cmd_ide.c	before loading a Image from a IDE device
-  -42	common/cmd_ide.c	Bad usage of "ide" command
-   42	common/cmd_ide.c	correct usage of "ide" command
-  -43	common/cmd_ide.c	No boot device
-   43	common/cmd_ide.c	boot device found
-  -44	common/cmd_ide.c	Device not available
-   44	common/cmd_ide.c	Device available
-  -45	common/cmd_ide.c	wrong partition selected
-   45	common/cmd_ide.c	partition selected
-  -46	common/cmd_ide.c	Unknown partition table
-   46	common/cmd_ide.c	valid partition table found
-  -47	common/cmd_ide.c	Invalid partition type
-   47	common/cmd_ide.c	correct partition type
-  -48	common/cmd_ide.c	Error reading Image Header on boot device
-   48	common/cmd_ide.c	reading Image Header from IDE device OK
-  -49	common/cmd_ide.c	Image header has bad magic number
-   49	common/cmd_ide.c	Image header has correct magic number
-  -50	common/cmd_ide.c	Image header has bad	 checksum
-   50	common/cmd_ide.c	Image header has correct checksum
-  -51	common/cmd_ide.c	Error reading Image from IDE device
-   51	common/cmd_ide.c	reading Image from IDE device OK
-   52	common/cmd_nand.c	before loading a Image from a NAND device
-  -53	common/cmd_nand.c	Bad usage of "nand" command
-   53	common/cmd_nand.c	correct usage of "nand" command
-  -54	common/cmd_nand.c	No boot device
-   54	common/cmd_nand.c	boot device found
-  -55	common/cmd_nand.c	Unknown Chip ID on boot device
-   55	common/cmd_nand.c	correct chip ID found, device available
-  -56	common/cmd_nand.c	Error reading Image Header on boot device
-   56	common/cmd_nand.c	reading Image Header from NAND device OK
-  -57	common/cmd_nand.c	Image header has bad magic number
-   57	common/cmd_nand.c	Image header has correct magic number
-  -58	common/cmd_nand.c	Error reading Image from NAND device
-   58	common/cmd_nand.c	reading Image from NAND device OK
-
-  -60	common/env_common.c	Environment has a bad CRC, using default
-
-   64	net/eth.c		starting with Ethernet configuration.
-  -64	net/eth.c		no Ethernet found.
-   65	net/eth.c		Ethernet found.
-
-  -80	common/cmd_net.c	usage wrong
-   80	common/cmd_net.c	before calling net_loop()
-  -81	common/cmd_net.c	some error in net_loop() occurred
-   81	common/cmd_net.c	net_loop() back without error
-  -82	common/cmd_net.c	size == 0 (File with size 0 loaded)
-   82	common/cmd_net.c	trying automatic boot
-   83	common/cmd_net.c	running "source" command
-  -83	common/cmd_net.c	some error in automatic boot or "source" command
-   84	common/cmd_net.c	end without errors
-
-FIT uImage format:
-
-  Arg	Where			When
-  100	common/cmd_bootm.c	Kernel FIT Image has correct format
- -100	common/cmd_bootm.c	Kernel FIT Image has incorrect format
-  101	common/cmd_bootm.c	No Kernel subimage unit name, using configuration
- -101	common/cmd_bootm.c	Can't get configuration for kernel subimage
-  102	common/cmd_bootm.c	Kernel unit name specified
- -103	common/cmd_bootm.c	Can't get kernel subimage node offset
-  103	common/cmd_bootm.c	Found configuration node
-  104	common/cmd_bootm.c	Got kernel subimage node offset
- -104	common/cmd_bootm.c	Kernel subimage hash verification failed
-  105	common/cmd_bootm.c	Kernel subimage hash verification OK
- -105	common/cmd_bootm.c	Kernel subimage is for unsupported architecture
-  106	common/cmd_bootm.c	Architecture check OK
- -106	common/cmd_bootm.c	Kernel subimage has wrong type
-  107	common/cmd_bootm.c	Kernel subimage type OK
- -107	common/cmd_bootm.c	Can't get kernel subimage data/size
-  108	common/cmd_bootm.c	Got kernel subimage data/size
- -108	common/cmd_bootm.c	Wrong image type (not legacy, FIT)
- -109	common/cmd_bootm.c	Can't get kernel subimage type
- -110	common/cmd_bootm.c	Can't get kernel subimage comp
- -111	common/cmd_bootm.c	Can't get kernel subimage os
- -112	common/cmd_bootm.c	Can't get kernel subimage load address
- -113	common/cmd_bootm.c	Image uncompress/copy overwrite error
-
-  120	common/image.c		Start initial ramdisk verification
- -120	common/image.c		Ramdisk FIT image has incorrect format
-  121	common/image.c		Ramdisk FIT image has correct format
-  122	common/image.c		No ramdisk subimage unit name, using configuration
- -122	common/image.c		Can't get configuration for ramdisk subimage
-  123	common/image.c		Ramdisk unit name specified
- -124	common/image.c		Can't get ramdisk subimage node offset
-  125	common/image.c		Got ramdisk subimage node offset
- -125	common/image.c		Ramdisk subimage hash verification failed
-  126	common/image.c		Ramdisk subimage hash verification OK
- -126	common/image.c		Ramdisk subimage for unsupported architecture
-  127	common/image.c		Architecture check OK
- -127	common/image.c		Can't get ramdisk subimage data/size
-  128	common/image.c		Got ramdisk subimage data/size
-  129	common/image.c		Can't get ramdisk load address
- -129	common/image.c		Got ramdisk load address
-
- -130	common/cmd_doc.c	Incorrect FIT image format
-  131	common/cmd_doc.c	FIT image format OK
-
- -140	common/cmd_ide.c	Incorrect FIT image format
-  141	common/cmd_ide.c	FIT image format OK
-
- -150	common/cmd_nand.c	Incorrect FIT image format
-  151	common/cmd_nand.c	FIT image format OK
-
-- legacy image format:
-		CONFIG_IMAGE_FORMAT_LEGACY
-		enables the legacy image format support in U-Boot.
-
-		Default:
-		enabled if CONFIG_FIT_SIGNATURE is not defined.
-
-		CONFIG_DISABLE_IMAGE_LEGACY
-		disable the legacy image format
-
-		This define is introduced, as the legacy image format is
-		enabled per default for backward compatibility.
-
-- FIT image support:
-		CONFIG_FIT
-		Enable support for the FIT uImage format.
-
-		CONFIG_FIT_BEST_MATCH
-		When no configuration is explicitly selected, default to the
-		one whose fdt's compatibility field best matches that of
-		U-Boot itself. A match is considered "best" if it matches the
-		most specific compatibility entry of U-Boot's fdt's root node.
-		The order of entries in the configuration's fdt is ignored.
-
-		CONFIG_FIT_SIGNATURE
-		This option enables signature verification of FIT uImages,
-		using a hash signed and verified using RSA. If
-		CONFIG_SHA_PROG_HW_ACCEL is defined, i.e support for progressive
-		hashing is available using hardware, RSA library will use it.
-		See doc/uImage.FIT/signature.txt for more details.
-
-		WARNING: When relying on signed FIT images with required
-		signature check the legacy image format is default
-		disabled. If a board need legacy image format support
-		enable this through CONFIG_IMAGE_FORMAT_LEGACY
-
-		CONFIG_FIT_DISABLE_SHA256
-		Supporting SHA256 hashes has quite an impact on binary size.
-		For constrained systems sha256 hash support can be disabled
-		with this option.
-
-- Standalone program support:
-		CONFIG_STANDALONE_LOAD_ADDR
-
-		This option defines a board specific value for the
-		address where standalone program gets loaded, thus
-		overwriting the architecture dependent default
-		settings.
-
-- Frame Buffer Address:
-		CONFIG_FB_ADDR
-
-		Define CONFIG_FB_ADDR if you want to use specific
-		address for frame buffer.  This is typically the case
-		when using a graphics controller has separate video
-		memory.  U-Boot will then place the frame buffer at
-		the given address instead of dynamically reserving it
-		in system RAM by calling lcd_setmem(), which grabs
-		the memory for the frame buffer depending on the
-		configured panel size.
-
-		Please see board_init_f function.
-
-- Automatic software updates via TFTP server
-		CONFIG_UPDATE_TFTP
-		CONFIG_UPDATE_TFTP_CNT_MAX
-		CONFIG_UPDATE_TFTP_MSEC_MAX
-
-		These options enable and control the auto-update feature;
-		for a more detailed description refer to doc/README.update.
-
-- MTD Support (mtdparts command, UBI support)
-		CONFIG_MTD_DEVICE
-
-		Adds the MTD device infrastructure from the Linux kernel.
-		Needed for mtdparts command support.
-
-		CONFIG_MTD_PARTITIONS
-
-		Adds the MTD partitioning infrastructure from the Linux
-		kernel. Needed for UBI support.
-
-- UBI support
-		CONFIG_CMD_UBI
-
-		Adds commands for interacting with MTD partitions formatted
-		with the UBI flash translation layer
-
-		Requires also defining CONFIG_RBTREE
-
-		CONFIG_UBI_SILENCE_MSG
-
-		Make the verbose messages from UBI stop printing.  This leaves
-		warnings and errors enabled.
-
-
-		CONFIG_MTD_UBI_WL_THRESHOLD
-		This parameter defines the maximum difference between the highest
-		erase counter value and the lowest erase counter value of eraseblocks
-		of UBI devices. When this threshold is exceeded, UBI starts performing
-		wear leveling by means of moving data from eraseblock with low erase
-		counter to eraseblocks with high erase counter.
-
-		The default value should be OK for SLC NAND flashes, NOR flashes and
-		other flashes which have eraseblock life-cycle 100000 or more.
-		However, in case of MLC NAND flashes which typically have eraseblock
-		life-cycle less than 10000, the threshold should be lessened (e.g.,
-		to 128 or 256, although it does not have to be power of 2).
-
-		default: 4096
-
-		CONFIG_MTD_UBI_BEB_LIMIT
-		This option specifies the maximum bad physical eraseblocks UBI
-		expects on the MTD device (per 1024 eraseblocks). If the
-		underlying flash does not admit of bad eraseblocks (e.g. NOR
-		flash), this value is ignored.
-
-		NAND datasheets often specify the minimum and maximum NVM
-		(Number of Valid Blocks) for the flashes' endurance lifetime.
-		The maximum expected bad eraseblocks per 1024 eraseblocks
-		then can be calculated as "1024 * (1 - MinNVB / MaxNVB)",
-		which gives 20 for most NANDs (MaxNVB is basically the total
-		count of eraseblocks on the chip).
-
-		To put it differently, if this value is 20, UBI will try to
-		reserve about 1.9% of physical eraseblocks for bad blocks
-		handling. And that will be 1.9% of eraseblocks on the entire
-		NAND chip, not just the MTD partition UBI attaches. This means
-		that if you have, say, a NAND flash chip admits maximum 40 bad
-		eraseblocks, and it is split on two MTD partitions of the same
-		size, UBI will reserve 40 eraseblocks when attaching a
-		partition.
-
-		default: 20
-
-		CONFIG_MTD_UBI_FASTMAP
-		Fastmap is a mechanism which allows attaching an UBI device
-		in nearly constant time. Instead of scanning the whole MTD device it
-		only has to locate a checkpoint (called fastmap) on the device.
-		The on-flash fastmap contains all information needed to attach
-		the device. Using fastmap makes only sense on large devices where
-		attaching by scanning takes long. UBI will not automatically install
-		a fastmap on old images, but you can set the UBI parameter
-		CONFIG_MTD_UBI_FASTMAP_AUTOCONVERT to 1 if you want so. Please note
-		that fastmap-enabled images are still usable with UBI implementations
-		without	fastmap support. On typical flash devices the whole fastmap
-		fits into one PEB. UBI will reserve PEBs to hold two fastmaps.
-
-		CONFIG_MTD_UBI_FASTMAP_AUTOCONVERT
-		Set this parameter to enable fastmap automatically on images
-		without a fastmap.
-		default: 0
-
-		CONFIG_MTD_UBI_FM_DEBUG
-		Enable UBI fastmap debug
-		default: 0
-
-- UBIFS support
-		CONFIG_CMD_UBIFS
-
-		Adds commands for interacting with UBI volumes formatted as
-		UBIFS.  UBIFS is read-only in u-boot.
-
-		Requires UBI support as well as CONFIG_LZO
-
-		CONFIG_UBIFS_SILENCE_MSG
-
-		Make the verbose messages from UBIFS stop printing.  This leaves
-		warnings and errors enabled.
-
-- SPL framework
-		CONFIG_SPL
-		Enable building of SPL globally.
-
-		CONFIG_SPL_LDSCRIPT
-		LDSCRIPT for linking the SPL binary.
-
-		CONFIG_SPL_MAX_FOOTPRINT
-		Maximum size in memory allocated to the SPL, BSS included.
-		When defined, the linker checks that the actual memory
-		used by SPL from _start to __bss_end does not exceed it.
-		CONFIG_SPL_MAX_FOOTPRINT and CONFIG_SPL_BSS_MAX_SIZE
-		must not be both defined at the same time.
-
-		CONFIG_SPL_MAX_SIZE
-		Maximum size of the SPL image (text, data, rodata, and
-		linker lists sections), BSS excluded.
-		When defined, the linker checks that the actual size does
-		not exceed it.
-
-		CONFIG_SPL_TEXT_BASE
-		TEXT_BASE for linking the SPL binary.
-
-		CONFIG_SPL_RELOC_TEXT_BASE
-		Address to relocate to.  If unspecified, this is equal to
-		CONFIG_SPL_TEXT_BASE (i.e. no relocation is done).
-
-		CONFIG_SPL_BSS_START_ADDR
-		Link address for the BSS within the SPL binary.
-
-		CONFIG_SPL_BSS_MAX_SIZE
-		Maximum size in memory allocated to the SPL BSS.
-		When defined, the linker checks that the actual memory used
-		by SPL from __bss_start to __bss_end does not exceed it.
-		CONFIG_SPL_MAX_FOOTPRINT and CONFIG_SPL_BSS_MAX_SIZE
-		must not be both defined at the same time.
-
-		CONFIG_SPL_STACK
-		Adress of the start of the stack SPL will use
-
-		CONFIG_SPL_PANIC_ON_RAW_IMAGE
-		When defined, SPL will panic() if the image it has
-		loaded does not have a signature.
-		Defining this is useful when code which loads images
-		in SPL cannot guarantee that absolutely all read errors
-		will be caught.
-		An example is the LPC32XX MLC NAND driver, which will
-		consider that a completely unreadable NAND block is bad,
-		and thus should be skipped silently.
-
-		CONFIG_SPL_RELOC_STACK
-		Adress of the start of the stack SPL will use after
-		relocation.  If unspecified, this is equal to
-		CONFIG_SPL_STACK.
-
-		CONFIG_SYS_SPL_MALLOC_START
-		Starting address of the malloc pool used in SPL.
-		When this option is set the full malloc is used in SPL and
-		it is set up by spl_init() and before that, the simple malloc()
-		can be used if CONFIG_SYS_MALLOC_F is defined.
-
-		CONFIG_SYS_SPL_MALLOC_SIZE
-		The size of the malloc pool used in SPL.
-
-		CONFIG_SPL_FRAMEWORK
-		Enable the SPL framework under common/.  This framework
-		supports MMC, NAND and YMODEM loading of U-Boot and NAND
-		NAND loading of the Linux Kernel.
-
-		CONFIG_SPL_OS_BOOT
-		Enable booting directly to an OS from SPL.
-		See also: doc/README.falcon
-
-		CONFIG_SPL_DISPLAY_PRINT
-		For ARM, enable an optional function to print more information
-		about the running system.
-
-		CONFIG_SPL_INIT_MINIMAL
-		Arch init code should be built for a very small image
-
-		CONFIG_SPL_LIBCOMMON_SUPPORT
-		Support for common/libcommon.o in SPL binary
-
-		CONFIG_SPL_LIBDISK_SUPPORT
-		Support for disk/libdisk.o in SPL binary
-
-		CONFIG_SPL_I2C_SUPPORT
-		Support for drivers/i2c/libi2c.o in SPL binary
-
-		CONFIG_SPL_GPIO_SUPPORT
-		Support for drivers/gpio/libgpio.o in SPL binary
-
-		CONFIG_SPL_MMC_SUPPORT
-		Support for drivers/mmc/libmmc.o in SPL binary
-
-		CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR,
-		CONFIG_SYS_U_BOOT_MAX_SIZE_SECTORS,
-		Address and partition on the MMC to load U-Boot from
-		when the MMC is being used in raw mode.
-
-		CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION
-		Partition on the MMC to load U-Boot from when the MMC is being
-		used in raw mode
-
-		CONFIG_SYS_MMCSD_RAW_MODE_KERNEL_SECTOR
-		Sector to load kernel uImage from when MMC is being
-		used in raw mode (for Falcon mode)
-
-		CONFIG_SYS_MMCSD_RAW_MODE_ARGS_SECTOR,
-		CONFIG_SYS_MMCSD_RAW_MODE_ARGS_SECTORS
-		Sector and number of sectors to load kernel argument
-		parameters from when MMC is being used in raw mode
-		(for falcon mode)
-
-		CONFIG_SYS_MMCSD_FS_BOOT_PARTITION
-		Partition on the MMC to load U-Boot from when the MMC is being
-		used in fs mode
-
-		CONFIG_SPL_FAT_SUPPORT
-		Support for fs/fat/libfat.o in SPL binary
-
-		CONFIG_SPL_EXT_SUPPORT
-		Support for EXT filesystem in SPL binary
-
-		CONFIG_SPL_FS_LOAD_PAYLOAD_NAME
-		Filename to read to load U-Boot when reading from filesystem
-
-		CONFIG_SPL_FS_LOAD_KERNEL_NAME
-		Filename to read to load kernel uImage when reading
-		from filesystem (for Falcon mode)
-
-		CONFIG_SPL_FS_LOAD_ARGS_NAME
-		Filename to read to load kernel argument parameters
-		when reading from filesystem (for Falcon mode)
-
-		CONFIG_SPL_MPC83XX_WAIT_FOR_NAND
-		Set this for NAND SPL on PPC mpc83xx targets, so that
-		start.S waits for the rest of the SPL to load before
-		continuing (the hardware starts execution after just
-		loading the first page rather than the full 4K).
-
-		CONFIG_SPL_SKIP_RELOCATE
-		Avoid SPL relocation
-
-		CONFIG_SPL_NAND_BASE
-		Include nand_base.c in the SPL.  Requires
-		CONFIG_SPL_NAND_DRIVERS.
-
-		CONFIG_SPL_NAND_DRIVERS
-		SPL uses normal NAND drivers, not minimal drivers.
-
-		CONFIG_SPL_NAND_ECC
-		Include standard software ECC in the SPL
-
-		CONFIG_SPL_NAND_SIMPLE
-		Support for NAND boot using simple NAND drivers that
-		expose the cmd_ctrl() interface.
-
-		CONFIG_SPL_MTD_SUPPORT
-		Support for the MTD subsystem within SPL.  Useful for
-		environment on NAND support within SPL.
-
-		CONFIG_SPL_NAND_RAW_ONLY
-		Support to boot only raw u-boot.bin images. Use this only
-		if you need to save space.
-
-		CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
-		Set for the SPL on PPC mpc8xxx targets, support for
-		drivers/ddr/fsl/libddr.o in SPL binary.
-
-		CONFIG_SPL_COMMON_INIT_DDR
-		Set for common ddr init with serial presence detect in
-		SPL binary.
-
-		CONFIG_SYS_NAND_5_ADDR_CYCLE, CONFIG_SYS_NAND_PAGE_COUNT,
-		CONFIG_SYS_NAND_PAGE_SIZE, CONFIG_SYS_NAND_OOBSIZE,
-		CONFIG_SYS_NAND_BLOCK_SIZE, CONFIG_SYS_NAND_BAD_BLOCK_POS,
-		CONFIG_SYS_NAND_ECCPOS, CONFIG_SYS_NAND_ECCSIZE,
-		CONFIG_SYS_NAND_ECCBYTES
-		Defines the size and behavior of the NAND that SPL uses
-		to read U-Boot
-
-		CONFIG_SPL_NAND_BOOT
-		Add support NAND boot
-
-		CONFIG_SYS_NAND_U_BOOT_OFFS
-		Location in NAND to read U-Boot from
-
-		CONFIG_SYS_NAND_U_BOOT_DST
-		Location in memory to load U-Boot to
-
-		CONFIG_SYS_NAND_U_BOOT_SIZE
-		Size of image to load
-
-		CONFIG_SYS_NAND_U_BOOT_START
-		Entry point in loaded image to jump to
-
-		CONFIG_SYS_NAND_HW_ECC_OOBFIRST
-		Define this if you need to first read the OOB and then the
-		data. This is used, for example, on davinci platforms.
-
-		CONFIG_SPL_OMAP3_ID_NAND
-		Support for an OMAP3-specific set of functions to return the
-		ID and MFR of the first attached NAND chip, if present.
-
-		CONFIG_SPL_SERIAL_SUPPORT
-		Support for drivers/serial/libserial.o in SPL binary
-
-		CONFIG_SPL_SPI_FLASH_SUPPORT
-		Support for drivers/mtd/spi/libspi_flash.o in SPL binary
-
-		CONFIG_SPL_SPI_SUPPORT
-		Support for drivers/spi/libspi.o in SPL binary
-
-		CONFIG_SPL_RAM_DEVICE
-		Support for running image already present in ram, in SPL binary
-
-		CONFIG_SPL_LIBGENERIC_SUPPORT
-		Support for lib/libgeneric.o in SPL binary
-
-		CONFIG_SPL_ENV_SUPPORT
-		Support for the environment operating in SPL binary
-
-		CONFIG_SPL_NET_SUPPORT
-		Support for the net/libnet.o in SPL binary.
-		It conflicts with SPL env from storage medium specified by
-		CONFIG_ENV_IS_xxx but CONFIG_ENV_IS_NOWHERE
-
-		CONFIG_SPL_PAD_TO
-		Image offset to which the SPL should be padded before appending
-		the SPL payload. By default, this is defined as
-		CONFIG_SPL_MAX_SIZE, or 0 if CONFIG_SPL_MAX_SIZE is undefined.
-		CONFIG_SPL_PAD_TO must be either 0, meaning to append the SPL
-		payload without any padding, or >= CONFIG_SPL_MAX_SIZE.
-
-		CONFIG_SPL_TARGET
-		Final target image containing SPL and payload.  Some SPLs
-		use an arch-specific makefile fragment instead, for
-		example if more than one image needs to be produced.
-
-		CONFIG_FIT_SPL_PRINT
-		Printing information about a FIT image adds quite a bit of
-		code to SPL. So this is normally disabled in SPL. Use this
-		option to re-enable it. This will affect the output of the
-		bootm command when booting a FIT image.
-
-- TPL framework
-		CONFIG_TPL
-		Enable building of TPL globally.
-
-		CONFIG_TPL_PAD_TO
-		Image offset to which the TPL should be padded before appending
-		the TPL payload. By default, this is defined as
-		CONFIG_SPL_MAX_SIZE, or 0 if CONFIG_SPL_MAX_SIZE is undefined.
-		CONFIG_SPL_PAD_TO must be either 0, meaning to append the SPL
-		payload without any padding, or >= CONFIG_SPL_MAX_SIZE.
-
-- Interrupt support (PPC):
-
-		There are common interrupt_init() and timer_interrupt()
-		for all PPC archs. interrupt_init() calls interrupt_init_cpu()
-		for CPU specific initialization. interrupt_init_cpu()
-		should set decrementer_count to appropriate value. If
-		CPU resets decrementer automatically after interrupt
-		(ppc4xx) it should set decrementer_count to zero.
-		timer_interrupt() calls timer_interrupt_cpu() for CPU
-		specific handling. If board has watchdog / status_led
-		/ other_activity_monitor it works automatically from
-		general timer_interrupt().
-
-
-Board initialization settings:
-------------------------------
-
-During Initialization u-boot calls a number of board specific functions
-to allow the preparation of board specific prerequisites, e.g. pin setup
-before drivers are initialized. To enable these callbacks the
-following configuration macros have to be defined. Currently this is
-architecture specific, so please check arch/your_architecture/lib/board.c
-typically in board_init_f() and board_init_r().
-
-- CONFIG_BOARD_EARLY_INIT_F: Call board_early_init_f()
-- CONFIG_BOARD_EARLY_INIT_R: Call board_early_init_r()
-- CONFIG_BOARD_LATE_INIT: Call board_late_init()
-- CONFIG_BOARD_POSTCLK_INIT: Call board_postclk_init()
-
-Configuration Settings:
------------------------
-
-- CONFIG_SYS_SUPPORT_64BIT_DATA: Defined automatically if compiled as 64-bit.
-		Optionally it can be defined to support 64-bit memory commands.
-
-- CONFIG_SYS_LONGHELP: Defined when you want long help messages included;
-		undefine this when you're short of memory.
-
-- CONFIG_SYS_HELP_CMD_WIDTH: Defined when you want to override the default
-		width of the commands listed in the 'help' command output.
-
-- CONFIG_SYS_PROMPT:	This is what U-Boot prints on the console to
-		prompt for user input.
-
-- CONFIG_SYS_CBSIZE:	Buffer size for input from the Console
-
-- CONFIG_SYS_PBSIZE:	Buffer size for Console output
-
-- CONFIG_SYS_MAXARGS:	max. Number of arguments accepted for monitor commands
-
-- CONFIG_SYS_BARGSIZE: Buffer size for Boot Arguments which are passed to
-		the application (usually a Linux kernel) when it is
-		booted
-
-- CONFIG_SYS_BAUDRATE_TABLE:
-		List of legal baudrate settings for this board.
-
-- CONFIG_SYS_CONSOLE_INFO_QUIET
-		Suppress display of console information at boot.
-
-- CONFIG_SYS_CONSOLE_IS_IN_ENV
-		If the board specific function
-			extern int overwrite_console (void);
-		returns 1, the stdin, stderr and stdout are switched to the
-		serial port, else the settings in the environment are used.
-
-- CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
-		Enable the call to overwrite_console().
-
-- CONFIG_SYS_CONSOLE_ENV_OVERWRITE
-		Enable overwrite of previous console environment settings.
-
-- CONFIG_SYS_MEMTEST_START, CONFIG_SYS_MEMTEST_END:
-		Begin and End addresses of the area used by the
-		simple memory test.
-
-- CONFIG_SYS_ALT_MEMTEST:
-		Enable an alternate, more extensive memory test.
-
-- CONFIG_SYS_MEMTEST_SCRATCH:
-		Scratch address used by the alternate memory test
-		You only need to set this if address zero isn't writeable
-
-- CONFIG_SYS_MEM_RESERVE_SECURE
-		If defined, the size of CONFIG_SYS_MEM_RESERVE_SECURE memory
-		is substracted from total RAM and won't be reported to OS.
-		This memory can be used as secure memory. A variable
-		gd->secure_ram is used to track the location. In systems
-		the RAM base is not zero, or RAM is divided into banks,
-		this variable needs to be recalcuated to get the address.
-
-- CONFIG_SYS_MEM_TOP_HIDE:
-		If CONFIG_SYS_MEM_TOP_HIDE is defined in the board config header,
-		this specified memory area will get subtracted from the top
-		(end) of RAM and won't get "touched" at all by U-Boot. By
-		fixing up gd->ram_size the Linux kernel should gets passed
-		the now "corrected" memory size and won't touch it either.
-		This should work for arch/ppc and arch/powerpc. Only Linux
-		board ports in arch/powerpc with bootwrapper support that
-		recalculate the memory size from the SDRAM controller setup
-		will have to get fixed in Linux additionally.
-
-		This option can be used as a workaround for the 440EPx/GRx
-		CHIP 11 errata where the last 256 bytes in SDRAM shouldn't
-		be touched.
-
-		WARNING: Please make sure that this value is a multiple of
-		the Linux page size (normally 4k). If this is not the case,
-		then the end address of the Linux memory will be located at a
-		non page size aligned address and this could cause major
-		problems.
-
-- CONFIG_SYS_LOADS_BAUD_CHANGE:
-		Enable temporary baudrate change while serial download
-
-- CONFIG_SYS_SDRAM_BASE:
-		Physical start address of SDRAM. _Must_ be 0 here.
-
-- CONFIG_SYS_MBIO_BASE:
-		Physical start address of Motherboard I/O (if using a
-		Cogent motherboard)
-
-- CONFIG_SYS_FLASH_BASE:
-		Physical start address of Flash memory.
-
-- CONFIG_SYS_MONITOR_BASE:
-		Physical start address of boot monitor code (set by
-		make config files to be same as the text base address
-		(CONFIG_SYS_TEXT_BASE) used when linking) - same as
-		CONFIG_SYS_FLASH_BASE when booting from flash.
-
-- CONFIG_SYS_MONITOR_LEN:
-		Size of memory reserved for monitor code, used to
-		determine _at_compile_time_ (!) if the environment is
-		embedded within the U-Boot image, or in a separate
-		flash sector.
-
-- CONFIG_SYS_MALLOC_LEN:
-		Size of DRAM reserved for malloc() use.
-
-- CONFIG_SYS_MALLOC_F_LEN
-		Size of the malloc() pool for use before relocation. If
-		this is defined, then a very simple malloc() implementation
-		will become available before relocation. The address is just
-		below the global data, and the stack is moved down to make
-		space.
-
-		This feature allocates regions with increasing addresses
-		within the region. calloc() is supported, but realloc()
-		is not available. free() is supported but does nothing.
-		The memory will be freed (or in fact just forgotten) when
-		U-Boot relocates itself.
-
-		Pre-relocation malloc() is only supported on ARM and sandbox
-		at present but is fairly easy to enable for other archs.
-
-- CONFIG_SYS_MALLOC_SIMPLE
-		Provides a simple and small malloc() and calloc() for those
-		boards which do not use the full malloc in SPL (which is
-		enabled with CONFIG_SYS_SPL_MALLOC_START).
-
-- CONFIG_SYS_NONCACHED_MEMORY:
-		Size of non-cached memory area. This area of memory will be
-		typically located right below the malloc() area and mapped
-		uncached in the MMU. This is useful for drivers that would
-		otherwise require a lot of explicit cache maintenance. For
-		some drivers it's also impossible to properly maintain the
-		cache. For example if the regions that need to be flushed
-		are not a multiple of the cache-line size, *and* padding
-		cannot be allocated between the regions to align them (i.e.
-		if the HW requires a contiguous array of regions, and the
-		size of each region is not cache-aligned), then a flush of
-		one region may result in overwriting data that hardware has
-		written to another region in the same cache-line. This can
-		happen for example in network drivers where descriptors for
-		buffers are typically smaller than the CPU cache-line (e.g.
-		16 bytes vs. 32 or 64 bytes).
-
-		Non-cached memory is only supported on 32-bit ARM at present.
-
-- CONFIG_SYS_BOOTM_LEN:
-		Normally compressed uImages are limited to an
-		uncompressed size of 8 MBytes. If this is not enough,
-		you can define CONFIG_SYS_BOOTM_LEN in your board config file
-		to adjust this setting to your needs.
-
-- CONFIG_SYS_BOOTMAPSZ:
-		Maximum size of memory mapped by the startup code of
-		the Linux kernel; all data that must be processed by
-		the Linux kernel (bd_info, boot arguments, FDT blob if
-		used) must be put below this limit, unless "bootm_low"
-		environment variable is defined and non-zero. In such case
-		all data for the Linux kernel must be between "bootm_low"
-		and "bootm_low" + CONFIG_SYS_BOOTMAPSZ.	 The environment
-		variable "bootm_mapsize" will override the value of
-		CONFIG_SYS_BOOTMAPSZ.  If CONFIG_SYS_BOOTMAPSZ is undefined,
-		then the value in "bootm_size" will be used instead.
-
-- CONFIG_SYS_BOOT_RAMDISK_HIGH:
-		Enable initrd_high functionality.  If defined then the
-		initrd_high feature is enabled and the bootm ramdisk subcommand
-		is enabled.
-
-- CONFIG_SYS_BOOT_GET_CMDLINE:
-		Enables allocating and saving kernel cmdline in space between
-		"bootm_low" and "bootm_low" + BOOTMAPSZ.
-
-- CONFIG_SYS_BOOT_GET_KBD:
-		Enables allocating and saving a kernel copy of the bd_info in
-		space between "bootm_low" and "bootm_low" + BOOTMAPSZ.
-
-- CONFIG_SYS_MAX_FLASH_BANKS:
-		Max number of Flash memory banks
-
-- CONFIG_SYS_MAX_FLASH_SECT:
-		Max number of sectors on a Flash chip
-
-- CONFIG_SYS_FLASH_ERASE_TOUT:
-		Timeout for Flash erase operations (in ms)
-
-- CONFIG_SYS_FLASH_WRITE_TOUT:
-		Timeout for Flash write operations (in ms)
-
-- CONFIG_SYS_FLASH_LOCK_TOUT
-		Timeout for Flash set sector lock bit operation (in ms)
-
-- CONFIG_SYS_FLASH_UNLOCK_TOUT
-		Timeout for Flash clear lock bits operation (in ms)
-
-- CONFIG_SYS_FLASH_PROTECTION
-		If defined, hardware flash sectors protection is used
-		instead of U-Boot software protection.
-
-- CONFIG_SYS_DIRECT_FLASH_TFTP:
-
-		Enable TFTP transfers directly to flash memory;
-		without this option such a download has to be
-		performed in two steps: (1) download to RAM, and (2)
-		copy from RAM to flash.
-
-		The two-step approach is usually more reliable, since
-		you can check if the download worked before you erase
-		the flash, but in some situations (when system RAM is
-		too limited to allow for a temporary copy of the
-		downloaded image) this option may be very useful.
-
-- CONFIG_SYS_FLASH_CFI:
-		Define if the flash driver uses extra elements in the
-		common flash structure for storing flash geometry.
-
-- CONFIG_FLASH_CFI_DRIVER
-		This option also enables the building of the cfi_flash driver
-		in the drivers directory
-
-- CONFIG_FLASH_CFI_MTD
-		This option enables the building of the cfi_mtd driver
-		in the drivers directory. The driver exports CFI flash
-		to the MTD layer.
-
-- CONFIG_SYS_FLASH_USE_BUFFER_WRITE
-		Use buffered writes to flash.
-
-- CONFIG_FLASH_SPANSION_S29WS_N
-		s29ws-n MirrorBit flash has non-standard addresses for buffered
-		write commands.
-
-- CONFIG_SYS_FLASH_QUIET_TEST
-		If this option is defined, the common CFI flash doesn't
-		print it's warning upon not recognized FLASH banks. This
-		is useful, if some of the configured banks are only
-		optionally available.
-
-- CONFIG_FLASH_SHOW_PROGRESS
-		If defined (must be an integer), print out countdown
-		digits and dots.  Recommended value: 45 (9..1) for 80
-		column displays, 15 (3..1) for 40 column displays.
-
-- CONFIG_FLASH_VERIFY
-		If defined, the content of the flash (destination) is compared
-		against the source after the write operation. An error message
-		will be printed when the contents are not identical.
-		Please note that this option is useless in nearly all cases,
-		since such flash programming errors usually are detected earlier
-		while unprotecting/erasing/programming. Please only enable
-		this option if you really know what you are doing.
-
-- CONFIG_SYS_RX_ETH_BUFFER:
-		Defines the number of Ethernet receive buffers. On some
-		Ethernet controllers it is recommended to set this value
-		to 8 or even higher (EEPRO100 or 405 EMAC), since all
-		buffers can be full shortly after enabling the interface
-		on high Ethernet traffic.
-		Defaults to 4 if not defined.
-
-- CONFIG_ENV_MAX_ENTRIES
-
-	Maximum number of entries in the hash table that is used
-	internally to store the environment settings. The default
-	setting is supposed to be generous and should work in most
-	cases. This setting can be used to tune behaviour; see
-	lib/hashtable.c for details.
-
-- CONFIG_ENV_FLAGS_LIST_DEFAULT
-- CONFIG_ENV_FLAGS_LIST_STATIC
-	Enable validation of the values given to environment variables when
-	calling env set.  Variables can be restricted to only decimal,
-	hexadecimal, or boolean.  If CONFIG_CMD_NET is also defined,
-	the variables can also be restricted to IP address or MAC address.
-
-	The format of the list is:
-		type_attribute = [s|d|x|b|i|m]
-		access_attribute = [a|r|o|c]
-		attributes = type_attribute[access_attribute]
-		entry = variable_name[:attributes]
-		list = entry[,list]
-
-	The type attributes are:
-		s - String (default)
-		d - Decimal
-		x - Hexadecimal
-		b - Boolean ([1yYtT|0nNfF])
-		i - IP address
-		m - MAC address
-
-	The access attributes are:
-		a - Any (default)
-		r - Read-only
-		o - Write-once
-		c - Change-default
-
-	- CONFIG_ENV_FLAGS_LIST_DEFAULT
-		Define this to a list (string) to define the ".flags"
-		environment variable in the default or embedded environment.
-
-	- CONFIG_ENV_FLAGS_LIST_STATIC
-		Define this to a list (string) to define validation that
-		should be done if an entry is not found in the ".flags"
-		environment variable.  To override a setting in the static
-		list, simply add an entry for the same variable name to the
-		".flags" variable.
-
-	If CONFIG_REGEX is defined, the variable_name above is evaluated as a
-	regular expression. This allows multiple variables to define the same
-	flags without explicitly listing them for each variable.
-
-- CONFIG_ENV_ACCESS_IGNORE_FORCE
-	If defined, don't allow the -f switch to env set override variable
-	access flags.
-
-- CONFIG_SYS_GENERIC_BOARD
-	This selects the architecture-generic board system instead of the
-	architecture-specific board files. It is intended to move boards
-	to this new framework over time. Defining this will disable the
-	arch/foo/lib/board.c file and use common/board_f.c and
-	common/board_r.c instead. To use this option your architecture
-	must support it (i.e. must select HAVE_GENERIC_BOARD in arch/Kconfig).
-	If you find problems enabling this option on your board please report
-	the problem and send patches!
-
-- CONFIG_OMAP_PLATFORM_RESET_TIME_MAX_USEC (OMAP only)
-	This is set by OMAP boards for the max time that reset should
-	be asserted. See doc/README.omap-reset-time for details on how
-	the value can be calculated on a given board.
-
-- CONFIG_USE_STDINT
-	If stdint.h is available with your toolchain you can define this
-	option to enable it. You can provide option 'USE_STDINT=1' when
-	building U-Boot to enable this.
-
-The following definitions that deal with the placement and management
-of environment data (variable area); in general, we support the
-following configurations:
-
-- CONFIG_BUILD_ENVCRC:
-
-	Builds up envcrc with the target environment so that external utils
-	may easily extract it and embed it in final U-Boot images.
-
-- CONFIG_ENV_IS_IN_FLASH:
-
-	Define this if the environment is in flash memory.
-
-	a) The environment occupies one whole flash sector, which is
-	   "embedded" in the text segment with the U-Boot code. This
-	   happens usually with "bottom boot sector" or "top boot
-	   sector" type flash chips, which have several smaller
-	   sectors at the start or the end. For instance, such a
-	   layout can have sector sizes of 8, 2x4, 16, Nx32 kB. In
-	   such a case you would place the environment in one of the
-	   4 kB sectors - with U-Boot code before and after it. With
-	   "top boot sector" type flash chips, you would put the
-	   environment in one of the last sectors, leaving a gap
-	   between U-Boot and the environment.
-
-	- CONFIG_ENV_OFFSET:
-
-	   Offset of environment data (variable area) to the
-	   beginning of flash memory; for instance, with bottom boot
-	   type flash chips the second sector can be used: the offset
-	   for this sector is given here.
-
-	   CONFIG_ENV_OFFSET is used relative to CONFIG_SYS_FLASH_BASE.
-
-	- CONFIG_ENV_ADDR:
-
-	   This is just another way to specify the start address of
-	   the flash sector containing the environment (instead of
-	   CONFIG_ENV_OFFSET).
-
-	- CONFIG_ENV_SECT_SIZE:
-
-	   Size of the sector containing the environment.
-
-
-	b) Sometimes flash chips have few, equal sized, BIG sectors.
-	   In such a case you don't want to spend a whole sector for
-	   the environment.
-
-	- CONFIG_ENV_SIZE:
-
-	   If you use this in combination with CONFIG_ENV_IS_IN_FLASH
-	   and CONFIG_ENV_SECT_SIZE, you can specify to use only a part
-	   of this flash sector for the environment. This saves
-	   memory for the RAM copy of the environment.
-
-	   It may also save flash memory if you decide to use this
-	   when your environment is "embedded" within U-Boot code,
-	   since then the remainder of the flash sector could be used
-	   for U-Boot code. It should be pointed out that this is
-	   STRONGLY DISCOURAGED from a robustness point of view:
-	   updating the environment in flash makes it always
-	   necessary to erase the WHOLE sector. If something goes
-	   wrong before the contents has been restored from a copy in
-	   RAM, your target system will be dead.
-
-	- CONFIG_ENV_ADDR_REDUND
-	  CONFIG_ENV_SIZE_REDUND
-
-	   These settings describe a second storage area used to hold
-	   a redundant copy of the environment data, so that there is
-	   a valid backup copy in case there is a power failure during
-	   a "saveenv" operation.
-
-BE CAREFUL! Any changes to the flash layout, and some changes to the
-source code will make it necessary to adapt <board>/u-boot.lds*
-accordingly!
-
-
-- CONFIG_ENV_IS_IN_NVRAM:
-
-	Define this if you have some non-volatile memory device
-	(NVRAM, battery buffered SRAM) which you want to use for the
-	environment.
-
-	- CONFIG_ENV_ADDR:
-	- CONFIG_ENV_SIZE:
-
-	  These two #defines are used to determine the memory area you
-	  want to use for environment. It is assumed that this memory
-	  can just be read and written to, without any special
-	  provision.
-
-BE CAREFUL! The first access to the environment happens quite early
-in U-Boot initialization (when we try to get the setting of for the
-console baudrate). You *MUST* have mapped your NVRAM area then, or
-U-Boot will hang.
-
-Please note that even with NVRAM we still use a copy of the
-environment in RAM: we could work on NVRAM directly, but we want to
-keep settings there always unmodified except somebody uses "saveenv"
-to save the current settings.
-
-
-- CONFIG_ENV_IS_IN_EEPROM:
-
-	Use this if you have an EEPROM or similar serial access
-	device and a driver for it.
-
-	- CONFIG_ENV_OFFSET:
-	- CONFIG_ENV_SIZE:
-
-	  These two #defines specify the offset and size of the
-	  environment area within the total memory of your EEPROM.
-
-	- CONFIG_SYS_I2C_EEPROM_ADDR:
-	  If defined, specified the chip address of the EEPROM device.
-	  The default address is zero.
-
-	- CONFIG_SYS_I2C_EEPROM_BUS:
-	  If defined, specified the i2c bus of the EEPROM device.
-
-	- CONFIG_SYS_EEPROM_PAGE_WRITE_BITS:
-	  If defined, the number of bits used to address bytes in a
-	  single page in the EEPROM device.  A 64 byte page, for example
-	  would require six bits.
-
-	- CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS:
-	  If defined, the number of milliseconds to delay between
-	  page writes.	The default is zero milliseconds.
-
-	- CONFIG_SYS_I2C_EEPROM_ADDR_LEN:
-	  The length in bytes of the EEPROM memory array address.  Note
-	  that this is NOT the chip address length!
-
-	- CONFIG_SYS_I2C_EEPROM_ADDR_OVERFLOW:
-	  EEPROM chips that implement "address overflow" are ones
-	  like Catalyst 24WC04/08/16 which has 9/10/11 bits of
-	  address and the extra bits end up in the "chip address" bit
-	  slots. This makes a 24WC08 (1Kbyte) chip look like four 256
-	  byte chips.
-
-	  Note that we consider the length of the address field to
-	  still be one byte because the extra address bits are hidden
-	  in the chip address.
-
-	- CONFIG_SYS_EEPROM_SIZE:
-	  The size in bytes of the EEPROM device.
-
-	- CONFIG_ENV_EEPROM_IS_ON_I2C
-	  define this, if you have I2C and SPI activated, and your
-	  EEPROM, which holds the environment, is on the I2C bus.
-
-	- CONFIG_I2C_ENV_EEPROM_BUS
-	  if you have an Environment on an EEPROM reached over
-	  I2C muxes, you can define here, how to reach this
-	  EEPROM. For example:
-
-	  #define CONFIG_I2C_ENV_EEPROM_BUS	  1
-
-	  EEPROM which holds the environment, is reached over
-	  a pca9547 i2c mux with address 0x70, channel 3.
-
-- CONFIG_ENV_IS_IN_DATAFLASH:
-
-	Define this if you have a DataFlash memory device which you
-	want to use for the environment.
-
-	- CONFIG_ENV_OFFSET:
-	- CONFIG_ENV_ADDR:
-	- CONFIG_ENV_SIZE:
-
-	  These three #defines specify the offset and size of the
-	  environment area within the total memory of your DataFlash placed
-	  at the specified address.
-
-- CONFIG_ENV_IS_IN_SPI_FLASH:
-
-	Define this if you have a SPI Flash memory device which you
-	want to use for the environment.
-
-	- CONFIG_ENV_OFFSET:
-	- CONFIG_ENV_SIZE:
-
-	  These two #defines specify the offset and size of the
-	  environment area within the SPI Flash. CONFIG_ENV_OFFSET must be
-	  aligned to an erase sector boundary.
-
-	- CONFIG_ENV_SECT_SIZE:
-
-	  Define the SPI flash's sector size.
-
-	- CONFIG_ENV_OFFSET_REDUND (optional):
-
-	  This setting describes a second storage area of CONFIG_ENV_SIZE
-	  size used to hold a redundant copy of the environment data, so
-	  that there is a valid backup copy in case there is a power failure
-	  during a "saveenv" operation. CONFIG_ENV_OFFSET_RENDUND must be
-	  aligned to an erase sector boundary.
-
-	- CONFIG_ENV_SPI_BUS (optional):
-	- CONFIG_ENV_SPI_CS (optional):
-
-	  Define the SPI bus and chip select. If not defined they will be 0.
-
-	- CONFIG_ENV_SPI_MAX_HZ (optional):
-
-	  Define the SPI max work clock. If not defined then use 1MHz.
-
-	- CONFIG_ENV_SPI_MODE (optional):
-
-	  Define the SPI work mode. If not defined then use SPI_MODE_3.
-
-- CONFIG_ENV_IS_IN_REMOTE:
-
-	Define this if you have a remote memory space which you
-	want to use for the local device's environment.
-
-	- CONFIG_ENV_ADDR:
-	- CONFIG_ENV_SIZE:
-
-	  These two #defines specify the address and size of the
-	  environment area within the remote memory space. The
-	  local device can get the environment from remote memory
-	  space by SRIO or PCIE links.
-
-BE CAREFUL! For some special cases, the local device can not use
-"saveenv" command. For example, the local device will get the
-environment stored in a remote NOR flash by SRIO or PCIE link,
-but it can not erase, write this NOR flash by SRIO or PCIE interface.
-
-- CONFIG_ENV_IS_IN_NAND:
-
-	Define this if you have a NAND device which you want to use
-	for the environment.
-
-	- CONFIG_ENV_OFFSET:
-	- CONFIG_ENV_SIZE:
-
-	  These two #defines specify the offset and size of the environment
-	  area within the first NAND device.  CONFIG_ENV_OFFSET must be
-	  aligned to an erase block boundary.
-
-	- CONFIG_ENV_OFFSET_REDUND (optional):
-
-	  This setting describes a second storage area of CONFIG_ENV_SIZE
-	  size used to hold a redundant copy of the environment data, so
-	  that there is a valid backup copy in case there is a power failure
-	  during a "saveenv" operation.	 CONFIG_ENV_OFFSET_RENDUND must be
-	  aligned to an erase block boundary.
-
-	- CONFIG_ENV_RANGE (optional):
-
-	  Specifies the length of the region in which the environment
-	  can be written.  This should be a multiple of the NAND device's
-	  block size.  Specifying a range with more erase blocks than
-	  are needed to hold CONFIG_ENV_SIZE allows bad blocks within
-	  the range to be avoided.
-
-	- CONFIG_ENV_OFFSET_OOB (optional):
-
-	  Enables support for dynamically retrieving the offset of the
-	  environment from block zero's out-of-band data.  The
-	  "nand env.oob" command can be used to record this offset.
-	  Currently, CONFIG_ENV_OFFSET_REDUND is not supported when
-	  using CONFIG_ENV_OFFSET_OOB.
-
-- CONFIG_NAND_ENV_DST
-
-	Defines address in RAM to which the nand_spl code should copy the
-	environment. If redundant environment is used, it will be copied to
-	CONFIG_NAND_ENV_DST + CONFIG_ENV_SIZE.
-
-- CONFIG_ENV_IS_IN_UBI:
-
-	Define this if you have an UBI volume that you want to use for the
-	environment.  This has the benefit of wear-leveling the environment
-	accesses, which is important on NAND.
-
-	- CONFIG_ENV_UBI_PART:
-
-	  Define this to a string that is the mtd partition containing the UBI.
-
-	- CONFIG_ENV_UBI_VOLUME:
-
-	  Define this to the name of the volume that you want to store the
-	  environment in.
-
-	- CONFIG_ENV_UBI_VOLUME_REDUND:
-
-	  Define this to the name of another volume to store a second copy of
-	  the environment in.  This will enable redundant environments in UBI.
-	  It is assumed that both volumes are in the same MTD partition.
-
-	- CONFIG_UBI_SILENCE_MSG
-	- CONFIG_UBIFS_SILENCE_MSG
-
-	  You will probably want to define these to avoid a really noisy system
-	  when storing the env in UBI.
-
-- CONFIG_ENV_IS_IN_FAT:
-       Define this if you want to use the FAT file system for the environment.
-
-       - FAT_ENV_INTERFACE:
-
-         Define this to a string that is the name of the block device.
-
-       - FAT_ENV_DEV_AND_PART:
-
-         Define this to a string to specify the partition of the device. It can
-         be as following:
-
-           "D:P", "D:0", "D", "D:" or "D:auto" (D, P are integers. And P >= 1)
-               - "D:P": device D partition P. Error occurs if device D has no
-                        partition table.
-               - "D:0": device D.
-               - "D" or "D:": device D partition 1 if device D has partition
-                              table, or the whole device D if has no partition
-                              table.
-               - "D:auto": first partition in device D with bootable flag set.
-                           If none, first valid partition in device D. If no
-                           partition table then means device D.
-
-       - FAT_ENV_FILE:
-
-         It's a string of the FAT file name. This file use to store the
-         environment.
-
-       - CONFIG_FAT_WRITE:
-         This should be defined. Otherwise it cannot save the environment file.
-
-- CONFIG_ENV_IS_IN_MMC:
-
-	Define this if you have an MMC device which you want to use for the
-	environment.
-
-	- CONFIG_SYS_MMC_ENV_DEV:
-
-	  Specifies which MMC device the environment is stored in.
-
-	- CONFIG_SYS_MMC_ENV_PART (optional):
-
-	  Specifies which MMC partition the environment is stored in. If not
-	  set, defaults to partition 0, the user area. Common values might be
-	  1 (first MMC boot partition), 2 (second MMC boot partition).
-
-	- CONFIG_ENV_OFFSET:
-	- CONFIG_ENV_SIZE:
-
-	  These two #defines specify the offset and size of the environment
-	  area within the specified MMC device.
-
-	  If offset is positive (the usual case), it is treated as relative to
-	  the start of the MMC partition. If offset is negative, it is treated
-	  as relative to the end of the MMC partition. This can be useful if
-	  your board may be fitted with different MMC devices, which have
-	  different sizes for the MMC partitions, and you always want the
-	  environment placed at the very end of the partition, to leave the
-	  maximum possible space before it, to store other data.
-
-	  These two values are in units of bytes, but must be aligned to an
-	  MMC sector boundary.
-
-	- CONFIG_ENV_OFFSET_REDUND (optional):
-
-	  Specifies a second storage area, of CONFIG_ENV_SIZE size, used to
-	  hold a redundant copy of the environment data. This provides a
-	  valid backup copy in case the other copy is corrupted, e.g. due
-	  to a power failure during a "saveenv" operation.
-
-	  This value may also be positive or negative; this is handled in the
-	  same way as CONFIG_ENV_OFFSET.
-
-	  This value is also in units of bytes, but must also be aligned to
-	  an MMC sector boundary.
-
-	- CONFIG_ENV_SIZE_REDUND (optional):
-
-	  This value need not be set, even when CONFIG_ENV_OFFSET_REDUND is
-	  set. If this value is set, it must be set to the same value as
-	  CONFIG_ENV_SIZE.
-
-- CONFIG_SYS_SPI_INIT_OFFSET
-
-	Defines offset to the initial SPI buffer area in DPRAM. The
-	area is used at an early stage (ROM part) if the environment
-	is configured to reside in the SPI EEPROM: We need a 520 byte
-	scratch DPRAM area. It is used between the two initialization
-	calls (spi_init_f() and spi_init_r()). A value of 0xB00 seems
-	to be a good choice since it makes it far enough from the
-	start of the data area as well as from the stack pointer.
-
-Please note that the environment is read-only until the monitor
-has been relocated to RAM and a RAM copy of the environment has been
-created; also, when using EEPROM you will have to use getenv_f()
-until then to read environment variables.
-
-The environment is protected by a CRC32 checksum. Before the monitor
-is relocated into RAM, as a result of a bad CRC you will be working
-with the compiled-in default environment - *silently*!!! [This is
-necessary, because the first environment variable we need is the
-"baudrate" setting for the console - if we have a bad CRC, we don't
-have any device yet where we could complain.]
-
-Note: once the monitor has been relocated, then it will complain if
-the default environment is used; a new CRC is computed as soon as you
-use the "saveenv" command to store a valid environment.
-
-- CONFIG_SYS_FAULT_ECHO_LINK_DOWN:
-		Echo the inverted Ethernet link state to the fault LED.
-
-		Note: If this option is active, then CONFIG_SYS_FAULT_MII_ADDR
-		      also needs to be defined.
-
-- CONFIG_SYS_FAULT_MII_ADDR:
-		MII address of the PHY to check for the Ethernet link state.
-
-- CONFIG_NS16550_MIN_FUNCTIONS:
-		Define this if you desire to only have use of the NS16550_init
-		and NS16550_putc functions for the serial driver located at
-		drivers/serial/ns16550.c.  This option is useful for saving
-		space for already greatly restricted images, including but not
-		limited to NAND_SPL configurations.
-
-- CONFIG_DISPLAY_BOARDINFO
-		Display information about the board that U-Boot is running on
-		when U-Boot starts up. The board function checkboard() is called
-		to do this.
-
-- CONFIG_DISPLAY_BOARDINFO_LATE
-		Similar to the previous option, but display this information
-		later, once stdio is running and output goes to the LCD, if
-		present.
-
-- CONFIG_BOARD_SIZE_LIMIT:
-		Maximum size of the U-Boot image. When defined, the
-		build system checks that the actual size does not
-		exceed it.
-
-Low Level (hardware related) configuration options:
----------------------------------------------------
-
-- CONFIG_SYS_CACHELINE_SIZE:
-		Cache Line Size of the CPU.
-
-- CONFIG_SYS_DEFAULT_IMMR:
-		Default address of the IMMR after system reset.
-
-		Needed on some 8260 systems (MPC8260ADS, PQ2FADS-ZU,
-		and RPXsuper) to be able to adjust the position of
-		the IMMR register after a reset.
-
-- CONFIG_SYS_CCSRBAR_DEFAULT:
-		Default (power-on reset) physical address of CCSR on Freescale
-		PowerPC SOCs.
-
-- CONFIG_SYS_CCSRBAR:
-		Virtual address of CCSR.  On a 32-bit build, this is typically
-		the same value as CONFIG_SYS_CCSRBAR_DEFAULT.
-
-		CONFIG_SYS_DEFAULT_IMMR must also be set to this value,
-		for cross-platform code that uses that macro instead.
-
-- CONFIG_SYS_CCSRBAR_PHYS:
-		Physical address of CCSR.  CCSR can be relocated to a new
-		physical address, if desired.  In this case, this macro should
-		be set to that address.	 Otherwise, it should be set to the
-		same value as CONFIG_SYS_CCSRBAR_DEFAULT.  For example, CCSR
-		is typically relocated on 36-bit builds.  It is recommended
-		that this macro be defined via the _HIGH and _LOW macros:
-
-		#define CONFIG_SYS_CCSRBAR_PHYS ((CONFIG_SYS_CCSRBAR_PHYS_HIGH
-			* 1ull) << 32 | CONFIG_SYS_CCSRBAR_PHYS_LOW)
-
-- CONFIG_SYS_CCSRBAR_PHYS_HIGH:
-		Bits 33-36 of CONFIG_SYS_CCSRBAR_PHYS.	This value is typically
-		either 0 (32-bit build) or 0xF (36-bit build).	This macro is
-		used in assembly code, so it must not contain typecasts or
-		integer size suffixes (e.g. "ULL").
-
-- CONFIG_SYS_CCSRBAR_PHYS_LOW:
-		Lower 32-bits of CONFIG_SYS_CCSRBAR_PHYS.  This macro is
-		used in assembly code, so it must not contain typecasts or
-		integer size suffixes (e.g. "ULL").
-
-- CONFIG_SYS_CCSR_DO_NOT_RELOCATE:
-		If this macro is defined, then CONFIG_SYS_CCSRBAR_PHYS will be
-		forced to a value that ensures that CCSR is not relocated.
-
-- Floppy Disk Support:
-		CONFIG_SYS_FDC_DRIVE_NUMBER
-
-		the default drive number (default value 0)
-
-		CONFIG_SYS_ISA_IO_STRIDE
-
-		defines the spacing between FDC chipset registers
-		(default value 1)
-
-		CONFIG_SYS_ISA_IO_OFFSET
-
-		defines the offset of register from address. It
-		depends on which part of the data bus is connected to
-		the FDC chipset. (default value 0)
-
-		If CONFIG_SYS_ISA_IO_STRIDE CONFIG_SYS_ISA_IO_OFFSET and
-		CONFIG_SYS_FDC_DRIVE_NUMBER are undefined, they take their
-		default value.
-
-		if CONFIG_SYS_FDC_HW_INIT is defined, then the function
-		fdc_hw_init() is called at the beginning of the FDC
-		setup. fdc_hw_init() must be provided by the board
-		source code. It is used to make hardware-dependent
-		initializations.
-
-- CONFIG_IDE_AHB:
-		Most IDE controllers were designed to be connected with PCI
-		interface. Only few of them were designed for AHB interface.
-		When software is doing ATA command and data transfer to
-		IDE devices through IDE-AHB controller, some additional
-		registers accessing to these kind of IDE-AHB controller
-		is required.
-
-- CONFIG_SYS_IMMR:	Physical address of the Internal Memory.
-		DO NOT CHANGE unless you know exactly what you're
-		doing! (11-4) [MPC8xx/82xx systems only]
-
-- CONFIG_SYS_INIT_RAM_ADDR:
-
-		Start address of memory area that can be used for
-		initial data and stack; please note that this must be
-		writable memory that is working WITHOUT special
-		initialization, i. e. you CANNOT use normal RAM which
-		will become available only after programming the
-		memory controller and running certain initialization
-		sequences.
-
-		U-Boot uses the following memory types:
-		- MPC8xx and MPC8260: IMMR (internal memory of the CPU)
-		- MPC824X: data cache
-		- PPC4xx:  data cache
-
-- CONFIG_SYS_GBL_DATA_OFFSET:
-
-		Offset of the initial data structure in the memory
-		area defined by CONFIG_SYS_INIT_RAM_ADDR. Usually
-		CONFIG_SYS_GBL_DATA_OFFSET is chosen such that the initial
-		data is located at the end of the available space
-		(sometimes written as (CONFIG_SYS_INIT_RAM_SIZE -
-		CONFIG_SYS_INIT_DATA_SIZE), and the initial stack is just
-		below that area (growing from (CONFIG_SYS_INIT_RAM_ADDR +
-		CONFIG_SYS_GBL_DATA_OFFSET) downward.
-
-	Note:
-		On the MPC824X (or other systems that use the data
-		cache for initial memory) the address chosen for
-		CONFIG_SYS_INIT_RAM_ADDR is basically arbitrary - it must
-		point to an otherwise UNUSED address space between
-		the top of RAM and the start of the PCI space.
-
-- CONFIG_SYS_SIUMCR:	SIU Module Configuration (11-6)
-
-- CONFIG_SYS_SYPCR:	System Protection Control (11-9)
-
-- CONFIG_SYS_TBSCR:	Time Base Status and Control (11-26)
-
-- CONFIG_SYS_PISCR:	Periodic Interrupt Status and Control (11-31)
-
-- CONFIG_SYS_PLPRCR:	PLL, Low-Power, and Reset Control Register (15-30)
-
-- CONFIG_SYS_SCCR:	System Clock and reset Control Register (15-27)
-
-- CONFIG_SYS_OR_TIMING_SDRAM:
-		SDRAM timing
-
-- CONFIG_SYS_MAMR_PTA:
-		periodic timer for refresh
-
-- CONFIG_SYS_DER:	Debug Event Register (37-47)
-
-- FLASH_BASE0_PRELIM, FLASH_BASE1_PRELIM, CONFIG_SYS_REMAP_OR_AM,
-  CONFIG_SYS_PRELIM_OR_AM, CONFIG_SYS_OR_TIMING_FLASH, CONFIG_SYS_OR0_REMAP,
-  CONFIG_SYS_OR0_PRELIM, CONFIG_SYS_BR0_PRELIM, CONFIG_SYS_OR1_REMAP, CONFIG_SYS_OR1_PRELIM,
-  CONFIG_SYS_BR1_PRELIM:
-		Memory Controller Definitions: BR0/1 and OR0/1 (FLASH)
-
-- SDRAM_BASE2_PRELIM, SDRAM_BASE3_PRELIM, SDRAM_MAX_SIZE,
-  CONFIG_SYS_OR_TIMING_SDRAM, CONFIG_SYS_OR2_PRELIM, CONFIG_SYS_BR2_PRELIM,
-  CONFIG_SYS_OR3_PRELIM, CONFIG_SYS_BR3_PRELIM:
-		Memory Controller Definitions: BR2/3 and OR2/3 (SDRAM)
-
-- CONFIG_SYS_MAMR_PTA, CONFIG_SYS_MPTPR_2BK_4K, CONFIG_SYS_MPTPR_1BK_4K, CONFIG_SYS_MPTPR_2BK_8K,
-  CONFIG_SYS_MPTPR_1BK_8K, CONFIG_SYS_MAMR_8COL, CONFIG_SYS_MAMR_9COL:
-		Machine Mode Register and Memory Periodic Timer
-		Prescaler definitions (SDRAM timing)
-
-- CONFIG_SYS_I2C_UCODE_PATCH, CONFIG_SYS_I2C_DPMEM_OFFSET [0x1FC0]:
-		enable I2C microcode relocation patch (MPC8xx);
-		define relocation offset in DPRAM [DSP2]
-
-- CONFIG_SYS_SMC_UCODE_PATCH, CONFIG_SYS_SMC_DPMEM_OFFSET [0x1FC0]:
-		enable SMC microcode relocation patch (MPC8xx);
-		define relocation offset in DPRAM [SMC1]
-
-- CONFIG_SYS_SPI_UCODE_PATCH, CONFIG_SYS_SPI_DPMEM_OFFSET [0x1FC0]:
-		enable SPI microcode relocation patch (MPC8xx);
-		define relocation offset in DPRAM [SCC4]
-
-- CONFIG_SYS_USE_OSCCLK:
-		Use OSCM clock mode on MBX8xx board. Be careful,
-		wrong setting might damage your board. Read
-		doc/README.MBX before setting this variable!
-
-- CONFIG_SYS_CPM_POST_WORD_ADDR: (MPC8xx, MPC8260 only)
-		Offset of the bootmode word in DPRAM used by post
-		(Power On Self Tests). This definition overrides
-		#define'd default value in commproc.h resp.
-		cpm_8260.h.
-
-- CONFIG_SYS_PCI_SLV_MEM_LOCAL, CONFIG_SYS_PCI_SLV_MEM_BUS, CONFIG_SYS_PICMR0_MASK_ATTRIB,
-  CONFIG_SYS_PCI_MSTR0_LOCAL, CONFIG_SYS_PCIMSK0_MASK, CONFIG_SYS_PCI_MSTR1_LOCAL,
-  CONFIG_SYS_PCIMSK1_MASK, CONFIG_SYS_PCI_MSTR_MEM_LOCAL, CONFIG_SYS_PCI_MSTR_MEM_BUS,
-  CONFIG_SYS_CPU_PCI_MEM_START, CONFIG_SYS_PCI_MSTR_MEM_SIZE, CONFIG_SYS_POCMR0_MASK_ATTRIB,
-  CONFIG_SYS_PCI_MSTR_MEMIO_LOCAL, CONFIG_SYS_PCI_MSTR_MEMIO_BUS, CPU_PCI_MEMIO_START,
-  CONFIG_SYS_PCI_MSTR_MEMIO_SIZE, CONFIG_SYS_POCMR1_MASK_ATTRIB, CONFIG_SYS_PCI_MSTR_IO_LOCAL,
-  CONFIG_SYS_PCI_MSTR_IO_BUS, CONFIG_SYS_CPU_PCI_IO_START, CONFIG_SYS_PCI_MSTR_IO_SIZE,
-  CONFIG_SYS_POCMR2_MASK_ATTRIB: (MPC826x only)
-		Overrides the default PCI memory map in arch/powerpc/cpu/mpc8260/pci.c if set.
-
-- CONFIG_PCI_DISABLE_PCIE:
-		Disable PCI-Express on systems where it is supported but not
-		required.
-
-- CONFIG_PCI_ENUM_ONLY
-		Only scan through and get the devices on the buses.
-		Don't do any setup work, presumably because someone or
-		something has already done it, and we don't need to do it
-		a second time.	Useful for platforms that are pre-booted
-		by coreboot or similar.
-
-- CONFIG_PCI_INDIRECT_BRIDGE:
-		Enable support for indirect PCI bridges.
-
-- CONFIG_SYS_SRIO:
-		Chip has SRIO or not
-
-- CONFIG_SRIO1:
-		Board has SRIO 1 port available
-
-- CONFIG_SRIO2:
-		Board has SRIO 2 port available
-
-- CONFIG_SRIO_PCIE_BOOT_MASTER
-		Board can support master function for Boot from SRIO and PCIE
-
-- CONFIG_SYS_SRIOn_MEM_VIRT:
-		Virtual Address of SRIO port 'n' memory region
-
-- CONFIG_SYS_SRIOn_MEM_PHYS:
-		Physical Address of SRIO port 'n' memory region
-
-- CONFIG_SYS_SRIOn_MEM_SIZE:
-		Size of SRIO port 'n' memory region
-
-- CONFIG_SYS_NAND_BUSWIDTH_16BIT
-		Defined to tell the NAND controller that the NAND chip is using
-		a 16 bit bus.
-		Not all NAND drivers use this symbol.
-		Example of drivers that use it:
-		- drivers/mtd/nand/ndfc.c
-		- drivers/mtd/nand/mxc_nand.c
-
-- CONFIG_SYS_NDFC_EBC0_CFG
-		Sets the EBC0_CFG register for the NDFC. If not defined
-		a default value will be used.
-
-- CONFIG_SPD_EEPROM
-		Get DDR timing information from an I2C EEPROM. Common
-		with pluggable memory modules such as SODIMMs
-
-  SPD_EEPROM_ADDRESS
-		I2C address of the SPD EEPROM
-
-- CONFIG_SYS_SPD_BUS_NUM
-		If SPD EEPROM is on an I2C bus other than the first
-		one, specify here. Note that the value must resolve
-		to something your driver can deal with.
-
-- CONFIG_SYS_DDR_RAW_TIMING
-		Get DDR timing information from other than SPD. Common with
-		soldered DDR chips onboard without SPD. DDR raw timing
-		parameters are extracted from datasheet and hard-coded into
-		header files or board specific files.
-
-- CONFIG_FSL_DDR_INTERACTIVE
-		Enable interactive DDR debugging. See doc/README.fsl-ddr.
-
-- CONFIG_FSL_DDR_SYNC_REFRESH
-		Enable sync of refresh for multiple controllers.
-
-- CONFIG_FSL_DDR_BIST
-		Enable built-in memory test for Freescale DDR controllers.
-
-- CONFIG_SYS_83XX_DDR_USES_CS0
-		Only for 83xx systems. If specified, then DDR should
-		be configured using CS0 and CS1 instead of CS2 and CS3.
-
-- CONFIG_ETHER_ON_FEC[12]
-		Define to enable FEC[12] on a 8xx series processor.
-
-- CONFIG_FEC[12]_PHY
-		Define to the hardcoded PHY address which corresponds
-		to the given FEC; i. e.
-			#define CONFIG_FEC1_PHY 4
-		means that the PHY with address 4 is connected to FEC1
-
-		When set to -1, means to probe for first available.
-
-- CONFIG_FEC[12]_PHY_NORXERR
-		The PHY does not have a RXERR line (RMII only).
-		(so program the FEC to ignore it).
-
-- CONFIG_RMII
-		Enable RMII mode for all FECs.
-		Note that this is a global option, we can't
-		have one FEC in standard MII mode and another in RMII mode.
-
-- CONFIG_CRC32_VERIFY
-		Add a verify option to the crc32 command.
-		The syntax is:
-
-		=> crc32 -v <address> <count> <crc32>
-
-		Where address/count indicate a memory area
-		and crc32 is the correct crc32 which the
-		area should have.
-
-- CONFIG_LOOPW
-		Add the "loopw" memory command. This only takes effect if
-		the memory commands are activated globally (CONFIG_CMD_MEM).
-
-- CONFIG_MX_CYCLIC
-		Add the "mdc" and "mwc" memory commands. These are cyclic
-		"md/mw" commands.
-		Examples:
-
-		=> mdc.b 10 4 500
-		This command will print 4 bytes (10,11,12,13) each 500 ms.
-
-		=> mwc.l 100 12345678 10
-		This command will write 12345678 to address 100 all 10 ms.
-
-		This only takes effect if the memory commands are activated
-		globally (CONFIG_CMD_MEM).
-
-- CONFIG_SKIP_LOWLEVEL_INIT
-		[ARM, NDS32, MIPS only] If this variable is defined, then certain
-		low level initializations (like setting up the memory
-		controller) are omitted and/or U-Boot does not
-		relocate itself into RAM.
-
-		Normally this variable MUST NOT be defined. The only
-		exception is when U-Boot is loaded (to RAM) by some
-		other boot loader or by a debugger which performs
-		these initializations itself.
-
-- CONFIG_SPL_BUILD
-		Modifies the behaviour of start.S when compiling a loader
-		that is executed before the actual U-Boot. E.g. when
-		compiling a NAND SPL.
-
-- CONFIG_TPL_BUILD
-		Modifies the behaviour of start.S  when compiling a loader
-		that is executed after the SPL and before the actual U-Boot.
-		It is loaded by the SPL.
-
-- CONFIG_SYS_MPC85XX_NO_RESETVEC
-		Only for 85xx systems. If this variable is specified, the section
-		.resetvec is not kept and the section .bootpg is placed in the
-		previous 4k of the .text section.
-
-- CONFIG_ARCH_MAP_SYSMEM
-		Generally U-Boot (and in particular the md command) uses
-		effective address. It is therefore not necessary to regard
-		U-Boot address as virtual addresses that need to be translated
-		to physical addresses. However, sandbox requires this, since
-		it maintains its own little RAM buffer which contains all
-		addressable memory. This option causes some memory accesses
-		to be mapped through map_sysmem() / unmap_sysmem().
-
-- CONFIG_USE_ARCH_MEMCPY
-  CONFIG_USE_ARCH_MEMSET
-		If these options are used a optimized version of memcpy/memset will
-		be used if available. These functions may be faster under some
-		conditions but may increase the binary size.
-
-- CONFIG_X86_RESET_VECTOR
-		If defined, the x86 reset vector code is included. This is not
-		needed when U-Boot is running from Coreboot.
-
-- CONFIG_SYS_MPUCLK
-		Defines the MPU clock speed (in MHz).
-
-		NOTE : currently only supported on AM335x platforms.
-
-- CONFIG_SPL_AM33XX_ENABLE_RTC32K_OSC:
-		Enables the RTC32K OSC on AM33xx based plattforms
-
-- CONFIG_SYS_NAND_NO_SUBPAGE_WRITE
-		Option to disable subpage write in NAND driver
-		driver that uses this:
-		drivers/mtd/nand/davinci_nand.c
-
-Freescale QE/FMAN Firmware Support:
------------------------------------
-
-The Freescale QUICCEngine (QE) and Frame Manager (FMAN) both support the
-loading of "firmware", which is encoded in the QE firmware binary format.
-This firmware often needs to be loaded during U-Boot booting, so macros
-are used to identify the storage device (NOR flash, SPI, etc) and the address
-within that device.
-
-- CONFIG_SYS_FMAN_FW_ADDR
-	The address in the storage device where the FMAN microcode is located.  The
-	meaning of this address depends on which CONFIG_SYS_QE_FW_IN_xxx macro
-	is also specified.
-
-- CONFIG_SYS_QE_FW_ADDR
-	The address in the storage device where the QE microcode is located.  The
-	meaning of this address depends on which CONFIG_SYS_QE_FW_IN_xxx macro
-	is also specified.
-
-- CONFIG_SYS_QE_FMAN_FW_LENGTH
-	The maximum possible size of the firmware.  The firmware binary format
-	has a field that specifies the actual size of the firmware, but it
-	might not be possible to read any part of the firmware unless some
-	local storage is allocated to hold the entire firmware first.
-
-- CONFIG_SYS_QE_FMAN_FW_IN_NOR
-	Specifies that QE/FMAN firmware is located in NOR flash, mapped as
-	normal addressable memory via the LBC.  CONFIG_SYS_FMAN_FW_ADDR is the
-	virtual address in NOR flash.
-
-- CONFIG_SYS_QE_FMAN_FW_IN_NAND
-	Specifies that QE/FMAN firmware is located in NAND flash.
-	CONFIG_SYS_FMAN_FW_ADDR is the offset within NAND flash.
-
-- CONFIG_SYS_QE_FMAN_FW_IN_MMC
-	Specifies that QE/FMAN firmware is located on the primary SD/MMC
-	device.  CONFIG_SYS_FMAN_FW_ADDR is the byte offset on that device.
-
-- CONFIG_SYS_QE_FMAN_FW_IN_SPIFLASH
-	Specifies that QE/FMAN firmware is located on the primary SPI
-	device.  CONFIG_SYS_FMAN_FW_ADDR is the byte offset on that device.
-
-- CONFIG_SYS_QE_FMAN_FW_IN_REMOTE
-	Specifies that QE/FMAN firmware is located in the remote (master)
-	memory space.	CONFIG_SYS_FMAN_FW_ADDR is a virtual address which
-	can be mapped from slave TLB->slave LAW->slave SRIO or PCIE outbound
-	window->master inbound window->master LAW->the ucode address in
-	master's memory space.
-
-Freescale Layerscape Management Complex Firmware Support:
----------------------------------------------------------
-The Freescale Layerscape Management Complex (MC) supports the loading of
-"firmware".
-This firmware often needs to be loaded during U-Boot booting, so macros
-are used to identify the storage device (NOR flash, SPI, etc) and the address
-within that device.
-
-- CONFIG_FSL_MC_ENET
-	Enable the MC driver for Layerscape SoCs.
-
-- CONFIG_SYS_LS_MC_FW_ADDR
-	The address in the storage device where the firmware is located.  The
-	meaning of this address depends on which CONFIG_SYS_LS_MC_FW_IN_xxx macro
-	is also specified.
-
-- CONFIG_SYS_LS_MC_FW_LENGTH
-	The maximum possible size of the firmware.  The firmware binary format
-	has a field that specifies the actual size of the firmware, but it
-	might not be possible to read any part of the firmware unless some
-	local storage is allocated to hold the entire firmware first.
-
-- CONFIG_SYS_LS_MC_FW_IN_NOR
-	Specifies that MC firmware is located in NOR flash, mapped as
-	normal addressable memory via the LBC. CONFIG_SYS_LS_MC_FW_ADDR is the
-	virtual address in NOR flash.
-
-Freescale Layerscape Debug Server Support:
--------------------------------------------
-The Freescale Layerscape Debug Server Support supports the loading of
-"Debug Server firmware" and triggering SP boot-rom.
-This firmware often needs to be loaded during U-Boot booting.
-
-- CONFIG_FSL_DEBUG_SERVER
-	Enable the Debug Server for Layerscape SoCs.
-
-- CONFIG_SYS_DEBUG_SERVER_DRAM_BLOCK_MIN_SIZE
-	Define minimum DDR size required for debug server image
-
-- CONFIG_SYS_MC_RSV_MEM_ALIGN
-	Define alignment of reserved memory MC requires
-
-Reproducible builds
--------------------
-
-In order to achieve reproducible builds, timestamps used in the U-Boot build
-process have to be set to a fixed value.
-
-This is done using the SOURCE_DATE_EPOCH environment variable.
-SOURCE_DATE_EPOCH is to be set on the build host's shell, not as a configuration
-option for U-Boot or an environment variable in U-Boot.
-
-SOURCE_DATE_EPOCH should be set to a number of seconds since the epoch, in UTC.
-
-Building the Software:
-======================
-
-Building U-Boot has been tested in several native build environments
-and in many different cross environments. Of course we cannot support
-all possibly existing versions of cross development tools in all
-(potentially obsolete) versions. In case of tool chain problems we
-recommend to use the ELDK (see http://www.denx.de/wiki/DULG/ELDK)
-which is extensively used to build and test U-Boot.
-
-If you are not using a native environment, it is assumed that you
-have GNU cross compiling tools available in your path. In this case,
-you must set the environment variable CROSS_COMPILE in your shell.
-Note that no changes to the Makefile or any other source files are
-necessary. For example using the ELDK on a 4xx CPU, please enter:
-
-	$ CROSS_COMPILE=ppc_4xx-
-	$ export CROSS_COMPILE
-
-Note: If you wish to generate Windows versions of the utilities in
-      the tools directory you can use the MinGW toolchain
-      (http://www.mingw.org).  Set your HOST tools to the MinGW
-      toolchain and execute 'make tools'.  For example:
-
-       $ make HOSTCC=i586-mingw32msvc-gcc HOSTSTRIP=i586-mingw32msvc-strip tools
-
-      Binaries such as tools/mkimage.exe will be created which can
-      be executed on computers running Windows.
-
-U-Boot is intended to be simple to build. After installing the
-sources you must configure U-Boot for one specific board type. This
-is done by typing:
-
-	make NAME_defconfig
-
-where "NAME_defconfig" is the name of one of the existing configu-
-rations; see boards.cfg for supported names.
-
-Note: for some board special configuration names may exist; check if
-      additional information is available from the board vendor; for
-      instance, the TQM823L systems are available without (standard)
-      or with LCD support. You can select such additional "features"
-      when choosing the configuration, i. e.
-
-      make TQM823L_defconfig
-	- will configure for a plain TQM823L, i. e. no LCD support
-
-      make TQM823L_LCD_defconfig
-	- will configure for a TQM823L with U-Boot console on LCD
-
-      etc.
-
-
-Finally, type "make all", and you should get some working U-Boot
-images ready for download to / installation on your system:
-
-- "u-boot.bin" is a raw binary image
-- "u-boot" is an image in ELF binary format
-- "u-boot.srec" is in Motorola S-Record format
-
-By default the build is performed locally and the objects are saved
-in the source directory. One of the two methods can be used to change
-this behavior and build U-Boot to some external directory:
-
-1. Add O= to the make command line invocations:
-
-	make O=/tmp/build distclean
-	make O=/tmp/build NAME_defconfig
-	make O=/tmp/build all
-
-2. Set environment variable KBUILD_OUTPUT to point to the desired location:
-
-	export KBUILD_OUTPUT=/tmp/build
-	make distclean
-	make NAME_defconfig
-	make all
-
-Note that the command line "O=" setting overrides the KBUILD_OUTPUT environment
-variable.
-
-
-Please be aware that the Makefiles assume you are using GNU make, so
-for instance on NetBSD you might need to use "gmake" instead of
-native "make".
-
-
-If the system board that you have is not listed, then you will need
-to port U-Boot to your hardware platform. To do this, follow these
-steps:
-
-1.  Create a new directory to hold your board specific code. Add any
-    files you need. In your board directory, you will need at least
-    the "Makefile" and a "<board>.c".
-2.  Create a new configuration file "include/configs/<board>.h" for
-    your board.
-3.  If you're porting U-Boot to a new CPU, then also create a new
-    directory to hold your CPU specific code. Add any files you need.
-4.  Run "make <board>_defconfig" with your new name.
-5.  Type "make", and you should get a working "u-boot.srec" file
-    to be installed on your target system.
-6.  Debug and solve any problems that might arise.
-    [Of course, this last step is much harder than it sounds.]
-
-
-Testing of U-Boot Modifications, Ports to New Hardware, etc.:
-==============================================================
-
-If you have modified U-Boot sources (for instance added a new board
-or support for new devices, a new CPU, etc.) you are expected to
-provide feedback to the other developers. The feedback normally takes
-the form of a "patch", i. e. a context diff against a certain (latest
-official or latest in the git repository) version of U-Boot sources.
-
-But before you submit such a patch, please verify that your modifi-
-cation did not break existing code. At least make sure that *ALL* of
-the supported boards compile WITHOUT ANY compiler warnings. To do so,
-just run the "MAKEALL" script, which will configure and build U-Boot
-for ALL supported system. Be warned, this will take a while. You can
-select which (cross) compiler to use by passing a `CROSS_COMPILE'
-environment variable to the script, i. e. to use the ELDK cross tools
-you can type
-
-	CROSS_COMPILE=ppc_8xx- MAKEALL
-
-or to build on a native PowerPC system you can type
-
-	CROSS_COMPILE=' ' MAKEALL
-
-When using the MAKEALL script, the default behaviour is to build
-U-Boot in the source directory. This location can be changed by
-setting the BUILD_DIR environment variable. Also, for each target
-built, the MAKEALL script saves two log files (<target>.ERR and
-<target>.MAKEALL) in the <source dir>/LOG directory. This default
-location can be changed by setting the MAKEALL_LOGDIR environment
-variable. For example:
-
-	export BUILD_DIR=/tmp/build
-	export MAKEALL_LOGDIR=/tmp/log
-	CROSS_COMPILE=ppc_8xx- MAKEALL
-
-With the above settings build objects are saved in the /tmp/build,
-log files are saved in the /tmp/log and the source tree remains clean
-during the whole build process.
-
-
-See also "U-Boot Porting Guide" below.
-
-
-Monitor Commands - Overview:
-============================
-
-go	- start application at address 'addr'
-run	- run commands in an environment variable
-bootm	- boot application image from memory
-bootp	- boot image via network using BootP/TFTP protocol
-bootz   - boot zImage from memory
-tftpboot- boot image via network using TFTP protocol
-	       and env variables "ipaddr" and "serverip"
-	       (and eventually "gatewayip")
-tftpput - upload a file via network using TFTP protocol
-rarpboot- boot image via network using RARP/TFTP protocol
-diskboot- boot from IDE devicebootd   - boot default, i.e., run 'bootcmd'
-loads	- load S-Record file over serial line
-loadb	- load binary file over serial line (kermit mode)
-md	- memory display
-mm	- memory modify (auto-incrementing)
-nm	- memory modify (constant address)
-mw	- memory write (fill)
-cp	- memory copy
-cmp	- memory compare
-crc32	- checksum calculation
-i2c	- I2C sub-system
-sspi	- SPI utility commands
-base	- print or set address offset
-printenv- print environment variables
-setenv	- set environment variables
-saveenv - save environment variables to persistent storage
-protect - enable or disable FLASH write protection
-erase	- erase FLASH memory
-flinfo	- print FLASH memory information
-nand	- NAND memory operations (see doc/README.nand)
-bdinfo	- print Board Info structure
-iminfo	- print header information for application image
-coninfo - print console devices and informations
-ide	- IDE sub-system
-loop	- infinite loop on address range
-loopw	- infinite write loop on address range
-mtest	- simple RAM test
-icache	- enable or disable instruction cache
-dcache	- enable or disable data cache
-reset	- Perform RESET of the CPU
-echo	- echo args to console
-version - print monitor version
-help	- print online help
-?	- alias for 'help'
-
-
-Monitor Commands - Detailed Description:
-========================================
-
-TODO.
-
-For now: just type "help <command>".
-
-
-Environment Variables:
-======================
-
-U-Boot supports user configuration using Environment Variables which
-can be made persistent by saving to Flash memory.
-
-Environment Variables are set using "setenv", printed using
-"printenv", and saved to Flash using "saveenv". Using "setenv"
-without a value can be used to delete a variable from the
-environment. As long as you don't save the environment you are
-working with an in-memory copy. In case the Flash area containing the
-environment is erased by accident, a default environment is provided.
-
-Some configuration options can be set using Environment Variables.
-
-List of environment variables (most likely not complete):
-
-  baudrate	- see CONFIG_BAUDRATE
-
-  bootdelay	- see CONFIG_BOOTDELAY
-
-  bootcmd	- see CONFIG_BOOTCOMMAND
-
-  bootargs	- Boot arguments when booting an RTOS image
-
-  bootfile	- Name of the image to load with TFTP
-
-  bootm_low	- Memory range available for image processing in the bootm
-		  command can be restricted. This variable is given as
-		  a hexadecimal number and defines lowest address allowed
-		  for use by the bootm command. See also "bootm_size"
-		  environment variable. Address defined by "bootm_low" is
-		  also the base of the initial memory mapping for the Linux
-		  kernel -- see the description of CONFIG_SYS_BOOTMAPSZ and
-		  bootm_mapsize.
-
-  bootm_mapsize - Size of the initial memory mapping for the Linux kernel.
-		  This variable is given as a hexadecimal number and it
-		  defines the size of the memory region starting at base
-		  address bootm_low that is accessible by the Linux kernel
-		  during early boot.  If unset, CONFIG_SYS_BOOTMAPSZ is used
-		  as the default value if it is defined, and bootm_size is
-		  used otherwise.
-
-  bootm_size	- Memory range available for image processing in the bootm
-		  command can be restricted. This variable is given as
-		  a hexadecimal number and defines the size of the region
-		  allowed for use by the bootm command. See also "bootm_low"
-		  environment variable.
-
-  updatefile	- Location of the software update file on a TFTP server, used
-		  by the automatic software update feature. Please refer to
-		  documentation in doc/README.update for more details.
-
-  autoload	- if set to "no" (any string beginning with 'n'),
-		  "bootp" will just load perform a lookup of the
-		  configuration from the BOOTP server, but not try to
-		  load any image using TFTP
-
-  autostart	- if set to "yes", an image loaded using the "bootp",
-		  "rarpboot", "tftpboot" or "diskboot" commands will
-		  be automatically started (by internally calling
-		  "bootm")
-
-		  If set to "no", a standalone image passed to the
-		  "bootm" command will be copied to the load address
-		  (and eventually uncompressed), but NOT be started.
-		  This can be used to load and uncompress arbitrary
-		  data.
-
-  fdt_high	- if set this restricts the maximum address that the
-		  flattened device tree will be copied into upon boot.
-		  For example, if you have a system with 1 GB memory
-		  at physical address 0x10000000, while Linux kernel
-		  only recognizes the first 704 MB as low memory, you
-		  may need to set fdt_high as 0x3C000000 to have the
-		  device tree blob be copied to the maximum address
-		  of the 704 MB low memory, so that Linux kernel can
-		  access it during the boot procedure.
-
-		  If this is set to the special value 0xFFFFFFFF then
-		  the fdt will not be copied at all on boot.  For this
-		  to work it must reside in writable memory, have
-		  sufficient padding on the end of it for u-boot to
-		  add the information it needs into it, and the memory
-		  must be accessible by the kernel.
-
-  fdtcontroladdr- if set this is the address of the control flattened
-		  device tree used by U-Boot when CONFIG_OF_CONTROL is
-		  defined.
-
-  i2cfast	- (PPC405GP|PPC405EP only)
-		  if set to 'y' configures Linux I2C driver for fast
-		  mode (400kHZ). This environment variable is used in
-		  initialization code. So, for changes to be effective
-		  it must be saved and board must be reset.
-
-  initrd_high	- restrict positioning of initrd images:
-		  If this variable is not set, initrd images will be
-		  copied to the highest possible address in RAM; this
-		  is usually what you want since it allows for
-		  maximum initrd size. If for some reason you want to
-		  make sure that the initrd image is loaded below the
-		  CONFIG_SYS_BOOTMAPSZ limit, you can set this environment
-		  variable to a value of "no" or "off" or "0".
-		  Alternatively, you can set it to a maximum upper
-		  address to use (U-Boot will still check that it
-		  does not overwrite the U-Boot stack and data).
-
-		  For instance, when you have a system with 16 MB
-		  RAM, and want to reserve 4 MB from use by Linux,
-		  you can do this by adding "mem=12M" to the value of
-		  the "bootargs" variable. However, now you must make
-		  sure that the initrd image is placed in the first
-		  12 MB as well - this can be done with
-
-		  setenv initrd_high 00c00000
-
-		  If you set initrd_high to 0xFFFFFFFF, this is an
-		  indication to U-Boot that all addresses are legal
-		  for the Linux kernel, including addresses in flash
-		  memory. In this case U-Boot will NOT COPY the
-		  ramdisk at all. This may be useful to reduce the
-		  boot time on your system, but requires that this
-		  feature is supported by your Linux kernel.
-
-  ipaddr	- IP address; needed for tftpboot command
-
-  loadaddr	- Default load address for commands like "bootp",
-		  "rarpboot", "tftpboot", "loadb" or "diskboot"
-
-  loads_echo	- see CONFIG_LOADS_ECHO
-
-  serverip	- TFTP server IP address; needed for tftpboot command
-
-  bootretry	- see CONFIG_BOOT_RETRY_TIME
-
-  bootdelaykey	- see CONFIG_AUTOBOOT_DELAY_STR
-
-  bootstopkey	- see CONFIG_AUTOBOOT_STOP_STR
-
-  ethprime	- controls which interface is used first.
-
-  ethact	- controls which interface is currently active.
-		  For example you can do the following
-
-		  => setenv ethact FEC
-		  => ping 192.168.0.1 # traffic sent on FEC
-		  => setenv ethact SCC
-		  => ping 10.0.0.1 # traffic sent on SCC
-
-  ethrotate	- When set to "no" U-Boot does not go through all
-		  available network interfaces.
-		  It just stays at the currently selected interface.
-
-  netretry	- When set to "no" each network operation will
-		  either succeed or fail without retrying.
-		  When set to "once" the network operation will
-		  fail when all the available network interfaces
-		  are tried once without success.
-		  Useful on scripts which control the retry operation
-		  themselves.
-
-  npe_ucode	- set load address for the NPE microcode
-
-  silent_linux  - If set then Linux will be told to boot silently, by
-		  changing the console to be empty. If "yes" it will be
-		  made silent. If "no" it will not be made silent. If
-		  unset, then it will be made silent if the U-Boot console
-		  is silent.
-
-  tftpsrcp	- If this is set, the value is used for TFTP's
-		  UDP source port.
-
-  tftpdstp	- If this is set, the value is used for TFTP's UDP
-		  destination port instead of the Well Know Port 69.
-
-  tftpblocksize - Block size to use for TFTP transfers; if not set,
-		  we use the TFTP server's default block size
-
-  tftptimeout	- Retransmission timeout for TFTP packets (in milli-
-		  seconds, minimum value is 1000 = 1 second). Defines
-		  when a packet is considered to be lost so it has to
-		  be retransmitted. The default is 5000 = 5 seconds.
-		  Lowering this value may make downloads succeed
-		  faster in networks with high packet loss rates or
-		  with unreliable TFTP servers.
-
-  tftptimeoutcountmax	- maximum count of TFTP timeouts (no
-		  unit, minimum value = 0). Defines how many timeouts
-		  can happen during a single file transfer before that
-		  transfer is aborted. The default is 10, and 0 means
-		  'no timeouts allowed'. Increasing this value may help
-		  downloads succeed with high packet loss rates, or with
-		  unreliable TFTP servers or client hardware.
-
-  vlan		- When set to a value < 4095 the traffic over
-		  Ethernet is encapsulated/received over 802.1q
-		  VLAN tagged frames.
-
-  bootpretryperiod	- Period during which BOOTP/DHCP sends retries.
-		  Unsigned value, in milliseconds. If not set, the period will
-		  be either the default (28000), or a value based on
-		  CONFIG_NET_RETRY_COUNT, if defined. This value has
-		  precedence over the valu based on CONFIG_NET_RETRY_COUNT.
-
-The following image location variables contain the location of images
-used in booting. The "Image" column gives the role of the image and is
-not an environment variable name. The other columns are environment
-variable names. "File Name" gives the name of the file on a TFTP
-server, "RAM Address" gives the location in RAM the image will be
-loaded to, and "Flash Location" gives the image's address in NOR
-flash or offset in NAND flash.
-
-*Note* - these variables don't have to be defined for all boards, some
-boards currently use other variables for these purposes, and some
-boards use these variables for other purposes.
-
-Image		    File Name	     RAM Address       Flash Location
------		    ---------	     -----------       --------------
-u-boot		    u-boot	     u-boot_addr_r     u-boot_addr
-Linux kernel	    bootfile	     kernel_addr_r     kernel_addr
-device tree blob    fdtfile	     fdt_addr_r	       fdt_addr
-ramdisk		    ramdiskfile	     ramdisk_addr_r    ramdisk_addr
-
-The following environment variables may be used and automatically
-updated by the network boot commands ("bootp" and "rarpboot"),
-depending the information provided by your boot server:
-
-  bootfile	- see above
-  dnsip		- IP address of your Domain Name Server
-  dnsip2	- IP address of your secondary Domain Name Server
-  gatewayip	- IP address of the Gateway (Router) to use
-  hostname	- Target hostname
-  ipaddr	- see above
-  netmask	- Subnet Mask
-  rootpath	- Pathname of the root filesystem on the NFS server
-  serverip	- see above
-
-
-There are two special Environment Variables:
-
-  serial#	- contains hardware identification information such
-		  as type string and/or serial number
-  ethaddr	- Ethernet address
-
-These variables can be set only once (usually during manufacturing of
-the board). U-Boot refuses to delete or overwrite these variables
-once they have been set once.
-
-
-Further special Environment Variables:
-
-  ver		- Contains the U-Boot version string as printed
-		  with the "version" command. This variable is
-		  readonly (see CONFIG_VERSION_VARIABLE).
-
-
-Please note that changes to some configuration parameters may take
-only effect after the next boot (yes, that's just like Windoze :-).
-
-
-Callback functions for environment variables:
----------------------------------------------
-
-For some environment variables, the behavior of u-boot needs to change
-when their values are changed.  This functionality allows functions to
-be associated with arbitrary variables.  On creation, overwrite, or
-deletion, the callback will provide the opportunity for some side
-effect to happen or for the change to be rejected.
-
-The callbacks are named and associated with a function using the
-U_BOOT_ENV_CALLBACK macro in your board or driver code.
-
-These callbacks are associated with variables in one of two ways.  The
-static list can be added to by defining CONFIG_ENV_CALLBACK_LIST_STATIC
-in the board configuration to a string that defines a list of
-associations.  The list must be in the following format:
-
-	entry = variable_name[:callback_name]
-	list = entry[,list]
-
-If the callback name is not specified, then the callback is deleted.
-Spaces are also allowed anywhere in the list.
-
-Callbacks can also be associated by defining the ".callbacks" variable
-with the same list format above.  Any association in ".callbacks" will
-override any association in the static list. You can define
-CONFIG_ENV_CALLBACK_LIST_DEFAULT to a list (string) to define the
-".callbacks" environment variable in the default or embedded environment.
-
-If CONFIG_REGEX is defined, the variable_name above is evaluated as a
-regular expression. This allows multiple variables to be connected to
-the same callback without explicitly listing them all out.
-
-
-Command Line Parsing:
-=====================
-
-There are two different command line parsers available with U-Boot:
-the old "simple" one, and the much more powerful "hush" shell:
-
-Old, simple command line parser:
---------------------------------
-
-- supports environment variables (through setenv / saveenv commands)
-- several commands on one line, separated by ';'
-- variable substitution using "... ${name} ..." syntax
-- special characters ('$', ';') can be escaped by prefixing with '\',
-  for example:
-	setenv bootcmd bootm \${address}
-- You can also escape text by enclosing in single apostrophes, for example:
-	setenv addip 'setenv bootargs $bootargs ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname::off'
-
-Hush shell:
------------
-
-- similar to Bourne shell, with control structures like
-  if...then...else...fi, for...do...done; while...do...done,
-  until...do...done, ...
-- supports environment ("global") variables (through setenv / saveenv
-  commands) and local shell variables (through standard shell syntax
-  "name=value"); only environment variables can be used with "run"
-  command
-
-General rules:
---------------
-
-(1) If a command line (or an environment variable executed by a "run"
-    command) contains several commands separated by semicolon, and
-    one of these commands fails, then the remaining commands will be
-    executed anyway.
-
-(2) If you execute several variables with one call to run (i. e.
-    calling run with a list of variables as arguments), any failing
-    command will cause "run" to terminate, i. e. the remaining
-    variables are not executed.
-
-Note for Redundant Ethernet Interfaces:
-=======================================
-
-Some boards come with redundant Ethernet interfaces; U-Boot supports
-such configurations and is capable of automatic selection of a
-"working" interface when needed. MAC assignment works as follows:
-
-Network interfaces are numbered eth0, eth1, eth2, ... Corresponding
-MAC addresses can be stored in the environment as "ethaddr" (=>eth0),
-"eth1addr" (=>eth1), "eth2addr", ...
-
-If the network interface stores some valid MAC address (for instance
-in SROM), this is used as default address if there is NO correspon-
-ding setting in the environment; if the corresponding environment
-variable is set, this overrides the settings in the card; that means:
-
-o If the SROM has a valid MAC address, and there is no address in the
-  environment, the SROM's address is used.
-
-o If there is no valid address in the SROM, and a definition in the
-  environment exists, then the value from the environment variable is
-  used.
-
-o If both the SROM and the environment contain a MAC address, and
-  both addresses are the same, this MAC address is used.
-
-o If both the SROM and the environment contain a MAC address, and the
-  addresses differ, the value from the environment is used and a
-  warning is printed.
-
-o If neither SROM nor the environment contain a MAC address, an error
-  is raised. If CONFIG_NET_RANDOM_ETHADDR is defined, then in this case
-  a random, locally-assigned MAC is used.
-
-If Ethernet drivers implement the 'write_hwaddr' function, valid MAC addresses
-will be programmed into hardware as part of the initialization process.	 This
-may be skipped by setting the appropriate 'ethmacskip' environment variable.
-The naming convention is as follows:
-"ethmacskip" (=>eth0), "eth1macskip" (=>eth1) etc.
-
-Image Formats:
-==============
-
-U-Boot is capable of booting (and performing other auxiliary operations on)
-images in two formats:
-
-New uImage format (FIT)
------------------------
-
-Flexible and powerful format based on Flattened Image Tree -- FIT (similar
-to Flattened Device Tree). It allows the use of images with multiple
-components (several kernels, ramdisks, etc.), with contents protected by
-SHA1, MD5 or CRC32. More details are found in the doc/uImage.FIT directory.
-
-
-Old uImage format
------------------
-
-Old image format is based on binary files which can be basically anything,
-preceded by a special header; see the definitions in include/image.h for
-details; basically, the header defines the following image properties:
-
-* Target Operating System (Provisions for OpenBSD, NetBSD, FreeBSD,
-  4.4BSD, Linux, SVR4, Esix, Solaris, Irix, SCO, Dell, NCR, VxWorks,
-  LynxOS, pSOS, QNX, RTEMS, INTEGRITY;
-  Currently supported: Linux, NetBSD, VxWorks, QNX, RTEMS, LynxOS,
-  INTEGRITY).
-* Target CPU Architecture (Provisions for Alpha, ARM, AVR32, Intel x86,
-  IA64, MIPS, NDS32, Nios II, PowerPC, IBM S390, SuperH, Sparc, Sparc 64 Bit;
-  Currently supported: ARM, AVR32, Intel x86, MIPS, NDS32, Nios II, PowerPC).
-* Compression Type (uncompressed, gzip, bzip2)
-* Load Address
-* Entry Point
-* Image Name
-* Image Timestamp
-
-The header is marked by a special Magic Number, and both the header
-and the data portions of the image are secured against corruption by
-CRC32 checksums.
-
-
-Linux Support:
-==============
-
-Although U-Boot should support any OS or standalone application
-easily, the main focus has always been on Linux during the design of
-U-Boot.
-
-U-Boot includes many features that so far have been part of some
-special "boot loader" code within the Linux kernel. Also, any
-"initrd" images to be used are no longer part of one big Linux image;
-instead, kernel and "initrd" are separate images. This implementation
-serves several purposes:
-
-- the same features can be used for other OS or standalone
-  applications (for instance: using compressed images to reduce the
-  Flash memory footprint)
-
-- it becomes much easier to port new Linux kernel versions because
-  lots of low-level, hardware dependent stuff are done by U-Boot
-
-- the same Linux kernel image can now be used with different "initrd"
-  images; of course this also means that different kernel images can
-  be run with the same "initrd". This makes testing easier (you don't
-  have to build a new "zImage.initrd" Linux image when you just
-  change a file in your "initrd"). Also, a field-upgrade of the
-  software is easier now.
-
-
-Linux HOWTO:
-============
-
-Porting Linux to U-Boot based systems:
----------------------------------------
-
-U-Boot cannot save you from doing all the necessary modifications to
-configure the Linux device drivers for use with your target hardware
-(no, we don't intend to provide a full virtual machine interface to
-Linux :-).
-
-But now you can ignore ALL boot loader code (in arch/powerpc/mbxboot).
-
-Just make sure your machine specific header file (for instance
-include/asm-ppc/tqm8xx.h) includes the same definition of the Board
-Information structure as we define in include/asm-<arch>/u-boot.h,
-and make sure that your definition of IMAP_ADDR uses the same value
-as your U-Boot configuration in CONFIG_SYS_IMMR.
-
-Note that U-Boot now has a driver model, a unified model for drivers.
-If you are adding a new driver, plumb it into driver model. If there
-is no uclass available, you are encouraged to create one. See
-doc/driver-model.
-
-
-Configuring the Linux kernel:
------------------------------
-
-No specific requirements for U-Boot. Make sure you have some root
-device (initial ramdisk, NFS) for your target system.
-
-
-Building a Linux Image:
------------------------
-
-With U-Boot, "normal" build targets like "zImage" or "bzImage" are
-not used. If you use recent kernel source, a new build target
-"uImage" will exist which automatically builds an image usable by
-U-Boot. Most older kernels also have support for a "pImage" target,
-which was introduced for our predecessor project PPCBoot and uses a
-100% compatible format.
-
-Example:
-
-	make TQM850L_defconfig
-	make oldconfig
-	make dep
-	make uImage
-
-The "uImage" build target uses a special tool (in 'tools/mkimage') to
-encapsulate a compressed Linux kernel image with header	 information,
-CRC32 checksum etc. for use with U-Boot. This is what we are doing:
-
-* build a standard "vmlinux" kernel image (in ELF binary format):
-
-* convert the kernel into a raw binary image:
-
-	${CROSS_COMPILE}-objcopy -O binary \
-				 -R .note -R .comment \
-				 -S vmlinux linux.bin
-
-* compress the binary image:
-
-	gzip -9 linux.bin
-
-* package compressed binary image for U-Boot:
-
-	mkimage -A ppc -O linux -T kernel -C gzip \
-		-a 0 -e 0 -n "Linux Kernel Image" \
-		-d linux.bin.gz uImage
-
-
-The "mkimage" tool can also be used to create ramdisk images for use
-with U-Boot, either separated from the Linux kernel image, or
-combined into one file. "mkimage" encapsulates the images with a 64
-byte header containing information about target architecture,
-operating system, image type, compression method, entry points, time
-stamp, CRC32 checksums, etc.
-
-"mkimage" can be called in two ways: to verify existing images and
-print the header information, or to build new images.
-
-In the first form (with "-l" option) mkimage lists the information
-contained in the header of an existing U-Boot image; this includes
-checksum verification:
-
-	tools/mkimage -l image
-	  -l ==> list image header information
-
-The second form (with "-d" option) is used to build a U-Boot image
-from a "data file" which is used as image payload:
-
-	tools/mkimage -A arch -O os -T type -C comp -a addr -e ep \
-		      -n name -d data_file image
-	  -A ==> set architecture to 'arch'
-	  -O ==> set operating system to 'os'
-	  -T ==> set image type to 'type'
-	  -C ==> set compression type 'comp'
-	  -a ==> set load address to 'addr' (hex)
-	  -e ==> set entry point to 'ep' (hex)
-	  -n ==> set image name to 'name'
-	  -d ==> use image data from 'datafile'
-
-Right now, all Linux kernels for PowerPC systems use the same load
-address (0x00000000), but the entry point address depends on the
-kernel version:
-
-- 2.2.x kernels have the entry point at 0x0000000C,
-- 2.3.x and later kernels have the entry point at 0x00000000.
-
-So a typical call to build a U-Boot image would read:
-
-	-> tools/mkimage -n '2.4.4 kernel for TQM850L' \
-	> -A ppc -O linux -T kernel -C gzip -a 0 -e 0 \
-	> -d /opt/elsk/ppc_8xx/usr/src/linux-2.4.4/arch/powerpc/coffboot/vmlinux.gz \
-	> examples/uImage.TQM850L
-	Image Name:   2.4.4 kernel for TQM850L
-	Created:      Wed Jul 19 02:34:59 2000
-	Image Type:   PowerPC Linux Kernel Image (gzip compressed)
-	Data Size:    335725 Bytes = 327.86 kB = 0.32 MB
-	Load Address: 0x00000000
-	Entry Point:  0x00000000
-
-To verify the contents of the image (or check for corruption):
-
-	-> tools/mkimage -l examples/uImage.TQM850L
-	Image Name:   2.4.4 kernel for TQM850L
-	Created:      Wed Jul 19 02:34:59 2000
-	Image Type:   PowerPC Linux Kernel Image (gzip compressed)
-	Data Size:    335725 Bytes = 327.86 kB = 0.32 MB
-	Load Address: 0x00000000
-	Entry Point:  0x00000000
-
-NOTE: for embedded systems where boot time is critical you can trade
-speed for memory and install an UNCOMPRESSED image instead: this
-needs more space in Flash, but boots much faster since it does not
-need to be uncompressed:
-
-	-> gunzip /opt/elsk/ppc_8xx/usr/src/linux-2.4.4/arch/powerpc/coffboot/vmlinux.gz
-	-> tools/mkimage -n '2.4.4 kernel for TQM850L' \
-	> -A ppc -O linux -T kernel -C none -a 0 -e 0 \
-	> -d /opt/elsk/ppc_8xx/usr/src/linux-2.4.4/arch/powerpc/coffboot/vmlinux \
-	> examples/uImage.TQM850L-uncompressed
-	Image Name:   2.4.4 kernel for TQM850L
-	Created:      Wed Jul 19 02:34:59 2000
-	Image Type:   PowerPC Linux Kernel Image (uncompressed)
-	Data Size:    792160 Bytes = 773.59 kB = 0.76 MB
-	Load Address: 0x00000000
-	Entry Point:  0x00000000
-
-
-Similar you can build U-Boot images from a 'ramdisk.image.gz' file
-when your kernel is intended to use an initial ramdisk:
-
-	-> tools/mkimage -n 'Simple Ramdisk Image' \
-	> -A ppc -O linux -T ramdisk -C gzip \
-	> -d /LinuxPPC/images/SIMPLE-ramdisk.image.gz examples/simple-initrd
-	Image Name:   Simple Ramdisk Image
-	Created:      Wed Jan 12 14:01:50 2000
-	Image Type:   PowerPC Linux RAMDisk Image (gzip compressed)
-	Data Size:    566530 Bytes = 553.25 kB = 0.54 MB
-	Load Address: 0x00000000
-	Entry Point:  0x00000000
-
-The "dumpimage" is a tool to disassemble images built by mkimage. Its "-i"
-option performs the converse operation of the mkimage's second form (the "-d"
-option). Given an image built by mkimage, the dumpimage extracts a "data file"
-from the image:
-
-	tools/dumpimage -i image -T type -p position data_file
-	  -i ==> extract from the 'image' a specific 'data_file'
-	  -T ==> set image type to 'type'
-	  -p ==> 'position' (starting at 0) of the 'data_file' inside the 'image'
-
-
-Installing a Linux Image:
--------------------------
-
-To downloading a U-Boot image over the serial (console) interface,
-you must convert the image to S-Record format:
-
-	objcopy -I binary -O srec examples/image examples/image.srec
-
-The 'objcopy' does not understand the information in the U-Boot
-image header, so the resulting S-Record file will be relative to
-address 0x00000000. To load it to a given address, you need to
-specify the target address as 'offset' parameter with the 'loads'
-command.
-
-Example: install the image to address 0x40100000 (which on the
-TQM8xxL is in the first Flash bank):
-
-	=> erase 40100000 401FFFFF
-
-	.......... done
-	Erased 8 sectors
-
-	=> loads 40100000
-	## Ready for S-Record download ...
-	~>examples/image.srec
-	1 2 3 4 5 6 7 8 9 10 11 12 13 ...
-	...
-	15989 15990 15991 15992
-	[file transfer complete]
-	[connected]
-	## Start Addr = 0x00000000
-
-
-You can check the success of the download using the 'iminfo' command;
-this includes a checksum verification so you can be sure no data
-corruption happened:
-
-	=> imi 40100000
-
-	## Checking Image at 40100000 ...
-	   Image Name:	 2.2.13 for initrd on TQM850L
-	   Image Type:	 PowerPC Linux Kernel Image (gzip compressed)
-	   Data Size:	 335725 Bytes = 327 kB = 0 MB
-	   Load Address: 00000000
-	   Entry Point:	 0000000c
-	   Verifying Checksum ... OK
-
-
-Boot Linux:
------------
-
-The "bootm" command is used to boot an application that is stored in
-memory (RAM or Flash). In case of a Linux kernel image, the contents
-of the "bootargs" environment variable is passed to the kernel as
-parameters. You can check and modify this variable using the
-"printenv" and "setenv" commands:
-
-
-	=> printenv bootargs
-	bootargs=root=/dev/ram
-
-	=> setenv bootargs root=/dev/nfs rw nfsroot=10.0.0.2:/LinuxPPC nfsaddrs=10.0.0.99:10.0.0.2
-
-	=> printenv bootargs
-	bootargs=root=/dev/nfs rw nfsroot=10.0.0.2:/LinuxPPC nfsaddrs=10.0.0.99:10.0.0.2
-
-	=> bootm 40020000
-	## Booting Linux kernel at 40020000 ...
-	   Image Name:	 2.2.13 for NFS on TQM850L
-	   Image Type:	 PowerPC Linux Kernel Image (gzip compressed)
-	   Data Size:	 381681 Bytes = 372 kB = 0 MB
-	   Load Address: 00000000
-	   Entry Point:	 0000000c
-	   Verifying Checksum ... OK
-	   Uncompressing Kernel Image ... OK
-	Linux version 2.2.13 (wd@denx.local.net) (gcc version 2.95.2 19991024 (release)) #1 Wed Jul 19 02:35:17 MEST 2000
-	Boot arguments: root=/dev/nfs rw nfsroot=10.0.0.2:/LinuxPPC nfsaddrs=10.0.0.99:10.0.0.2
-	time_init: decrementer frequency = 187500000/60
-	Calibrating delay loop... 49.77 BogoMIPS
-	Memory: 15208k available (700k kernel code, 444k data, 32k init) [c0000000,c1000000]
-	...
-
-If you want to boot a Linux kernel with initial RAM disk, you pass
-the memory addresses of both the kernel and the initrd image (PPBCOOT
-format!) to the "bootm" command:
-
-	=> imi 40100000 40200000
-
-	## Checking Image at 40100000 ...
-	   Image Name:	 2.2.13 for initrd on TQM850L
-	   Image Type:	 PowerPC Linux Kernel Image (gzip compressed)
-	   Data Size:	 335725 Bytes = 327 kB = 0 MB
-	   Load Address: 00000000
-	   Entry Point:	 0000000c
-	   Verifying Checksum ... OK
-
-	## Checking Image at 40200000 ...
-	   Image Name:	 Simple Ramdisk Image
-	   Image Type:	 PowerPC Linux RAMDisk Image (gzip compressed)
-	   Data Size:	 566530 Bytes = 553 kB = 0 MB
-	   Load Address: 00000000
-	   Entry Point:	 00000000
-	   Verifying Checksum ... OK
-
-	=> bootm 40100000 40200000
-	## Booting Linux kernel at 40100000 ...
-	   Image Name:	 2.2.13 for initrd on TQM850L
-	   Image Type:	 PowerPC Linux Kernel Image (gzip compressed)
-	   Data Size:	 335725 Bytes = 327 kB = 0 MB
-	   Load Address: 00000000
-	   Entry Point:	 0000000c
-	   Verifying Checksum ... OK
-	   Uncompressing Kernel Image ... OK
-	## Loading RAMDisk Image at 40200000 ...
-	   Image Name:	 Simple Ramdisk Image
-	   Image Type:	 PowerPC Linux RAMDisk Image (gzip compressed)
-	   Data Size:	 566530 Bytes = 553 kB = 0 MB
-	   Load Address: 00000000
-	   Entry Point:	 00000000
-	   Verifying Checksum ... OK
-	   Loading Ramdisk ... OK
-	Linux version 2.2.13 (wd@denx.local.net) (gcc version 2.95.2 19991024 (release)) #1 Wed Jul 19 02:32:08 MEST 2000
-	Boot arguments: root=/dev/ram
-	time_init: decrementer frequency = 187500000/60
-	Calibrating delay loop... 49.77 BogoMIPS
-	...
-	RAMDISK: Compressed image found at block 0
-	VFS: Mounted root (ext2 filesystem).
-
-	bash#
-
-Boot Linux and pass a flat device tree:
------------
-
-First, U-Boot must be compiled with the appropriate defines. See the section
-titled "Linux Kernel Interface" above for a more in depth explanation. The
-following is an example of how to start a kernel and pass an updated
-flat device tree:
-
-=> print oftaddr
-oftaddr=0x300000
-=> print oft
-oft=oftrees/mpc8540ads.dtb
-=> tftp $oftaddr $oft
-Speed: 1000, full duplex
-Using TSEC0 device
-TFTP from server 192.168.1.1; our IP address is 192.168.1.101
-Filename 'oftrees/mpc8540ads.dtb'.
-Load address: 0x300000
-Loading: #
-done
-Bytes transferred = 4106 (100a hex)
-=> tftp $loadaddr $bootfile
-Speed: 1000, full duplex
-Using TSEC0 device
-TFTP from server 192.168.1.1; our IP address is 192.168.1.2
-Filename 'uImage'.
-Load address: 0x200000
-Loading:############
-done
-Bytes transferred = 1029407 (fb51f hex)
-=> print loadaddr
-loadaddr=200000
-=> print oftaddr
-oftaddr=0x300000
-=> bootm $loadaddr - $oftaddr
-## Booting image at 00200000 ...
-   Image Name:	 Linux-2.6.17-dirty
-   Image Type:	 PowerPC Linux Kernel Image (gzip compressed)
-   Data Size:	 1029343 Bytes = 1005.2 kB
-   Load Address: 00000000
-   Entry Point:	 00000000
-   Verifying Checksum ... OK
-   Uncompressing Kernel Image ... OK
-Booting using flat device tree at 0x300000
-Using MPC85xx ADS machine description
-Memory CAM mapping: CAM0=256Mb, CAM1=256Mb, CAM2=0Mb residual: 0Mb
-[snip]
-
-
-More About U-Boot Image Types:
-------------------------------
-
-U-Boot supports the following image types:
-
-   "Standalone Programs" are directly runnable in the environment
-	provided by U-Boot; it is expected that (if they behave
-	well) you can continue to work in U-Boot after return from
-	the Standalone Program.
-   "OS Kernel Images" are usually images of some Embedded OS which
-	will take over control completely. Usually these programs
-	will install their own set of exception handlers, device
-	drivers, set up the MMU, etc. - this means, that you cannot
-	expect to re-enter U-Boot except by resetting the CPU.
-   "RAMDisk Images" are more or less just data blocks, and their
-	parameters (address, size) are passed to an OS kernel that is
-	being started.
-   "Multi-File Images" contain several images, typically an OS
-	(Linux) kernel image and one or more data images like
-	RAMDisks. This construct is useful for instance when you want
-	to boot over the network using BOOTP etc., where the boot
-	server provides just a single image file, but you want to get
-	for instance an OS kernel and a RAMDisk image.
-
-	"Multi-File Images" start with a list of image sizes, each
-	image size (in bytes) specified by an "uint32_t" in network
-	byte order. This list is terminated by an "(uint32_t)0".
-	Immediately after the terminating 0 follow the images, one by
-	one, all aligned on "uint32_t" boundaries (size rounded up to
-	a multiple of 4 bytes).
-
-   "Firmware Images" are binary images containing firmware (like
-	U-Boot or FPGA images) which usually will be programmed to
-	flash memory.
-
-   "Script files" are command sequences that will be executed by
-	U-Boot's command interpreter; this feature is especially
-	useful when you configure U-Boot to use a real shell (hush)
-	as command interpreter.
-
-Booting the Linux zImage:
--------------------------
-
-On some platforms, it's possible to boot Linux zImage. This is done
-using the "bootz" command. The syntax of "bootz" command is the same
-as the syntax of "bootm" command.
-
-Note, defining the CONFIG_SUPPORT_RAW_INITRD allows user to supply
-kernel with raw initrd images. The syntax is slightly different, the
-address of the initrd must be augmented by it's size, in the following
-format: "<initrd addres>:<initrd size>".
-
-
-Standalone HOWTO:
-=================
-
-One of the features of U-Boot is that you can dynamically load and
-run "standalone" applications, which can use some resources of
-U-Boot like console I/O functions or interrupt services.
-
-Two simple examples are included with the sources:
-
-"Hello World" Demo:
--------------------
-
-'examples/hello_world.c' contains a small "Hello World" Demo
-application; it is automatically compiled when you build U-Boot.
-It's configured to run at address 0x00040004, so you can play with it
-like that:
-
-	=> loads
-	## Ready for S-Record download ...
-	~>examples/hello_world.srec
-	1 2 3 4 5 6 7 8 9 10 11 ...
-	[file transfer complete]
-	[connected]
-	## Start Addr = 0x00040004
-
-	=> go 40004 Hello World! This is a test.
-	## Starting application at 0x00040004 ...
-	Hello World
-	argc = 7
-	argv[0] = "40004"
-	argv[1] = "Hello"
-	argv[2] = "World!"
-	argv[3] = "This"
-	argv[4] = "is"
-	argv[5] = "a"
-	argv[6] = "test."
-	argv[7] = "<NULL>"
-	Hit any key to exit ...
-
-	## Application terminated, rc = 0x0
-
-Another example, which demonstrates how to register a CPM interrupt
-handler with the U-Boot code, can be found in 'examples/timer.c'.
-Here, a CPM timer is set up to generate an interrupt every second.
-The interrupt service routine is trivial, just printing a '.'
-character, but this is just a demo program. The application can be
-controlled by the following keys:
-
-	? - print current values og the CPM Timer registers
-	b - enable interrupts and start timer
-	e - stop timer and disable interrupts
-	q - quit application
-
-	=> loads
-	## Ready for S-Record download ...
-	~>examples/timer.srec
-	1 2 3 4 5 6 7 8 9 10 11 ...
-	[file transfer complete]
-	[connected]
-	## Start Addr = 0x00040004
-
-	=> go 40004
-	## Starting application at 0x00040004 ...
-	TIMERS=0xfff00980
-	Using timer 1
-	  tgcr @ 0xfff00980, tmr @ 0xfff00990, trr @ 0xfff00994, tcr @ 0xfff00998, tcn @ 0xfff0099c, ter @ 0xfff009b0
-
-Hit 'b':
-	[q, b, e, ?] Set interval 1000000 us
-	Enabling timer
-Hit '?':
-	[q, b, e, ?] ........
-	tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0xef6, ter=0x0
-Hit '?':
-	[q, b, e, ?] .
-	tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0x2ad4, ter=0x0
-Hit '?':
-	[q, b, e, ?] .
-	tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0x1efc, ter=0x0
-Hit '?':
-	[q, b, e, ?] .
-	tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0x169d, ter=0x0
-Hit 'e':
-	[q, b, e, ?] ...Stopping timer
-Hit 'q':
-	[q, b, e, ?] ## Application terminated, rc = 0x0
-
-
-Minicom warning:
-================
-
-Over time, many people have reported problems when trying to use the
-"minicom" terminal emulation program for serial download. I (wd)
-consider minicom to be broken, and recommend not to use it. Under
-Unix, I recommend to use C-Kermit for general purpose use (and
-especially for kermit binary protocol download ("loadb" command), and
-use "cu" for S-Record download ("loads" command).  See
-http://www.denx.de/wiki/view/DULG/SystemSetup#Section_4.3.
-for help with kermit.
-
-
-Nevertheless, if you absolutely want to use it try adding this
-configuration to your "File transfer protocols" section:
-
-	   Name	   Program			Name U/D FullScr IO-Red. Multi
-	X  kermit  /usr/bin/kermit -i -l %l -s	 Y    U	   Y	   N	  N
-	Y  kermit  /usr/bin/kermit -i -l %l -r	 N    D	   Y	   N	  N
-
-
-NetBSD Notes:
-=============
-
-Starting at version 0.9.2, U-Boot supports NetBSD both as host
-(build U-Boot) and target system (boots NetBSD/mpc8xx).
-
-Building requires a cross environment; it is known to work on
-NetBSD/i386 with the cross-powerpc-netbsd-1.3 package (you will also
-need gmake since the Makefiles are not compatible with BSD make).
-Note that the cross-powerpc package does not install include files;
-attempting to build U-Boot will fail because <machine/ansi.h> is
-missing.  This file has to be installed and patched manually:
-
-	# cd /usr/pkg/cross/powerpc-netbsd/include
-	# mkdir powerpc
-	# ln -s powerpc machine
-	# cp /usr/src/sys/arch/powerpc/include/ansi.h powerpc/ansi.h
-	# ${EDIT} powerpc/ansi.h	## must remove __va_list, _BSD_VA_LIST
-
-Native builds *don't* work due to incompatibilities between native
-and U-Boot include files.
-
-Booting assumes that (the first part of) the image booted is a
-stage-2 loader which in turn loads and then invokes the kernel
-proper. Loader sources will eventually appear in the NetBSD source
-tree (probably in sys/arc/mpc8xx/stand/u-boot_stage2/); in the
-meantime, see ftp://ftp.denx.de/pub/u-boot/ppcboot_stage2.tar.gz
-
-
-Implementation Internals:
-=========================
-
-The following is not intended to be a complete description of every
-implementation detail. However, it should help to understand the
-inner workings of U-Boot and make it easier to port it to custom
-hardware.
-
-
-Initial Stack, Global Data:
----------------------------
-
-The implementation of U-Boot is complicated by the fact that U-Boot
-starts running out of ROM (flash memory), usually without access to
-system RAM (because the memory controller is not initialized yet).
-This means that we don't have writable Data or BSS segments, and BSS
-is not initialized as zero. To be able to get a C environment working
-at all, we have to allocate at least a minimal stack. Implementation
-options for this are defined and restricted by the CPU used: Some CPU
-models provide on-chip memory (like the IMMR area on MPC8xx and
-MPC826x processors), on others (parts of) the data cache can be
-locked as (mis-) used as memory, etc.
-
-	Chris Hallinan posted a good summary of these issues to the
-	U-Boot mailing list:
-
-	Subject: RE: [U-Boot-Users] RE: More On Memory Bank x (nothingness)?
-	From: "Chris Hallinan" <clh@net1plus.com>
-	Date: Mon, 10 Feb 2003 16:43:46 -0500 (22:43 MET)
-	...
-
-	Correct me if I'm wrong, folks, but the way I understand it
-	is this: Using DCACHE as initial RAM for Stack, etc, does not
-	require any physical RAM backing up the cache. The cleverness
-	is that the cache is being used as a temporary supply of
-	necessary storage before the SDRAM controller is setup. It's
-	beyond the scope of this list to explain the details, but you
-	can see how this works by studying the cache architecture and
-	operation in the architecture and processor-specific manuals.
-
-	OCM is On Chip Memory, which I believe the 405GP has 4K. It
-	is another option for the system designer to use as an
-	initial stack/RAM area prior to SDRAM being available. Either
-	option should work for you. Using CS 4 should be fine if your
-	board designers haven't used it for something that would
-	cause you grief during the initial boot! It is frequently not
-	used.
-
-	CONFIG_SYS_INIT_RAM_ADDR should be somewhere that won't interfere
-	with your processor/board/system design. The default value
-	you will find in any recent u-boot distribution in
-	walnut.h should work for you. I'd set it to a value larger
-	than your SDRAM module. If you have a 64MB SDRAM module, set
-	it above 400_0000. Just make sure your board has no resources
-	that are supposed to respond to that address! That code in
-	start.S has been around a while and should work as is when
-	you get the config right.
-
-	-Chris Hallinan
-	DS4.COM, Inc.
-
-It is essential to remember this, since it has some impact on the C
-code for the initialization procedures:
-
-* Initialized global data (data segment) is read-only. Do not attempt
-  to write it.
-
-* Do not use any uninitialized global data (or implicitly initialized
-  as zero data - BSS segment) at all - this is undefined, initiali-
-  zation is performed later (when relocating to RAM).
-
-* Stack space is very limited. Avoid big data buffers or things like
-  that.
-
-Having only the stack as writable memory limits means we cannot use
-normal global data to share information between the code. But it
-turned out that the implementation of U-Boot can be greatly
-simplified by making a global data structure (gd_t) available to all
-functions. We could pass a pointer to this data as argument to _all_
-functions, but this would bloat the code. Instead we use a feature of
-the GCC compiler (Global Register Variables) to share the data: we
-place a pointer (gd) to the global data into a register which we
-reserve for this purpose.
-
-When choosing a register for such a purpose we are restricted by the
-relevant  (E)ABI  specifications for the current architecture, and by
-GCC's implementation.
-
-For PowerPC, the following registers have specific use:
-	R1:	stack pointer
-	R2:	reserved for system use
-	R3-R4:	parameter passing and return values
-	R5-R10: parameter passing
-	R13:	small data area pointer
-	R30:	GOT pointer
-	R31:	frame pointer
-
-	(U-Boot also uses R12 as internal GOT pointer. r12
-	is a volatile register so r12 needs to be reset when
-	going back and forth between asm and C)
-
-    ==> U-Boot will use R2 to hold a pointer to the global data
-
-    Note: on PPC, we could use a static initializer (since the
-    address of the global data structure is known at compile time),
-    but it turned out that reserving a register results in somewhat
-    smaller code - although the code savings are not that big (on
-    average for all boards 752 bytes for the whole U-Boot image,
-    624 text + 127 data).
-
-On Blackfin, the normal C ABI (except for P3) is followed as documented here:
-	http://docs.blackfin.uclinux.org/doku.php?id=application_binary_interface
-
-    ==> U-Boot will use P3 to hold a pointer to the global data
-
-On ARM, the following registers are used:
-
-	R0:	function argument word/integer result
-	R1-R3:	function argument word
-	R9:	platform specific
-	R10:	stack limit (used only if stack checking is enabled)
-	R11:	argument (frame) pointer
-	R12:	temporary workspace
-	R13:	stack pointer
-	R14:	link register
-	R15:	program counter
-
-    ==> U-Boot will use R9 to hold a pointer to the global data
-
-    Note: on ARM, only R_ARM_RELATIVE relocations are supported.
-
-On Nios II, the ABI is documented here:
-	http://www.altera.com/literature/hb/nios2/n2cpu_nii51016.pdf
-
-    ==> U-Boot will use gp to hold a pointer to the global data
-
-    Note: on Nios II, we give "-G0" option to gcc and don't use gp
-    to access small data sections, so gp is free.
-
-On NDS32, the following registers are used:
-
-	R0-R1:	argument/return
-	R2-R5:	argument
-	R15:	temporary register for assembler
-	R16:	trampoline register
-	R28:	frame pointer (FP)
-	R29:	global pointer (GP)
-	R30:	link register (LP)
-	R31:	stack pointer (SP)
-	PC:	program counter (PC)
-
-    ==> U-Boot will use R10 to hold a pointer to the global data
-
-NOTE: DECLARE_GLOBAL_DATA_PTR must be used with file-global scope,
-or current versions of GCC may "optimize" the code too much.
-
-Memory Management:
-------------------
-
-U-Boot runs in system state and uses physical addresses, i.e. the
-MMU is not used either for address mapping nor for memory protection.
-
-The available memory is mapped to fixed addresses using the memory
-controller. In this process, a contiguous block is formed for each
-memory type (Flash, SDRAM, SRAM), even when it consists of several
-physical memory banks.
-
-U-Boot is installed in the first 128 kB of the first Flash bank (on
-TQM8xxL modules this is the range 0x40000000 ... 0x4001FFFF). After
-booting and sizing and initializing DRAM, the code relocates itself
-to the upper end of DRAM. Immediately below the U-Boot code some
-memory is reserved for use by malloc() [see CONFIG_SYS_MALLOC_LEN
-configuration setting]. Below that, a structure with global Board
-Info data is placed, followed by the stack (growing downward).
-
-Additionally, some exception handler code is copied to the low 8 kB
-of DRAM (0x00000000 ... 0x00001FFF).
-
-So a typical memory configuration with 16 MB of DRAM could look like
-this:
-
-	0x0000 0000	Exception Vector code
-	      :
-	0x0000 1FFF
-	0x0000 2000	Free for Application Use
-	      :
-	      :
-
-	      :
-	      :
-	0x00FB FF20	Monitor Stack (Growing downward)
-	0x00FB FFAC	Board Info Data and permanent copy of global data
-	0x00FC 0000	Malloc Arena
-	      :
-	0x00FD FFFF
-	0x00FE 0000	RAM Copy of Monitor Code
-	...		eventually: LCD or video framebuffer
-	...		eventually: pRAM (Protected RAM - unchanged by reset)
-	0x00FF FFFF	[End of RAM]
-
-
-System Initialization:
-----------------------
-
-In the reset configuration, U-Boot starts at the reset entry point
-(on most PowerPC systems at address 0x00000100). Because of the reset
-configuration for CS0# this is a mirror of the on board Flash memory.
-To be able to re-map memory U-Boot then jumps to its link address.
-To be able to implement the initialization code in C, a (small!)
-initial stack is set up in the internal Dual Ported RAM (in case CPUs
-which provide such a feature like MPC8xx or MPC8260), or in a locked
-part of the data cache. After that, U-Boot initializes the CPU core,
-the caches and the SIU.
-
-Next, all (potentially) available memory banks are mapped using a
-preliminary mapping. For example, we put them on 512 MB boundaries
-(multiples of 0x20000000: SDRAM on 0x00000000 and 0x20000000, Flash
-on 0x40000000 and 0x60000000, SRAM on 0x80000000). Then UPM A is
-programmed for SDRAM access. Using the temporary configuration, a
-simple memory test is run that determines the size of the SDRAM
-banks.
-
-When there is more than one SDRAM bank, and the banks are of
-different size, the largest is mapped first. For equal size, the first
-bank (CS2#) is mapped first. The first mapping is always for address
-0x00000000, with any additional banks following immediately to create
-contiguous memory starting from 0.
-
-Then, the monitor installs itself at the upper end of the SDRAM area
-and allocates memory for use by malloc() and for the global Board
-Info data; also, the exception vector code is copied to the low RAM
-pages, and the final stack is set up.
-
-Only after this relocation will you have a "normal" C environment;
-until that you are restricted in several ways, mostly because you are
-running from ROM, and because the code will have to be relocated to a
-new address in RAM.
-
-
-U-Boot Porting Guide:
-----------------------
-
-[Based on messages by Jerry Van Baren in the U-Boot-Users mailing
-list, October 2002]
-
-
-int main(int argc, char *argv[])
-{
-	sighandler_t no_more_time;
-
-	signal(SIGALRM, no_more_time);
-	alarm(PROJECT_DEADLINE - toSec (3 * WEEK));
-
-	if (available_money > available_manpower) {
-		Pay consultant to port U-Boot;
-		return 0;
-	}
-
-	Download latest U-Boot source;
-
-	Subscribe to u-boot mailing list;
-
-	if (clueless)
-		email("Hi, I am new to U-Boot, how do I get started?");
-
-	while (learning) {
-		Read the README file in the top level directory;
-		Read http://www.denx.de/twiki/bin/view/DULG/Manual;
-		Read applicable doc/*.README;
-		Read the source, Luke;
-		/* find . -name "*.[chS]" | xargs grep -i <keyword> */
-	}
-
-	if (available_money > toLocalCurrency ($2500))
-		Buy a BDI3000;
-	else
-		Add a lot of aggravation and time;
-
-	if (a similar board exists) {	/* hopefully... */
-		cp -a board/<similar> board/<myboard>
-		cp include/configs/<similar>.h include/configs/<myboard>.h
-	} else {
-		Create your own board support subdirectory;
-		Create your own board include/configs/<myboard>.h file;
-	}
-	Edit new board/<myboard> files
-	Edit new include/configs/<myboard>.h
-
-	while (!accepted) {
-		while (!running) {
-			do {
-				Add / modify source code;
-			} until (compiles);
-			Debug;
-			if (clueless)
-				email("Hi, I am having problems...");
-		}
-		Send patch file to the U-Boot email list;
-		if (reasonable critiques)
-			Incorporate improvements from email list code review;
-		else
-			Defend code as written;
-	}
-
-	return 0;
-}
-
-void no_more_time (int sig)
-{
-      hire_a_guru();
-}
-
-
-Coding Standards:
------------------
-
-All contributions to U-Boot should conform to the Linux kernel
-coding style; see the file "Documentation/CodingStyle" and the script
-"scripts/Lindent" in your Linux kernel source directory.
-
-Source files originating from a different project (for example the
-MTD subsystem) are generally exempt from these guidelines and are not
-reformatted to ease subsequent migration to newer versions of those
-sources.
-
-Please note that U-Boot is implemented in C (and to some small parts in
-Assembler); no C++ is used, so please do not use C++ style comments (//)
-in your code.
-
-Please also stick to the following formatting rules:
-- remove any trailing white space
-- use TAB characters for indentation and vertical alignment, not spaces
-- make sure NOT to use DOS '\r\n' line feeds
-- do not add more than 2 consecutive empty lines to source files
-- do not add trailing empty lines to source files
-
-Submissions which do not conform to the standards may be returned
-with a request to reformat the changes.
-
-
-Submitting Patches:
--------------------
-
-Since the number of patches for U-Boot is growing, we need to
-establish some rules. Submissions which do not conform to these rules
-may be rejected, even when they contain important and valuable stuff.
-
-Please see http://www.denx.de/wiki/U-Boot/Patches for details.
-
-Patches shall be sent to the u-boot mailing list <u-boot@lists.denx.de>;
-see http://lists.denx.de/mailman/listinfo/u-boot
-
-When you send a patch, please include the following information with
-it:
-
-* For bug fixes: a description of the bug and how your patch fixes
-  this bug. Please try to include a way of demonstrating that the
-  patch actually fixes something.
-
-* For new features: a description of the feature and your
-  implementation.
-
-* A CHANGELOG entry as plaintext (separate from the patch)
-
-* For major contributions, add a MAINTAINERS file with your
-  information and associated file and directory references.
-
-* When you add support for a new board, don't forget to add a
-  maintainer e-mail address to the boards.cfg file, too.
-
-* If your patch adds new configuration options, don't forget to
-  document these in the README file.
-
-* The patch itself. If you are using git (which is *strongly*
-  recommended) you can easily generate the patch using the
-  "git format-patch". If you then use "git send-email" to send it to
-  the U-Boot mailing list, you will avoid most of the common problems
-  with some other mail clients.
-
-  If you cannot use git, use "diff -purN OLD NEW". If your version of
-  diff does not support these options, then get the latest version of
-  GNU diff.
-
-  The current directory when running this command shall be the parent
-  directory of the U-Boot source tree (i. e. please make sure that
-  your patch includes sufficient directory information for the
-  affected files).
-
-  We prefer patches as plain text. MIME attachments are discouraged,
-  and compressed attachments must not be used.
-
-* If one logical set of modifications affects or creates several
-  files, all these changes shall be submitted in a SINGLE patch file.
-
-* Changesets that contain different, unrelated modifications shall be
-  submitted as SEPARATE patches, one patch per changeset.
-
-
-Notes:
-
-* Before sending the patch, run the MAKEALL script on your patched
-  source tree and make sure that no errors or warnings are reported
-  for any of the boards.
-
-* Keep your modifications to the necessary minimum: A patch
-  containing several unrelated changes or arbitrary reformats will be
-  returned with a request to re-formatting / split it.
-
-* If you modify existing code, make sure that your new code does not
-  add to the memory footprint of the code ;-) Small is beautiful!
-  When adding new features, these should compile conditionally only
-  (using #ifdef), and the resulting code with the new feature
-  disabled must not need more memory than the old code without your
-  modification.
-
-* Remember that there is a size limit of 100 kB per message on the
-  u-boot mailing list. Bigger patches will be moderated. If they are
-  reasonable and not too big, they will be acknowledged. But patches
-  bigger than the size limit should be avoided.
diff -urN u-boot-2016.03/README.md ebf_6ull_uboot/README.md
--- u-boot-2016.03/README.md	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/README.md	2021-04-16 14:42:13.932576852 +0800
@@ -0,0 +1,99 @@
+# ebf_6ull_uboot
+
+## 开发环境
+
+**ubuntu18.04**
+
+**安装独立编译工具链**
+
+arm-none-eabi-gcc：v6.3.1
+
+```bash
+ sudo apt-get install gcc-arm-none-eabi
+```
+
+**测试arm-none-eabi-gcc安装是否成功**
+
+```bash
+arm-none-eabi-gcc -v
+```
+
+**如果你的系统是64位的**
+
+如果出现`No such file or directory`问题，可以用以下命令解决
+```bash
+sudo apt-get install lib32ncurses5 lib32tinfo5 libc6-i386
+```
+---
+
+## 编译过程
+
+**清除编译信息**
+
+```bash
+make ARCH=arm clean
+```
+
+## 设置配置选项
+
+选择一个与野火开发板版本一致的配置即可!!
+
+> 注意：SD卡版本是适用于SD卡的uboot
+
+**nand版本**
+
+```bash
+make ARCH=arm mx6ull_14x14_evk_nand_defconfig
+```
+
+**#emmc版本**
+
+```bash
+make ARCH=arm mx6ull_14x14_evk_emmc_defconfig
+```
+
+**sd卡版本**
+
+```bash
+make ARCH=arm mx6ull_14x14_evk_defconfig
+```
+
+**开始编译**
+```bash
+make -j4 ARCH=arm CROSS_COMPILE=arm-none-eabi-
+```
+
+## 编译生成的uboot输出路径
+
+生成`u-boot.imx`文件
+
+```bash
+ebf_6ull_uboot/u-boot.imx
+```
+
+---
+
+## 其他信息
+
+**内核版本**
+
+来源官方 `imx_v2016.03_4.1.15_2.0.0_ga` 分支
+
+uboot官方源码：[http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/](http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/)
+
+```bash
+# Clone 
+git://git.freescale.com/imx/uboot-imx.git
+
+http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git
+```
+
+
+
+
+
+
+
+
+
+
二进制文件 u-boot-2016.03/scripts/basic/fixdep 和 ebf_6ull_uboot/scripts/basic/fixdep 不同
二进制文件 u-boot-2016.03/scripts/kconfig/conf 和 ebf_6ull_uboot/scripts/kconfig/conf 不同
diff -urN u-boot-2016.03/scripts/kconfig/zconf.hash.c ebf_6ull_uboot/scripts/kconfig/zconf.hash.c
--- u-boot-2016.03/scripts/kconfig/zconf.hash.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/scripts/kconfig/zconf.hash.c	2021-04-16 14:42:17.836597056 +0800
@@ -0,0 +1,289 @@
+/* ANSI-C code produced by gperf version 3.0.4 */
+/* Command-line: gperf -t --output-file scripts/kconfig/zconf.hash.c_shipped -a -C -E -g -k '1,3,$' -p -t scripts/kconfig/zconf.gperf  */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 10 "scripts/kconfig/zconf.gperf"
+struct kconf_id;
+
+static const struct kconf_id *kconf_id_lookup(register const char *str, register unsigned int len);
+/* maximum key range = 71, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+kconf_id_hash (register const char *str, register unsigned int len)
+{
+  static const unsigned char asso_values[] =
+    {
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73,  5, 25, 25,
+       0,  0,  0,  5,  0,  0, 73, 73,  5,  0,
+      10,  5, 45, 73, 20, 20,  0, 15, 15, 73,
+      20,  5, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73
+    };
+  register int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[2]];
+      /*FALLTHROUGH*/
+      case 2:
+      case 1:
+        hval += asso_values[(unsigned char)str[0]];
+        break;
+    }
+  return hval + asso_values[(unsigned char)str[len - 1]];
+}
+
+struct kconf_id_strings_t
+  {
+    char kconf_id_strings_str2[sizeof("if")];
+    char kconf_id_strings_str3[sizeof("int")];
+    char kconf_id_strings_str5[sizeof("endif")];
+    char kconf_id_strings_str7[sizeof("default")];
+    char kconf_id_strings_str8[sizeof("tristate")];
+    char kconf_id_strings_str9[sizeof("endchoice")];
+    char kconf_id_strings_str12[sizeof("def_tristate")];
+    char kconf_id_strings_str13[sizeof("def_bool")];
+    char kconf_id_strings_str14[sizeof("defconfig_list")];
+    char kconf_id_strings_str17[sizeof("on")];
+    char kconf_id_strings_str18[sizeof("optional")];
+    char kconf_id_strings_str21[sizeof("option")];
+    char kconf_id_strings_str22[sizeof("endmenu")];
+    char kconf_id_strings_str23[sizeof("mainmenu")];
+    char kconf_id_strings_str25[sizeof("menuconfig")];
+    char kconf_id_strings_str27[sizeof("modules")];
+    char kconf_id_strings_str28[sizeof("allnoconfig_y")];
+    char kconf_id_strings_str29[sizeof("menu")];
+    char kconf_id_strings_str31[sizeof("select")];
+    char kconf_id_strings_str32[sizeof("comment")];
+    char kconf_id_strings_str33[sizeof("env")];
+    char kconf_id_strings_str35[sizeof("range")];
+    char kconf_id_strings_str36[sizeof("choice")];
+    char kconf_id_strings_str39[sizeof("bool")];
+    char kconf_id_strings_str41[sizeof("source")];
+    char kconf_id_strings_str42[sizeof("visible")];
+    char kconf_id_strings_str43[sizeof("hex")];
+    char kconf_id_strings_str46[sizeof("config")];
+    char kconf_id_strings_str47[sizeof("boolean")];
+    char kconf_id_strings_str51[sizeof("string")];
+    char kconf_id_strings_str54[sizeof("help")];
+    char kconf_id_strings_str56[sizeof("prompt")];
+    char kconf_id_strings_str72[sizeof("depends")];
+  };
+static const struct kconf_id_strings_t kconf_id_strings_contents =
+  {
+    "if",
+    "int",
+    "endif",
+    "default",
+    "tristate",
+    "endchoice",
+    "def_tristate",
+    "def_bool",
+    "defconfig_list",
+    "on",
+    "optional",
+    "option",
+    "endmenu",
+    "mainmenu",
+    "menuconfig",
+    "modules",
+    "allnoconfig_y",
+    "menu",
+    "select",
+    "comment",
+    "env",
+    "range",
+    "choice",
+    "bool",
+    "source",
+    "visible",
+    "hex",
+    "config",
+    "boolean",
+    "string",
+    "help",
+    "prompt",
+    "depends"
+  };
+#define kconf_id_strings ((const char *) &kconf_id_strings_contents)
+#ifdef __GNUC__
+__inline
+#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+const struct kconf_id *
+kconf_id_lookup (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 33,
+      MIN_WORD_LENGTH = 2,
+      MAX_WORD_LENGTH = 14,
+      MIN_HASH_VALUE = 2,
+      MAX_HASH_VALUE = 72
+    };
+
+  static const struct kconf_id wordlist[] =
+    {
+      {-1}, {-1},
+#line 25 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str2,		T_IF,		TF_COMMAND|TF_PARAM},
+#line 36 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str3,		T_TYPE,		TF_COMMAND, S_INT},
+      {-1},
+#line 26 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str5,		T_ENDIF,	TF_COMMAND},
+      {-1},
+#line 29 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str7,	T_DEFAULT,	TF_COMMAND, S_UNKNOWN},
+#line 31 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str8,	T_TYPE,		TF_COMMAND, S_TRISTATE},
+#line 20 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str9,	T_ENDCHOICE,	TF_COMMAND},
+      {-1}, {-1},
+#line 32 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str12,	T_DEFAULT,	TF_COMMAND, S_TRISTATE},
+#line 35 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str13,	T_DEFAULT,	TF_COMMAND, S_BOOLEAN},
+#line 45 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str14,	T_OPT_DEFCONFIG_LIST,TF_OPTION},
+      {-1}, {-1},
+#line 43 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str17,		T_ON,		TF_PARAM},
+#line 28 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str18,	T_OPTIONAL,	TF_COMMAND},
+      {-1}, {-1},
+#line 42 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str21,		T_OPTION,	TF_COMMAND},
+#line 17 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str22,	T_ENDMENU,	TF_COMMAND},
+#line 15 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str23,	T_MAINMENU,	TF_COMMAND},
+      {-1},
+#line 23 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str25,	T_MENUCONFIG,	TF_COMMAND},
+      {-1},
+#line 44 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str27,	T_OPT_MODULES,	TF_OPTION},
+#line 47 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str28,	T_OPT_ALLNOCONFIG_Y,TF_OPTION},
+#line 16 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str29,		T_MENU,		TF_COMMAND},
+      {-1},
+#line 39 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str31,		T_SELECT,	TF_COMMAND},
+#line 21 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str32,	T_COMMENT,	TF_COMMAND},
+#line 46 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str33,		T_OPT_ENV,	TF_OPTION},
+      {-1},
+#line 40 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str35,		T_RANGE,	TF_COMMAND},
+#line 19 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str36,		T_CHOICE,	TF_COMMAND},
+      {-1}, {-1},
+#line 33 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str39,		T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {-1},
+#line 18 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str41,		T_SOURCE,	TF_COMMAND},
+#line 41 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str42,	T_VISIBLE,	TF_COMMAND},
+#line 37 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str43,		T_TYPE,		TF_COMMAND, S_HEX},
+      {-1}, {-1},
+#line 22 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str46,		T_CONFIG,	TF_COMMAND},
+#line 34 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str47,	T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {-1}, {-1}, {-1},
+#line 38 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str51,		T_TYPE,		TF_COMMAND, S_STRING},
+      {-1}, {-1},
+#line 24 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str54,		T_HELP,		TF_COMMAND},
+      {-1},
+#line 30 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str56,		T_PROMPT,	TF_COMMAND},
+      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+#line 27 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str72,	T_DEPENDS,	TF_COMMAND}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = kconf_id_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register int o = wordlist[key].name;
+          if (o >= 0)
+            {
+              register const char *s = o + kconf_id_strings;
+
+              if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')
+                return &wordlist[key];
+            }
+        }
+    }
+  return 0;
+}
+#line 48 "scripts/kconfig/zconf.gperf"
+
diff -urN u-boot-2016.03/scripts/kconfig/zconf.lex.c ebf_6ull_uboot/scripts/kconfig/zconf.lex.c
--- u-boot-2016.03/scripts/kconfig/zconf.lex.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/scripts/kconfig/zconf.lex.c	2021-04-16 14:42:17.836597056 +0800
@@ -0,0 +1,2420 @@
+
+#line 3 "scripts/kconfig/zconf.lex.c_shipped"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer zconf_create_buffer
+#define yy_delete_buffer zconf_delete_buffer
+#define yy_flex_debug zconf_flex_debug
+#define yy_init_buffer zconf_init_buffer
+#define yy_flush_buffer zconf_flush_buffer
+#define yy_load_buffer_state zconf_load_buffer_state
+#define yy_switch_to_buffer zconf_switch_to_buffer
+#define yyin zconfin
+#define yyleng zconfleng
+#define yylex zconflex
+#define yylineno zconflineno
+#define yyout zconfout
+#define yyrestart zconfrestart
+#define yytext zconftext
+#define yywrap zconfwrap
+#define yyalloc zconfalloc
+#define yyrealloc zconfrealloc
+#define yyfree zconffree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE zconfrestart(zconfin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int zconfleng;
+
+extern FILE *zconfin, *zconfout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up zconftext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via zconfrestart()), so that the user can continue scanning by
+	 * just pointing zconfin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when zconftext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int zconfleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow zconfwrap()'s to do buffer switches
+ * instead of setting up a fresh zconfin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void zconfrestart (FILE *input_file  );
+void zconf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE zconf_create_buffer (FILE *file,int size  );
+void zconf_delete_buffer (YY_BUFFER_STATE b  );
+void zconf_flush_buffer (YY_BUFFER_STATE b  );
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void zconfpop_buffer_state (void );
+
+static void zconfensure_buffer_stack (void );
+static void zconf_load_buffer_state (void );
+static void zconf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER zconf_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE zconf_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE zconf_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE zconf_scan_bytes (yyconst char *bytes,int len  );
+
+void *zconfalloc (yy_size_t  );
+void *zconfrealloc (void *,yy_size_t  );
+void zconffree (void *  );
+
+#define yy_new_buffer zconf_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define zconfwrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *zconfin = (FILE *) 0, *zconfout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int zconflineno;
+
+int zconflineno = 1;
+
+extern char *zconftext;
+#define yytext_ptr zconftext
+static yyconst flex_int16_t yy_nxt[][17] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+    },
+
+    {
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+       11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+       11,  -13,   39,   40,  -13,  -13,   41,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+       11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+       11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+       11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,   44,  -18,  -18,  -18
+    },
+
+    {
+       11,   45,   45,  -19,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+
+    },
+
+    {
+       11,  -20,   46,   47,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20
+    },
+
+    {
+       11,   48,  -21,  -21,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -22,   49,   49,  -22,   49,
+       49,   49,   49,   49,   49,  -22,   49
+    },
+
+    {
+       11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23
+    },
+
+    {
+       11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24
+
+    },
+
+    {
+       11,   51,   51,   52,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51
+    },
+
+    {
+       11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26
+    },
+
+    {
+       11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27
+    },
+
+    {
+       11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,   53,  -28,  -28
+    },
+
+    {
+       11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29
+
+    },
+
+    {
+       11,   54,   54,  -30,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,  -31,  -31,  -31,  -31,  -31,  -31,   55,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31
+    },
+
+    {
+       11,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+       11,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33
+    },
+
+    {
+       11,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,   56,   57,   57,  -34,  -34,  -34
+
+    },
+
+    {
+       11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,   57,   57,   57,  -35,  -35,  -35
+    },
+
+    {
+       11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+       11,  -37,  -37,   58,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37
+    },
+
+    {
+       11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,   59
+    },
+
+    {
+       11,  -39,   39,   40,  -39,  -39,   41,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+       11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+       11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,   44,  -44,  -44,  -44
+
+    },
+
+    {
+       11,   45,   45,  -45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+    },
+
+    {
+       11,  -46,   46,   47,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46
+    },
+
+    {
+       11,   48,  -47,  -47,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -49,   49,   49,  -49,   49,
+       49,   49,   49,   49,   49,  -49,   49
+
+    },
+
+    {
+       11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50
+    },
+
+    {
+       11,  -51,  -51,   52,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+       11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+       11,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53
+    },
+
+    {
+       11,   54,   54,  -54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+
+    },
+
+    {
+       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55
+    },
+
+    {
+       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,   60,   57,   57,  -56,  -56,  -56
+    },
+
+    {
+       11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,   57,   57,   57,  -57,  -57,  -57
+    },
+
+    {
+       11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+      -58,  -58,  -58,  -58,  -58,  -58,  -58
+    },
+
+    {
+       11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59
+
+    },
+
+    {
+       11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,   57,   57,   57,  -60,  -60,  -60
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up zconftext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	zconfleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 33
+#define YY_END_OF_BUFFER 34
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[61] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       34,    5,    4,    2,    3,    7,    8,    6,   32,   29,
+       31,   24,   28,   27,   26,   22,   17,   13,   16,   20,
+       22,   11,   12,   19,   19,   14,   22,   22,    4,    2,
+        3,    3,    1,    6,   32,   29,   31,   30,   24,   23,
+       26,   25,   15,   20,    9,   19,   19,   21,   10,   18
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   13,    1,   13,   13,   13,   13,
+
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,    1,   16,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+extern int zconf_flex_debug;
+int zconf_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *zconftext;
+#define YY_NO_INPUT 1
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "lkc.h"
+
+#define START_STRSIZE	16
+
+static struct {
+	struct file *file;
+	int lineno;
+} current_pos;
+
+static char *text;
+static int text_size, text_asize;
+
+struct buffer {
+	struct buffer *parent;
+	YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static void zconf_endfile(void);
+
+static void new_string(void)
+{
+	text = xmalloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_size = 0;
+	*text = 0;
+}
+
+static void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		new_size += START_STRSIZE - 1;
+		new_size &= -START_STRSIZE;
+		text = realloc(text, new_size);
+		text_asize = new_size;
+	}
+	memcpy(text + text_size, str, size);
+	text_size += size;
+	text[text_size] = 0;
+}
+
+static void alloc_string(const char *str, int size)
+{
+	text = xmalloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+
+#define INITIAL 0
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int zconflex_destroy (void );
+
+int zconfget_debug (void );
+
+void zconfset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE zconfget_extra (void );
+
+void zconfset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *zconfget_in (void );
+
+void zconfset_in  (FILE * in_str  );
+
+FILE *zconfget_out (void );
+
+void zconfset_out  (FILE * out_str  );
+
+int zconfget_leng (void );
+
+char *zconfget_text (void );
+
+int zconfget_lineno (void );
+
+void zconfset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int zconfwrap (void );
+#else
+extern int zconfwrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( zconftext, zconfleng, 1, zconfout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(zconfin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(zconfin); \
+	}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int zconflex (void);
+
+#define YY_DECL int zconflex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after zconftext and zconfleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+	int str = 0;
+	int ts, i;
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! zconfin )
+			zconfin = stdin;
+
+		if ( ! zconfout )
+			zconfout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			zconfensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				zconf_create_buffer(zconfin,YY_BUF_SIZE );
+		}
+
+		zconf_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of zconftext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+/* rule 1 can match eol */
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+{
+	current_file->lineno++;
+	return T_EOL;
+}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+{
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+{
+	unput(zconftext[0]);
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+
+case 6:
+YY_RULE_SETUP
+{
+		const struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		BEGIN(PARAM);
+		current_pos.file = current_file;
+		current_pos.lineno = current_file->lineno;
+		if (id && id->flags & TF_COMMAND) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 8:
+/* rule 8 can match eol */
+YY_RULE_SETUP
+{
+		BEGIN(INITIAL);
+		current_file->lineno++;
+		return T_EOL;
+	}
+	YY_BREAK
+
+case 9:
+YY_RULE_SETUP
+return T_AND;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+return T_OR;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+return T_OPEN_PAREN;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+return T_NOT;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+return T_EQUAL;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+return T_UNEQUAL;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+{
+		str = zconftext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	YY_BREAK
+case 17:
+/* rule 17 can match eol */
+YY_RULE_SETUP
+BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+/* ignore */
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+{
+		const struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		if (id && id->flags & TF_PARAM) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+/* comment */
+	YY_BREAK
+case 21:
+/* rule 21 can match eol */
+YY_RULE_SETUP
+current_file->lineno++;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+
+	YY_BREAK
+case YY_STATE_EOF(PARAM):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 23:
+/* rule 23 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+	}
+	YY_BREAK
+case 25:
+/* rule 25 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+	}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+{
+		if (str == zconftext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			return T_WORD_QUOTE;
+		} else
+			append_string(zconftext, 1);
+	}
+	YY_BREAK
+case 28:
+/* rule 28 can match eol */
+YY_RULE_SETUP
+{
+		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		current_file->lineno++;
+		BEGIN(INITIAL);
+		return T_EOL;
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 29:
+YY_RULE_SETUP
+{
+		ts = 0;
+		for (i = 0; i < zconfleng; i++) {
+			if (zconftext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+	}
+	YY_BREAK
+case 30:
+/* rule 30 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 31:
+/* rule 31 can match eol */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+{
+		while (zconfleng) {
+			if ((zconftext[zconfleng-1] != ' ') && (zconftext[zconfleng-1] != '\t'))
+				break;
+			zconfleng--;
+		}
+		append_string(zconftext, zconfleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMAND):
+{
+	if (current_file) {
+		zconf_endfile();
+		return T_EOL;
+	}
+	fclose(zconfin);
+	yyterminate();
+}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed zconfin at a new source and called
+			 * zconflex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = zconfin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( zconfwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * zconftext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of zconflex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					zconfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			zconfrestart(zconfin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) zconfrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up zconftext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					zconfrestart(zconfin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( zconfwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve zconftext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void zconfrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        zconfensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            zconf_create_buffer(zconfin,YY_BUF_SIZE );
+	}
+
+	zconf_init_buffer(YY_CURRENT_BUFFER,input_file );
+	zconf_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		zconfpop_buffer_state();
+	 *		zconfpush_buffer_state(new_buffer);
+     */
+	zconfensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	zconf_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (zconfwrap()) processing, but the only time this flag
+	 * is looked at is after zconfwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void zconf_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	zconfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) zconfalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	zconf_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with zconf_create_buffer()
+ * 
+ */
+    void zconf_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		zconffree((void *) b->yy_ch_buf  );
+
+	zconffree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a zconfrestart() or at EOF.
+ */
+    static void zconf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	zconf_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then zconf_init_buffer was _probably_
+     * called from zconfrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void zconf_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		zconf_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	zconfensure_buffer_stack();
+
+	/* This block is copied from zconf_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from zconf_switch_to_buffer. */
+	zconf_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void zconfpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	zconf_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		zconf_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void zconfensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	zconf_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to zconflex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       zconf_scan_bytes() instead.
+ */
+YY_BUFFER_STATE zconf_scan_string (yyconst char * yystr )
+{
+    
+	return zconf_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to zconflex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) zconfalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = zconf_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in zconf_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		zconftext[zconfleng] = (yy_hold_char); \
+		(yy_c_buf_p) = zconftext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		zconfleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int zconfget_lineno  (void)
+{
+        
+    return zconflineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *zconfget_in  (void)
+{
+        return zconfin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *zconfget_out  (void)
+{
+        return zconfout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int zconfget_leng  (void)
+{
+        return zconfleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *zconfget_text  (void)
+{
+        return zconftext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void zconfset_lineno (int  line_number )
+{
+    
+    zconflineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see zconf_switch_to_buffer
+ */
+void zconfset_in (FILE *  in_str )
+{
+        zconfin = in_str ;
+}
+
+void zconfset_out (FILE *  out_str )
+{
+        zconfout = out_str ;
+}
+
+int zconfget_debug  (void)
+{
+        return zconf_flex_debug;
+}
+
+void zconfset_debug (int  bdebug )
+{
+        zconf_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from zconflex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    zconfin = stdin;
+    zconfout = stdout;
+#else
+    zconfin = (FILE *) 0;
+    zconfout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * zconflex_init()
+     */
+    return 0;
+}
+
+/* zconflex_destroy is for both reentrant and non-reentrant scanners. */
+int zconflex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		zconf_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		zconfpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	zconffree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * zconflex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *zconfalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *zconfrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void zconffree (void * ptr )
+{
+	free( (char *) ptr );	/* see zconfrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL);
+}
+
+/*
+ * Try to open specified file with following names:
+ * ./name
+ * $(srctree)/name
+ * The latter is used when srctree is separate from objtree
+ * when compiling the kernel.
+ * Return NULL if file is not found.
+ */
+FILE *zconf_fopen(const char *name)
+{
+	char *env, fullname[PATH_MAX+1];
+	FILE *f;
+
+	f = fopen(name, "r");
+	if (!f && name != NULL && name[0] != '/') {
+		env = getenv(SRCTREE);
+		if (env) {
+			sprintf(fullname, "%s/%s", env, name);
+			f = fopen(fullname, "r");
+		}
+	}
+	return f;
+}
+
+void zconf_initscan(const char *name)
+{
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+
+	current_buf = xmalloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *iter;
+	struct file *file = file_lookup(name);
+	struct buffer *buf = xmalloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	zconfin = zconf_fopen(file->name);
+	if (!zconfin) {
+		printf("%s:%d: can't open file \"%s\"\n",
+		    zconf_curname(), zconf_lineno(), file->name);
+		exit(1);
+	}
+	zconf_switch_to_buffer(zconf_create_buffer(zconfin,YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	for (iter = current_file->parent; iter; iter = iter->parent ) {
+		if (!strcmp(current_file->name,iter->name) ) {
+			printf("%s:%d: recursive inclusion detected. "
+			       "Inclusion path:\n  current file : '%s'\n",
+			       zconf_curname(), zconf_lineno(),
+			       zconf_curname());
+			iter = current_file->parent;
+			while (iter && \
+			       strcmp(iter->name,current_file->name)) {
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno-1);
+				iter = iter->parent;
+			}
+			if (iter)
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno+1);
+			exit(1);
+		}
+	}
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static void zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		fclose(zconfin);
+		zconf_delete_buffer(YY_CURRENT_BUFFER);
+		zconf_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+}
+
+int zconf_lineno(void)
+{
+	return current_pos.lineno;
+}
+
+const char *zconf_curname(void)
+{
+	return current_pos.file ? current_pos.file->name : "<none>";
+}
+
diff -urN u-boot-2016.03/scripts/kconfig/zconf.tab.c ebf_6ull_uboot/scripts/kconfig/zconf.tab.c
--- u-boot-2016.03/scripts/kconfig/zconf.tab.c	1970-01-01 08:00:00.000000000 +0800
+++ ebf_6ull_uboot/scripts/kconfig/zconf.tab.c	2021-04-16 14:42:17.836597056 +0800
@@ -0,0 +1,2538 @@
+/* A Bison parser, made by GNU Bison 2.5.  */
+
+/* Bison implementation for Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.5"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse         zconfparse
+#define yylex           zconflex
+#define yyerror         zconferror
+#define yylval          zconflval
+#define yychar          zconfchar
+#define yydebug         zconfdebug
+#define yynerrs         zconfnerrs
+
+
+/* Copy the first part of user declarations.  */
+
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include "lkc.h"
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconf_error(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(const struct kconf_id *id, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[SYMBOL_HASHSIZE];
+
+static struct menu *current_menu, *current_entry;
+
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_MAINMENU = 258,
+     T_MENU = 259,
+     T_ENDMENU = 260,
+     T_SOURCE = 261,
+     T_CHOICE = 262,
+     T_ENDCHOICE = 263,
+     T_COMMENT = 264,
+     T_CONFIG = 265,
+     T_MENUCONFIG = 266,
+     T_HELP = 267,
+     T_HELPTEXT = 268,
+     T_IF = 269,
+     T_ENDIF = 270,
+     T_DEPENDS = 271,
+     T_OPTIONAL = 272,
+     T_PROMPT = 273,
+     T_TYPE = 274,
+     T_DEFAULT = 275,
+     T_SELECT = 276,
+     T_RANGE = 277,
+     T_VISIBLE = 278,
+     T_OPTION = 279,
+     T_ON = 280,
+     T_WORD = 281,
+     T_WORD_QUOTE = 282,
+     T_UNEQUAL = 283,
+     T_CLOSE_PAREN = 284,
+     T_OPEN_PAREN = 285,
+     T_EOL = 286,
+     T_OR = 287,
+     T_AND = 288,
+     T_EQUAL = 289,
+     T_NOT = 290
+   };
+#endif
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+
+	char *string;
+	struct file *file;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+	const struct kconf_id *id;
+
+
+
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Include zconf.hash.c here so it can see the token constants. */
+#include "zconf.hash.c"
+
+
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  11
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   290
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  36
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  50
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  118
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  191
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   290
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     6,     8,    11,    13,    14,    17,    20,
+      23,    26,    31,    36,    40,    42,    44,    46,    48,    50,
+      52,    54,    56,    58,    60,    62,    64,    66,    68,    72,
+      75,    79,    82,    86,    89,    90,    93,    96,    99,   102,
+     105,   108,   112,   117,   122,   127,   133,   137,   138,   142,
+     143,   146,   150,   153,   155,   159,   160,   163,   166,   169,
+     172,   175,   180,   184,   187,   192,   193,   196,   200,   202,
+     206,   207,   210,   213,   216,   220,   224,   228,   230,   234,
+     235,   238,   241,   244,   248,   252,   255,   258,   261,   262,
+     265,   268,   271,   276,   277,   280,   283,   286,   287,   290,
+     292,   294,   297,   300,   303,   305,   308,   309,   312,   314,
+     318,   322,   326,   329,   333,   337,   339,   341,   342
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      37,     0,    -1,    81,    38,    -1,    38,    -1,    63,    39,
+      -1,    39,    -1,    -1,    39,    41,    -1,    39,    55,    -1,
+      39,    67,    -1,    39,    80,    -1,    39,    26,     1,    31,
+      -1,    39,    40,     1,    31,    -1,    39,     1,    31,    -1,
+      16,    -1,    18,    -1,    19,    -1,    21,    -1,    17,    -1,
+      22,    -1,    20,    -1,    23,    -1,    31,    -1,    61,    -1,
+      71,    -1,    44,    -1,    46,    -1,    69,    -1,    26,     1,
+      31,    -1,     1,    31,    -1,    10,    26,    31,    -1,    43,
+      47,    -1,    11,    26,    31,    -1,    45,    47,    -1,    -1,
+      47,    48,    -1,    47,    49,    -1,    47,    75,    -1,    47,
+      73,    -1,    47,    42,    -1,    47,    31,    -1,    19,    78,
+      31,    -1,    18,    79,    82,    31,    -1,    20,    83,    82,
+      31,    -1,    21,    26,    82,    31,    -1,    22,    84,    84,
+      82,    31,    -1,    24,    50,    31,    -1,    -1,    50,    26,
+      51,    -1,    -1,    34,    79,    -1,     7,    85,    31,    -1,
+      52,    56,    -1,    80,    -1,    53,    58,    54,    -1,    -1,
+      56,    57,    -1,    56,    75,    -1,    56,    73,    -1,    56,
+      31,    -1,    56,    42,    -1,    18,    79,    82,    31,    -1,
+      19,    78,    31,    -1,    17,    31,    -1,    20,    26,    82,
+      31,    -1,    -1,    58,    41,    -1,    14,    83,    81,    -1,
+      80,    -1,    59,    62,    60,    -1,    -1,    62,    41,    -1,
+      62,    67,    -1,    62,    55,    -1,     3,    79,    81,    -1,
+       4,    79,    31,    -1,    64,    76,    74,    -1,    80,    -1,
+      65,    68,    66,    -1,    -1,    68,    41,    -1,    68,    67,
+      -1,    68,    55,    -1,     6,    79,    31,    -1,     9,    79,
+      31,    -1,    70,    74,    -1,    12,    31,    -1,    72,    13,
+      -1,    -1,    74,    75,    -1,    74,    31,    -1,    74,    42,
+      -1,    16,    25,    83,    31,    -1,    -1,    76,    77,    -1,
+      76,    31,    -1,    23,    82,    -1,    -1,    79,    82,    -1,
+      26,    -1,    27,    -1,     5,    31,    -1,     8,    31,    -1,
+      15,    31,    -1,    31,    -1,    81,    31,    -1,    -1,    14,
+      83,    -1,    84,    -1,    84,    34,    84,    -1,    84,    28,
+      84,    -1,    30,    83,    29,    -1,    35,    83,    -1,    83,
+      32,    83,    -1,    83,    33,    83,    -1,    26,    -1,    27,
+      -1,    -1,    26,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   103,   103,   103,   105,   105,   107,   109,   110,   111,
+     112,   113,   114,   118,   122,   122,   122,   122,   122,   122,
+     122,   122,   126,   127,   128,   129,   130,   131,   135,   136,
+     142,   150,   156,   164,   174,   176,   177,   178,   179,   180,
+     181,   184,   192,   198,   208,   214,   220,   223,   225,   236,
+     237,   242,   251,   256,   264,   267,   269,   270,   271,   272,
+     273,   276,   282,   293,   299,   309,   311,   316,   324,   332,
+     335,   337,   338,   339,   344,   351,   358,   363,   371,   374,
+     376,   377,   378,   381,   389,   396,   403,   409,   416,   418,
+     419,   420,   423,   431,   433,   434,   437,   444,   446,   451,
+     452,   455,   456,   457,   461,   462,   465,   466,   469,   470,
+     471,   472,   473,   474,   475,   478,   479,   482,   483
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "T_MAINMENU", "T_MENU", "T_ENDMENU",
+  "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG",
+  "T_MENUCONFIG", "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS",
+  "T_OPTIONAL", "T_PROMPT", "T_TYPE", "T_DEFAULT", "T_SELECT", "T_RANGE",
+  "T_VISIBLE", "T_OPTION", "T_ON", "T_WORD", "T_WORD_QUOTE", "T_UNEQUAL",
+  "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_EOL", "T_OR", "T_AND", "T_EQUAL",
+  "T_NOT", "$accept", "input", "start", "stmt_list", "option_name",
+  "common_stmt", "option_error", "config_entry_start", "config_stmt",
+  "menuconfig_entry_start", "menuconfig_stmt", "config_option_list",
+  "config_option", "symbol_option", "symbol_option_list",
+  "symbol_option_arg", "choice", "choice_entry", "choice_end",
+  "choice_stmt", "choice_option_list", "choice_option", "choice_block",
+  "if_entry", "if_end", "if_stmt", "if_block", "mainmenu_stmt", "menu",
+  "menu_entry", "menu_end", "menu_stmt", "menu_block", "source_stmt",
+  "comment", "comment_stmt", "help_start", "help", "depends_list",
+  "depends", "visibility_list", "visible", "prompt_stmt_opt", "prompt",
+  "end", "nl", "if_expr", "expr", "symbol", "word_opt", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    36,    37,    37,    38,    38,    39,    39,    39,    39,
+      39,    39,    39,    39,    40,    40,    40,    40,    40,    40,
+      40,    40,    41,    41,    41,    41,    41,    41,    42,    42,
+      43,    44,    45,    46,    47,    47,    47,    47,    47,    47,
+      47,    48,    48,    48,    48,    48,    49,    50,    50,    51,
+      51,    52,    53,    54,    55,    56,    56,    56,    56,    56,
+      56,    57,    57,    57,    57,    58,    58,    59,    60,    61,
+      62,    62,    62,    62,    63,    64,    65,    66,    67,    68,
+      68,    68,    68,    69,    70,    71,    72,    73,    74,    74,
+      74,    74,    75,    76,    76,    76,    77,    78,    78,    79,
+      79,    80,    80,    80,    81,    81,    82,    82,    83,    83,
+      83,    83,    83,    83,    83,    84,    84,    85,    85
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     2,     1,     2,     1,     0,     2,     2,     2,
+       2,     4,     4,     3,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     3,     2,
+       3,     2,     3,     2,     0,     2,     2,     2,     2,     2,
+       2,     3,     4,     4,     4,     5,     3,     0,     3,     0,
+       2,     3,     2,     1,     3,     0,     2,     2,     2,     2,
+       2,     4,     3,     2,     4,     0,     2,     3,     1,     3,
+       0,     2,     2,     2,     3,     3,     3,     1,     3,     0,
+       2,     2,     2,     3,     3,     2,     2,     2,     0,     2,
+       2,     2,     4,     0,     2,     2,     2,     0,     2,     1,
+       1,     2,     2,     2,     1,     2,     0,     2,     1,     3,
+       3,     3,     2,     3,     3,     1,     1,     0,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
+   Performed when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       6,     0,   104,     0,     3,     0,     6,     6,    99,   100,
+       0,     1,     0,     0,     0,     0,   117,     0,     0,     0,
+       0,     0,     0,    14,    18,    15,    16,    20,    17,    19,
+      21,     0,    22,     0,     7,    34,    25,    34,    26,    55,
+      65,     8,    70,    23,    93,    79,     9,    27,    88,    24,
+      10,     0,   105,     2,    74,    13,     0,   101,     0,   118,
+       0,   102,     0,     0,     0,   115,   116,     0,     0,     0,
+     108,   103,     0,     0,     0,     0,     0,     0,     0,    88,
+       0,     0,    75,    83,    51,    84,    30,    32,     0,   112,
+       0,     0,    67,     0,     0,    11,    12,     0,     0,     0,
+       0,    97,     0,     0,     0,    47,     0,    40,    39,    35,
+      36,     0,    38,    37,     0,     0,    97,     0,    59,    60,
+      56,    58,    57,    66,    54,    53,    71,    73,    69,    72,
+      68,   106,    95,     0,    94,    80,    82,    78,    81,    77,
+      90,    91,    89,   111,   113,   114,   110,   109,    29,    86,
+       0,   106,     0,   106,   106,   106,     0,     0,     0,    87,
+      63,   106,     0,   106,     0,    96,     0,     0,    41,    98,
+       0,     0,   106,    49,    46,    28,     0,    62,     0,   107,
+      92,    42,    43,    44,     0,     0,    48,    61,    64,    45,
+      50
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     3,     4,     5,    33,    34,   108,    35,    36,    37,
+      38,    74,   109,   110,   157,   186,    39,    40,   124,    41,
+      76,   120,    77,    42,   128,    43,    78,     6,    44,    45,
+     137,    46,    80,    47,    48,    49,   111,   112,    81,   113,
+      79,   134,   152,   153,    50,     7,   165,    69,    70,    60
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -90
+static const yytype_int16 yypact[] =
+{
+       4,    42,   -90,    96,   -90,   111,   -90,    15,   -90,   -90,
+      75,   -90,    82,    42,   104,    42,   110,   107,    42,   115,
+     125,    -4,   121,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   162,   -90,   163,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   139,   -90,   -90,   138,   -90,   142,   -90,   143,   -90,
+     152,   -90,   164,   167,   168,   -90,   -90,    -4,    -4,    77,
+     -18,   -90,   177,   185,    33,    71,   195,   247,   236,    -2,
+     236,   171,   -90,   -90,   -90,   -90,   -90,   -90,    41,   -90,
+      -4,    -4,   138,    97,    97,   -90,   -90,   186,   187,   194,
+      42,    42,    -4,   196,    97,   -90,   219,   -90,   -90,   -90,
+     -90,   210,   -90,   -90,   204,    42,    42,   199,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   222,   -90,   223,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   215,   -90,   -90,   -90,   -90,   -90,
+      -4,   222,   228,   222,    -5,   222,    97,    35,   229,   -90,
+     -90,   222,   232,   222,    -4,   -90,   135,   233,   -90,   -90,
+     234,   235,   222,   240,   -90,   -90,   237,   -90,   239,   -13,
+     -90,   -90,   -90,   -90,   244,    42,   -90,   -90,   -90,   -90,
+     -90
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+     -90,   -90,   269,   271,   -90,    23,   -70,   -90,   -90,   -90,
+     -90,   243,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -48,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -20,   -90,   -90,   -90,   -90,   -90,   206,   205,   -68,
+     -90,   -90,   169,    -1,    27,    -7,   118,   -66,   -89,   -90
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -86
+static const yytype_int16 yytable[] =
+{
+      10,    88,    89,    54,   146,   147,   119,     1,   122,   164,
+      93,   141,    56,   142,    58,   156,    94,    62,     1,    90,
+      91,   131,    65,    66,   144,   145,    67,    90,    91,   132,
+     127,    68,   136,   -31,    97,     2,   154,   -31,   -31,   -31,
+     -31,   -31,   -31,   -31,   -31,    98,    52,   -31,   -31,    99,
+     -31,   100,   101,   102,   103,   104,   -31,   105,   129,   106,
+     138,   173,    92,   141,   107,   142,   174,   172,     8,     9,
+     143,   -33,    97,    90,    91,   -33,   -33,   -33,   -33,   -33,
+     -33,   -33,   -33,    98,   166,   -33,   -33,    99,   -33,   100,
+     101,   102,   103,   104,   -33,   105,    11,   106,   179,   151,
+     123,   126,   107,   135,   125,   130,     2,   139,     2,    90,
+      91,    -5,    12,    55,   161,    13,    14,    15,    16,    17,
+      18,    19,    20,    65,    66,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    57,    59,    31,    61,    -4,
+      12,    63,    32,    13,    14,    15,    16,    17,    18,    19,
+      20,    64,    71,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    72,    73,    31,   180,    90,    91,    52,
+      32,   -85,    97,    82,    83,   -85,   -85,   -85,   -85,   -85,
+     -85,   -85,   -85,    84,   190,   -85,   -85,    99,   -85,   -85,
+     -85,   -85,   -85,   -85,   -85,    85,    97,   106,    86,    87,
+     -52,   -52,   140,   -52,   -52,   -52,   -52,    98,    95,   -52,
+     -52,    99,   114,   115,   116,   117,    96,   148,   149,   150,
+     158,   106,   155,   159,    97,   163,   118,   -76,   -76,   -76,
+     -76,   -76,   -76,   -76,   -76,   160,   164,   -76,   -76,    99,
+      13,    14,    15,    16,    17,    18,    19,    20,    91,   106,
+      21,    22,    14,    15,   140,    17,    18,    19,    20,   168,
+     175,    21,    22,   177,   181,   182,   183,    32,   187,   167,
+     188,   169,   170,   171,   185,   189,    53,    51,    32,   176,
+      75,   178,   121,     0,   133,   162,     0,     0,     0,     0,
+     184
+};
+
+#define yypact_value_is_default(yystate) \
+  ((yystate) == (-90))
+
+#define yytable_value_is_error(yytable_value) \
+  YYID (0)
+
+static const yytype_int16 yycheck[] =
+{
+       1,    67,    68,    10,    93,    94,    76,     3,    76,    14,
+      28,    81,    13,    81,    15,   104,    34,    18,     3,    32,
+      33,    23,    26,    27,    90,    91,    30,    32,    33,    31,
+      78,    35,    80,     0,     1,    31,   102,     4,     5,     6,
+       7,     8,     9,    10,    11,    12,    31,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,    24,    78,    26,
+      80,    26,    69,   133,    31,   133,    31,   156,    26,    27,
+      29,     0,     1,    32,    33,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,   150,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    24,     0,    26,   164,   100,
+      77,    78,    31,    80,    77,    78,    31,    80,    31,    32,
+      33,     0,     1,    31,   115,     4,     5,     6,     7,     8,
+       9,    10,    11,    26,    27,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    31,    26,    26,    31,     0,
+       1,    26,    31,     4,     5,     6,     7,     8,     9,    10,
+      11,    26,    31,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,     1,     1,    26,    31,    32,    33,    31,
+      31,     0,     1,    31,    31,     4,     5,     6,     7,     8,
+       9,    10,    11,    31,   185,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    31,     1,    26,    31,    31,
+       5,     6,    31,     8,     9,    10,    11,    12,    31,    14,
+      15,    16,    17,    18,    19,    20,    31,    31,    31,    25,
+       1,    26,    26,    13,     1,    26,    31,     4,     5,     6,
+       7,     8,     9,    10,    11,    31,    14,    14,    15,    16,
+       4,     5,     6,     7,     8,     9,    10,    11,    33,    26,
+      14,    15,     5,     6,    31,     8,     9,    10,    11,    31,
+      31,    14,    15,    31,    31,    31,    31,    31,    31,   151,
+      31,   153,   154,   155,    34,    31,     7,     6,    31,   161,
+      37,   163,    76,    -1,    79,   116,    -1,    -1,    -1,    -1,
+     172
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,    31,    37,    38,    39,    63,    81,    26,    27,
+      79,     0,     1,     4,     5,     6,     7,     8,     9,    10,
+      11,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      23,    26,    31,    40,    41,    43,    44,    45,    46,    52,
+      53,    55,    59,    61,    64,    65,    67,    69,    70,    71,
+      80,    39,    31,    38,    81,    31,    79,    31,    79,    26,
+      85,    31,    79,    26,    26,    26,    27,    30,    35,    83,
+      84,    31,     1,     1,    47,    47,    56,    58,    62,    76,
+      68,    74,    31,    31,    31,    31,    31,    31,    83,    83,
+      32,    33,    81,    28,    34,    31,    31,     1,    12,    16,
+      18,    19,    20,    21,    22,    24,    26,    31,    42,    48,
+      49,    72,    73,    75,    17,    18,    19,    20,    31,    42,
+      57,    73,    75,    41,    54,    80,    41,    55,    60,    67,
+      80,    23,    31,    74,    77,    41,    55,    66,    67,    80,
+      31,    42,    75,    29,    83,    83,    84,    84,    31,    31,
+      25,    79,    78,    79,    83,    26,    84,    50,     1,    13,
+      31,    79,    78,    26,    14,    82,    83,    82,    31,    82,
+      82,    82,    84,    26,    31,    31,    82,    31,    82,    83,
+      31,    31,    31,    31,    82,    34,    51,    31,    31,    31,
+      79
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  However,
+   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
+   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
+   discussed.  */
+
+#define YYFAIL		goto yyerrlab
+#if defined YYFAIL
+  /* This is here to suppress warnings from the GCC cpp's
+     -Wunused-macros.  Normally we don't worry about that warning, but
+     some users do, and we want to make it easy for users to remove
+     YYFAIL uses, which will produce warnings from Bison 2.5.  */
+#endif
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* This macro is provided for backward compatibility. */
+
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  YYSIZE_T yysize1;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = 0;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - Assume YYFAIL is not used.  It's too flawed to consider.  See
+       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
+       for details.  YYERROR is fine as it does not invoke this
+       function.
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+                if (! (yysize <= yysize1
+                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                  return 2;
+                yysize = yysize1;
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  yysize1 = yysize + yystrlen (yyformat);
+  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+    return 2;
+  yysize = yysize1;
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+      case 53: /* "choice_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 59: /* "if_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 65: /* "menu_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+
+      default:
+	break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 10:
+
+    { zconf_error("unexpected end statement"); }
+    break;
+
+  case 11:
+
+    { zconf_error("unknown statement \"%s\"", (yyvsp[(2) - (4)].string)); }
+    break;
+
+  case 12:
+
+    {
+	zconf_error("unexpected option \"%s\"", kconf_id_strings + (yyvsp[(2) - (4)].id)->name);
+}
+    break;
+
+  case 13:
+
+    { zconf_error("invalid statement"); }
+    break;
+
+  case 28:
+
+    { zconf_error("unknown option \"%s\"", (yyvsp[(1) - (3)].string)); }
+    break;
+
+  case 29:
+
+    { zconf_error("invalid option"); }
+    break;
+
+  case 30:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+}
+    break;
+
+  case 31:
+
+    {
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 32:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:menuconfig %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+}
+    break;
+
+  case 33:
+
+    {
+	if (current_entry->prompt)
+		current_entry->prompt->type = P_MENU;
+	else
+		zconfprint("warning: menuconfig statement without prompt");
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 41:
+
+    {
+	menu_set_type((yyvsp[(1) - (3)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (3)].id)->stype);
+}
+    break;
+
+  case 42:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 43:
+
+    {
+	menu_add_expr(P_DEFAULT, (yyvsp[(2) - (4)].expr), (yyvsp[(3) - (4)].expr));
+	if ((yyvsp[(1) - (4)].id)->stype != S_UNKNOWN)
+		menu_set_type((yyvsp[(1) - (4)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:default(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (4)].id)->stype);
+}
+    break;
+
+  case 44:
+
+    {
+	menu_add_symbol(P_SELECT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 45:
+
+    {
+	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,(yyvsp[(2) - (5)].symbol), (yyvsp[(3) - (5)].symbol)), (yyvsp[(4) - (5)].expr));
+	printd(DEBUG_PARSE, "%s:%d:range\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 48:
+
+    {
+	const struct kconf_id *id = kconf_id_lookup((yyvsp[(2) - (3)].string), strlen((yyvsp[(2) - (3)].string)));
+	if (id && id->flags & TF_OPTION)
+		menu_add_option(id->token, (yyvsp[(3) - (3)].string));
+	else
+		zconfprint("warning: ignoring unknown option %s", (yyvsp[(2) - (3)].string));
+	free((yyvsp[(2) - (3)].string));
+}
+    break;
+
+  case 49:
+
+    { (yyval.string) = NULL; }
+    break;
+
+  case 50:
+
+    { (yyval.string) = (yyvsp[(2) - (2)].string); }
+    break;
+
+  case 51:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), SYMBOL_CHOICE);
+	sym->flags |= SYMBOL_AUTO;
+	menu_add_entry(sym);
+	menu_add_expr(P_CHOICE, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 52:
+
+    {
+	(yyval.menu) = menu_add_menu();
+}
+    break;
+
+  case 53:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+}
+    break;
+
+  case 61:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 62:
+
+    {
+	if ((yyvsp[(1) - (3)].id)->stype == S_BOOLEAN || (yyvsp[(1) - (3)].id)->stype == S_TRISTATE) {
+		menu_set_type((yyvsp[(1) - (3)].id)->stype);
+		printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+			zconf_curname(), zconf_lineno(),
+			(yyvsp[(1) - (3)].id)->stype);
+	} else
+		YYERROR;
+}
+    break;
+
+  case 63:
+
+    {
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 64:
+
+    {
+	if ((yyvsp[(1) - (4)].id)->stype == S_UNKNOWN) {
+		menu_add_symbol(P_DEFAULT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+		printd(DEBUG_PARSE, "%s:%d:default\n",
+			zconf_curname(), zconf_lineno());
+	} else
+		YYERROR;
+}
+    break;
+
+  case 67:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	menu_add_dep((yyvsp[(2) - (3)].expr));
+	(yyval.menu) = menu_add_menu();
+}
+    break;
+
+  case 68:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+}
+    break;
+
+  case 74:
+
+    {
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+}
+    break;
+
+  case 75:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 76:
+
+    {
+	(yyval.menu) = menu_add_menu();
+}
+    break;
+
+  case 77:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+}
+    break;
+
+  case 83:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+	zconf_nextfile((yyvsp[(2) - (3)].string));
+}
+    break;
+
+  case 84:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_COMMENT, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 85:
+
+    {
+	menu_end_entry();
+}
+    break;
+
+  case 86:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+}
+    break;
+
+  case 87:
+
+    {
+	current_entry->help = (yyvsp[(2) - (2)].string);
+}
+    break;
+
+  case 92:
+
+    {
+	menu_add_dep((yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 96:
+
+    {
+	menu_add_visibility((yyvsp[(2) - (2)].expr));
+}
+    break;
+
+  case 98:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(1) - (2)].string), (yyvsp[(2) - (2)].expr));
+}
+    break;
+
+  case 101:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); }
+    break;
+
+  case 102:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); }
+    break;
+
+  case 103:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); }
+    break;
+
+  case 106:
+
+    { (yyval.expr) = NULL; }
+    break;
+
+  case 107:
+
+    { (yyval.expr) = (yyvsp[(2) - (2)].expr); }
+    break;
+
+  case 108:
+
+    { (yyval.expr) = expr_alloc_symbol((yyvsp[(1) - (1)].symbol)); }
+    break;
+
+  case 109:
+
+    { (yyval.expr) = expr_alloc_comp(E_EQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); }
+    break;
+
+  case 110:
+
+    { (yyval.expr) = expr_alloc_comp(E_UNEQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); }
+    break;
+
+  case 111:
+
+    { (yyval.expr) = (yyvsp[(2) - (3)].expr); }
+    break;
+
+  case 112:
+
+    { (yyval.expr) = expr_alloc_one(E_NOT, (yyvsp[(2) - (2)].expr)); }
+    break;
+
+  case 113:
+
+    { (yyval.expr) = expr_alloc_two(E_OR, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); }
+    break;
+
+  case 114:
+
+    { (yyval.expr) = expr_alloc_two(E_AND, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); }
+    break;
+
+  case 115:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), 0); free((yyvsp[(1) - (1)].string)); }
+    break;
+
+  case 116:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), SYMBOL_CONST); free((yyvsp[(1) - (1)].string)); }
+    break;
+
+  case 117:
+
+    { (yyval.string) = NULL; }
+    break;
+
+
+
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+
+
+void conf_parse(const char *name)
+{
+	struct symbol *sym;
+	int i;
+
+	zconf_initscan(name);
+
+	sym_init();
+	_menu_init();
+	rootmenu.prompt = menu_add_prompt(P_MENU, "Linux Kernel Configuration", NULL);
+
+	if (getenv("ZCONF_DEBUG"))
+		zconfdebug = 1;
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	if (!modules_sym)
+		modules_sym = sym_find( "n" );
+
+	rootmenu.prompt->text = _(rootmenu.prompt->text);
+	rootmenu.prompt->text = sym_expand_string_value(rootmenu.prompt->text);
+
+	menu_finalize(&rootmenu);
+	for_all_symbols(i, sym) {
+		if (sym_check_deps(sym))
+			zconfnerrs++;
+	}
+	if (zconfnerrs)
+		exit(1);
+	sym_set_change_count(1);
+}
+
+static const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	case T_DEPENDS:		return "depends";
+	case T_VISIBLE:		return "visible";
+	}
+	return "<token>";
+}
+
+static bool zconf_endtoken(const struct kconf_id *id, int starttoken, int endtoken)
+{
+	if (id->token != endtoken) {
+		zconf_error("unexpected '%s' within %s block",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconf_error("'%s' in different file than '%s'",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		fprintf(stderr, "%s:%d: location of the '%s'\n",
+			current_menu->file->name, current_menu->lineno,
+			zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconf_error(const char *err, ...)
+{
+	va_list ap;
+
+	zconfnerrs++;
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
+}
+
+static void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+static void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "\nchoice\n");
+	else
+		fprintf(out, "\nconfig %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			expr_fprint(prop->expr, out);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		case P_SELECT:
+			fputs( "  select ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_RANGE:
+			fputs( "  range ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_MENU:
+			fputs( "  menu ", out);
+			print_quoted_string(out, prop->text);
+			fputc('\n', out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (menu->help) {
+		int len = strlen(menu->help);
+		while (menu->help[--len] == '\n')
+			menu->help[len] = 0;
+		fprintf(out, "  help\n%s\n", menu->help);
+	}
+}
+
+void zconfdump(FILE *out)
+{
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			default:
+				;
+			}
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs("  depends ", out);
+				expr_fprint(prop->visible.expr, out);
+				fputc('\n', out);
+			}
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "zconf.lex.c"
+#include "util.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
+
diff -urN u-boot-2016.03/snapshot.commit ebf_6ull_uboot/snapshot.commit
--- u-boot-2016.03/snapshot.commit	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/snapshot.commit	2021-04-16 14:42:15.704586022 +0800
@@ -1 +1 @@
-df61a74e6845ec9bdcdd48d2aff5e9c2c6debeaa  Mon, 14 Mar 2016 10:20:21 -0400
+$Format:%H  %cD$
diff -urN u-boot-2016.03/tools/imximage.c ebf_6ull_uboot/tools/imximage.c
--- u-boot-2016.03/tools/imximage.c	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/tools/imximage.c	2021-04-16 14:42:17.844597098 +0800
@@ -6,6 +6,8 @@
  * Marvell Semiconductor <www.marvell.com>
  * Written-by: Prafulla Wadaskar <prafulla@marvell.com>
  *
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -27,6 +29,9 @@
 	{CMD_CHECK_BITS_CLR,    "CHECK_BITS_CLR",   "Reg Check bits clr", },
 	{CMD_CSF,               "CSF",           "Command Sequence File", },
 	{CMD_IMAGE_VERSION,     "IMAGE_VERSION",        "image version",  },
+#ifdef CONFIG_USE_PLUGIN
+	{CMD_PLUGIN,            "PLUGIN",               "file plugin_addr",  },
+#endif
 	{-1,                    "",                     "",	          },
 };
 
@@ -80,6 +85,8 @@
 static uint32_t imximage_csf_size = UNDEFINED;
 /* Initial Load Region Size */
 static uint32_t imximage_init_loadsize;
+static uint32_t imximage_iram_free_start;
+static uint32_t imximage_plugin_size;
 
 static set_dcd_val_t set_dcd_val;
 static set_dcd_param_t set_dcd_param;
@@ -118,7 +125,11 @@
 
 	/* Try to detect V2 */
 	if ((fhdr_v2->header.tag == IVT_HEADER_TAG) &&
-		(hdr_v2->dcd_table.header.tag == DCD_HEADER_TAG))
+		(hdr_v2->data.dcd_table.header.tag == DCD_HEADER_TAG))
+		return IMXIMAGE_V2;
+
+	if ((fhdr_v2->header.tag == IVT_HEADER_TAG) &&
+		hdr_v2->boot_data.plugin)
 		return IMXIMAGE_V2;
 
 	return IMXIMAGE_VER_INVALID;
@@ -165,7 +176,7 @@
 static void set_dcd_param_v2(struct imx_header *imxhdr, uint32_t dcd_len,
 		int32_t cmd)
 {
-	dcd_v2_t *dcd_v2 = &imxhdr->header.hdr_v2.dcd_table;
+	dcd_v2_t *dcd_v2 = &imxhdr->header.hdr_v2.data.dcd_table;
 	struct dcd_v2_cmd *d = gd_last_cmd;
 	struct dcd_v2_cmd *d2;
 	int len;
@@ -209,7 +220,7 @@
 		d = d2;
 		d->write_dcd_command.tag = DCD_CHECK_DATA_COMMAND_TAG;
 		d->write_dcd_command.length = cpu_to_be16(4);
-		d->write_dcd_command.param = DCD_CHECK_BITS_SET_PARAM;
+		d->write_dcd_command.param = DCD_CHECK_BITS_CLR_PARAM;
 		break;
 	default:
 		break;
@@ -261,21 +272,23 @@
 static void set_dcd_rst_v2(struct imx_header *imxhdr, uint32_t dcd_len,
 						char *name, int lineno)
 {
-	dcd_v2_t *dcd_v2 = &imxhdr->header.hdr_v2.dcd_table;
-	struct dcd_v2_cmd *d = gd_last_cmd;
-	int len;
-
-	if (!d)
-		d = &dcd_v2->dcd_cmd;
-	len = be16_to_cpu(d->write_dcd_command.length);
-	if (len > 4)
-		d = (struct dcd_v2_cmd *)(((char *)d) + len);
-
-	len = (char *)d - (char *)&dcd_v2->header;
-
-	dcd_v2->header.tag = DCD_HEADER_TAG;
-	dcd_v2->header.length = cpu_to_be16(len);
-	dcd_v2->header.version = DCD_VERSION;
+	if (!imxhdr->header.hdr_v2.boot_data.plugin) {
+		dcd_v2_t *dcd_v2 = &imxhdr->header.hdr_v2.data.dcd_table;
+		struct dcd_v2_cmd *d = gd_last_cmd;
+		int len;
+
+		if (!d)
+			d = &dcd_v2->dcd_cmd;
+		len = be16_to_cpu(d->write_dcd_command.length);
+		if (len > 4)
+			d = (struct dcd_v2_cmd *)(((char *)d) + len);
+
+		len = (char *)d - (char *)&dcd_v2->header;
+
+		dcd_v2->header.tag = DCD_HEADER_TAG;
+		dcd_v2->header.length = cpu_to_be16(len);
+		dcd_v2->header.version = DCD_VERSION;
+	}
 }
 
 static void set_imx_hdr_v1(struct imx_header *imxhdr, uint32_t dcd_len,
@@ -317,24 +330,91 @@
 	fhdr_v2->header.length = cpu_to_be16(sizeof(flash_header_v2_t));
 	fhdr_v2->header.version = IVT_VERSION; /* 0x40 */
 
-	fhdr_v2->entry = entry_point;
-	fhdr_v2->reserved1 = fhdr_v2->reserved2 = 0;
-	hdr_base = entry_point - imximage_init_loadsize +
-		flash_offset;
-	fhdr_v2->self = hdr_base;
-	if (dcd_len > 0)
-		fhdr_v2->dcd_ptr = hdr_base
-			+ offsetof(imx_header_v2_t, dcd_table);
-	else
+	if (!hdr_v2->boot_data.plugin) {
+		fhdr_v2->entry = entry_point;
+		fhdr_v2->reserved1 = fhdr_v2->reserved2 = 0;
+		hdr_base = entry_point - imximage_init_loadsize +
+			flash_offset;
+		fhdr_v2->self = hdr_base;
+		if (dcd_len > 0)
+			fhdr_v2->dcd_ptr = hdr_base +
+				offsetof(imx_header_v2_t, data);
+		else
+			fhdr_v2->dcd_ptr = 0;
+		fhdr_v2->boot_data_ptr = hdr_base
+				+ offsetof(imx_header_v2_t, boot_data);
+		hdr_v2->boot_data.start = entry_point - imximage_init_loadsize;
+
+		fhdr_v2->csf = 0;
+
+		header_size_ptr = &hdr_v2->boot_data.size;
+		csf_ptr = &fhdr_v2->csf;
+	} else {
+		imx_header_v2_t *next_hdr_v2;
+		flash_header_v2_t *next_fhdr_v2;
+
+		if (imximage_csf_size != 0) {
+			fprintf(stderr, "Error: Header v2: SECURE_BOOT"
+					"is only supported in DCD mode!");
+			exit(EXIT_FAILURE);
+		}
+
+		fhdr_v2->entry = imximage_iram_free_start +
+			flash_offset + sizeof(flash_header_v2_t) +
+			sizeof(boot_data_t);
+
+		fhdr_v2->reserved1 = fhdr_v2->reserved2 = 0;
+		fhdr_v2->self = imximage_iram_free_start + flash_offset;
+
 		fhdr_v2->dcd_ptr = 0;
-	fhdr_v2->boot_data_ptr = hdr_base
-			+ offsetof(imx_header_v2_t, boot_data);
-	hdr_v2->boot_data.start = entry_point - imximage_init_loadsize;
 
-	fhdr_v2->csf = 0;
+		fhdr_v2->boot_data_ptr = fhdr_v2->self +
+				offsetof(imx_header_v2_t, boot_data);
+
+		hdr_v2->boot_data.start = imximage_iram_free_start;
+		/*
+		 * The actural size of plugin image is "imximage_plugin_size +
+		 * sizeof(flash_header_v2_t) + sizeof(boot_data_t)", plus the
+		 * flash_offset space.The ROM code only need to copy this size
+		 * to run the plugin code. However, later when copy the whole
+		 * U-Boot image to DDR, the ROM code use memcpy to copy the
+		 * first part of the image, and use the storage read function
+		 * to get the remaining part. This requires the dividing point
+		 * must be multiple of storage sector size. Here we set the
+		 * first section to be 16KB for this purpose.
+		 */
+		hdr_v2->boot_data.size = MAX_PLUGIN_CODE_SIZE;
+
+		/* Security feature are not supported */
+		fhdr_v2->csf = 0;
+
+		next_hdr_v2 = (imx_header_v2_t *)((char*)hdr_v2 +
+				imximage_plugin_size);
+
+		next_fhdr_v2 = &next_hdr_v2->fhdr;
+
+		next_fhdr_v2->header.tag = IVT_HEADER_TAG; /* 0xD1 */
+		next_fhdr_v2->header.length =
+			cpu_to_be16(sizeof(flash_header_v2_t));
+		next_fhdr_v2->header.version = IVT_VERSION; /* 0x40 */
 
-	header_size_ptr = &hdr_v2->boot_data.size;
-	csf_ptr = &fhdr_v2->csf;
+		next_fhdr_v2->entry = entry_point;
+		hdr_base = entry_point - sizeof(struct imx_header);
+		next_fhdr_v2->reserved1 = next_fhdr_v2->reserved2 = 0;
+		next_fhdr_v2->self = hdr_base + imximage_plugin_size;
+
+		next_fhdr_v2->dcd_ptr = 0;
+		next_fhdr_v2->boot_data_ptr = next_fhdr_v2->self +
+				offsetof(imx_header_v2_t, boot_data);
+
+		next_hdr_v2->boot_data.start = hdr_base - flash_offset;
+
+		header_size_ptr = &next_hdr_v2->boot_data.size;
+
+		next_hdr_v2->boot_data.plugin = 0;
+
+		next_fhdr_v2->csf = 0;
+	}
 }
 
 static void set_hdr_func(void)
@@ -393,16 +473,19 @@
 {
 	imx_header_v2_t *hdr_v2 = &imx_hdr->header.hdr_v2;
 	flash_header_v2_t *fhdr_v2 = &hdr_v2->fhdr;
-	dcd_v2_t *dcd_v2 = &hdr_v2->dcd_table;
-	uint32_t size, version;
+	dcd_v2_t *dcd_v2 = &hdr_v2->data.dcd_table;
+	uint32_t size, version, plugin;
 
-	size = be16_to_cpu(dcd_v2->header.length);
-	if (size > (MAX_HW_CFG_SIZE_V2 * sizeof(dcd_addr_data_t)) + 8) {
+	plugin = hdr_v2->boot_data.plugin;
+	if (!plugin) {
+		size = be16_to_cpu(dcd_v2->header.length) - 8;
+		if (size > (MAX_HW_CFG_SIZE_V2 * sizeof(dcd_addr_data_t))) {
 		fprintf(stderr,
 			"Error: Image corrupt DCD size %d exceed maximum %d\n",
 			(uint32_t)(size / sizeof(dcd_addr_data_t)),
 			MAX_HW_CFG_SIZE_V2);
 		exit(EXIT_FAILURE);
+		}
 	}
 
 	version = detect_imximage_version(imx_hdr);
@@ -410,18 +493,82 @@
 	printf("Image Type:   Freescale IMX Boot Image\n");
 	printf("Image Ver:    %x", version);
 	printf("%s\n", get_table_entry_name(imximage_versions, NULL, version));
-	printf("Data Size:    ");
-	genimg_print_size(hdr_v2->boot_data.size);
-	printf("Load Address: %08x\n", (uint32_t)fhdr_v2->boot_data_ptr);
-	printf("Entry Point:  %08x\n", (uint32_t)fhdr_v2->entry);
-	if (fhdr_v2->csf && (imximage_ivt_offset != UNDEFINED) &&
-	    (imximage_csf_size != UNDEFINED)) {
-		printf("HAB Blocks:   %08x %08x %08x\n",
-		       (uint32_t)fhdr_v2->self, 0,
-		       hdr_v2->boot_data.size - imximage_ivt_offset -
-		       imximage_csf_size);
+	printf("Mode:         %s\n", plugin ? "PLUGIN" : "DCD");
+	if (!plugin) {
+		printf("Data Size:    ");
+		genimg_print_size(hdr_v2->boot_data.size);
+		printf("Load Address: %08x\n", (uint32_t)fhdr_v2->boot_data_ptr);
+		printf("Entry Point:  %08x\n", (uint32_t)fhdr_v2->entry);
+		if (fhdr_v2->csf && (imximage_ivt_offset != UNDEFINED) &&
+		    (imximage_csf_size != UNDEFINED)) {
+			printf("HAB Blocks:   %08x %08x %08x\n",
+			       (uint32_t)fhdr_v2->self, 0,
+			       hdr_v2->boot_data.size - imximage_ivt_offset -
+			       imximage_csf_size);
+		}
+	} else {
+		imx_header_v2_t *next_hdr_v2;
+		flash_header_v2_t *next_fhdr_v2;
+
+		/*First Header*/
+		printf("Plugin Data Size:     ");
+		genimg_print_size(hdr_v2->boot_data.size);
+		printf("Plugin Code Size:     ");
+		genimg_print_size(imximage_plugin_size);
+		printf("Plugin Load Address:  %08x\n", hdr_v2->boot_data.start);
+		printf("Plugin Entry Point:   %08x\n",
+				(uint32_t)fhdr_v2->entry);
+
+		/*Second Header*/
+		next_hdr_v2 = (imx_header_v2_t *)((char*)hdr_v2 +
+				imximage_plugin_size);
+		next_fhdr_v2 = &next_hdr_v2->fhdr;
+		printf("U-Boot Data Size:     ");
+		genimg_print_size(next_hdr_v2->boot_data.size);
+		printf("U-Boot Load Address:  %08x\n", next_hdr_v2->boot_data.start);
+		printf("U-Boot Entry Point:   %08x\n",
+				(uint32_t)next_fhdr_v2->entry);
+	}
+}
+
+#ifdef CONFIG_USE_PLUGIN
+static void copy_plugin_code(struct imx_header *imxhdr, char *plugin_file)
+{
+	int ifd = -1;
+	struct stat sbuf;
+	char *plugin_buf = imxhdr->header.hdr_v2.data.plugin_code;
+	char *ptr;
+
+	ifd = open(plugin_file, O_RDONLY|O_BINARY);
+	if (fstat(ifd, &sbuf) < 0) {
+		fprintf(stderr, "Can't stat %s: %s\n",
+			plugin_file,
+			strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	ptr = mmap(0, sbuf.st_size, PROT_READ, MAP_SHARED, ifd, 0);
+	if (ptr == MAP_FAILED) {
+		fprintf(stderr, "Can't read %s: %s\n",
+			plugin_file,
+			strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	if (sbuf.st_size > MAX_PLUGIN_CODE_SIZE) {
+		printf("plugin binary size too large\n");
+		exit(EXIT_FAILURE);
 	}
+
+	memcpy(plugin_buf, ptr, sbuf.st_size);
+	imximage_plugin_size = sbuf.st_size;
+
+	(void) munmap((void *)ptr, sbuf.st_size);
+	(void) close(ifd);
+
+	imxhdr->header.hdr_v2.boot_data.plugin = 1;
 }
+#endif
 
 static void parse_cfg_cmd(struct imx_header *imxhdr, int32_t cmd, char *token,
 				char *name, int lineno, int fld, int dcd_len)
@@ -497,6 +644,11 @@
 		if (unlikely(cmd_ver_first != 1))
 			cmd_ver_first = 0;
 		break;
+#ifdef CONFIG_USE_PLUGIN
+	case CMD_PLUGIN:
+		copy_plugin_code(imxhdr, token);
+		break;
+#endif
 	}
 }
 
@@ -542,6 +694,12 @@
 				}
 			}
 			break;
+#ifdef CONFIG_USE_PLUGIN
+		case CMD_PLUGIN:
+			value = get_cfg_value(token, name, lineno);
+			imximage_iram_free_start = value;
+			break;
+#endif
 		default:
 			break;
 		}
diff -urN u-boot-2016.03/tools/imximage.h ebf_6ull_uboot/tools/imximage.h
--- u-boot-2016.03/tools/imximage.h	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/tools/imximage.h	2021-04-16 14:42:17.844597098 +0800
@@ -2,13 +2,17 @@
  * (C) Copyright 2009
  * Stefano Babic, DENX Software Engineering, sbabic@denx.de.
  *
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #ifndef _IMXIMAGE_H_
 #define _IMXIMAGE_H_
 
+#include <config.h>
 #define MAX_HW_CFG_SIZE_V2 220 /* Max number of registers imx can set for v2 */
+#define MAX_PLUGIN_CODE_SIZE (16*1024)
 #define MAX_HW_CFG_SIZE_V1 60  /* Max number of registers imx can set for v1 */
 #define APP_CODE_BARKER	0xB1
 #define DCD_BARKER	0xB17219E9
@@ -26,10 +30,17 @@
 #define FLASH_OFFSET_NAND	FLASH_OFFSET_STANDARD
 #define FLASH_OFFSET_SD		FLASH_OFFSET_STANDARD
 #define FLASH_OFFSET_SPI	FLASH_OFFSET_STANDARD
+#define FLASH_OFFSET_SATA	FLASH_OFFSET_STANDARD
+
+#ifdef CONFIG_IMX_FIXED_IVT_OFFSET
+#define FLASH_OFFSET_ONENAND	FLASH_OFFSET_STANDARD
+#define FLASH_OFFSET_NOR	FLASH_OFFSET_STANDARD
+#define FLASH_OFFSET_QSPI	FLASH_OFFSET_STANDARD
+#else
 #define FLASH_OFFSET_ONENAND	0x100
 #define FLASH_OFFSET_NOR	0x1000
-#define FLASH_OFFSET_SATA	FLASH_OFFSET_STANDARD
 #define FLASH_OFFSET_QSPI	0x1000
+#endif
 
 /* Initial Load Region Size */
 #define FLASH_LOADSIZE_UNDEFINED	0xFFFFFFFF
@@ -64,6 +75,7 @@
 	CMD_CHECK_BITS_SET,
 	CMD_CHECK_BITS_CLR,
 	CMD_CSF,
+	CMD_PLUGIN,
 };
 
 enum imximage_fld_types {
@@ -164,7 +176,12 @@
 typedef struct {
 	flash_header_v2_t fhdr;
 	boot_data_t boot_data;
-	dcd_v2_t dcd_table;
+	union {
+		dcd_v2_t dcd_table;
+#ifdef CONFIG_USE_PLUGIN
+		char plugin_code[MAX_PLUGIN_CODE_SIZE];
+#endif
+	} data;
 } imx_header_v2_t;
 
 /* The header must be aligned to 4k on MX53 for NAND boot */
二进制文件 u-boot-2016.03/tools/logos/freescale-bak.bmp 和 ebf_6ull_uboot/tools/logos/freescale-bak.bmp 不同
二进制文件 u-boot-2016.03/tools/logos/freescale.bmp 和 ebf_6ull_uboot/tools/logos/freescale.bmp 不同
diff -urN u-boot-2016.03/.travis.yml ebf_6ull_uboot/.travis.yml
--- u-boot-2016.03/.travis.yml	2016-03-14 22:20:21.000000000 +0800
+++ ebf_6ull_uboot/.travis.yml	1970-01-01 08:00:00.000000000 +0800
@@ -1,189 +0,0 @@
-# Copyright Roger Meier <r.meier@siemens.com>
-# SPDX-License-Identifier:	GPL-2.0+
-
-# build U-Boot on Travis CI - https://travis-ci.org/
-
-sudo: true
-
-language: c
-
-addons:
-  apt:
-    packages:
-    - cppcheck
-    - sloccount
-    - sparse
-    - bc
-    - build-essential
-    - libsdl1.2-dev
-    - python
-    - python-virtualenv
-
-cache:
- - apt
-
-install:
- # install latest device tree compiler
- - git clone --depth=1 https://git.kernel.org/pub/scm/utils/dtc/dtc.git /tmp/dtc
- - make -j4 -C /tmp/dtc
- # prepare buildman environment
- - export BUILDMAN_ROOT="root:"
- - export BUILDMAN_PPC="ppc:"
- - export BUILDMAN_ARM="arm:"
- - export BUILDMAN_SANDBOX="sandbox:"
- - echo -e "[toolchain]\n${BUILDMAN_ROOT} /\n" > ~/.buildman
- - echo -e "${BUILDMAN_PPC} /opt/eldk-5.4/powerpc/sysroots/i686-eldk-linux/usr/bin/powerpc-linux/\n" >> ~/.buildman
- - echo -e "${BUILDMAN_ARM} /opt/eldk-5.4/armv5te/sysroots/i686-eldk-linux/usr/bin/armv5te-linux-gnueabi/\n" >> ~/.buildman
- - echo -e "${BUILDMAN_SANDBOX} /usr/bin/gcc\n" >> ~/.buildman
- - export BUILDMAN_ALIAS="x86:"
- - export BUILDMAN_ALIAS_ARM="arm:"
- - echo -e "\n\n[toolchain-alias]\n${BUILDMAN_ALIAS} i386\n" >> ~/.buildman
- - echo -e "${BUILDMAN_ALIAS_ARM} armv5te\n" >> ~/.buildman
- - cat ~/.buildman
- - virtualenv /tmp/venv
- - . /tmp/venv/bin/activate
- - pip install pytest
-
-env:
-  global:
-    - PATH=/tmp/dtc:$PATH
-    - BUILD_DIR=build
-    - HOSTCC="cc"
-    - HOSTCXX="c++"
-
-before_script:
-  # install toolchains based on TOOLCHAIN} variable
-  - if [[ "${TOOLCHAIN}" == *aarch64* ]]; then ./tools/buildman/buildman --fetch-arch aarch64 ; fi
-  - if [[ "${TOOLCHAIN}" == *arm* ]]; then wget ftp://ftp.denx.de/pub/eldk/5.4/targets/armv5te/eldk-eglibc-i686-arm-toolchain-gmae-5.4.sh ; fi
-  - if [[ "${TOOLCHAIN}" == *arm* ]]; then sh eldk-eglibc-i686-arm-toolchain-gmae-5.4.sh -y ; fi
-  - if [[ "${TOOLCHAIN}" == *avr32* ]]; then ./tools/buildman/buildman --fetch-arch avr32 ; fi
-  - if [[ "${TOOLCHAIN}" == *i386* ]]; then ./tools/buildman/buildman sandbox --fetch-arch i386 ; fi
-  - if [[ "${TOOLCHAIN}" == *m68k* ]]; then ./tools/buildman/buildman --fetch-arch m68k ; fi
-  - if [[ "${TOOLCHAIN}" == *mips* ]]; then ./tools/buildman/buildman --fetch-arch mips ; fi
-  - if [[ "${TOOLCHAIN}" == *ppc* ]]; then wget ftp://ftp.denx.de/pub/eldk/5.4/targets/powerpc/eldk-eglibc-i686-powerpc-toolchain-gmae-5.4.sh ; fi
-  - if [[ "${TOOLCHAIN}" == *ppc* ]]; then sh eldk-eglibc-i686-powerpc-toolchain-gmae-5.4.sh -y ; fi
-
-script:
- # the execution sequence for each test
- - if [[ "${TEST_CMD}" != "" ]]; then
-     ${TEST_CMD};
-   fi
- - if [[ "${BUILDMAN}" != "" ]]; then
-     tools/buildman/buildman ${BUILDMAN};
-   fi
-
-matrix:
-  include:
-  # we need to build by vendor due to 50min time limit for builds
-  # each env setting here is a dedicated build
-    - env:
-        - BUILDMAN="arm1136"
-          TOOLCHAIN="arm"
-    - env:
-        - BUILDMAN="arm1136"
-          TOOLCHAIN="arm"
-    - env:
-        - BUILDMAN="arm1176"
-          TOOLCHAIN="arm"
-    - env:
-        - BUILDMAN="arm720t"
-          TOOLCHAIN="arm"
-    - env:
-        - BUILDMAN="arm920t"
-          TOOLCHAIN="arm"
-    - env:
-        - BUILDMAN="atmel -x avr32"
-          TOOLCHAIN="arm"
-    - env:
-        - BUILDMAN="avr32"
-          TOOLCHAIN="avr32"
-    - env:
-        - BUILDMAN="davinci"
-          TOOLCHAIN="arm"
-    - env:
-        - BUILDMAN="denx"
-          TOOLCHAIN="arm"
-    - env:
-        - BUILDMAN="freescale -x powerpc,m68k,aarch64"
-          TOOLCHAIN="arm"
-    - env:
-        - BUILDMAN="sandbox x86"
-          TOOLCHAIN="i386"
-    - env:
-        - BUILDMAN="kirkwood"
-          TOOLCHAIN="arm"
-    - env:
-        - BUILDMAN="m68k"
-          TOOLCHAIN="m68k"
-    - env:
-        - BUILDMAN="mips"
-          TOOLCHAIN="mips"
-    - env:
-        - BUILDMAN="mpc512x"
-          TOOLCHAIN="ppc"
-    - env:
-        - BUILDMAN="mpc5xx"
-          TOOLCHAIN="ppc"
-    - env:
-        - BUILDMAN="mpc5xxx"
-          TOOLCHAIN="ppc"
-    - env:
-        - BUILDMAN="mpc8260"
-          TOOLCHAIN="ppc"
-    - env:
-        - BUILDMAN="mpc83xx"
-          TOOLCHAIN="ppc"
-    - env:
-        - BUILDMAN="mpc85xx -x freescale"
-          TOOLCHAIN="ppc"
-    - env:
-        - BUILDMAN="mpc85xx -x t208xrdb -x t4qds -x t102* -x p1_p2_rdb_pc -x p1010rdb -x corenet_ds -x b4860qds -x sbc8548 -x bsc91*"
-          TOOLCHAIN="ppc"
-    - env:
-        - BUILDMAN="t208xrdb t4qds t102*"
-          TOOLCHAIN="ppc"
-    - env:
-        - BUILDMAN="p1_p2_rdb_pc p1010rdb"
-          TOOLCHAIN="ppc"
-    - env:
-        - BUILDMAN="corenet_ds b4860qds sbc8548 bsc91*"
-          TOOLCHAIN="ppc"
-    - env:
-        - BUILDMAN="mpc86xx"
-          TOOLCHAIN="ppc"
-    - env:
-        - BUILDMAN="mpc8xx"
-          TOOLCHAIN="ppc"
-    - env:
-        - BUILDMAN="siemens"
-          TOOLCHAIN="arm"
-    - env:
-        - BUILDMAN="ti"
-          TOOLCHAIN="arm"
-    - env:
-        - BUILDMAN="aarch64"
-          TOOLCHAIN="aarch64"
-
-    # QA jobs for code analytics
-    # static code analysis with cppcheck (we can add --enable=all later)
-    - env:
-        - TEST_CMD="cppcheck --force --quiet --inline-suppr ."
-    # search for TODO within source tree
-    - env:
-        - TEST_CMD="grep -r TODO ."
-    # search for FIXME within source tree
-    - env:
-        - TEST_CMD="grep -r FIXME ."
-    # search for HACK within source tree and ignore HACKKIT board
-    - env:
-        - TEST_CMD="grep -r HACK . | grep -v HACKKIT"
-      script:
-        - grep -r HACK . | grep -v HACKKIT
-    # some statistics about the code base
-    - env:
-        - TEST_CMD="sloccount ."
-    # test/py
-    - env:
-        - TEST_CMD="./test/py/test.py --bd sandbox --build"
-
-# TODO make it perfect ;-r
